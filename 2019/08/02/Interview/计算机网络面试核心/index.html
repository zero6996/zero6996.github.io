<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>OSI7层模型和计算机网络相关知识 | Zero的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta name="description" content="OSI开放式互联参考模型、三次握手和四次挥手已经计算机网络常见面试题">
<meta name="keywords" content="计算机网络">
<meta property="og:type" content="article">
<meta property="og:title" content="OSI7层模型和计算机网络相关知识">
<meta property="og:url" content="https://zero6996.github.io/2019/08/02/Interview/计算机网络面试核心/index.html">
<meta property="og:site_name" content="Zero的博客">
<meta property="og:description" content="OSI开放式互联参考模型、三次握手和四次挥手已经计算机网络常见面试题">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/OSI-1564755170924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP_IP-1564755221704.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP-1564755257344.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-1564755271685.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-1564755288068.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/cookie-1564755310096.jpg">
<meta property="og:updated_time" content="2020-01-03T11:43:19.548Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OSI7层模型和计算机网络相关知识">
<meta name="twitter:description" content="OSI开放式互联参考模型、三次握手和四次挥手已经计算机网络常见面试题">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/OSI-1564755170924.png">
  
    <link rel="alternate" href="/atom.xml" title="Zero的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/4.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
</head>
</html>
<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" style="background-image: url(/images/wlop3.jpg)" title="图片作者wlop">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main"><article id="post-Interview/计算机网络面试核心" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      OSI7层模型和计算机网络相关知识
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/08/02/Interview/计算机网络面试核心/" class="article-date">
  <time datetime="2019-08-02T14:00:00.000Z" itemprop="datePublished">2019-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Interview/">Interview</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

  </div>
  
    <span id="busuanzi_container_page_pv">
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
    </span>
  
    <!-- Table of Contents -->
  

  <div class="article-inner">
    
    <div class="article-content article-content-doorframe" itemprop="articleBody">
      
        <h2 id="1-OSI开放式互联参考模型"><a href="#1-OSI开放式互联参考模型" class="headerlink" title="1. OSI开放式互联参考模型"></a>1. OSI开放式互联参考模型</h2><p>OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能就是帮助<strong>不同类型的主机实现数据传输 </strong>。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/OSI-1564755170924.png" alt="OSI"></p>
<p>一个设备在哪一层，关键看它工作时利用哪一层的数据头部信息。举例来说：</p>
<ul>
<li>物理层：网卡、网线、集线器、中继器、调制解调器</li>
<li>数据链路层：网桥、交换机</li>
<li>网络层：路由器</li>
</ul>
<p><strong>网关</strong>工作在第四层传输层及其以上。<strong>集线器</strong>是物理层设备，采用广播的形式来传输信息。<strong>交换机</strong>就是用来进行报文交换的及其，多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文。<strong>路由器</strong>的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。</p>
<h3 id="1-1-物理层"><a href="#1-1-物理层" class="headerlink" title="1.1 物理层"></a>1.1 物理层</h3><p>在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。</p>
<ul>
<li>主要功能：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li>
</ul>
<p>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<h3 id="1-2-数据链路层"><a href="#1-2-数据链路层" class="headerlink" title="1.2 数据链路层"></a>1.2 数据链路层</h3><p>数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。</p>
<ul>
<li>主要功能：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</li>
</ul>
<p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p>
<p>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p>
<ul>
<li>MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制</li>
<li>LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。</li>
</ul>
<p>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p>
<h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><p>网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。</p>
<p>其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。<br>一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 </p>
<p>在实现网络层功能时，需要解决的主要问题如下：</p>
<ul>
<li>寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。</li>
<li>交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。</li>
<li>路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。</li>
<li>连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。</li>
</ul>
<h3 id="1-4-传输层"><a href="#1-4-传输层" class="headerlink" title="1.4 传输层"></a>1.4 传输层</h3><p>OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。</p>
<ul>
<li>主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。</li>
<li>该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。</li>
</ul>
<p>传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。</p>
<p>因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：</p>
<ul>
<li>传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。</li>
<li>处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。</li>
<li>监控服务质量。</li>
</ul>
<h3 id="1-5-会话层"><a href="#1-5-会话层" class="headerlink" title="1.5 会话层"></a>1.5 会话层</h3><p>会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：<strong>向两个实体的表示层提供建立和使用连接的方法</strong>。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。<br>用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名（DN）就是一种网络上使用的远程地址例如：<code>www.baidu.com</code> 就是一个域名。</p>
<p>会话层的具体功能如下：</p>
<ul>
<li>会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。</li>
<li>会话流量控制：提供会话流量控制和交叉会话功能。</li>
<li>寻址：使用远程地址建立会话连接。</li>
<li>出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。</li>
</ul>
<h3 id="1-6-表示层"><a href="#1-6-表示层" class="headerlink" title="1.6 表示层"></a>1.6 表示层</h3><p>表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“<strong>处理用户信息的表示问题，如编码、数据格式转换和加密解密</strong>”等。</p>
<p>表示层的具体功能如下：</p>
<ul>
<li>数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。</li>
<li>数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。</li>
<li>压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。</li>
<li>数据的加密和解密：可以提高网络的安全性。</li>
</ul>
<h3 id="1-7-应用层"><a href="#1-7-应用层" class="headerlink" title="1.7 应用层"></a>1.7 应用层</h3><p>应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，<strong>负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议</strong>。</p>
<p>此外，该层还负责协调各个应用程序间的工作。<br>应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。</p>
<p>应用层的主要功能如下：</p>
<ul>
<li>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。</li>
<li>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</li>
</ul>
<h3 id="1-8-OSI7层模型小结"><a href="#1-8-OSI7层模型小结" class="headerlink" title="1.8 OSI7层模型小结"></a>1.8 OSI7层模型小结</h3><p>由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。</p>
<p>在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层、应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。</p>
<blockquote>
<p>简言之：下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。</p>
</blockquote>
<h3 id="1-9-TCP-IP分层模型"><a href="#1-9-TCP-IP分层模型" class="headerlink" title="1.9 TCP/IP分层模型"></a>1.9 TCP/IP分层模型</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP_IP-1564755221704.jpg" alt="TCP_IP"></p>
<p>TCP/IP分层模型的四个协议层分别完成以下的功能：</p>
<ul>
<li><p>第一层，链路层：包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。</p>
</li>
<li><p>第二层，网络层：对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。</p>
</li>
<li>第三层，传输层：对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。</li>
<li>第四层，应用层：对应于OSI七层参考模型的应用层和表达层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等。</li>
</ul>
<h2 id="2-三次握手和四次挥手"><a href="#2-三次握手和四次挥手" class="headerlink" title="2. 三次握手和四次挥手"></a>2. 三次握手和四次挥手</h2><ul>
<li>TCP概述：</li>
</ul>
<p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字(socket)，它的定义为端口号拼接到IP地址即构成了套接字。例如，假设IP地址为<code>192.3.4.15</code>，端口号为80，那么得到的套接字为<code>192.3.4.15:80</code>。</p>
<h3 id="2-1-TCP的三次握手"><a href="#2-1-TCP的三次握手" class="headerlink" title="2.1 TCP的三次握手"></a>2.1 TCP的三次握手</h3><p>所谓三次握手，即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。</p>
<h4 id="2-1-1-传输控制协议TCP简介"><a href="#2-1-1-传输控制协议TCP简介" class="headerlink" title="2.1.1 传输控制协议TCP简介"></a>2.1.1 传输控制协议TCP简介</h4><ul>
<li>面向连接的、可靠的、基于字节流的传输层通信协议</li>
<li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li>
<li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li>
<li>使用<strong>校验和</strong>来校验数据在传输过程中是否有误</li>
</ul>
<h4 id="2-1-2-TCP报文结构详解"><a href="#2-1-2-TCP报文结构详解" class="headerlink" title="2.1.2 TCP报文结构详解"></a>2.1.2 TCP报文结构详解</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP-1564755257344.jpg" alt="TCP"></p>
<p>TCP报文由首部和数据两部分组成。首部一般由20-60字节(Byte)构成，长度可变。其中前20B格式固定，后40B为可选。</p>
<p>因为，TCP报文还得传给下层网络层，封装成IP包，而一个IP包最大长度为65535，同时IP包首部也包含最少20B，所以一个IP包或TCP包可以包含的数据部分最多为65535-20-20=65495B。</p>
<p>TCP报文中数据部分是可选的，即TCP报文可以不包含数据（同理IP包也可以不包含数据）。不含数据的TCP报文通常是一些确认和控制信息类的报文，如TCP建立连接时的三次握手和TCP终止时的四次挥手等。</p>
<p>参数详解：</p>
<ol>
<li>源端口号（Source Port）：长度为16位占2个字节，指明发送数据的进程。</li>
<li>目的端口号（Destination Port）：长度为16位占2个字节，指明目的主机接收数据的进程。</li>
<li>序号（Sequence Number）：也称为序列号，长度为32位占4个字节。<strong>TCP连接中传送的字节流中的每个字节都按顺序编号</strong>。例如，一段报文的序号字段是301，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始。</li>
<li>确认号（Acknowledgement Number）：长度为32位占4个字节，<strong>是期望收到对方下一个报文的第一个数据字节的序号</strong>。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，<strong>这表明B正确的收到了A发送的到序号700为止的数据</strong>。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。确认号只有在ACK标志为1时才有效。</li>
<li>数据偏移：占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远。</li>
<li>首部长度：长度为4位，用于表示TCP报文首部的长度。用4位(bit)表示，十进制值就是[0,15]，一个TCP报文前20个字节是必有的，后40个字节根据情况可有可无。如果TCP报文首部是20个字节，则该位应是20/4=5。</li>
<li>保留位（Reserved）：长度为6位，必须是0，它是为将来定义新用途保留的。</li>
<li>标志（Code Bits）：长度为6位，在TCP报文中不管是挥手还是传数据等，这6位标志都很重要。6位从左到右依次为：<ul>
<li>URG：紧急标志位，当URG=1时，表明紧急指针有效。告诉系统此报文段中有紧急数据。</li>
<li>ACK：确认标志位，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置为1。</li>
<li>PSH：推标志位，当两个应用程序进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时就可以将PSH=1。</li>
<li>RST：复位标志，用于重建一个已经混乱的连接。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。</li>
<li>SYN：同步标志，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1,ACK=1。</li>
<li>FIN：结束标志，带该标志位的数据包用于结束一个TCP会话。当FIN=1,时，表明此报文的发送方数据已经发送完毕，并且要求释放。</li>
</ul>
</li>
<li>窗口大小（Window Size）：长度为16位占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接收。</li>
<li>校验和（Checksum）：长度为16位占2字节，该字段覆盖整个TCP报文端，是个强制性的字段，是由发送端计算和存储，到接收端后，由接收端进行验证。主要检验首部和数据这两部分。</li>
<li>紧急指针（Urgent Pointer）：长度为16位占2字节，指出本报文段中的紧急数据的字节数，该字段在URG标志置位时有效。</li>
<li>选型（Options）：长度可变，定义一些其他的可选参数。通常包含：最长报文大小（Maximum Segment Size，MSS）、窗口扩大选项、时间戳选项、选择性确认（Selective ACKnowlegement，SACK）等。</li>
<li>数据：TCP 报文段中的数据部分是可选的。</li>
</ol>
<blockquote>
<ul>
<li>单工数据传输只支持数据在一个方向上传输；</li>
<li>半双工数据传输允许数据在两个方向上传输，但在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；</li>
<li>全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都具有独立的接收和发送能力。</li>
</ul>
</blockquote>
<h4 id="2-1-3-TCP三次握手流程图"><a href="#2-1-3-TCP三次握手流程图" class="headerlink" title="2.1.3 TCP三次握手流程图"></a>2.1.3 TCP三次握手流程图</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-1564755271685.gif" alt="三次握手"></p>
<p><strong>整个流程为</strong>：</p>
<ol>
<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态。</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同步位SYN=1，同时选择一个初始序列号Seq=x，此时TCP客户端进程进入了SYN-SENT(同步已发送)状态。TCP规定，SYN报文段(SYN=1的报文段)不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该ACK=1,SYN=1,确认号是ack=x+1，同时也要为自己初始化一个序列号Seq=y。此时，TCP服务器进程进入了SYN-RCVD(同步收到)状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号Seq=x+1。此时，TCP连接建立，客户端进入ESTABLISHED(已建立连接)状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<blockquote>
<p>TCB：传输控制块，它是协议栈的核心数据结构，一个套接字在TCP、IP层的代表就是一个传输控制块，它包含了一个套接字所需要的所有信息。</p>
</blockquote>
<p><a href="https://www.cnblogs.com/lipengfei159263/p/9745986.html" target="_blank" rel="noopener">内容详见文章</a></p>
<p><strong>流程小结</strong>：</p>
<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<p>第一次握手：建立连接时，客户端发送SYN包{syn=x}到服务器，并进入SYN_SEND(同步已发送)状态，等待服务器确认。</p>
<p>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包(syn=y)，即SYN+ACK包，此时服务器进入SYN_RECV(同步收到)状态。</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK{ack=y+1}，此包发送完毕，客户端和服务器进入ESTABLISHED（已建立连接）状态，完成三次握手。</p>
<h4 id="2-1-4-SYN攻击"><a href="#2-1-4-SYN攻击" class="headerlink" title="2.1.4 SYN攻击"></a>2.1.4 SYN攻击</h4><p>在三次握手过程中，服务端发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接，此时服务端处于SYN-RCVD(同步收到)状态。当收到ACK后，服务端才会进入ESTABLISHED（已建立连接）状态。SYN攻击就是客户端在短时间内伪造大量不存在的IP地址，并向服务端不断发送SYN包，服务端回复确认包，并等待客户端的确认，由于源地址IP是不存在的，因此，服务端需要不断重发直至SYN超时。这些伪造的SYN包将占用未连接队列，导致正常的SYN请求因队列满而被丢弃，从而引起网络阻塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当服务端上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。使用如下命令可以让其现行：<code>netstat -nap | grep SYN_RECV</code></p>
<h3 id="2-2-TCP的四次挥手"><a href="#2-2-TCP的四次挥手" class="headerlink" title="2.2  TCP的四次挥手"></a>2.2  TCP的四次挥手</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-1564755288068.gif" alt="四次挥手"></p>
<blockquote>
<p>数据传输完毕后，双方都可释放连接。最开始时，客户端和服务端都是处于ESTABLISHED状态，然后客户端主动关闭，服务端被动关闭。</p>
</blockquote>
<p><strong>具体流程</strong>：</p>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）。此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务端收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。<strong>TCP服务器通知高层应用进程，客户端要释放向服务器的通信连接了，这时处于半关闭状态，即客户端已经无数据要发送了，但服务器若发送数据，客户端依然要接受。</strong>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时，客户端进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1。由于处在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，那么此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1。此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销响应的TCB后，才会进入CLOSED状态。</li>
<li>服务器只要收到了客户端发出的确认，会立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ol>
<p><strong>挥手小结</strong>：</p>
<p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态；</p>
<p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态，Client进入FIN-WAIT-2状态；</p>
<p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态；</p>
<p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，Client在经过2MSL后也会进入CLOSED状态，完成四次挥手；</p>
<h2 id="3-计算机网络相关面试题"><a href="#3-计算机网络相关面试题" class="headerlink" title="3. 计算机网络相关面试题"></a>3. 计算机网络相关面试题</h2><h4 id="3-1-为什么TCP客户端最后还要发送一次确认呢？为什么需要三次握手才能建立起连接？"><a href="#3-1-为什么TCP客户端最后还要发送一次确认呢？为什么需要三次握手才能建立起连接？" class="headerlink" title="3.1 为什么TCP客户端最后还要发送一次确认呢？为什么需要三次握手才能建立起连接？"></a>3.1 为什么TCP客户端最后还要发送一次确认呢？为什么需要三次握手才能建立起连接？</h4><p>主要为了防止已经失效的连接请求报文突然又传送到了服务端，因而产生错误。</p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h4 id="3-2-为什么在四次挥手时客户端最后还要等待2MSL？"><a href="#3-2-为什么在四次挥手时客户端最后还要等待2MSL？" class="headerlink" title="3.2 为什么在四次挥手时客户端最后还要等待2MSL？"></a>3.2 为什么在四次挥手时客户端最后还要等待2MSL？</h4><blockquote>
<p>MSL（Maximum Segment Lifetime）最长报文段寿命，TCP允许不同的实现可以设置不同的MSL值。</p>
</blockquote>
<p>第一：<strong>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失</strong>。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二：<strong>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中</strong>。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h4 id="3-3-为什么建立连接是三次握手，关闭连接却是四次挥手呢？"><a href="#3-3-为什么建立连接是三次握手，关闭连接却是四次挥手呢？" class="headerlink" title="3.3 为什么建立连接是三次握手，关闭连接却是四次挥手呢？"></a>3.3 为什么建立连接是三次握手，关闭连接却是四次挥手呢？</h4><p>建立连接时，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p>
<p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，己方ACK和FIN一般都会分开发送，从而导致多一次数据包传递。</p>
<h4 id="3-4-如果已经建立了连接，但客户端突然出现故障了怎么办？"><a href="#3-4-如果已经建立了连接，但客户端突然出现故障了怎么办？" class="headerlink" title="3.4 如果已经建立了连接，但客户端突然出现故障了怎么办？"></a>3.4 如果已经建立了连接，但客户端突然出现故障了怎么办？</h4><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h4 id="3-5-TCP和UDP的区别"><a href="#3-5-TCP和UDP的区别" class="headerlink" title="3.5 TCP和UDP的区别"></a>3.5 TCP和UDP的区别</h4><table>
<thead>
<tr>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>可靠性高，利用握手确认和重传机制保证数据不丢失</td>
<td>可靠性不高，可能会丢失数据</td>
</tr>
<tr>
<td>有序性：利用序列号保证消息包的顺序交互</td>
<td>无有序性</td>
</tr>
<tr>
<td>需要创建连接，保证消息的可靠性和有序性，导致速度较慢</td>
<td>无需考虑连接和可靠，速度较快</td>
</tr>
<tr>
<td>消息头20字节，重量级</td>
<td>消息头只需8字节，轻量级</td>
</tr>
</tbody>
</table>
<h4 id="3-6-在浏览器地址栏键入URL，按下回车之后经历的流程"><a href="#3-6-在浏览器地址栏键入URL，按下回车之后经历的流程" class="headerlink" title="3.6 在浏览器地址栏键入URL，按下回车之后经历的流程"></a>3.6 在浏览器地址栏键入URL，按下回车之后经历的流程</h4><ol>
<li><strong>DNS解析</strong>：首先浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名所对应的IP地址。DNS缓存从近到远依次是：浏览器缓存→系统缓存→路由器缓存→IPS服务器缓存→根域名服务器缓存→顶级域名服务器缓存。找到IP则直接返回，不查询后续缓存。</li>
<li><strong>TCP连接</strong>：根据IP地址和默认端口(80)来和服务器建立TCP连接(三次握手)。</li>
<li><strong>发送HTTP请求</strong>：浏览器发出读取文件的HTTP请求，该请求将发送给服务器。</li>
<li><strong>服务器处理请求并返回HTTP报文</strong>：服务器对浏览器请求作出响应，并把对应的带有HTML文本的HTTP响应报文发送给浏览器。</li>
<li><strong>浏览器解析渲染页面</strong>：浏览器接收到HTML，并在显示窗口内渲染它。</li>
<li><strong>连接结束</strong>：浏览器释放TCP连接(四次挥手)。</li>
</ol>
<h4 id="3-7-说说常见的HTTP状态码"><a href="#3-7-说说常见的HTTP状态码" class="headerlink" title="3.7 说说常见的HTTP状态码"></a>3.7 说说常见的HTTP状态码</h4><ul>
<li><p><strong>200 OK：</strong>正常返回信息</p>
</li>
<li><p><strong>400 Bad Request：</strong>客户端请求有语法错误，不能被服务器所理解</p>
</li>
<li><p><strong>401 Unauthorized：</strong>请求未经授权，这个状态码必须和<code>WWW-Authenticate</code>报头域一起使用</p>
</li>
<li><p><strong>403 Forbidden：</strong>服务器收到请求，但是拒绝提供服务</p>
</li>
<li><p><strong>404 Not Found：</strong>请求资源不存在，eg：输入了错误的URL</p>
</li>
<li><p><strong>500 Internal Server Error：</strong>服务器发生不可预期的错误</p>
</li>
<li><p><strong>501 Server Unavailable：</strong>服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
</li>
</ul>
<h4 id="3-8-GET请求和POST请求的区别"><a href="#3-8-GET请求和POST请求的区别" class="headerlink" title="3.8 GET请求和POST请求的区别"></a>3.8 GET请求和POST请求的区别</h4><p>从以下几个层面来解答</p>
<ul>
<li>Http报文层面：GET将请求信息放在URL后面，请求信息与URL以？隔开，请求信息的格式为键值对；POST将请求信息放在报文体中，获取请求信息必须解析报文，因此安全性较GET要高一些。 </li>
<li>长度方面：GET请求信息放在URL后面，浏览器会限制URL长度，故GET请求长度有限；POST请求消息放在报文体中，所以长度没有限制。</li>
<li>数据库层面：GET符合幂等性(对数据库的一次操作和多次操作的结果是一致的)和安全性(对数据库的操作没有改变数据库中的数据)，POST不符合。</li>
<li>其他层面：GET可以被缓存、被存储，可以保存在浏览器的浏览记录中，而POST不行。</li>
</ul>
<h4 id="3-9-Cookie和Session的区别"><a href="#3-9-Cookie和Session的区别" class="headerlink" title="3.9 Cookie和Session的区别"></a>3.9 Cookie和Session的区别</h4><h5 id="3-9-1-Cookie简介"><a href="#3-9-1-Cookie简介" class="headerlink" title="3.9.1 Cookie简介"></a>3.9.1 Cookie简介</h5><ul>
<li>是由服务器发送给客户端的特殊信息，以文本的形式存放在客户端</li>
<li>客户端再次请求时，会把Cookie放在请求头中回发</li>
<li>服务器接收到后，会解析Cookie生成与客户端相对应的内容(记住密码功能)</li>
<li>Cookie的设置及发送过程如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/cookie-1564755310096.jpg" alt="cookie"></p>
<h5 id="3-9-2-Session简介"><a href="#3-9-2-Session简介" class="headerlink" title="3.9.2 Session简介"></a>3.9.2 Session简介</h5><ul>
<li>服务器端的机制，在服务器上保存的信息</li>
<li>解析客户端请求并操作<code>session id</code>，按需保存状态信息。当服务器需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否包含的session标识(<code>即session id</code>)，如果已包含<code>session id</code>，则说明以前已经为此客户端创建过session了，服务器就根据这个<code>session id</code>把session检索出来使用。如果检索不到，会新建一个。如果客户端不包含<code>session id</code>，则会为此客户端创建一个session，并创建一个与此session相关的<code>session id</code>，这个id会在本次请求中回发给客户端进行保存。</li>
</ul>
<h5 id="3-9-3-三点主要区别"><a href="#3-9-3-三点主要区别" class="headerlink" title="3.9.3 三点主要区别"></a>3.9.3 三点主要区别</h5><ul>
<li><p>Cookie数据存放在客户的浏览器上，Session数据放在服务器上</p>
</li>
<li><p>Session相对于Cookie更安全</p>
</li>
<li><p>因Session存放在服务器端，大量存放会造成服务器负担，如考虑到减轻服务器负担，应当使用Cookie</p>
</li>
</ul>
<h4 id="3-10-HTTP和HTTPS的区别"><a href="#3-10-HTTP和HTTPS的区别" class="headerlink" title="3.10 HTTP和HTTPS的区别"></a>3.10 HTTP和HTTPS的区别</h4><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP传输协议。</p>
<ul>
<li>SSL（Security Sockets Layer，安全套接层）<ul>
<li>为网络通信提供安全及数据完整性的一种安全协议</li>
<li>是操作系统对外的API，SSL3.0后更名为TLS</li>
<li>采用身份验证和数据加密保证网络通信的安全和数据的完整性</li>
</ul>
</li>
</ul>
<h5 id="3-10-1-主要区别如下"><a href="#3-10-1-主要区别如下" class="headerlink" title="3.10.1 主要区别如下"></a>3.10.1 主要区别如下</h5><ul>
<li>HTTPS需到CA申请证书，HTTP不需要</li>
<li>HTTPS密文传输，HTTP明文传输</li>
<li>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口</li>
<li>HTTPS=HTTP+SSL加密+身份认证+完整性保护，较HTTP安全</li>
</ul>

      
    </div>
    
      <footer class="article-footer">
        完
      </footer>
    
  </div>
  
    
<nav id="article-nav">
  <div class="article-nav-block">
    
      <a href="/2019/08/05/FrameWork/Spring入门/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption"></strong>
        <div class="article-nav-title">
          
            Spring简单入门
          
        </div>
      </a>
    
  </div>
  <div class="article-nav-block">
    
      <a href="/2019/07/29/JavaWeb/travel项目开发日志/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">&#39;travel项目开发日志&#39;</div>
        <strong class="article-nav-caption"></strong>
      </a>
    
  </div>
</nav>

    <link rel="stylesheet" href="/css/gitment.css"> 
<script src="/js/gitment.js"></script>

<div id="gitmentContainer"></div>

<script>
var gitment = new Gitment({
  owner: '',
  repo: '',
  oauth: {
    client_id: '',
    client_secret: '',
  },
})
gitment.render('gitmentContainer')
</script>

  
  
</article>
</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/4.jpg" title="祢豆子"></img>
    <h3 class="avatar-name">
      
        zero
      
    </h3>
    <p class="avatar-slogan">
      在追赶前人的脚步上努力的Java菜鸟
    </p>
  </div>
</div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerScience/">ComputerScience</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Interview/">Interview</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java学习笔记/">Java学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL基础/">MySQL基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringMVC/">SpringMVC</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 12px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IO流/" style="font-size: 12px;">IO流</a> <a href="/tags/JQuery/" style="font-size: 12px;">JQuery</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 12px;">JavaScript</a> <a href="/tags/MyBatis/" style="font-size: 12px;">MyBatis</a> <a href="/tags/Project/" style="font-size: 16px;">Project</a> <a href="/tags/Spring/" style="font-size: 18px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 14px;">SpringMVC</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/线程/" style="font-size: 12px;">线程</a> <a href="/tags/计算机网络/" style="font-size: 10px;">计算机网络</a> <a href="/tags/随笔/" style="font-size: 12px;">随笔</a> <a href="/tags/集合/" style="font-size: 12px;">集合</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/22/ComputerScience/04_二进制/">计科04:[二进制]</a>
          </li>
        
          <li>
            <a href="/2020/01/10/ComputerScience/03_布尔逻辑和逻辑门/">计科03:[布尔代数和逻辑门]</a>
          </li>
        
          <li>
            <a href="/2020/01/08/ComputerScience/02_电子计算机/">计科02:[电子计算机]</a>
          </li>
        
          <li>
            <a href="/2020/01/03/ComputerScience/01_计算机早期历史/">计科01:[计算机早期历史]</a>
          </li>
        
          <li>
            <a href="/2019/11/04/Other/Live2D/">Hexo博客添加live2d动态模型插件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://blog.littleha.cn/" title target='_blank'
        >小哈博客</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2020 Zero &nbsp;&nbsp;
    驱动于 <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>
<!-- 添加页面点击小红心js效果-->
{% if theme.clicklove %}
  <script type="text/javascript" src="/js/clicklove.js"></script>
{% endif%}

<!--页面标题崩溃欺骗-->
<script type="text/javascript" src="/js/crash_cheat.js"></script>