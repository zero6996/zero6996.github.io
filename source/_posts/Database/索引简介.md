---
title: MySQL索引
date: 2020-03-21 15:00:00
categories: DataBase
tags: MySQL Index
urlname: Index
---

### 1. 什么是索引

索引是帮助MySQL高效获取数据的数据结构，**索引是数据结构**。索引的目的在于提高查询效率，可以理解为：<font color=red>排好序的快速查找数据结构。</font>

<!--more-->

除了数据本身之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构的基础上实现高级查找算法**，这种数据结构就是索引。**索引以索引文件形式存储在磁盘上。

我们平常所说的所有，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀所有，唯一索引默认都是使用B+树索引，统称索引。当然除了B+树这种类型的索引之外，还有哈希索引(hash index)等。

### 2. 索引的优劣势

#### 2.1 优势

- 类似图书馆建立书目索引，提高数据检索的效率，降低数据库的IO成本。
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。

#### 2.2 劣势

- 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所有索引列也是要占用空间的。
- 虽然索引大大提交了查询速度，但同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE等写操作。因为更新表，MySQL不仅要保存数据，还要保存索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。
- 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优索引，或优化查询语句。

### 3. 索引分类

1. 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。
2. 唯一索引：索引列的值必须唯一，但允许有空值。
3. 复合索引：即一个索引包含多个列。

#### 3.1 基本语法

- 创建索引

```sql
CREATE [UNIQUE] INDEX indexName ON mytable(columnName(length));
```

- 查看索引

```sql
SHOW INDEX FROM table_name;
```

- 删除索引

```sql
DROP INDEX index_name ON table_name;
```

- 使用ALTER命令创建索引

```sql
# 添加主键索引，该索引值必须唯一且不为null
ALTER TABLE table_name ADD PRIMARY KEY(column_list);
# 添加唯一索引，允许为null
ALTER TABLE table_name ADD UNIQUE INDEX un_dept_2(column_list);
# 添加普通索引，索引值允许多次
ALTER TABLE table_name ADD INDEX index_name(column_list);
# 添加全文索引
ALTER TABLE table_name ADD FULLTEXT index_name(column_list);
```

### 4. 索引结构

索引的结构包含多种(Btree、Hash、fulltext、RTree)，这里只介绍`BTree`索引。

![索引结构](http://yanxuan.nosdn.127.net/5785ffe134a8e5a140efc4f6ff14f8da.png)

#### 4.1 B树检索原理

- B树介绍

一颗b+树，浅蓝色的块我们称之为一个磁盘块，每个磁盘块包含几个数据项(深蓝色)和指针(黄色)。

如果磁盘块1包含数据项17和35，包含指针P1、P2、P3；其中P1表示小于17的磁盘块，P2表示介于17和35之间的磁盘块，P3表示大于35的磁盘块。

<font color=red>真实的数据只存在于叶子节点</font>，即最下方的3、5、9、10、13等等。**非叶子节点不存储真实数据**，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

- 查找过程

举例查找数据29，那么首先会把磁盘块1由磁盘加载到内存，此时**发生第一次IO**；在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，通过P2指针指向的磁盘地址把磁盘块3由磁盘加载到内存，**发生第二次IO**；二分查找确定29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘8到内存，**发生第三次IO**，同时内存中做二分查找找到29，结束查询，共计3次IO。

> 3层高度的b+树可以表示上百万的数据，如果上百万数据查找只需3次IO，那么性能的提升将是巨大的。

### 5. 创建索引的情况

#### 5.1 哪些情况需要创建索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其他表关联的字段，外键关系建立索引
4. 频繁更新的字段不适合创建索引，因为每次更新不单单更新了表记录，还会更新索引表，增加IO负担。
5. Where条件里用不到的字段不创建索引。
6. 单值/组合索引的选择问题(在高并发下倾向创建组合索引)
7. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。因为索引本身就是有序的，不会在进行`filesort`，提高效率。
8. 查询中统计或分组字段。

#### 5.2 哪些情况不需要创建索引

1. 表记录太少
2. 经常增删改的表，虽然提高了查询速度，但会降低更新表的速度。
3. 数据重复且分布平均的表字段，没必要建立索引；因此应该只为经常查询和经常排序的数据列建立索引。例如某数据列有10万条记录，其中字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对字段A建立索引就没有太大的实际效果，一般不会提高数据库的查询速度。

> **索引的选择性**是指索引列中不同值的数目与表中记录数的比。假如一个表中有10000条记录，表索引列有9990个不同的值，那么这个索引的选择性就是9990/10000=0.999。一个索引的选择性越接近于1，这个索引的效率就越高。

