---
title: Java中的线程详解和同步方法
date: 2019-4-28 23:30
categories: Java学习笔记 # 分类
tags: [Java]
description: Java中的多线程运行原理及使用，同步代码的使用
---

## 1. 线程
线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 

<!--more-->

### 1.1 多线程原理
代码示例：
```java
// 定义线程类
public class MyThread extends Thread{
    // 定义指定线程名称的构造方法
    public MyThread(String name) {
        // 调用父类的String参数的构造方法，指定线程的名称
        super(name); 
    }
    // 重写run方法，完成该线程的执行逻辑
    @Override
    public void run(){
        for(int i = 0;i < 10;i++){
            System.out.println(getName()+"正在执行第"+i+"次");// getName获取当前线程名称
        }
    }
}

// 测试类
public class TestThread {
    public static void main(String[] args) {
        // 创建线程对象
        MyThread mt = new MyThread("小强");
        // 启动线程
        mt.start();
        // 在主方法中执行for循环
        for(int i = 0;i < 10;i++){
            System.out.println("旺财"+i);
        }
    }
}
```
![title](https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E7%BA%BF%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE-1556453011478.png)

程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的
start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。

多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。
![title](https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E6%A0%88%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE-1556454114513.bmp)

当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。

### 1.2 Thread类
`java.lang.Thread`类中定义了有关线程的一些方法:

**构造方法**：
* `public Thread()` ：分配一个新的线程对象。
* `public Thread(String name)` :分配一个指定名字的新的线程对象。
* `public Thread(Runnable target)` :分配一个带有指定目标新的线程对象。
* `public Thread(Runnable target,String name)` :分配一个带有指定目标新的线程对象并指定名字。

**常用方法**:
* `public String getName()`:获取当前线程名称。
* `public void start() `:导致此线程开始执行; Java虚拟机调用此线程的run方法。
* `public void run() `:此线程要执行的任务在此处定义代码。
* `public static void sleep(long millis) `:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
* `public static Thread currentThread() `:返回对当前正在执行的线程对象的引用

### 1.3 创建线程方式二
采用 `java.lang.Runnable` 也是非常常见的一种，我们只需要重写run方法即可。
步骤如下：
1. 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
2. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正
的线程对象。
3. 调用线程对象的start()方法来启动线程。

代码示例如下：
~~~java
// 实现类
public class MyRunnable implements Runnable{
    @Override
    public void run() { // 重写run方法
        for (int i = 0;i < 10; i++){
            System.out.println(Thread.currentThread().getName()+" "+i);
        }
    }
}
// 测试类
public class RunnableDemo {
    public static void main(String[] args) {
        // 创建类对象，线程任务对象
        MyRunnable mr = new MyRunnable();
        // 创建线程对象
        Thread r = new Thread(mr,"小强");
        r.start();
        for (int i = 0;i < 10;i++){
            System.out.println("旺财"+i);
        }
    }
}
~~~

通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程
代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。

在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread
对象的start()方法来运行多线程代码。

实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，**熟悉Thread类的API**是进行多线程编程的基础。

> Tips::Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。
而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。

### 1.4 Thread和Runnable的区别
如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。

**实现Runnable接口创建多线程程序的好处：**
1. 适合多个相同的程序代码的线程去共享同一个资源。
2. 可以避免java中的单继承的局限性。
3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类

> 在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。

### 1.5	匿名内部类方法实现线程的创建
使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。

使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：
```java
public class NoNameInnerClassThread {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            @Override
            public void run() {
                for(int i = 0;i<10;i++){
                    System.out.println("小张"+i);
                }
            }
        };
        new Thread(r).start();
        for (int i = 0; i < 10; i++) {
            System.out.println("小李"+i);
        }
    }
}
```

## 2. 线程安全
如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。

举例演示线程的安全问题：
电影院要卖票，模拟电影院的卖票过程。假设要播放的电影是“复联4”，本次电影的座位共100个(本场电影只能卖100张票)。

我们模拟电影院的售票窗口，实现多个窗口同时卖“复联4”这场电影票(多个窗口一起卖这100张票)

需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟

代码示例如下：
~~~java
// 实现类
public class Ticket implements Runnable{
    private int ticket = 100;
    // 执行卖票流程
    @Override
    public void run() {
        // 每个窗口的卖票操作
        while (true){
            if (ticket>0){
                try{
                    Thread.sleep(100);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+"正在卖"+ticket--);
            }
        }
    }
}
// 测试类
public class TicketDemo {
    public static void main(String[] args) {
        Ticket tk = new Ticket(); // 创建线程任务对象
        // 创建3个窗口对象
        Thread t1 = new Thread(tk,"窗口1");
        Thread t2 = new Thread(tk,"窗口2");
        Thread t3 = new Thread(tk,"窗口3");
        // 同时进行卖票操作
        t1.start();
        t2.start();
        t3.start();
    }
}
~~~
结果有一部分会出现如下情况：<br>
![title](https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-1556459958932.jpg)<br>
发现程序出现了两个问题：
1. 有部分相同的票数被卖了两回。
2. 不存在的票，比如0票与-1票，是不存在的。

这种几个窗口(线程)票数不同步了，这种问题称为线程不安全。
> 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作,一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

### 2.1 线程同步
当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。
要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制
(synchronized)来解决。
根据案例简述：
```txt
窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。
```
为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。
有三种方式完成同步操作：
1. 同步代码块。
2. 同步方法。
3. 锁机制。

### 2.2 同步代码块
* **同步代码块**：`synchronized`关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。格式：`synchronized`(同步锁){需要同步操作的代码}

**同步锁：**
对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁。
1. 锁对象 可以是任意类型。
2. 多个线程对象 要使用同一把锁。

> 注意：	在任何时候候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着
(BLOCKED)。

使用同步代码块解决线程同步问题实例：
```java
public class Ticket implements Runnable{
    private int ticket = 100;
    Object lock = new Object(); // 创建锁对象
    // 执行卖票流程
    @Override
    public void run() {
        // 每个窗口的卖票操作
        while (true){
            synchronized (lock) { // 加锁
                if (ticket > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "正在卖" + ticket--);
                }else{
                    break;
                }
            }

        }
    }
}
// 当使用了同步代码块后，上述的线程的安全问题就解决了。
```

### 2.3 同步方法
* **同步方法**：使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。格式：`public synchroized void method(){可能会产生线程问题的代码}`

> 同步锁是谁？对于非static方法，同步锁就是this。对于static方法，使用当前方法所在类的字节码对象(类名.class)

使用同步方法解决线程安全问题代码示例：
```java
public class Ticket implements Runnable{
    private int ticket = 100;
    Object lock = new Object(); // 创建锁对象
    // 执行卖票流程
    @Override
    public void run() {
        // 每个窗口的卖票操作
        while (true){
            sellTicket();
            if (ticket==0)
                break;
        }
    }
    public synchronized void sellTicket(){ // 使用synchronized修饰方法
	// 卖票操作
        if (ticket > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "正在卖" + ticket--);
        }
    }
}
```

### 2.4 Lock锁
`java.util.concurrent.locks.Lock `机制提供了比**synchronized**代码块和**synchronized**方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。

Lock锁也称同步锁，加锁与释放锁方法化了，如下：
* `public void lock()` :加同步锁。
* `public void unlock()` :释放同步锁。

使用Lock锁解决线程安全问题代码示例：
~~~java
public class Ticket implements Runnable{
    private int ticket = 100;
    Lock lock = new ReentrantLock();
    // 执行卖票流程
    @Override
    public void run() {
        // 每个窗口的卖票操作
        while (true){
            lock.lock(); // 上锁
            if (ticket > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在卖" + ticket--);
            }
            lock.unlock(); // 解锁
            if (ticket == 0)
                break;
        }
    }
}
~~~

## 3, 线程状态
### 3.1线程状态概述
当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，
有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态：

这里先列出各个线程状态发生的条件，下面对每种状态进行详细解析：<br>
![title](https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/6%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81-1556462102520.jpg)

### 3.2 Timed Waiting(计时等待)
Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。

在前面写的卖票案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就
强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。

其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等
待)，以下通过案例加深理解。

**实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串**
```java
public class TimeWaitingDemo extends Thread{
    public void run(){
        for (int i = 0; i < 100; i++) {
            if (i%10==0)
                System.out.println("------"+i);
            System.out.print(i);
            try {
                Thread.sleep(1000);
                System.out.print("线程睡眠1s！\n");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    public static void main(String[] args){
        new TimeWaitingDemo().start();
    }
}
```
sleep方法的使用还是很简单的,需要注意下面几点：
1. 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协
作关系。
2. 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程
中会睡眠
3. sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。

Timed Waiting 线程状态图：<br>
![title](https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85-1556463087958.png)

### 3.3 BLOCKED(锁阻塞)
Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。

在学完同步机制后，这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获
取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。

这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，如下图示：<br>
![title](https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E9%94%81%E9%98%BB%E5%A1%9E-1556463246524.png)

### 3.4 Wating(无限等待)
Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。
代码示例：
~~~java
public class WaitingDemo {
    public static Object obj = new Object();

    public static void main(String[] args){
        // 演示waiting
        new Thread(new Runnable() { // 匿名内部类
            @Override
            public void run() {
                while (true){
                    synchronized (obj){
                        try {
                            System.out.println(Thread.currentThread().getName()+"=== 获取到锁对" +
                                    "象，调用wait方法，进入waiting状态，释放锁对象");
                            obj.wait();// 进入无限等待状态
//                            obj.wait(5); // 5s后自动醒来
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName()+"=== 从waiting状态" +
                                "醒来，获取到锁对象，继续执行");
                    }
                }
            }
        },"等待线程").start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+"------- 等待3秒");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (obj){
                    System.out.println(Thread.currentThread().getName()+"------ 获取到锁对象" +
                            "，调用notify方法，释放锁对象");
                    obj.notify(); // 释放锁对象
                }
            }
        },"唤醒线程").start();
    }
}
// 输出结果：
等待线程=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象
唤醒线程------- 等待3秒
唤醒线程------ 获取到锁对象，调用notify方法，释放锁对象
等待线程=== 从waiting状态醒来，获取到锁对象，继续执行
等待线程=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象
.....阻塞等待中
~~~
通过上述案例可以发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的
Object.notify()方法 或 Object.notifyAll()方法。

其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，
多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞
争，但更多时候你们更多是一起合作以完成某些任务。

当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入
了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了
notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入
Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。

![title](https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85-1556464661325.png)

### 3.5 补充知识点
![title](https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE-1556464693106.png)

我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，
比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。
这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是
如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两
得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒
计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。


### 今日总结
1. 多线程原理解析
2. Thread类构造方法和常用方法的使用
3. Runnable类的使用
4. 线程安全问题
5. 线程同步的三种方法
6. 线程六种状态概述