<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redi相关面试题</title>
      <link href="/DataBase/Redis-interview.html"/>
      <url>/DataBase/Redis-interview.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h2><p>主流应用架构图</p><p><img src="http://yanxuan.nosdn.127.net/00d1ad6dbbe033d63dc316ecd2fb8f6c.png" alt="主流应用架构"></p><ol><li>客户端请求数据会先去缓存层查询；</li><li>查询到数据直接返回</li><li>查询不到数据，就会穿透缓存层去存储层查询；</li><li>存储层查询到数据后，携带数据回写到缓存层中，然后返回给客户端；</li><li>如果存储层无法完成请求，可以让客户端请求直接打在缓存层上；</li><li>不管是否获取到数据，都直接返回。</li></ol><h3 id="1-缓存中间件对比"><a href="#1-缓存中间件对比" class="headerlink" title="1. 缓存中间件对比"></a>1. 缓存中间件对比</h3><p>Memcache和Redis的区别：</p><ul><li>Memcache：代码层次类似Hash<ul><li>支持简单数据类型</li><li>不支持数据持久化存储</li><li>不支持主从</li><li>不支持分片</li></ul></li><li>Redis<ul><li>丰富的数据类型</li><li>支持数据磁盘持久化存储</li><li>支持主从</li><li>支持分片</li></ul></li></ul><h3 id="2-为什么Redis能这么快"><a href="#2-为什么Redis能这么快" class="headerlink" title="2. 为什么Redis能这么快"></a>2. 为什么Redis能这么快</h3><p>官方宣称有100000+QPS(QPS即query per second，每秒内查询次数)</p><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高；</li><li>数据结构简单，对数据操作也简单；</li><li>采用<strong>单线程</strong>，单线程也能处理高并发请求，也可启动多实例利用多核性能；</li><li>使用多路I/O复用模型，非阻塞IO(NIO)。  </li></ul><h3 id="3-多路I-O复用模型"><a href="#3-多路I-O复用模型" class="headerlink" title="3. 多路I/O复用模型"></a>3. 多路I/O复用模型</h3><ul><li>FD：File Descriptor，文件描述符；指一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射。</li></ul><h4 id="3-1-传统的阻塞I-O模型-BIO"><a href="#3-1-传统的阻塞I-O模型-BIO" class="headerlink" title="3.1 传统的阻塞I/O模型(BIO)"></a>3.1 传统的阻塞I/O模型(BIO)</h4><p>同步阻塞I/O(Block IO，简称BIO)</p><p>这种方式下，用户进程在发起一个I/O操作后，必须等待I/O操作的完成，只有当真正完成了I/O操作以后，用户进程才能运行；模式简单方便使用，但是并发性低。</p><h4 id="3-2-多路复用函数：Selector"><a href="#3-2-多路复用函数：Selector" class="headerlink" title="3.2 多路复用函数：Selector"></a>3.2 多路复用函数：Selector</h4><p>同步非阻塞(New IO，简称NIO)</p><p>此种方式下，用户进程发起一个I/O操作以后就可以返回做其他事情，但是用户进程需周期性地去询问I/O操作是否就绪，会造成一定的CPU资源的浪费。</p><p><img src="http://yanxuan.nosdn.127.net/b9ad045e9c54ced198ddb267404dee97.png" alt="Select"></p><p>Select函数可以同时监控多个FD的可读可写情况，当某些文件可读或可写时，Select就会返回FD的可读可写个数；Select是用于监听文件的读写状态，将监听任务交给Select后，用户进程就可以继续做别的事情了，从而不被阻塞。</p><h4 id="3-3-Redis采用的多路复用函数"><a href="#3-3-Redis采用的多路复用函数" class="headerlink" title="3.3 Redis采用的多路复用函数"></a>3.3 Redis采用的多路复用函数</h4><p>多路复用函数有多种：epoll、kqueue、evport、select</p><p>Redis会智能选择，因地制宜，根据不同的平台会选择不同的多路复用函数，优先会选择时间复杂度为O(1)的I/O多路复用函数作为底层实现；但不管哪个平台都会有select函数作为保底实现。</p><ul><li>Redis基于react设计模式监听I/O事件</li></ul><h3 id="4-Redis常用数据类型"><a href="#4-Redis常用数据类型" class="headerlink" title="4. Redis常用数据类型"></a>4. Redis常用数据类型</h3><ul><li><strong>String</strong>：最基本的数据类型，键值对形式；二进制安全，可以存储任何数据，包括jpg图片和序列化的对象；一个键最大能存储512MB。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; set name &quot;z3&quot;OK127.0.0.1:6379&gt; get name&quot;z3&quot;</code></pre><ul><li><strong>Hash</strong>：String类型的field和value组成的映射表，特别适合用于存储对象</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; hmset lisi name &quot;lisi&quot; age &quot;20&quot; title &quot;dev&quot;OK127.0.0.1:6379&gt; hget lisi name&quot;lisi&quot;127.0.0.1:6379&gt; hget lisi age&quot;20&quot;127.0.0.1:6379&gt; hset lisi age &quot;23&quot;(integer) 0127.0.0.1:6379&gt; hget lisi age&quot;23&quot;</code></pre><ul><li><strong>List</strong>：简单的字符串列表，按照String元素插入顺序排序，可以添加元素到列表的头部或者尾部，先进后出，有点像栈；每个列表可存储40多亿，比较适合实现最新消息，历史记录等功能。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; lpush mylist aaa(integer) 1127.0.0.1:6379&gt; lpush mylist bbb(integer) 2127.0.0.1:6379&gt; lpush mylist ccc(integer) 3127.0.0.1:6379&gt; lrange mylist 0 101) &quot;ccc&quot;2) &quot;bbb&quot;3) &quot;aaa&quot;</code></pre><ul><li><strong>Set</strong>：String类型的无序不可重复集合，集合是通过哈希表实现的，因此添加、删除、查找复杂度都是O(1)；</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; sadd myset 111(integer) 1127.0.0.1:6379&gt; sadd myset 222(integer) 1127.0.0.1:6379&gt; sadd myset 333(integer) 1127.0.0.1:6379&gt; sadd myset 222(integer) 0127.0.0.1:6379&gt; smembers myset1) &quot;111&quot;2) &quot;222&quot;3) &quot;333&quot;127.0.0.1:6379&gt; sadd myset aaa(integer) 1127.0.0.1:6379&gt; sadd myset bbb(integer) 1127.0.0.1:6379&gt; sadd myset ccc(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;333&quot;2) &quot;222&quot;3) &quot;bbb&quot;4) &quot;ccc&quot;5) &quot;111&quot;6) &quot;aaa&quot;</code></pre><ul><li>Soreed Set：是个有序的不允许重复的集合，通过分数来为集合中的成员进行从小到大的排序。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; zadd myzset 3 abc(integer) 1127.0.0.1:6379&gt; zadd myzset 1 abd(integer) 1127.0.0.1:6379&gt; zadd myzset 2 abb(integer) 1127.0.0.1:6379&gt; zadd myzset 2 abb(integer) 0127.0.0.1:6379&gt; zadd myzset 1 bcc(integer) 1127.0.0.1:6379&gt; zrangebyscore myzset 0 101) &quot;abd&quot;2) &quot;bcc&quot;3) &quot;abb&quot;4) &quot;abc&quot;</code></pre><ul><li>用于技术的HyperLogLog，用于支持存储地理位置信息的Geo，可了解。</li></ul><h4 id="4-1-各数据类型应用场景"><a href="#4-1-各数据类型应用场景" class="headerlink" title="4.1 各数据类型应用场景"></a>4.1 各数据类型应用场景</h4><table><thead><tr><th>类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td>String(字符串)</td><td>二进制安全</td><td>可以包含任何数据，如jpg或序列化的对象，一个键最大存储512MB</td><td>/</td></tr><tr><td>Hash(字典)</td><td>键值对集合，对应Java中的Map类型</td><td>适合存储对象，且可以像数据库中update一个属性一样只修改某一项属性值</td><td>存储、读取、修改用户属性</td></tr><tr><td>List(列表)</td><td>类似双向链表数据结构</td><td>增删快，先进后出FILO</td><td>最新消息排行、历史记录、消息队列</td></tr><tr><td>Set(集合)</td><td>哈希表实现，元素不重复</td><td>增删查复杂度都是O(1)，提供了求交集、并集、差集等操作</td><td>微博共同好友、利用唯一性统计访问网站的独立IP</td></tr><tr><td>Sorted Set(有序集合)</td><td>通过分数来设置元素的权重，按照分数有序排列</td><td>数据插入集合时，已经进行了排序</td><td>排行榜功能、带权重的消息队列</td></tr></tbody></table><h3 id="5-从海量Key里查询出某一固定前缀的Key"><a href="#5-从海量Key里查询出某一固定前缀的Key" class="headerlink" title="5. 从海量Key里查询出某一固定前缀的Key"></a>5. 从海量Key里查询出某一固定前缀的Key</h3><p>首先要问清楚数据规模，就是问清楚边界。</p><h4 id="5-1-使用keys命令对线上业务的影响"><a href="#5-1-使用keys命令对线上业务的影响" class="headerlink" title="5.1 使用keys命令对线上业务的影响"></a>5.1 使用keys命令对线上业务的影响</h4><ul><li><code>KEYS pattern</code>：查找所有符合给定模式pattern的key<ul><li>KEYS指令会一次性返回所有匹配的key</li><li>如果符合条件的key数量过大会使服务严重卡顿</li></ul></li></ul><h4 id="5-2-SCAN指令解决问题"><a href="#5-2-SCAN指令解决问题" class="headerlink" title="5.2 SCAN指令解决问题"></a>5.2 SCAN指令解决问题</h4><ul><li><p><code>SCAN cursor [MATCH pattern][Count count]</code></p><ul><li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程；</li><li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历；</li><li>不保证每次执行都返回某个给定数量的元素，支持模糊查询；</li><li>一次返回的数量不可控，只能大概率符合count参数</li></ul></li><li><p>大致使用方式</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; dbsize(integer) 20000014127.0.0.1:6379&gt; scan 0 match k1* count 101) &quot;1048576&quot;2) 1) &quot;k1009956&quot;   2) &quot;k18772691&quot;   3) &quot;k16159479&quot;   4) &quot;k16084955&quot;127.0.0.1:6379&gt; scan 1048576 match k1* count 101) &quot;524288&quot;2) 1) &quot;k14708101&quot;   2) &quot;k18736411&quot;   3) &quot;k18277238&quot;   4) &quot;k15412443&quot;   5) &quot;k11546971&quot;   6) &quot;k18222917&quot;   7) &quot;k18219047&quot;127.0.0.1:6379&gt; scan 524288 match k1* count 101) &quot;11010048&quot;2) 1) &quot;k16429625&quot;   2) &quot;k12792948&quot;   3) &quot;k18338950&quot;   4) &quot;k18423259&quot;</code></pre><p>可见每次返回的游标并非递增的，所以可能获取重复key，需要在外部程序自行去重（例如Java使用HashSet）。</p><h3 id="6-如何通过Redis实现分布式锁"><a href="#6-如何通过Redis实现分布式锁" class="headerlink" title="6. 如何通过Redis实现分布式锁"></a>6. 如何通过Redis实现分布式锁</h3><p>为了保证分布式锁的可用，确保锁实现同时必须满足以下四个条件：</p><ul><li>互斥性：任意时刻只能有一个客户端获取到锁，不能有两个客户端获取锁；</li><li>安全性：锁只能被持有锁的客户端释放，不能被其他客户端释放；</li><li>死锁：获取锁的客户端因为某些原因宕机未能释放锁，也需保证其他客户端能加锁；</li><li>容错：当某些redis节点宕机时，客户端仍然能获取锁和释放锁。</li></ul><h4 id="6-1-SETNX命令"><a href="#6-1-SETNX命令" class="headerlink" title="6.1 SETNX命令"></a>6.1 SETNX命令</h4><ul><li><code>SETNX key value</code>：如果key不存在，则创建并赋值</li></ul><p>初期时可以使用这个命令来实现分布式锁，但会有一个问题，SETNX设置的key是长期有效的。</p><ul><li><code>EXPIRE key seconds</code>：设置key的生存时间，当key过期时，会被自动删除</li></ul><p>可以通过<code>EXPIRE</code>命令来实现简单的分布式锁，使用<code>setnx</code>命令后返回状态1表示设置成功，然后给该key设置一个过期时间。伪代码如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">RedisService service = SpringUtils.getBean(RedisService.class);long status = service.setnx(key,&quot;1&quot;);if (status == 1) {    service.expire(key,expire);}</code></pre><p>但有个缺点就是，原子性无法满足，如果设置锁后程序突然奔溃，没有成功设置超时时间，就会发生死锁；两个原子操作结合起来，就不是原子性的了。</p><h4 id="6-2-SET命令"><a href="#6-2-SET命令" class="headerlink" title="6.2 SET命令"></a>6.2 SET命令</h4><ul><li><code>SET key value [EX seconds][PX milliseconds][NX|XX]</code><ul><li>EX seconds：设置键的过期时间为second秒</li><li>PX milliseconds：设置键的过期毫秒时间</li><li>NX：仅在键不存在时，才对键进行操作</li><li>XX：仅在键已存在时，才对键进行操作</li><li>SET操作成功，返回OK，反之返回nil</li></ul></li><li>redis中操作示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; set locktarget 12345 ex 10 nxOK127.0.0.1:6379&gt; set locktarget 12345 ex 10 nx(nil)127.0.0.1:6379&gt; set locktarget 123456 ex 10 nx(nil)ten seconds after127.0.0.1:6379&gt; set locktarget 123456 ex 10 nxOK</code></pre><ul><li>伪代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">RedisService service = SpringUtils.getBean(RedisService.class);String result = service.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);if (&quot;OK&quot;.equals(result)){    &#x2F;&#x2F; 执行独占资源逻辑}</code></pre><h4 id="6-3-当大量key同时过期需注意什么？"><a href="#6-3-当大量key同时过期需注意什么？" class="headerlink" title="6.3 当大量key同时过期需注意什么？"></a>6.3 当大量key同时过期需注意什么？</h4><p>关于集中过期现象，由于清除大量key很耗时，会出现短暂的卡顿现象</p><ul><li>解决方法：在设置key的过期时间时，给每个key的过期时间加上随机值，使过期时间分散些。</li></ul><h3 id="7-如何使用Redis做异步队列"><a href="#7-如何使用Redis做异步队列" class="headerlink" title="7. 如何使用Redis做异步队列"></a>7. 如何使用Redis做异步队列</h3><h4 id="7-1-使用List实现"><a href="#7-1-使用List实现" class="headerlink" title="7.1 使用List实现"></a>7.1 使用List实现</h4><p>根据List的数据结构特性，使用RPUSH生产消息，LPOP消费消息。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt;  rpush testlist aaa(integer) 1127.0.0.1:6379&gt;  rpush testlist bbb(integer) 2127.0.0.1:6379&gt;  rpush testlist ccc(integer) 3127.0.0.1:6379&gt; lpop testlist&quot;aaa&quot;127.0.0.1:6379&gt; lpop testlist&quot;bbb&quot;127.0.0.1:6379&gt; lpop testlist&quot;ccc&quot;</code></pre><ul><li>缺点：不会等待队列中有值才去消费</li><li>弥补：可以在代码层面引入sleep机制去调用lpop重试</li><li>如果不用sleep如何实现？：可以使用blpop实现比sleep更加精准的阻塞控制<ul><li><code>BLPOP key[key ...] timeout</code>：阻塞直到队列有消息或超时</li><li>缺点：只能供一个消费者消费</li></ul></li></ul><h4 id="7-2-主题订阅者模式"><a href="#7-2-主题订阅者模式" class="headerlink" title="7.2 主题订阅者模式"></a>7.2 主题订阅者模式</h4><p>使用redis的发布订阅可以实现1对多的生产者消费者模型。</p><ul><li>发送者（pub）发送消息，订阅者（sub）接收消息。</li><li>订阅者可订阅任意数量的频道</li><li>使用<code>SUBSCRIBE xxx</code>订阅xxx频道，使用<code>PUBLISH xxx “message”</code>对xxx频道发送消息。</li><li>pub/sub的缺点：消息的发布时无状态的，无法保证可达，想解决这个问题就需要使用到专门的消息队列，例如kafka等解决。</li></ul><h3 id="8-RDB"><a href="#8-RDB" class="headerlink" title="8. RDB"></a>8. RDB</h3><p>RDB（快照）持久化：保存某个时间点的全量数据快照</p><h4 id="8-1-默认配置"><a href="#8-1-默认配置" class="headerlink" title="8.1 默认配置"></a>8.1 默认配置</h4><p>默认配置参数位于<code>SNAPSHOTTING</code>配置区，参数如下（<code>save m n</code>触发用的是bgsave）：</p><ul><li><code>save 900 1</code>：15分钟内改动一次就保存</li><li><code>save 300 10</code>：5分钟内改动10次就保存</li><li><code>save 60 10000</code>：1分钟内改动1万次就保存</li><li><code>save &quot;&quot;</code>：禁用RDB配置</li></ul><h4 id="8-2-客户端中的相关命令"><a href="#8-2-客户端中的相关命令" class="headerlink" title="8.2 客户端中的相关命令"></a>8.2 客户端中的相关命令</h4><p>redis中也可使用RDB相关命令</p><ul><li><code>save</code>：马上执行一次RDB，将数据写入到磁盘，会阻塞Redis主进程，不推荐使用。</li><li><code>bgsave</code>：redis会后台异步进行快照操作，同时还可以响应客户端请求，推荐；底层会fork出一个子进程来创建rdb文件，不会阻塞主进程。</li><li><code>lastsave</code>：查看最后一次成功执行的快照时间</li></ul><h4 id="8-3-触发RDB情况"><a href="#8-3-触发RDB情况" class="headerlink" title="8.3 触发RDB情况"></a>8.3 触发RDB情况</h4><p>自动触发RDB持久化的情况：</p><ul><li>根据redis.conf配置文件中的<code>SAVE m n</code>触发</li><li>主从复制时，主节点会自动触发</li><li>执行Debug Reload时</li><li>redis服务Shutdown且没有开启AOF时</li></ul><h4 id="8-4-BGSAVE原理"><a href="#8-4-BGSAVE原理" class="headerlink" title="8.4 BGSAVE原理"></a>8.4 BGSAVE原理</h4><p><img src="https://s1.ax1x.com/2020/08/13/dpSe2D.png" alt="BGSAVE"></p><ul><li>系统调用fork()：创建进程，实现了<code>Copy-on-Write</code><ul><li>Cow：如果有多个调用者同时要求相同资源（如内存或磁盘上的数据），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初资源不变。</li></ul></li></ul><h4 id="8-5-RDB的缺点"><a href="#8-5-RDB的缺点" class="headerlink" title="8.5 RDB的缺点"></a>8.5 RDB的缺点</h4><ul><li>rdb备份数据时全量同步，数据量大时会由于I\O而严重影响性能</li><li>redis如果突然挂掉会丢失最近一次快照之后的所有数据</li></ul><h3 id="9-AOF"><a href="#9-AOF" class="headerlink" title="9. AOF"></a>9. AOF</h3><p>AOF（Append-Only-File）持久化：保存写操作指令，简单来说就是RDB备份数据，AOF备份写操作命令</p><ul><li>会记录下除查询以外的所有变更数据库状态的指令</li><li>以append形式追加到AOF文件中（增量）</li></ul><p>AOF的配置位于Redis配置文件的<code>APPEND ONLY MODE</code>配置区，配置<code>appendonly</code>参数，默认关闭。默认保存文件是<code>appendonly.aof</code>，位于redis启动目录下。默认是每秒保存一次。</p><h4 id="9-1-AOF重写机制"><a href="#9-1-AOF重写机制" class="headerlink" title="9.1 AOF重写机制"></a>9.1 AOF重写机制</h4><p>AOF采用的文件追加方式，文件会越来越大，为避免出现此种情况，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可使用命令<code>bgrewriteaof</code>手动启动。</p><ul><li>重写机制的原理<ul><li>调用fork()，创建子进程进行重写操作</li><li>子进程把新的AOF写到临时文件中，不依赖旧AOF文件</li><li>主进程持续将新变动写到内存和旧AOF中</li><li>主进程获取到子进程重写AOF完成信号，往新AOF中同步增量变动</li><li>使用新AOF文件替换掉旧AOF文件</li></ul></li></ul><p>AOF文件持续增长且文件过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有些类似。</p><ul><li>触发机制</li></ul><p>Redis会记录上次重写时的AOF文件大小，默认配置是当AOF文件大小为上次rewrite后大小的一倍且文件大于64MB时触发。</p><h4 id="9-2-RDB和AOF的优缺点"><a href="#9-2-RDB和AOF的优缺点" class="headerlink" title="9.2 RDB和AOF的优缺点"></a>9.2 RDB和AOF的优缺点</h4><ul><li>RDB优点：全量数据快照，文件小恢复快</li><li>RDB缺点：无法保存最近一次快照之后的数据</li><li>AOF优点：可读性高，适合保存增量数据，数据不易丢失</li><li>AOF缺点：文件体积大，恢复时间长</li></ul><h3 id="10-Pipeline"><a href="#10-Pipeline" class="headerlink" title="10. Pipeline"></a>10. Pipeline</h3><ul><li>Pipeline和Linux的管道类似</li><li>Redis基于请求/响应模型，即单一请求处理会一一应答</li><li>Pipeline批量执行指令，能节省多次IO往返的时间</li><li>如果是有顺序依赖的指令，建议分批发送</li></ul><h3 id="11-主从同步的原理"><a href="#11-主从同步的原理" class="headerlink" title="11.  主从同步的原理"></a>11.  主从同步的原理</h3><ol><li>Salve启动成功连接到Master后会发送一个同步命令sync</li><li>Master启动一个后台进程bgsave，将Redis中的数据快照保存到RDB文件中</li><li>Master会将保存数据快照期间接收到的写命令缓存到复制缓冲区中<ol><li>全量复制：Master完成备份文件操作后，将该RDB文件发送给Slave节点</li><li>增量复制：Master继续将新收集到的写操作命令依次传给slave，完成同步操作</li></ol></li><li>Master将期间收集到的写命令发送给Salve节点以更新至主节点最新状态</li></ol><h3 id="12-哨兵模式"><a href="#12-哨兵模式" class="headerlink" title="12. 哨兵模式"></a>12. 哨兵模式</h3><p>Redis官方提供的一款集群管理工具，用于解决主机宕机的主从切换问题；本身是独立运行的进程，能够在后台监控主机是否故障，主要功能如下：</p><ul><li>监控：检查主节点是否运行正常</li><li>提醒：通过API向管理员或者其他应用程序发送故障通知</li><li>自动故障迁移：主从切换，主机故障会根据投票机制自动选取一台从机转换为主机。</li></ul><h3 id="13-一致性哈希算法"><a href="#13-一致性哈希算法" class="headerlink" title="13. 一致性哈希算法"></a>13. 一致性哈希算法</h3><p>一致性hash算法可以很好的解决Redis分布式的问题，将缓存均匀分配，提高缓存命中率；大致是通过对2的32次方取模，将哈希值空间组织成一个虚拟的圆环，再将节点分布到圆环上。</p><p>基本原理：</p><ul><li>假设一个圆环，环上有2^32^个点，从0~2^32^-1</li><li>对Redis节点进行哈希：hash(服务器IP)%2^32^，将服务器节点映射到环上</li><li>对缓存数据进行哈希：hash(缓存项的key)%2^32^，将各缓存项映射到环上</li><li>从缓存项的位置开始，顺时针方向遇到第一个服务器就是缓存项的缓存位置</li></ul><h4 id="13-1-优缺点"><a href="#13-1-优缺点" class="headerlink" title="13.1 优缺点"></a>13.1 优缺点</h4><ul><li>优点：当某个节点宕机时，缓存项会打到顺时针下去第一个节点，而不会丢失</li><li>缺点：如果节点被密集映射在同一区域，会导致大量缓存项被缓存到同一台服务器，导致数据倾斜，如果该节点宕机，可能会造成缓存雪崩<ul><li>解决方案：为每个节点生成多个虚拟节点，并映射到环上，尽量使缓存分配均匀</li><li>虚拟节点的哈希计算可以采用节点IP+数字后缀，例如<code>Hash(&quot;192.168.1.101#1&quot;)%2^32</code></li></ul></li></ul><h3 id="14-Redis事务和MySQL事务的区别"><a href="#14-Redis事务和MySQL事务的区别" class="headerlink" title="14. Redis事务和MySQL事务的区别"></a>14. Redis事务和MySQL事务的区别</h3><h4 id="14-1-Redis事务的实现原理"><a href="#14-1-Redis事务的实现原理" class="headerlink" title="14.1 Redis事务的实现原理"></a>14.1 Redis事务的实现原理</h4><p>Redis的事务就是：在一个队列中，一次性、顺序性、排他性的串行化执行一系列命令。</p><ul><li>redis实现事务是基于commands队列的，本质就是一组命令队列；</li><li>没有开启事务，命令会被立即执行返回结果，并直接写入磁盘中；</li><li>开启事务后，命令不会立即执行，而是按顺序排入队列中，调用exec才会执行命令队列；</li></ul><h4 id="14-2-MySQL事务的实现原理"><a href="#14-2-MySQL事务的实现原理" class="headerlink" title="14.2 MySQL事务的实现原理"></a>14.2 MySQL事务的实现原理</h4><ul><li>mysql实现事务是基于undo/redo日志的；</li><li>undo记录修改前的状态，rollback就是基于undo日志实现的，回滚到修改前的状态；</li><li>redo记录修改后的状态，commit基于redo日志实现的，提交事务；</li><li>mysql无论是否开启事务，sql都会被立即执行并返回结果，只是事务开启后执行的状态记录在redo日志中，只有执行commit命令后，数据才会被写入到磁盘中。</li></ul><h3 id="15-Redis有几种数据淘汰策略"><a href="#15-Redis有几种数据淘汰策略" class="headerlink" title="15. Redis有几种数据淘汰策略"></a>15. Redis有几种数据淘汰策略</h3><ul><li>volatile-lru：加入键时如果过限，首先从设置了过期时间的键集合中移除最久没有使用的键；</li><li>allkeys-lru：加入键如过限，首先通过LRU算法移除最久没有使用的键；</li><li>volatile-lfu：从所有配置了过期时间的键中移除使用频率最少的键；</li><li>allkeys-lfu：从所有键中移除使用频率最少的键；</li><li>volatile-random：从过期键的集合中随机移除键</li><li>allkeys-random：从所有键集合中随机移除；</li><li>volatile-ttl：从配置了过期时间的键中移除将要过期的键；</li><li>noeviction：不进行移除，内存过限将返回错误信息；</li></ul><h3 id="16-缓存穿透及解决"><a href="#16-缓存穿透及解决" class="headerlink" title="16. 缓存穿透及解决"></a>16. 缓存穿透及解决</h3><p>缓存穿透就是查询大量不存在的key，查询不到就穿透缓存层到数据库去查询了，会对后端数据库造成压力。</p><ul><li>解决方案：<ul><li>对查询结果为空的key也进行缓存，可以将过期时间设短一些或者key对应数据insert后清除该缓存。</li><li>使用布隆过滤器(bitmap)进行过滤，将所有可能存在的key放到一个大的Bitmap中，查询时过滤。</li></ul></li></ul><h3 id="17-缓存雪崩及解决"><a href="#17-缓存雪崩及解决" class="headerlink" title="17. 缓存雪崩及解决"></a>17. 缓存雪崩及解决</h3><p>当某一redis节点突然宕机或者大量缓存集中某一时间段失效，这样失效时，就会越过缓存层直接打到数据库上，对后端系统带来很大压力；此为缓存雪崩。</p><ul><li>解决方案：<ul><li>当缓存失效后，通过加锁或队列来限制读取数据库的线程数量，减轻后端压力。</li><li>做二级缓存，A1原始缓存设置短期缓存时间，A2拷贝缓存设置长期，当A1失效时访问A2即可。</li><li>设置key缓存时间时，加入随机种子设置不同过期时间，让缓存失效时间尽量均匀</li></ul></li></ul><h3 id="18-Redis的常见应用"><a href="#18-Redis的常见应用" class="headerlink" title="18. Redis的常见应用"></a>18. Redis的常见应用</h3><ol><li>会话缓存（session cache）</li><li>全页缓存（FPC）</li><li>队列</li><li>排行榜/计数器</li><li>发布/订阅</li></ol>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java锁体系概述</title>
      <link href="/JavaAdvanced/Java-Lock.html"/>
      <url>/JavaAdvanced/Java-Lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Java锁体系"><a href="#Java锁体系" class="headerlink" title="Java锁体系"></a>Java锁体系</h1><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码、使用场景进行举例，以介绍主流锁的知识点及其适用场景。</p><ol><li>乐观锁，悲观锁</li><li>读锁（共享锁），写锁（排他锁）</li><li>自旋锁，非自旋锁</li><li>无锁，偏向锁，轻量级锁，重量级锁</li><li>分布式锁</li><li>区间锁（分段锁）<code>java.util.concurrent</code> <code>ConcurrentHashMap</code></li><li>重入锁，非重入锁</li><li>公平锁，非公平锁</li></ol><p><img src="https://s1.ax1x.com/2020/06/28/N2aGzq.png" alt="Java锁体系"></p><h2 id="1-悲观锁与乐观锁"><a href="#1-悲观锁与乐观锁" class="headerlink" title="1. 悲观锁与乐观锁"></a>1. 悲观锁与乐观锁</h2><p>悲观锁与乐观锁是一种广义概念，体现的是看待线程同步的不同角度。</p><h3 id="1-1-悲观锁"><a href="#1-1-悲观锁" class="headerlink" title="1.1 悲观锁"></a>1.1 悲观锁</h3><p>悲观锁认为自己在使用数据时一定有别的线程会来修改数据，因此在获取数据时就会先加锁，确保数据不会被别的线程修改。</p><ul><li>锁实现：<code>synchronized</code>，<code>Lock</code>接口的相关实现类</li><li>适用场景：写操作较多的场景，先加锁以保证写操作时数据的正确性</li></ul><h3 id="1-2-乐观锁"><a href="#1-2-乐观锁" class="headerlink" title="1.2 乐观锁"></a>1.2 乐观锁</h3><p>乐观锁认为自己在使用数据时不会有别的线程来修改数据，所以不会加锁，但是在更新数据时会去判断之前有没有别的线程更新了这个数据； 如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。 </p><ul><li>锁实现：Java中通过使用无锁编程实现，常采用CAS算法，例如<code>AtomicInteger</code>类的原子自增就是通过CAS自旋实现的</li><li>适用场景：读操作较多的场景，不加锁的特点能使读操作的性能大幅提升</li></ul><h3 id="1-3-悲观锁与乐观锁的执行过程"><a href="#1-3-悲观锁与乐观锁的执行过程" class="headerlink" title="1.3 悲观锁与乐观锁的执行过程"></a>1.3 悲观锁与乐观锁的执行过程</h3><p><a href="https://www.processon.com/view/link/5ef8563ff346fb1ae5810e05" target="_blank" rel="noopener">见流程图</a></p><h3 id="1-4-CAS算法"><a href="#1-4-CAS算法" class="headerlink" title="1.4 CAS算法"></a>1.4 CAS算法</h3><p>为什么乐观锁能够做到不锁定资源情况下也正确的实现线程同步呢？因为乐观锁使用到了CAS技术。</p><p>CAS全称<code>Compare And Swap</code>（比较与交换），它是一种常见的降低读写锁冲突，保证数据一致性的乐观锁机制。 CAS是一种无锁算法，在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</p><h4 id="1-4-1-CAS算法原理"><a href="#1-4-1-CAS算法原理" class="headerlink" title="1.4.1 CAS算法原理"></a>1.4.1 CAS算法原理</h4><p>在JUC包中的原子类<code>AtomicInteger</code>就是通过CAS来实现了乐观锁，该算法会涉及到三个操作数：</p><ol><li>需要读写的内存值：V</li><li>进行比较的值：A</li><li>要写入的新值：B</li></ol><p>当且仅当V值等于A值时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作，一般“更新”操作会不断重试。</p><p>CAS<a href="https://www.processon.com/view/link/5ef8696b07912929cb61a06d" target="_blank" rel="noopener">算法执行原理</a></p><h4 id="1-4-2-CAS存在的问题"><a href="#1-4-2-CAS存在的问题" class="headerlink" title="1.4.2 CAS存在的问题"></a>1.4.2 CAS存在的问题</h4><ul><li>循环时间长开销大：CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来较大的开销。</li><li>只能保证一个共享变量的原子操作：对一个共享变量执行操作时，CAS能保证原子操作，但对多个共享变量操作时，CAS是无法保证操作的原子性的。</li><li>JDK1.5开始提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，可以把多个变量放在一个对象里进行CAS操作。</li><li>高并发场景下很容易发生的ABA问题</li></ul><p>假设两个线程T1和T2访问同一个变量V，当T1访问变量V时，读取到V的值为A；此时线程T1被抢占了，T2开始执行，T2会先将变量V的值从A改成B，然后又将变量V从B改回了A；此时T1得到时间片，继续执行，它发现变量V的值还是A，认为没有发生变化，就会继续执行。这个过程中，主内存中的变量V变化就是<code>A-&gt;B-A</code>，故称ABA问题。</p><p>明面上看不会导致什么问题，但实际上的问题在于：“值是一样的”等同于“没有发生变化”这个认知；就算V值被改回去了，那么现在的V也不是以前的V了。因此有的时候，我们并不只是需要判断变量是否相同，还需要在执行过程中，判断这个变量是否已经发生了变化。</p><ul><li>如何解决ABA问题</li></ul><p>对于ABA问题带来的隐患，各种乐观锁的实现通常会使用版本戳<code>version</code>来核对记录或者对象标记，避免并发操作带来的问题。Java中的<code>AtomicStampedReference</code>实现了这个作用， 它通过包装<code>[E,Integer]</code>的元组来对对象<strong>标记版本戳</strong><code>stamp</code>，从而避免ABA问题；代码实例如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ABA {    private static AtomicInteger atomicInt = new AtomicInteger(100);    private static AtomicStampedReference atomicStampedRef =  new AtomicStampedReference(100,0);    public static void main(String[] args) throws Exception{        Thread intT1 = new Thread(new Runnable() {            @Override            public void run() {                &#x2F;&#x2F; 复现ABA问题                atomicInt.compareAndSet(100, 101);                atomicInt.compareAndSet(101, 100);            }        });        Thread intT2 = new Thread(new Runnable() {            @Override            public void run() {                try {                    TimeUnit.SECONDS.sleep(1);                }catch (Exception e){                    e.printStackTrace();                }                &#x2F;&#x2F; 会成功执行CAS操作                boolean c3 = atomicInt.compareAndSet(100,101);                System.out.println(c3); &#x2F;&#x2F; true            }        });        intT1.start();        intT2.start();        intT1.join();        intT2.join();        Thread refT1 = new Thread(new Runnable() {            @Override            public void run() {                try {                    TimeUnit.SECONDS.sleep(1);                } catch (Exception e) {                    e.printStackTrace();                }                &#x2F;&#x2F; 使用AtomicStampedReference解决ABA问题                atomicStampedRef.compareAndSet(100,101,atomicStampedRef.getStamp(),atomicStampedRef.getStamp()+1);                atomicStampedRef.compareAndSet(101,100,atomicStampedRef.getStamp(),atomicStampedRef.getStamp()+1);            }        });        Thread refT2 = new Thread(new Runnable() {            @Override            public void run() {                int stamp = atomicStampedRef.getStamp();                try {                    TimeUnit.SECONDS.sleep(2);                } catch (Exception e) {                    e.printStackTrace();                }                &#x2F;&#x2F; 执行CAS操作会失败                boolean c3 = atomicStampedRef.compareAndSet(100,101,stamp,stamp+1);                System.out.println(c3); &#x2F;&#x2F; false            }        });        refT1.start();        refT2.start();    }}</code></pre><h2 id="2-自旋锁与适应性自旋锁"><a href="#2-自旋锁与适应性自旋锁" class="headerlink" title="2. 自旋锁与适应性自旋锁"></a>2. 自旋锁与适应性自旋锁</h2><h3 id="2-1-自旋锁"><a href="#2-1-自旋锁" class="headerlink" title="2.1 自旋锁"></a>2.1 自旋锁</h3><p>自旋锁是指当一个线程在获取锁时，如果锁已经被其他线程获取，那么该线程会一直循环判断锁是否被释放，直到获取到锁才会退出循环。</p><ul><li>自旋锁的原理</li></ul><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间，开销较大；如果同步代码块中的内容过于简单，状态切换消耗的时间可能比用户代码执行时间还要长，为了这一小段时间区切换CPU状态，线程挂起和恢复现场的花费可能让系统得不偿失。</p><p>如果持有锁的线程能在短时间内释放资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态了，它们只需要等一等（自旋），等到持有锁的线程释放锁后即可获取，这样就避免了用户进程和内核切换的消耗。</p><p><img src="https://s1.ax1x.com/2020/07/02/NbI9PI.png" alt="Spin-Lock"></p><h3 id="2-2-适应性自旋锁"><a href="#2-2-适应性自旋锁" class="headerlink" title="2.2 适应性自旋锁"></a>2.2 适应性自旋锁</h3><p>自旋锁本身是有缺点的，它并不能代替阻塞。自旋等待虽然避免了线程切换的开销，但是它会占用处理器时间；如果锁被占用时间很短，自旋等待的效果就会非常好，反之如果锁被占用时间很长，那么自旋的线程只会白浪费处理器资源。所以自旋等待的时间必须要有一定的限度，如果超过了限定次数没有成功获得锁，就挂起线程。</p><p>JDK1.6中就引入了<strong>适应性自旋锁</strong>，自适应意味着自旋的时间（次数）不再固定，而是由前一次在同锁上的自旋时间及锁拥有者的状态来决定；如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很可能成功，进而允许它拥有较长时间的自旋等待，反之则会直接阻塞线程。</p><p>可以通过<code>-XX:-UseSpining</code>参数来设置是否使用自旋锁，通过<code>-XX:PreBlockSpin</code>参数设置自旋次数（默认10次）。JDK1.7以后取消了用户对自旋参数的配置，均由虚拟机自动调整。</p><h3 id="2-3-小结：自旋锁的优缺点"><a href="#2-3-小结：自旋锁的优缺点" class="headerlink" title="2.3 小结：自旋锁的优缺点"></a>2.3 小结：自旋锁的优缺点</h3><ul><li>优点：自旋锁减少了线程的阻塞，对于<strong>锁竞争不激烈且占用锁时间非常短</strong>的代码来说性能能大幅提升，因为避免了线程的上下文切换。</li><li>缺点：如果锁竞争激烈且线程长时间占有锁，就不适合使用自旋锁了；因为自旋锁会一直占用CPU资源，如果长时间自旋无法获取锁，线程自旋的消耗大于线程阻塞挂起的消耗，就需要关闭自旋锁。</li></ul><h2 id="3-无锁、偏向锁、轻量级锁、重量级锁"><a href="#3-无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="3. 无锁、偏向锁、轻量级锁、重量级锁"></a>3. 无锁、偏向锁、轻量级锁、重量级锁</h2><p>这四种是指锁的状态，专门针对synchronized的。先了解一些额外知识。</p><h3 id="3-1-为什么Synchronized能实现线程同步？"><a href="#3-1-为什么Synchronized能实现线程同步？" class="headerlink" title="3.1 为什么Synchronized能实现线程同步？"></a>3.1 为什么Synchronized能实现线程同步？</h3><p>首先要知道两个重要概念：Java对象头、Monitor</p><h4 id="3-1-1-Java对象头"><a href="#3-1-1-Java对象头" class="headerlink" title="3.1.1 Java对象头"></a>3.1.1 Java对象头</h4><p>synchronized是悲观锁，在操作同步资源之前需给同步资源加锁，这把锁就是存在Java对象头里的。</p><p>以Hotspot虚拟机为例，Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针），如下就是一个对象的存储结构图</p><p><img src="https://s1.ax1x.com/2020/07/03/NjkK1A.png" alt="对象头"></p><ul><li><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息等。</li></ul><p>这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><ul><li><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><blockquote><p>面试题：Java中对象是如何存储的？</p><p>答：对象的实例数据存储在堆空间，对象的元数据存在方法区（元空间），对象的引用存在栈空间。</p></blockquote><h4 id="3-1-2-Monitor"><a href="#3-1-2-Monitor" class="headerlink" title="3.1.2 Monitor"></a>3.1.2 Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每个Java对象就有一把看不见的锁，称之为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每个线程都有一个可用monitor record列表，同时还有一个全局可用列表；每个被锁住的对象都会和一个monitor关联，同时monitor中有一个owner（所有者）字段存放拥有该锁线程的唯一标识，表示该锁被这个线程占用。</p><p>synchronized锁是JVM内置锁，通过内部对象Monitor（监视器锁）实现线程同步，监视器锁的实现依赖底层操作系统的<code>Mutex Lock</code>（互斥锁）来实现线程同步。</p><p>每个同步对象都有一个自己的Monitor：</p><p><img src="https://s1.ax1x.com/2020/07/01/N7WMwt.png" alt="Monitor"></p><h3 id="3-2-synchronized的锁升级"><a href="#3-2-synchronized的锁升级" class="headerlink" title="3.2 synchronized的锁升级"></a>3.2 synchronized的锁升级</h3><p>synchronized最初实现同步的方式就是阻塞和唤醒来实现线程同步，这就是JDK 6之前synchronized效率低的原因，这种<strong>依赖于操作系统Mutex Lock所实现的锁称之为“重量级锁”</strong>，JDK 6中为了减少获取锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>因此目前锁一共有4种状态，级别从低到高分别是：无锁、偏向锁、轻量级锁、重量级锁，锁状态只能升级不能降级。四种锁状态对应的Mark Word内容如下：</p><table><thead><tr><th>锁状态</th><th>存储内容</th><th style="text-align:center">标志位</th></tr></thead><tbody><tr><td>无锁</td><td>对象的HashCode、对象分代年龄、是否是偏向锁</td><td style="text-align:center">01</td></tr><tr><td>偏向锁</td><td>偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁</td><td style="text-align:center">01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td style="text-align:center">00</td></tr><tr><td>重量级锁</td><td>指向互斥量的指针</td><td style="text-align:center">10</td></tr></tbody></table><h4 id="3-2-1-无锁"><a href="#3-2-1-无锁" class="headerlink" title="3.2.1 无锁"></a>3.2.1 无锁</h4><p>无锁没有对资源进行锁定，所有线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则继续循环尝试。如果多个线程修改同一值，必定会有一个线程修改成功，其他修改失败的线程会不断重试直到修改成功。</p><p>如上面讲到的CAS原理及其应用就是无锁的实现，无锁无法全面代替锁，但在某些特定场合非常适合，能提高性能。</p><h4 id="3-2-2-偏向锁"><a href="#3-2-2-偏向锁" class="headerlink" title="3.2.2 偏向锁"></a>3.2.2 偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获取，为了让线程获取锁的代价更低而引入偏向锁。当一个线程访问同步代码块并获取锁时，会在Mark Word里记录偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，只需简单地测试一下Mark Word里是否存储着指向当前线程的偏向锁。</p><p>如果测试成功，表示线程已经获得了锁。</p><p>如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置为1（表示指向当前进程），如果没有则用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前进程。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。<strong>偏向锁的撤销</strong>：需要等待全局安全点（指在这个时间点上没有字节码正在执行），首先它会暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到无锁（标志位01）或者轻量级锁（标志位00）的状态。</p><p>偏向锁在JDK6以后的JVM里是默认启用的，可以通过JVM参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，关闭之后程序默认会进入轻量级锁状态。</p><h4 id="3-2-3-轻量级锁"><a href="#3-2-3-轻量级锁" class="headerlink" title="3.2.3 轻量级锁"></a>3.2.3 轻量级锁</h4><p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁竞争时 ，偏向锁就会升级为轻量级锁，其他线程会通过<strong>自旋</strong>的形式尝试获取锁，不会阻塞，从而提高性能。</p><ul><li>轻量级锁的加锁过程<ol><li>在代码块进入同步块时，如果同步对象锁状态为无锁状态（锁标志位01，是否偏向锁0），虚拟机首先将在当前线程的<strong>栈帧中建立一个名为锁记录</strong>（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为Displaced Mark Word。</li><li>拷贝对象头中的Mark Word复制到锁记录中。</li><li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果更新成功，则执行步骤4，否则执行步骤5</li><li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为00，表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那么可用直接进入同步块继续执行。否则说明有多个线程竞争锁，若当前只有一个等待线程，则该线程通过自旋进行等待；但当自旋超过一定次数或者一个线程持有锁，一个在自旋，又有第三个线程来访问，轻量级锁就会膨胀升级为重量级锁，锁标志位变为10。</li></ol></li><li><a href="https://www.processon.com/view/link/5effeb67e0b34d4dba69a2ca" target="_blank" rel="noopener">加锁过程图解见</a></li></ul><h4 id="3-2-4-重量级锁"><a href="#3-2-4-重量级锁" class="headerlink" title="3.2.4 重量级锁"></a>3.2.4 重量级锁</h4><p> 升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。 </p><p>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。 </p><h4 id="3-2-5-小结：锁的优缺点对比"><a href="#3-2-5-小结：锁的优缺点对比" class="headerlink" title="3.2.5 小结：锁的优缺点对比"></a>3.2.5 小结：锁的优缺点对比</h4><table><thead><tr><th style="text-align:left">锁</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:left">偏向锁</td><td style="text-align:center">加锁和解锁无需额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td style="text-align:center">如果线程间存在锁竞争，会带来额外锁撤销的消耗</td><td style="text-align:center">适用于单线程访问同步块场景</td></tr><tr><td style="text-align:left">轻量级锁</td><td style="text-align:center">竞争的线程不会阻塞，提高了程序的响应速度</td><td style="text-align:center">如果竞争的线程始终得不到锁，自旋操作会消耗CPU资源</td><td style="text-align:center">追求响应速度，同步块执行速度非常快的场景</td></tr><tr><td style="text-align:left">重量级锁</td><td style="text-align:center">线程竞争不使用自旋，不会消耗CPU资源</td><td style="text-align:center">线程阻塞，响应时间缓慢</td><td style="text-align:center">追求吞吐量，同步块执行耗时较长</td></tr></tbody></table><blockquote><p>Java中的显式锁和隐式锁的概念</p><ul><li>显式锁：例如<code>ReentrantLock</code>，整个加锁跟解锁的过程需要我们手动编写代码去控制</li><li>隐式锁：例如<code>synchronized</code>，加锁与解锁的过程都不需要我们在代码中人为控制，JVM会自动加锁和解锁。</li></ul></blockquote><h2 id="4-公平锁与非公平锁"><a href="#4-公平锁与非公平锁" class="headerlink" title="4. 公平锁与非公平锁"></a>4. 公平锁与非公平锁</h2><ul><li><p>公平锁：公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</p><ul><li>优点：公平锁的优点是等待的线程不会饿死</li><li>缺点：缺点是整体吞吐率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li></ul></li><li><p>非公平锁：非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取到锁的场景。</p><ul><li>优点：非公平锁的优点是可以减少唤起线程的开销，整体吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</li><li>缺点：缺点是处于等待队列中的线程可能会饿死，或者等很久才会获的锁。</li></ul></li></ul><blockquote><p>线程饥饿：是指线程因无法访问到所需资源而无法执行下去的情况，在CPU繁忙的情况下，优先级低的线程得到执行的机会很小，或者持有锁的线程长时间执行都会可能导致“饥饿”问题。</p></blockquote><h3 id="4-1-图示举例"><a href="#4-1-图示举例" class="headerlink" title="4.1 图示举例"></a>4.1 图示举例</h3><p><img src="https://s1.ax1x.com/2020/07/07/UF2S1S.png" alt="fairLock"></p><p>如上图所示，假设有一口水井， 有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。 </p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示： </p><p><img src="https://s1.ax1x.com/2020/07/07/UF2ncF.png" alt="NonFairLock"></p><h3 id="4-2-源码解读"><a href="#4-2-源码解读" class="headerlink" title="4.2 源码解读"></a>4.2 源码解读</h3><p>下面通过<code>ReentrantLock</code>源码来理解公平锁和非公平锁：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ReentrantLock implements Lock, java.io.Serializable {    private static final long serialVersionUID = 7373984872572414699L;    &#x2F;** Synchronizer providing all implementation mechanics *&#x2F;    private final Sync sync;    abstract static class Sync extends AbstractQueuedSynchronizer {...}    static final class NonfairSync extends Sync {...}    static final class FairSync extends Sync {...}    public ReentrantLock() {        sync = new NonfairSync();    }    public ReentrantLock(boolean fair) {        sync = fair ? new FairSync() : new NonfairSync();    }}</code></pre><p><code>ReentrantLock</code>里有一个内部类Sync，Sync继承自AQS（<code>AbstractQueueSynchronizer</code>，抽象排队同步器），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁<code>FairSync</code>和非公平锁<code>NonfairLock</code>两个子类，<code>ReentrantLock</code>默认使用非公平锁，也可通过构造器显式的指定使用公平锁。</p><p>下面是公平锁与非公平锁的源码解析：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 公平锁核心源码protected final boolean tryAcquire(int acquires) {    &#x2F;&#x2F; 获取当前线程对象    final Thread current = Thread.currentThread();    &#x2F;&#x2F; 获取当前显式锁加锁次数    int c = getState();    &#x2F;&#x2F; 如果当前没有锁    if (c == 0) {        &#x2F;&#x2F; 如果队列前面没有排队的线程并且能成功设置同步状态        if (!hasQueuedPredecessors() &amp;&amp;            compareAndSetState(0, acquires)) {            &#x2F;&#x2F; 设置当前线程为拥有独占锁的线程            setExclusiveOwnerThread(current);            return true;        }    }    &#x2F;&#x2F; 反之，如果当前线程就是拥有独占锁的线程    else if (current == getExclusiveOwnerThread()) {        &#x2F;&#x2F; 计算下一次加锁后的锁次数（ReentrantLock是可重入锁，一个线程可以多次加锁）        int nextc = c + acquires;        &#x2F;&#x2F; 如果锁次数小于0，报“超过最大锁数”错误        if (nextc &lt; 0)            throw new Error(&quot;Maximum lock count exceeded&quot;);        &#x2F;&#x2F; 反之设置加锁次数        setState(nextc);        return true;    }    &#x2F;&#x2F; 尝试获取锁失败，返回false    return false;}&#x2F;&#x2F; 非公平锁核心源码final boolean nonfairTryAcquire(int acquires) {    &#x2F;&#x2F; 获取当前线程    final Thread current = Thread.currentThread();    &#x2F;&#x2F; 获取加锁次数    int c = getState();    &#x2F;&#x2F; 如果没加锁    if (c == 0) {        &#x2F;&#x2F; cas设置同步状态        if (compareAndSetState(0, acquires)) {            &#x2F;&#x2F; 设置当前线程拥有独占锁            setExclusiveOwnerThread(current);            return true;        }    }    &#x2F;&#x2F; 反之如果当前线程就是拥有独占锁的线程    else if (current == getExclusiveOwnerThread()) {        &#x2F;&#x2F; 源码同公平锁解读        int nextc = c + acquires;        if (nextc &lt; 0) &#x2F;&#x2F; overflow            throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    }    return false;}</code></pre><p>由源码可见， 公平锁与非公平锁的<code>lock()</code>方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：<code>hasQueuedPredecessors()</code></p> <!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public final boolean hasQueuedPredecessors() {    &#x2F;&#x2F; The correctness of this depends on head being initialized    &#x2F;&#x2F; before tail and on head.next being accurate if the current    &#x2F;&#x2F; thread is first in queue.    Node t = tail; &#x2F;&#x2F; Read fields in reverse initialization order    Node h = head;    Node s;    &#x2F;&#x2F; 主要判断当前线程是否位于同步队列中的第一个，是则返回true，反之false    return h != t &amp;&amp;        ((s = h.next) == null || s.thread != Thread.currentThread());}</code></pre><p>公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。 </p><h2 id="5-可重入锁和非可重入锁"><a href="#5-可重入锁和非可重入锁" class="headerlink" title="5. 可重入锁和非可重入锁"></a>5. 可重入锁和非可重入锁</h2><p>可重入锁又名递归锁，是指同一个线程在外层方法获取锁时，再次进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。 下面看示例代码分析：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Widget {    public synchronized void doSomething() {        System.out.println(&quot;方法1执行...&quot;);        doOthers();    }    public synchronized void doOthers() {        System.out.println(&quot;方法2执行...&quot;);    }}</code></pre><p>上述代码中，类中的两个方法都是被内置锁synchronized修饰的，<code>doSomething()</code>方法中会调用<code>doOthers()</code>方法。因为内置锁是可重入的，所以同一个线程在调用<code>doOthers()</code>时可以直接获得当前对象的锁，进入<code>doOthers</code>代码块的操作。</p><p>如果是一个不可重入锁，那么当前线程在调用<code>doOthers()</code>之前需要将执行<code>doSomething()</code>时获取的当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。 </p><h3 id="5-1-为什么可重入锁在嵌套时可自动获取锁？"><a href="#5-1-为什么可重入锁在嵌套时可自动获取锁？" class="headerlink" title="5.1 为什么可重入锁在嵌套时可自动获取锁？"></a>5.1 为什么可重入锁在嵌套时可自动获取锁？</h3><p>下面通过 图示和源码来分析：</p><p>打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。 </p><p><img src="https://s1.ax1x.com/2020/07/07/UAKVbR.png" alt="reentrant"></p><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。 </p><p><img src="https://s1.ax1x.com/2020/07/07/UAKGqA.png" alt="Nonreentrant"></p><h3 id="5-2-源码分析"><a href="#5-2-源码分析" class="headerlink" title="5.2 源码分析"></a>5.2 源码分析</h3><p>ReentrantLock和synchronized都是重入锁，那么通过 重入锁<code>ReentrantLock</code>以及非可重入锁<code>NonReentrantLock</code>的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。 源码如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 可重入锁final boolean nonfairTryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) {        if (compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    &#x2F;&#x2F; 获取锁时先判断，如果当前线程是已经占用锁的线程，则status+1，并返回true    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0) &#x2F;&#x2F; overflow            throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    }    return false;}&#x2F;** 可重入锁-释放锁释放锁时，也会先判断当前线程是否是已占有锁的线程，然后再判断status如果status等于0，才会真正释放锁。**&#x2F;protected final boolean tryRelease(int releases) {    int c = getState() - releases;    &#x2F;&#x2F; 如果当前线程不是独占锁的线程，报 非法的监视器状态异常    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    &#x2F;&#x2F; 只有status等于0时才说明该线程所有的加锁都释放了    if (c == 0) {        free = true;        setExclusiveOwnerThread(null);    }    setState(c);    return free;}&#x2F;&#x2F; 非可重入锁：Java中的非可重入锁有哪些？</code></pre><h2 id="6-独享锁与共享锁"><a href="#6-独享锁与共享锁" class="headerlink" title="6. 独享锁与共享锁"></a>6. 独享锁与共享锁</h2><p> 独享锁和共享锁同样是一种概念 ，先介绍概念在看源码解读。</p><ul><li>独享锁：也叫排他锁 ，只指该锁一次只能被一个线程所持有。如果线程T对数据A加上排他锁后，则其他线程不能再对A加任何类型的锁，只有获得排他锁的线程能读写数据。JDK中的<code>synchronized</code>和JUC中的Lock相关实现类都是互斥锁。</li><li>共享锁：是指该线程可以被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排他锁。获得共享锁的线程只能读数据，不能修改数据。</li></ul><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或共享。</p><p>以下为<code>ReentrantReadWriteLock</code>部分源码：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ReentrantReadWriteLock    implements ReadWriteLock, java.io.Serializable {    private static final long serialVersionUID = -6992448646407690164L;    &#x2F;** Inner class providing readlock *&#x2F;    private final ReentrantReadWriteLock.ReadLock readerLock;    &#x2F;** Inner class providing writelock *&#x2F;    private final ReentrantReadWriteLock.WriteLock writerLock;    &#x2F;** Performs all synchronization mechanics *&#x2F;    final Sync sync;    &#x2F;&#x2F; 默认创建非公平锁    public ReentrantReadWriteLock() {        this(false);    }    public ReentrantReadWriteLock(boolean fair) {        sync = fair ? new FairSync() : new NonfairSync();        readerLock = new ReadLock(this);        writerLock = new WriteLock(this);    }    public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }    public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }        public static class ReadLock implements Lock, java.io.Serializable {        private static final long serialVersionUID = -5992448646407690164L;        private final Sync sync;        protected ReadLock(ReentrantReadWriteLock lock) {            sync = lock.sync;        }    }        public static class WriteLock implements Lock, java.io.Serializable {        private static final long serialVersionUID = -4992448646407690164L;        private final Sync sync;        protected WriteLock(ReentrantReadWriteLock lock) {            sync = lock.sync;        }    }}</code></pre><p>源码可知<code>ReentrantReadWriteLock</code>有两把锁，<code>ReadLock</code>和<code>WriteLock</code>，一个读锁和一个写锁，合称读写锁。读写锁都是靠内部类Sync实现的锁，Sync是AQS的子类，这种结构在<code>CountDownLatch</code>、<code>ReentrantLock</code>、<code>Semaphore</code>里面也都存在。 </p><p>在<code>ReentrantReadWriteLock</code>里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程是互斥的，因为读锁和写锁是分离的。所以<code>ReentrantReadWriteLock</code>的并发性相比一般的互斥锁有了很大提升。 </p><h3 id="6-1-读写锁源码分析"><a href="#6-1-读写锁源码分析" class="headerlink" title="6.1 读写锁源码分析"></a>6.1 读写锁源码分析</h3><p>AQS中有一个<code>state</code>参数，该字段表示有多少线程持有锁。在独享锁中这个值通常是0或者1（重入锁中state值表示重入次数），在共享锁中state就是持有锁的数量。但是在<code>ReentrantReadWriteLock</code>中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量；于是将state变量<strong>“按位切割”</strong>，切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数），如下图示：</p><p><img src="https://s1.ax1x.com/2020/07/08/UVBe8U.png" alt="state"></p><p>接下来查看写锁的加锁源码：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">protected final boolean tryAcquire(int acquires) {    &#x2F;&#x2F; 获取当前线程    Thread current = Thread.currentThread();    &#x2F;&#x2F; 获取当前锁的个数    int c = getState();    &#x2F;&#x2F; 获取写锁的个数    int w = exclusiveCount(c);    &#x2F;&#x2F; 如果已经有线程持有了锁(c!=0)    if (c != 0) {        &#x2F;&#x2F; (Note: if c != 0 and w == 0 then shared count != 0)        &#x2F;&#x2F; 如果写线程数(w)为0(换言之存在读锁) 或者持有锁的线程不是当前线程就返回失败        if (w == 0 || current != getExclusiveOwnerThread())            return false;        if (w + exclusiveCount(acquires) &gt; MAX_COUNT) &#x2F;&#x2F;如果写入锁数量大于最大数(65535 2的16次方-1 ) 就抛出一个Error            throw new Error(&quot;Maximum lock count exceeded&quot;);        &#x2F;&#x2F; 增加重入状态数        setState(c + acquires);        return true;    }    &#x2F;&#x2F; 如果当前线程需要阻塞那么就返回失败 或者 CAS设置同步状态失败也返回失败    if (writerShouldBlock() ||        !compareAndSetState(c, c + acquires))        return false;    &#x2F;&#x2F; 如果c=0,w=0或c&gt;0，w&gt;0(重入),则设置当前线程为锁拥有者    setExclusiveOwnerThread(current);    return true;}</code></pre><ul><li>写锁源码解读：<ul><li>首先获取当前锁的个数c，然后通过c获取写锁的个数；因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（<code>return c &amp; EXCLUSIVE_MASK</code>），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目；</li><li>在取到写锁线程数量后，首先判断是否有线程持有了锁。如果已经有线程持有了锁（c!=0），则查看当前写锁线程数量，如果写锁线程数量为0（即此时存在读锁，非写即读）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）；</li><li>如果写入锁数量大于最大数，就抛出一个Error；</li><li>如果当前写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败；</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！ </li></ul></li></ul><p><code>tryAcquire()</code>除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。 </p><p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。 </p><p>下面是读锁的源码：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">protected final int tryAcquireShared(int unused) {    Thread current = Thread.currentThread();    int c = getState();    if (exclusiveCount(c) != 0 &amp;&amp;        getExclusiveOwnerThread() != current)        return -1;  &#x2F;&#x2F; 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态    int r = sharedCount(c);    if (!readerShouldBlock() &amp;&amp;        r &lt; MAX_COUNT &amp;&amp;        compareAndSetState(c, c + SHARED_UNIT)) {        if (r == 0) {            firstReader = current;            firstReaderHoldCount = 1;        } else if (firstReader == current) {            firstReaderHoldCount++;        } else {            HoldCounter rh = cachedHoldCounter;            if (rh == null || rh.tid != getThreadId(current))                cachedHoldCounter = rh = readHolds.get();            else if (rh.count == 0)                readHolds.set(rh);            rh.count++;        }        return 1;    }    return fullTryAcquireShared(current);}</code></pre><p>可以看到在<code>tryAcquireShared(int unused)</code>方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。 </p><p>此时，再回头看看互斥锁<code>ReentrantLock</code>中公平锁和非公平锁的加锁源码 :</p><p><img src="https://s1.ax1x.com/2020/07/08/UVqDwn.png" alt="lock"></p><p><code>ReentrantLock</code>虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。 </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文主要内容均来自美团技术团队-<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java”锁”事</a>一文，仅做了部分个人理解上的修改，在最后读写锁源码分析这块内容尚未完全理解透彻，在此记录。</p>]]></content>
      
      
      <categories>
          
          <category> JavaAdvanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云Linux指令入门笔记</title>
      <link href="/Other/Linux-command.html"/>
      <url>/Other/Linux-command.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、Linux指令入门-文件与权限"><a href="#一、Linux指令入门-文件与权限" class="headerlink" title="一、Linux指令入门-文件与权限"></a>一、Linux指令入门-文件与权限</h1><h2 id="1-文件目录管理命令"><a href="#1-文件目录管理命令" class="headerlink" title="1. 文件目录管理命令"></a>1. 文件目录管理命令</h2><h3 id="1-1-tree"><a href="#1-1-tree" class="headerlink" title="1.1 tree"></a>1.1 tree</h3><p>命令描述：tree命令用于以树状图列出目录的内容。</p><p>tree命令没有内置在系统中，使用tree命令需要执行以下命令来安装：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash"># Ubuntuapt-get install tree# CentOSyum install -y tree</code></pre><p>命令使用示例：<code>tree /usr/share/wallpapers/</code></p><p>命令输出结果：</p><p><img src="https://s1.ax1x.com/2020/06/27/N6ZDkd.png" alt="tree"></p><h3 id="1-2-ls"><a href="#1-2-ls" class="headerlink" title="1.2 ls"></a>1.2 ls</h3><p>命令描述： ls命令用于显示指定工作目录下的内容。</p><p>命令格式：<code>ls [参数] [目录名]</code>。</p><p>参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-a</td><td style="text-align:left">显示所有文件及目录（包括隐藏文件）</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">将文件的权限、拥有者、文件大小等详细信息列出（<code>ll</code>等同于<code>ls -l</code>）</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:left">将文件反序列出（默认按英文字母正序）</td></tr><tr><td style="text-align:left">-t</td><td style="text-align:left">将文件按创建时间正序列出</td></tr><tr><td style="text-align:left">-R</td><td style="text-align:left">递归遍历目录下文件</td></tr></tbody></table><p>命令使用示例：查看当前目录下的所有文件（包括隐藏文件）<code>ll -a</code>。</p><p>命令输出结果：</p><p><img src="https://s1.ax1x.com/2020/06/27/N6nEYd.png" alt="N6nEYd.png"></p><h3 id="1-3-pwd"><a href="#1-3-pwd" class="headerlink" title="1.3 pwd"></a>1.3 pwd</h3><p>命令描述：获取当前工作目录的绝对路径。</p><p>命令使用示例：</p><p><img src="https://s1.ax1x.com/2020/06/27/N6nuOf.png" alt="pwd"> </p><h3 id="1-4-cd"><a href="#1-4-cd" class="headerlink" title="1.4 cd"></a>1.4 cd</h3><p>命令描述：cd命令用于切换工作目录。</p><p>命令使用示例：</p><p><img src="https://s1.ax1x.com/2020/06/27/N6ufvq.png" alt="cd"></p><p>在路径表示中：</p><ul><li>一个半角句号（<code>.</code>）表示当前目录，例如路径<code>./app/log</code>等同于<code>app/log。</code></li><li>两个半角句号（<code>..</code>）表示上级目录，例如路径<code>/usr/local/../src</code>等同于<code>/usr/src</code>，其中<code>local</code>和<code>src</code>目录同级。</li></ul><p><code>cd</code>命令的默认参数为<code>~</code>，符号<code>~</code>表示当前用户的<code>home</code>目录，即在root用户登录时，命令<code>cd</code>、<code>cd ~</code>和<code>cd /root</code>执行效果相同。</p><h3 id="1-5-touch"><a href="#1-5-touch" class="headerlink" title="1.5 touch"></a>1.5 touch</h3><p>命令描述：touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>命令格式：<code>touch [参数] [文件]</code>。</p><p>参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-c</td><td style="text-align:left">如果指定文件不存在，不会建立新文件</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:left">使用参考文件的时间记录</td></tr><tr><td style="text-align:left">-t</td><td style="text-align:left">设置文件的时间记录</td></tr></tbody></table><p>命令使用示例：</p><ul><li>创建两个空文件。</li></ul><p><img src="https://s1.ax1x.com/2020/06/27/N6uTVU.png" alt="touch1"></p><ul><li>修改demo1.txt的时间记录为当前系统时间。</li></ul><p><img src="https://s1.ax1x.com/2020/06/27/N6u7aF.png" alt="touch2"></p><ul><li>更新demo2.txt的时间记录，使其和demo1.txt的时间记录相同。</li></ul><p><img src="https://s1.ax1x.com/2020/06/27/N6uO2R.png" alt="touch3"></p><h3 id="1-6-mkdir"><a href="#1-6-mkdir" class="headerlink" title="1.6 mkdir"></a>1.6 mkdir</h3><p>命令描述：mkdir命令用于新建子目录。<code>-p</code>参数确保目录名称存在，不存在的就新建一个。</p><p>命令使用示例：新建目录a/b/c/d，并使用tree命令查看创建后的目录结构。</p><p><img src="https://s1.ax1x.com/2020/06/27/N6uvKx.png" alt="mkdir"></p><h3 id="1-7-rm"><a href="#1-7-rm" class="headerlink" title="1.7 rm"></a>1.7 rm</h3><p>命令描述：rm命令用于删除一个文件或者目录。</p><p>命令格式：<code>rm [参数] [文件]</code>。</p><p>参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-i</td><td style="text-align:left">删除前逐一询问确认</td></tr><tr><td style="text-align:left">-f</td><td style="text-align:left">无需确认，直接删除</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:left">删除目录下所有文件</td></tr></tbody></table><p>命令使用示例：</p><ul><li>无需确认直接删除文件。</li></ul><p><img src="https://s1.ax1x.com/2020/06/27/N6KudS.png" alt="rm1"></p><ul><li>无需确认直接删除目录a及其目录下所有子目录和文件。</li></ul><p><img src="https://s1.ax1x.com/2020/06/27/N6KNZT.png" alt="rm2"></p><h3 id="1-8-cp"><a href="#1-8-cp" class="headerlink" title="1.8 cp"></a>1.8 cp</h3><p>命令描述： cp命令主要用于复制文件或目录。</p><p>命令格式：<code>cp [参数] [源文件] [目标文件]</code>。</p><p>参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-d</td><td style="text-align:left">复制时保留链接</td></tr><tr><td style="text-align:left">-f</td><td style="text-align:left">覆盖已经存在的目标文件而不给出提示</td></tr><tr><td style="text-align:left">-i</td><td style="text-align:left">覆盖前询问</td></tr><tr><td style="text-align:left">-p</td><td style="text-align:left">除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:left">复制目录及目录内的所有项目</td></tr></tbody></table><p>命令使用示例：将目录c/d中的所有内容复制到目录a/b下。</p><p><img src="https://img.alicdn.com/tfs/TB10Ck3HuL2gK0jSZPhXXahvXXa-673-465.png" alt="cp"></p><h3 id="1-9-mv"><a href="#1-9-mv" class="headerlink" title="1.9 mv"></a>1.9 mv</h3><p>命令描述： mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p><p>命令格式：<code>mv [参数] [源文件] [目标文件]</code></p><p>参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-i</td><td style="text-align:left">若指定目录已有同名文件，则先询问是否覆盖旧文件</td></tr><tr><td style="text-align:left">-f</td><td style="text-align:left">如果目标文件已经存在，不会询问而直接覆盖</td></tr></tbody></table><p>命令使用示例：</p><ul><li>将文件名a.txt改为b.txt。<br><img src="https://img.alicdn.com/tfs/TB1z1M_Hvb2gK0jSZK9XXaEgFXa-348-151.png" alt="mv1"></li><li>将c目录移动到a/b/c/d/下。<br><img src="https://img.alicdn.com/tfs/TB1M9BiHRr0gK0jSZFnXXbRRXXa-387-276.png" alt="mv2"></li><li>将当前目录内容全部移动到/tmp目录中<code>mv ./* /tmp</code></li></ul><h3 id="1-10-rename"><a href="#1-10-rename" class="headerlink" title="1.10 rename"></a>1.10 rename</h3><p>命令描述：rename命令用字符串替换的方式批量改变文件名。rename命令有C语言和Perl语言两个版本，这里介绍C语言版本的rename命令，不支持正则表达式。</p><p>命令使用示例：</p><ul><li>将当前目录下所有文件名中的字符串demo改为大写的字符串DEMO。<br><img src="https://img.alicdn.com/tfs/TB164qEaepyVu4jSZFhXXbBpVXa-410-150.png" alt="rename1"></li><li><p>将当前目录下所有<code>.txt</code>文件后缀都改为<code>text</code>。</p><p><img src="https://img.alicdn.com/tfs/TB1l3pXHUT1gK0jSZFrXXcNCXXa-386-84.png" alt="rename2"></p></li></ul><h2 id="2-文件权限管理"><a href="#2-文件权限管理" class="headerlink" title="2. 文件权限管理"></a>2. 文件权限管理</h2><h3 id="2-1-ls"><a href="#2-1-ls" class="headerlink" title="2.1 ls"></a>2.1 ls</h3><p>目录描述：ls命令可以查看Linux系统上的文件、目录和设备的权限，<code>ls -l /boot/</code></p><p><img src="https://img.alicdn.com/tfs/TB12gXcHND1gK0jSZFKXXcJrVXa-869-420.png" alt="ls">上述<code>ls -l</code>命令中显示的第一列就是文件权限信息，共11位字符，分5部分。</p><ul><li>第1位表示存档类型，<code>d</code>表示目录（directory），<code>-</code>表示一般文件。</li><li>第2~4位表示当前用户的权限（<strong>属主权限</strong>）。</li><li>第5~7位表示同用户组的用户权限（<strong>属组权限</strong>）。</li><li>第8~10位表示不同用户组的用户权限（<strong>其他用户权限</strong>）。</li><li>第11位是一个半角句号<code>.</code>，表示SELinux安全标签。</li></ul><p>用户权限每组三位，rwx分别表示读（read）、写（write）、执行权限（execute），对应八进制表示为4、2、1。</p><p>例如efi目录的root用户权限为<code>drwxr-xr-x.</code>。</p><ul><li>该目录对root用户具有读写和执行所有权限。</li><li>该目录对root同组其他用户有读和执行权限。</li><li>该目录对其他用户有读和执行权限。</li></ul><p>所以该权限表示对应八进制权限表示为：</p><ul><li>属主权限：<code>4+2+1=7</code>。</li><li>属组权限：<code>4+1=5</code>。</li><li>其他用户权限：<code>4+1=5</code>。</li></ul><p>即755。</p><h3 id="2-2-chmod"><a href="#2-2-chmod" class="headerlink" title="2.2 chmod"></a>2.2 chmod</h3><p>chmod命令用于修改文件权限mode，<code>-R</code>参数以递归方式对子目录和文件进行修改。</p><blockquote><p>u表示属主（user），g表示属组（group），o表示其他（other），a表示所有用户（all）。</p></blockquote><p>命令使用示例：</p><ol><li>新建名为<code>hello.sh</code>的Shell脚本，该脚本将会输出<code>Hello World</code>。用<code>ll</code>命令可以看到新建的脚本没有执行权限，其权限用八进制表示为644。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">echo &quot;echo &#39;Hello World&#39;&quot; &gt; hello.shll</code></pre><p><img src="https://img.alicdn.com/tfs/TB1XPRcHNv1gK0jSZFFXXb0sXXa-520-111.png" alt="echo file"></p><ol start="2"><li>将hello.sh文件增加属主的执行权限。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">chmod u+x hello.shll</code></pre><p><img src="https://img.alicdn.com/tfs/TB1RX7nXSRLWu4jSZKPXXb6BpXa-469-110.png" alt="chmod u+x"></p><ol start="3"><li>将hello.sh文件撤销属主的执行权限。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">chmod u-x hello.shll</code></pre><p><img src="https://img.alicdn.com/tfs/TB1.q8XHFP7gK0jSZFjXXc5aXXa-458-108.png" alt="chmod u-x"></p><ol start="4"><li>将hello.sh文件权限修改为八进制表示的744权限。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">chmod 744 hello.shll</code></pre><p><img src="https://img.alicdn.com/tfs/TB1cq..HpT7gK0jSZFpXXaTkpXa-445-110.png" alt="chmod 744"></p><ol start="5"><li>使用bash命令解释器执行hello.sh脚本文件。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">&#x2F;bin&#x2F;bash hello.sh</code></pre><p>​                                           <img src="https://img.alicdn.com/tfs/TB1mIFeHQT2gK0jSZFkXXcIQFXa-448-67.png" alt="execute"> </p><h3 id="2-3-chown"><a href="#2-3-chown" class="headerlink" title="2.3 chown"></a>2.3 chown</h3><p>chown命令修改文件的属主和属组；<code>-R</code>参数以递归方式对子目录和文件进行修改；<code>ls -l</code>命令显示的第三列和第四列就是文件的属主和属组信息。</p><p>命令使用示例：</p><ol><li>新建一个文本文件test.txt，用<code>ll</code>命令可以看到该文件的属主和属组是root。<code>whoami</code>命令可以查看当前Shell环境登录的用户名。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">whoamitouch test.txtll</code></pre><p><img src="https://img.alicdn.com/tfs/TB1Xq..HpT7gK0jSZFpXXaTkpXa-457-153.png" alt="touch file"></p><ol start="2"><li>创建两个用户。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">useradd testuseradd admin</code></pre><ol start="3"><li>修改test.txt文件的属主用户为test。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">chown test test.txtll</code></pre><p><img src="https://img.alicdn.com/tfs/TB1IHVfHHj1gK0jSZFuXXcrHpXa-477-106.png" alt="chown1"></p><ol start="4"><li>修改test.txt文件的属主和属组为admin。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">chown admin:admin test.txtll</code></pre><p><img src="https://img.alicdn.com/tfs/TB1KbVfHHj1gK0jSZFuXXcrHpXa-471-108.png" alt="chown2"></p><h3 id="2-4-chgrp"><a href="#2-4-chgrp" class="headerlink" title="2.4 chgrp"></a>2.4 chgrp</h3><p>chgrp命令用于修改文件的属组。</p><p>命令使用示例：</p><p>将test.txt文件的属组改为root。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">chgrp root test.txtll</code></pre><p><img src="https://img.alicdn.com/tfs/TB1uLg.HxD1gK0jSZFsXXbldVXa-522-108.png" alt="chgrp"></p><h1 id="二、Linux指令入门-文本处理"><a href="#二、Linux指令入门-文本处理" class="headerlink" title="二、Linux指令入门-文本处理"></a>二、Linux指令入门-文本处理</h1><h2 id="1-文本编辑工具Vim"><a href="#1-文本编辑工具Vim" class="headerlink" title="1. 文本编辑工具Vim"></a>1. 文本编辑工具Vim</h2><h3 id="1-1-vim的三种操作模式"><a href="#1-1-vim的三种操作模式" class="headerlink" title="1.1 vim的三种操作模式"></a>1.1 vim的三种操作模式</h3><p>vim有三种操作模式，分别是命令模式（Command mode）、输入模式（Insert mode）和底线命令模式（Last line mode）。</p><p>三种模式切换快捷键：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">快捷键</th></tr></thead><tbody><tr><td style="text-align:left">命令模式</td><td style="text-align:left">ESC</td></tr><tr><td style="text-align:left">输入模式</td><td style="text-align:left">i或a</td></tr><tr><td style="text-align:left">底线命令模式</td><td style="text-align:left">:</td></tr></tbody></table><ul><li>命令模式</li></ul><p>在命令模式中控制光标移动和输入命令，可对文本进行复制、粘贴、删除和查找等工作。<br>使用命令vim filename后进入编辑器视图后，默认模式就是命令模式，此时敲击键盘字母会被识别为一个命令，例如在键盘上连续敲击两次d，就会删除光标所在行。</p><p>以下是在命令模式中常用的快捷操作：</p><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">快捷键</th></tr></thead><tbody><tr><td style="text-align:left">光标左移</td><td style="text-align:left">h</td></tr><tr><td style="text-align:left">光标右移</td><td style="text-align:left">l（小写L）</td></tr><tr><td style="text-align:left">光标上移</td><td style="text-align:left">k</td></tr><tr><td style="text-align:left">光标下移</td><td style="text-align:left">j</td></tr><tr><td style="text-align:left">光标移动到下一个单词</td><td style="text-align:left">w</td></tr><tr><td style="text-align:left">光标移动到上一个单词</td><td style="text-align:left">b</td></tr><tr><td style="text-align:left">移动游标到第n行</td><td style="text-align:left">nG</td></tr><tr><td style="text-align:left">移动游标到第一行</td><td style="text-align:left">gg</td></tr><tr><td style="text-align:left">移动游标到最后一行</td><td style="text-align:left">G</td></tr><tr><td style="text-align:left">快速回到上一次光标所在位置</td><td style="text-align:left">Ctrl+o</td></tr><tr><td style="text-align:left">删除当前字符</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">删除前一个字符</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">删除整行</td><td style="text-align:left">dd</td></tr><tr><td style="text-align:left">删除一个单词</td><td style="text-align:left">dw或daw</td></tr><tr><td style="text-align:left">删除至行尾</td><td style="text-align:left">d$或D</td></tr><tr><td style="text-align:left">删除至行首</td><td style="text-align:left">d^</td></tr><tr><td style="text-align:left">删除到文档末尾</td><td style="text-align:left">dG</td></tr><tr><td style="text-align:left">删除至文档首部</td><td style="text-align:left">d1G</td></tr><tr><td style="text-align:left">删除n行</td><td style="text-align:left">ndd</td></tr><tr><td style="text-align:left">删除n个连续字符</td><td style="text-align:left">nx</td></tr><tr><td style="text-align:left">将光标所在位置字母变成大写或小写</td><td style="text-align:left">~</td></tr><tr><td style="text-align:left">复制游标所在的整行</td><td style="text-align:left">yy（3yy表示复制3行）</td></tr><tr><td style="text-align:left">粘贴至光标后（下）</td><td style="text-align:left">p</td></tr><tr><td style="text-align:left">粘贴至光标前（上）</td><td style="text-align:left">P</td></tr><tr><td style="text-align:left">剪切</td><td style="text-align:left">dd</td></tr><tr><td style="text-align:left">交换上下行</td><td style="text-align:left">ddp</td></tr><tr><td style="text-align:left">替换整行，即删除游标所在行并进入插入模式</td><td style="text-align:left">cc</td></tr><tr><td style="text-align:left">撤销一次或n次操作</td><td style="text-align:left">u{n}</td></tr><tr><td style="text-align:left">撤销当前行的所有修改</td><td style="text-align:left">U</td></tr><tr><td style="text-align:left">恢复撤销操作</td><td style="text-align:left">Ctrl+r</td></tr><tr><td style="text-align:left">整行将向右缩进</td><td style="text-align:left">&gt;&gt;</td></tr><tr><td style="text-align:left">整行将向左退回</td><td style="text-align:left">&lt;&lt;</td></tr><tr><td style="text-align:left">若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开</td><td style="text-align:left">ZZ</td></tr></tbody></table><ul><li>输入模式</li></ul><p>在命令模式下按<code>i</code>或<code>a</code>键就进入了输入模式，在输入模式下，您可以正常的使用键盘按键对文本进行插入和删除等操作。</p><ul><li>底线命令模式</li></ul><p>在命令模式下按<code>:</code>键就进入了底线命令模式，在底线命令模式中可以输入单个或多个字符的命令。</p><p>以下是底线命令模式中常用的快捷操作：</p><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:left">保存</td><td style="text-align:left">:w</td></tr><tr><td style="text-align:left">退出</td><td style="text-align:left">:q</td></tr><tr><td style="text-align:left">保存并退出</td><td style="text-align:left">:wq（<code>:wq!</code>表示强制保存退出）</td></tr><tr><td style="text-align:left">将文件另存为其他文件名</td><td style="text-align:left">:w new_filename</td></tr><tr><td style="text-align:left">显示行号</td><td style="text-align:left">:set nu</td></tr><tr><td style="text-align:left">取消行号</td><td style="text-align:left">:set nonu</td></tr><tr><td style="text-align:left">使本行内容居中</td><td style="text-align:left">:ce</td></tr><tr><td style="text-align:left">使本行文本靠右</td><td style="text-align:left">:ri</td></tr><tr><td style="text-align:left">使本行内容靠左</td><td style="text-align:left">:le</td></tr><tr><td style="text-align:left">向光标之下寻找一个名称为word的字符串</td><td style="text-align:left">:/word</td></tr><tr><td style="text-align:left">向光标之上寻找一个字符串名称为word的字符串</td><td style="text-align:left">:?word</td></tr><tr><td style="text-align:left">重复前一个搜寻的动作</td><td style="text-align:left">:n</td></tr><tr><td style="text-align:left">从第一行到最后一行寻找word1字符串，并将该字符串取代为word2</td><td style="text-align:left"><code>:1,$s/word1/word2/g</code>或<code>:%s/word1/word2/g</code></td></tr></tbody></table><h3 id="1-2-vim使用示例"><a href="#1-2-vim使用示例" class="headerlink" title="1.2 vim使用示例"></a>1.2 vim使用示例</h3><p>在本示例将使用vim在文本文件中写入一首唐诗。</p><ol><li>新建一个文件并进入vim命令模式<code>vim 静夜思.txt</code></li></ol><p><img src="https://img.alicdn.com/tfs/TB1VZ4LHG61gK0jSZFlXXXDKFXa-911-414.png" alt="vim file"></p><ol start="2"><li>按下<code>i</code>进入输入模式，输入《静夜思》的诗名。</li></ol><p><img src="https://img.alicdn.com/tfs/TB1v7BEHQL0gK0jSZFtXXXQCXXa-913-410.png" alt="insert mode"></p><ol start="3"><li>按下ECS键回到命令模式，并输入底线命令<code>:ce</code>，使诗名居中。</li></ol><p><img src="https://img.alicdn.com/tfs/TB1S58EHUz1gK0jSZLeXXb9kVXa-905-428.png" alt="command :ce"></p><ol start="4"><li>按下<code>o</code>键换行并进入输入模式，输入第一行诗。</li></ol><p><img src="https://img.alicdn.com/tfs/TB1Db8GHHr1gK0jSZFDXXb9yVXa-904-412.png" alt="command o"></p><ol start="5"><li>按下ECS键回到命令模式，并输入底线命令<code>:ce</code>，使第一行诗居中。</li></ol><p><img src="https://img.alicdn.com/tfs/TB1poNDHFY7gK0jSZKzXXaikpXa-902-415.png" alt=":ce"></p><ol start="6"><li>按下<code>o</code>键换行并进入输入模式，输入第二行诗。</li></ol><p><img src="https://img.alicdn.com/tfs/TB1YGNHHKH2gK0jSZFEXXcqMpXa-907-412.png" alt="o"></p><ol start="7"><li>按下ECS键回到命令模式，并输入底线命令<code>:ce</code>，使第二行诗居中。</li></ol><p><img src="https://img.alicdn.com/tfs/TB1HoNDHLb2gK0jSZK9XXaEgFXa-905-412.png" alt=":ce 2"></p><ol start="8"><li>在命令模式中执行底线命令<code>:wq</code>保存并退出。</li></ol><h2 id="2-文本文件查看命令"><a href="#2-文本文件查看命令" class="headerlink" title="2. 文本文件查看命令"></a>2. 文本文件查看命令</h2><h3 id="2-1-cat"><a href="#2-1-cat" class="headerlink" title="2.1 cat"></a>2.1 cat</h3><p>命令描述：cat命令用于查看内容较少的纯文本文件。</p><p>命令格式：<code>cat [选项] [文件]</code>。</p><p>命令参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-n或–number</td><td style="text-align:left">显示行号</td></tr><tr><td style="text-align:left">-b或–number-nonblank</td><td style="text-align:left">显示行号，但是不对空白行进行编号</td></tr><tr><td style="text-align:left">-s或–squeeze-blank</td><td style="text-align:left">当遇到有连续两行以上的空白行，只显示一行的空白行</td></tr></tbody></table><p>命令使用示例：</p><ol><li>将一个自增序列写入<code>test.txt</code>文件中。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">for i in $(seq 1 10); do echo $i &gt;&gt; test.txt ; done</code></pre><ol start="2"><li>查看文件内容：<code>cat test.txt</code></li></ol><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB17S4FHHr1gK0jSZR0XXbP8XXa-612-258.png" alt="cat file"></p><ol start="3"><li><p>将文件内容清空：<code>cat /dev/null &gt; test.txt</code></p></li><li><p>再次检查文件内容：<code>cat test.txt</code></p></li></ol><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1CQBEHQL0gK0jSZFtXXXQCXXa-570-69.png" alt="cat file"></p><h3 id="2-2-more"><a href="#2-2-more" class="headerlink" title="2.2 more"></a>2.2 more</h3><p>命令描述：more命令从前向后分页显示文件内容。</p><p>常用操作命令：</p><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">Enter</td><td style="text-align:left">向下n行，n需要定义，默认为1行</td></tr><tr><td style="text-align:left">Ctrl+F或空格键（Space）</td><td style="text-align:left">向下滚动一页</td></tr><tr><td style="text-align:left">Ctrl+B</td><td style="text-align:left">向上滚动一页</td></tr><tr><td style="text-align:left">=</td><td style="text-align:left">输出当前行的行号</td></tr><tr><td style="text-align:left">!命令</td><td style="text-align:left">调用Shell执行命令</td></tr><tr><td style="text-align:left">q</td><td style="text-align:left">退出more</td></tr></tbody></table><p>命令使用示例：从第20行开始分页查看系统日志文件/var/log/messages。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">more +20 &#x2F;var&#x2F;log&#x2F;messages</code></pre><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1xcXGHHr1gK0jSZFDXXb9yVXa-1408-937.png" alt="more 20"></p><h3 id="2-3-less"><a href="#2-3-less" class="headerlink" title="2.3 less"></a>2.3 less</h3><p>命令描述：less命令可以对文件或其它输出进行分页显示，与moe命令相似，但使用 <strong>less 可以随意浏览文件，而 more 仅能向前移动</strong>，却不能向后移动。</p><p>命令格式：<code>less [参数] 文件</code>。</p><p>命令参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-e</td><td style="text-align:left">当文件显示结束后，自动离开</td></tr><tr><td style="text-align:left">-m</td><td style="text-align:left">显示类似more命令的百分比</td></tr><tr><td style="text-align:left">-N</td><td style="text-align:left">显示每行的行号</td></tr><tr><td style="text-align:left">-s</td><td style="text-align:left">显示连续空行为一行</td></tr></tbody></table><p>命令常用操作：</p><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">/字符串</td><td style="text-align:left">向下搜索字符串</td></tr><tr><td style="text-align:left">?字符串</td><td style="text-align:left">向上搜索字符串</td></tr><tr><td style="text-align:left">n</td><td style="text-align:left">重复前一个搜索</td></tr><tr><td style="text-align:left">N</td><td style="text-align:left">反向重复前一个搜索</td></tr><tr><td style="text-align:left">b或<code>pageup</code>键</td><td style="text-align:left">向上翻一页</td></tr><tr><td style="text-align:left">空格键或<code>pagedown</code>键</td><td style="text-align:left">向下翻一页</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">向前翻半页</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">向后翻半页</td></tr><tr><td style="text-align:left">y</td><td style="text-align:left">向前滚动一行</td></tr><tr><td style="text-align:left">回车键</td><td style="text-align:left">向后滚动一行</td></tr><tr><td style="text-align:left">q</td><td style="text-align:left">退出less命令</td></tr></tbody></table><p>命令使用示例：查看命令历史使用记录并通过less分页显示<code>history | less</code></p><h3 id="2-4-head"><a href="#2-4-head" class="headerlink" title="2.4 head"></a>2.4 head</h3><p>命令描述：head命令用于查看文件开头指定行数的内容。</p><p>命令格式：<code>head [参数] [文件]</code>。</p><p>命令参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-n [行数]</td><td style="text-align:left">显示开头指定行的文件内容，默认为10</td></tr><tr><td style="text-align:left">-c [字符数]</td><td style="text-align:left">显示开头指定个数的字符数</td></tr><tr><td style="text-align:left">-q</td><td style="text-align:left">不显示文件名字信息，适用于多个文件，多文件时默认会显示文件名</td></tr></tbody></table><p>命令使用示例：查看/etc/passwd文件的前5行内容<code>head -5 /etc/passwd</code>。</p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB13Pl7Xj39YK4jSZPcXXXrUFXa-590-153.png" alt="head"></p><h3 id="2-5-tail"><a href="#2-5-tail" class="headerlink" title="2.5 tail"></a>2.5 tail</h3><p>命令描述：tail命令用于查看文档的后N行或持续刷新内容。</p><p>命令格式：<code>tail [参数] [文件]</code>。</p><p>命令参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-f</td><td style="text-align:left">显示文件最新追加的内容</td></tr><tr><td style="text-align:left">-q</td><td style="text-align:left">当有多个文件参数时，不输出各个文件名</td></tr><tr><td style="text-align:left">-v</td><td style="text-align:left">当有多个文件参数时，总是输出各个文件名</td></tr><tr><td style="text-align:left">-c [字节数]</td><td style="text-align:left">显示文件的尾部n个字节内容</td></tr><tr><td style="text-align:left">-n [行数]</td><td style="text-align:left">显示文件的尾部n行内容</td></tr></tbody></table><p>命令使用示例：查看/var/log/messages系统日志文件的最新10行，并保持实时刷新<code>tail -f -n 10 /var/log/messages</code></p><p><img src="https://img.alicdn.com/tfs/TB1Pj8JHUY1gK0jSZFCXXcwqXXa-970-240.png" alt="tail"></p><p>按<code>ctrl+c</code>键退出文本实时查看界面。</p><h3 id="2-6-stat"><a href="#2-6-stat" class="headerlink" title="2.6 stat"></a>2.6 stat</h3><p>命令描述：用来显示文件的详细信息，包括inode、atime、mtime、ctime等。</p><p>命令使用示例：查看/etc/passwd文件的详细信息。<code>stat /etc/passwd</code></p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1cI8LHG61gK0jSZFlXXXDKFXa-628-195.png" alt="stat"></p><h3 id="2-7-wc"><a href="#2-7-wc" class="headerlink" title="2.7 wc"></a>2.7 wc</h3><p>命令描述：wc命令用于统计指定文本的<strong>行数、字数、字节数</strong>。</p><p>命令格式：<code>wc [参数] [文件]</code>。</p><p>命令参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-l</td><td style="text-align:left">只显示行数</td></tr><tr><td style="text-align:left">-w</td><td style="text-align:left">只显示单词数</td></tr><tr><td style="text-align:left">-c</td><td style="text-align:left">只显示字节数</td></tr></tbody></table><p>命令使用示例：统计/etc/passwd文件的行数<code>wc -l /etc/passwd</code></p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1E2FKHND1gK0jSZFyXXciOVXa-486-49.png" alt="wc"></p><h3 id="2-8-file"><a href="#2-8-file" class="headerlink" title="2.8 file"></a>2.8 file</h3><p>命令描述： file命令用于辨识文件类型。</p><p>命令格式：<code>file [参数] [文件]</code>。</p><p>命令参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-b</td><td style="text-align:left">列出辨识结果时，不显示文件名称</td></tr><tr><td style="text-align:left">-c</td><td style="text-align:left">详细显示指令执行过程，便于排错或分析程序执行的情形</td></tr><tr><td style="text-align:left">-f [文件]</td><td style="text-align:left">指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称</td></tr><tr><td style="text-align:left">-L</td><td style="text-align:left">直接显示符号连接所指向的文件类别</td></tr></tbody></table><p>命令使用示例：查看/var/log/messages文件的文件类型<code>file /var/log/messages</code></p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1aE0BHGL7gK0jSZFBXXXZZpXa-533-49.png" alt="file"></p><h3 id="2-9-diff"><a href="#2-9-diff" class="headerlink" title="2.9 diff"></a>2.9 diff</h3><p>命令描述：diff命令用于比较文件的差异。</p><p>命令使用示例：</p><ol><li>构造两个相似的文件</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">echo -e &#39;第一行\n第二行\n我是log1第3行\n第四行\n第五行\n第六行&#39; &gt; 1.logecho -e &#39;第一行\n第二行\n我是log2第3行\n第四行&#39; &gt; 2.log</code></pre><ol start="2"><li><p>分别查看两个文件<img src="https://img.alicdn.com/tfs/TB1KBxLHHj1gK0jSZFuXXcrHpXa-758-318.png" alt="cat file"></p></li><li><p>使用diff查看两个文件的差异</p></li></ol><p><img src="https://img.alicdn.com/tfs/TB1dqRHHKH2gK0jSZFEXXcqMpXa-455-190.png" alt="diff file"></p><p>对比结果中的3c3表示两个文件在第3行有不同，5,6d4表示2.log文件相比1.log文件在第4行处开始少了1.log文件的第5和第6行。</p><h2 id="3-文本文件处理命令"><a href="#3-文本文件处理命令" class="headerlink" title="3. 文本文件处理命令"></a>3. 文本文件处理命令</h2><h3 id="3-1-grep"><a href="#3-1-grep" class="headerlink" title="3.1 grep"></a>3.1 grep</h3><p>命令描述：grep命令用于查找文件里符合条件的字符串。</p><p>grep全称是Global Regular Expression Print，表示全局正则表达式版本，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>在Shell脚本中，grep通过返回一个状态值来表示搜索的状态：</p><ul><li>0：匹配成功。</li><li>1：匹配失败。</li><li>2：搜索的文件不存在。</li></ul><p>命令格式：<code>grep [参数] [正则表达式] [文件]</code>。</p><p>命令常用参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-c或–count</td><td style="text-align:left">计算符合样式的列数</td></tr><tr><td style="text-align:left">-d recurse或-r</td><td style="text-align:left">指定要查找的是目录而非文件</td></tr><tr><td style="text-align:left">-e [范本样式]</td><td style="text-align:left">指定字符串做为查找文件内容的样式</td></tr><tr><td style="text-align:left">-E 或 –extended-regexp</td><td style="text-align:left">将样式为延伸的正则表达式来使用</td></tr><tr><td style="text-align:left">-F 或 –fixed-regexp</td><td style="text-align:left">将样式视为固定字符串的列表</td></tr><tr><td style="text-align:left">-G 或 –basic-regexp</td><td style="text-align:left">将样式视为普通的表示法来使用</td></tr><tr><td style="text-align:left">-i 或 –ignore-case</td><td style="text-align:left">忽略字符大小写的差别</td></tr><tr><td style="text-align:left">-n 或 –line-number</td><td style="text-align:left">在显示符合样式的那一行之前，标示出该行的列数编号</td></tr><tr><td style="text-align:left">-v 或 –revert-match</td><td style="text-align:left">显示不包含匹配文本的所有行</td></tr></tbody></table><p>命令使用示例：</p><ul><li><p>查看sshd服务配置文件中监听端口配置所在行编号：<code>grep -n Port /etc/ssh/ssh_config</code></p><p>命令输出结果：<img src="https://s1.ax1x.com/2020/06/27/N61hHP.png" alt="grep -n"></p></li><li><p>查询字符串在文本中出现的行数：<code>grep -c localhost /etc/hosts</code></p><p>命令输出结果：<img src="https://s1.ax1x.com/2020/06/27/N61o4S.png" alt="grep -c"></p></li></ul><ul><li><p>反向查找，不显示符合条件的行。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">  # 查询sshd进程  ps -ef | grep sshd  # 排除grep进程，在上一结果集中继续查询sshd  ps -ef | grep -v grep | grep sshd</code></pre></li></ul><p>   命令输出结果：<img src="https://img.alicdn.com/tfs/TB1GVNGHUT1gK0jSZFrXXcNCXXa-668-149.png" alt="ps -ef"></p><ul><li><p>以递归的方式查找目录下含有关键字的文件：<code>grep -r *.sh /etc</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB17WBFHNz1gK0jSZSgXXavwpXa-912-134.png" alt="grep -r"></p></li><li><p>使用正则表达式匹配httpd配置文件中异常状态码响应的相关配置：<code>grep &#39;ntp[0-9].aliyun.com&#39; /etc/ntp.conf</code></p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB12ABEHQL0gK0jSZFtXXXQCXXa-562-276.png" alt="grep re"></p></li></ul><h3 id="3-2-sed"><a href="#3-2-sed" class="headerlink" title="3.2 sed"></a>3.2 sed</h3><p>命令描述：sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用。</p><ol><li>处理时，把当前处理的行存储在临时缓冲区中，称为模式空间（pattern space）。</li><li>接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。</li><li>接着处理下一行，这样不断重复，直到文件末尾。</li></ol><p>注意：</p><ul><li>sed命令不会修改原文件，例如删除命令只表示某些行不打印输出，而不是从原文件中删去。</li><li>如果要改变源文件，需要使用-i选项。</li></ul><p>命令格式：<code>sed [参数] [动作] [文件]</code>。 </p><p>参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-e [script]</td><td style="text-align:left">执行多个script</td></tr><tr><td style="text-align:left">-f [script文件]</td><td style="text-align:left">执行指定script文件</td></tr><tr><td style="text-align:left">-n</td><td style="text-align:left">仅显示script处理后的结果</td></tr><tr><td style="text-align:left">-i</td><td style="text-align:left">输出到原文件，静默执行（修改原文件）</td></tr></tbody></table><p>动作说明：</p><table><thead><tr><th style="text-align:left">动作</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">a</td><td style="text-align:left">在行后面增加内容</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">替换行</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">删除行</td></tr><tr><td style="text-align:left">i</td><td style="text-align:left">在行前面插入</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">打印相关的行</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">替换内容</td></tr></tbody></table><p>命令使用示例：</p><ul><li><p>删除第3行到最后一行内容：<code>sed &#39;3,$d&#39; /etc/passwd</code></p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1VGVHHQL0gK0jSZFAXXcA9pXa-633-570.png" alt="sed &#39;3,$d&#39;"></p></li><li><p>在最后一行新增行：<code>sed &#39;$a admin:x:1000:1000:admin:/home/admin:/bin/bash&#39; /etc/passwd</code></p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1wjVJHHH1gK0jSZFwXXc7aXXa-767-527.png" alt="sed add line"></p></li><li><p>替换内容：<code>sed &#39;s/SELINUX=disabled/SELINUX=enforcing/&#39; /etc/selinux/config</code></p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1gURDHLb2gK0jSZK9XXaEgFXa-789-655.png" alt="sed replace"></p></li><li><p>替换行：<code>sed &#39;1c abcdefg&#39; /etc/passwd</code></p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1z6XEHUz1gK0jSZLeXXb9kVXa-658-512.png" alt="sed replace line"></p></li></ul><h3 id="3-3-awk"><a href="#3-3-awk" class="headerlink" title="3.3 awk"></a>3.3 awk</h3><p>命令描述：和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。</p><p>命令格式：<code>awk [参数] [脚本] [文件]</code>。</p><p>参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-F fs</td><td style="text-align:left">指定以fs作为输入行的分隔符，awk 命令默认分隔符为空格或制表符</td></tr><tr><td style="text-align:left">-f file</td><td style="text-align:left">读取awk脚本</td></tr><tr><td style="text-align:left">-v val=val</td><td style="text-align:left">在执行处理过程之前，设置一个变量var，并给其设置初始值为val</td></tr></tbody></table><p>内置变量：</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">FS</td><td style="text-align:left">字段分隔符</td></tr><tr><td style="text-align:left">$n</td><td style="text-align:left">指定分隔的第n个字段，如$1、$3分别表示第1、第三列</td></tr><tr><td style="text-align:left">$0</td><td style="text-align:left">当前读入的整行文本内容</td></tr><tr><td style="text-align:left">NF</td><td style="text-align:left">记录当前处理行的字段个数（列数）</td></tr><tr><td style="text-align:left">NR</td><td style="text-align:left">记录当前已读入的行数</td></tr><tr><td style="text-align:left">FNR</td><td style="text-align:left">当前行在源文件中的行号</td></tr></tbody></table><p>awk中还可以指定脚本命令的运行时机。默认情况下，awk会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用BEGIN关键字，BEGIN会在awsk读取数据前强制执行该关键字后指定的脚本命令。</p><p>和BEGIN关键字相对应，END关键字允许我们指定一些脚本命令，awk会在读完数据后执行它们。</p><p>命令使用示例：</p><ul><li><p>查看本机IP地址：<code>ifconfig eth0 |awk &#39;/inet/{print $2}&#39;</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB1VwhFHUH1gK0jSZSyXXXtlpXa-482-66.png" alt="ifconfig"></p></li></ul><ul><li><p>查看本机剩余磁盘容量：<code>df -h |awk &#39;/\/$/{print $4}&#39;</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB1k.RDHLb2gK0jSZK9XXaEgFXa-423-70.png" alt="df"></p></li></ul><ul><li><p>统计系统用户个数：<code>awk -F: &#39;$3&lt;1000{x++} END{print x}&#39; /etc/passwd</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB1_AFFHFP7gK0jSZFjXXc5aXXa-553-66.png" alt="awk -F"></p></li></ul><ul><li><p>输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息：<code>awk -F: &#39;$7!~/nologin$/{print $1,$7}&#39; /etc/passwd</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB1EaRHHKH2gK0jSZFEXXcqMpXa-595-129.png" alt="nologin"></p></li></ul><ul><li><p>输出/etc/passwd文件中前三行记录的用户名和用户uid：<code>head -3 /etc/passwd | awk  &#39;BEGIN{FS=&quot;:&quot;;print &quot;name\tuid&quot;}{print $1,&quot;\t&quot;$3}END{print &quot;sum lines &quot;NR}&#39;</code></p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1hAXJHUY1gK0jSZFCXXcwqXXa-1020-151.png" alt="user"></p></li><li><p>查看tcp连接数：<code>netstat -na | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB10ghFHUH1gK0jSZSyXXXtlpXa-813-87.png" alt="tcp"></p></li><li><p>关闭指定服务的所有的进程：<code>ps -ef | grep httpd | awk {&#39;print $2&#39;} | xargs kill -9</code></p></li></ul><h3 id="3-4-cut"><a href="#3-4-cut" class="headerlink" title="3.4 cut"></a>3.4 cut</h3><p>命令描述：cut命令主要用来切割字符串，可以对输入的数据进行切割然后输出。</p><p>命令格式：<code>cut [参数] [文件]</code>。</p><p>参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-b</td><td style="text-align:left">以字节为单位进行分割</td></tr><tr><td style="text-align:left">-c</td><td style="text-align:left">以字符为单位进行分割</td></tr><tr><td style="text-align:left">-d</td><td style="text-align:left">自定义分隔符，默认为制表符</td></tr></tbody></table><p>命令使用示例：</p><ul><li>按字节进行切割。</li></ul><p><img src="https://img.alicdn.com/tfs/TB1ulVKHQT2gK0jSZFkXXcIQFXa-514-109.png" alt="cut -b"></p><ul><li>按字符进行切割。</li></ul><p><img src="https://img.alicdn.com/tfs/TB1HqRHHKH2gK0jSZFEXXcqMpXa-494-150.png" alt="cut -c"></p><ul><li>按指定字符进行切割。</li></ul><p><img src="https://img.alicdn.com/tfs/TB17VNGHUT1gK0jSZFrXXcNCXXa-516-107.png" alt="cut -d"></p><h3 id="3-5-tr"><a href="#3-5-tr" class="headerlink" title="3.5 tr"></a>3.5 tr</h3><p>命令描述：tr命令用于对来自标准输入的字符进行替换、压缩和删除。</p><p>命令格式：<code>tr [参数] [文本]</code>。</p><p>参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-c</td><td style="text-align:left">反选指定字符</td></tr><tr><td style="text-align:left">-d</td><td style="text-align:left">删除指定字符</td></tr><tr><td style="text-align:left">-s</td><td style="text-align:left">将重复的字符缩减成一个字符</td></tr><tr><td style="text-align:left">-t [第一字符集] [第二字符集]</td><td style="text-align:left">删除第一字符集较第二字符集多出的字符，使两个字符集长度相等</td></tr></tbody></table><p>命令使用示例：</p><ul><li><p>将输入字符由大写转换为小写：<code>echo &quot;HELLO WORLD&quot; | tr &#39;A-Z&#39; &#39;a-z&#39;</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB1YTdHHQY2gK0jSZFgXXc5OFXa-506-65.png" alt="tr toUpperCase"></p></li><li><p>删除字符：<code>echo &quot;hello 123 world 456&quot; | tr -d &#39;0-9&#39;</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB1XlBLHHj1gK0jSZFuXXcrHpXa-513-66.png" alt="tr -d"></p></li><li><p>压缩字符：<code>echo &quot;thissss is      a text linnnnnnne.&quot; | tr -s &#39; sn&#39;</code></p><p>命令输出结果：    <img src="https://img.alicdn.com/tfs/TB1nthJHHY1gK0jSZTEXXXDQVXa-605-68.png" alt="tr -s"></p></li><li><p>产生随机密码：<code>cat /dev/urandom | tr -dc a-zA-Z0-9 | head -c 13</code></p><p>命令输出结果： <img src="https://img.alicdn.com/tfs/TB1kGFGHQP2gK0jSZPxXXacQpXa-573-69.png" alt="random password"> </p></li></ul><h1 id="三、Linux指令入门-系统管理"><a href="#三、Linux指令入门-系统管理" class="headerlink" title="三、Linux指令入门-系统管理"></a>三、Linux指令入门-系统管理</h1><h2 id="1-常用系统工作命令"><a href="#1-常用系统工作命令" class="headerlink" title="1. 常用系统工作命令"></a>1. 常用系统工作命令</h2><h3 id="1-1-echo"><a href="#1-1-echo" class="headerlink" title="1.1 echo"></a>1.1 echo</h3><p>命令描述：echo命令用于在终端输出字符串或变量提取后的值。</p><p>命令格式：<code>echo [字符串 | $变量]</code>。</p><p>命令用法示例：</p><ul><li><p>显示普通字符串：<code>echo &quot;Hello World&quot;</code></p></li><li><p>显示变量</p><ul><li><p>首先在shell环境中定义一个临时变量name：<code>export name=&quot;Tom&quot;</code></p></li><li><p>使用echo命令将变量name的值显示到终端：<code>echo $name</code></p><p>输出结果：<img src="https://img.alicdn.com/tfs/TB1P6NMHHH1gK0jSZFwXXc7aXXa-506-89.png" alt="echo "></p></li></ul></li><li><p>显示结果定向至文件</p><p>以下命令会将文本<code>This is a test text.</code>输出重定向到文件test.txt中，如果文件已存在，将会覆盖文件内容，如果不存在则创建。其中<code>&gt;</code>符号表示输出重定向。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">  echo &quot;This is a test text.&quot; &gt; test.txt</code></pre></li></ul><p>  如果您希望将文本追加到文件内容最后，而不是覆盖它，请使用<code>&gt;&gt;</code>输出追加重定向符号。</p><ul><li><p>显示命令执行结果</p><ul><li>以下命令将会在终端显示当前的工作路径。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">  echo `pwd`</code></pre></li></ul><p>  注意：pwd命令是用一对反引号（<code></code>）包裹，而不是一对单引号（’’）。</p><p>  使用<code>$(command)</code>形式可以达到相同效果。</p>  <!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">  echo $(pwd)</code></pre><p>  输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1ntFMHNv1gK0jSZFFXXb0sXXa-513-154.png" alt="echo $(command)"></p><h3 id="1-2-date"><a href="#1-2-date" class="headerlink" title="1.2 date"></a>1.2 date</h3><p>命令描述：date命令用于显示和设置系统的时间和日期。</p><p>命令格式：<code>date [选项] [+格式]</code>。</p><p>其中，时间格式的部分控制字符解释如下：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">%a</td><td style="text-align:left">当地时间的星期名缩写（例如： 日，代表星期日）</td></tr><tr><td style="text-align:left">%A</td><td style="text-align:left">当地时间的星期名全称 （例如：星期日）</td></tr><tr><td style="text-align:left">%b</td><td style="text-align:left">当地时间的月名缩写 （例如：一，代表一月）</td></tr><tr><td style="text-align:left">%B</td><td style="text-align:left">当地时间的月名全称 （例如：一月）</td></tr><tr><td style="text-align:left">%c</td><td style="text-align:left">当地时间的日期和时间 （例如：2005年3月3日 星期四 23:05:25）</td></tr><tr><td style="text-align:left">%C</td><td style="text-align:left">世纪；比如 %Y，通常为省略当前年份的后两位数字（例如：20）</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">按月计的日期（例如：01）</td></tr><tr><td style="text-align:left">%D</td><td style="text-align:left">按月计的日期；等于%m/%d/%y</td></tr><tr><td style="text-align:left">%F</td><td style="text-align:left">完整日期格式，等价于 %Y-%m-%d</td></tr><tr><td style="text-align:left">%j</td><td style="text-align:left">按年计的日期（001-366）</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">按年计的日期（001-366）</td></tr><tr><td style="text-align:left">%r</td><td style="text-align:left">当地时间下的 12 小时时钟时间 （例如：11:11:04 下午）</td></tr><tr><td style="text-align:left">%R</td><td style="text-align:left">24 小时时间的时和分，等价于 %H:%M</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数</td></tr><tr><td style="text-align:left">%T</td><td style="text-align:left">时间，等于%H:%M:%S</td></tr><tr><td style="text-align:left">%U</td><td style="text-align:left">一年中的第几周，以周日为每星期第一天（00-53）</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">当地时间下的日期描述 （例如：12/31/99）</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">当地时间下的时间描述 （例如：23:13:48）</td></tr><tr><td style="text-align:left">%w</td><td style="text-align:left">一星期中的第几日（0-6），0 代表周一</td></tr><tr><td style="text-align:left">%W</td><td style="text-align:left">一年中的第几周，以周一为每星期第一天（00-53）</td></tr></tbody></table><p>命令用法示例：</p><ul><li><p>按照默认格式查看当前系统时间：<code>date</code></p><p>输出结果：<img src="https://img.alicdn.com/tfs/TB1EXbMjcKfxu4jSZPfXXb3dXXa-476-46.png" alt="date"></p></li><li><p>按照指定格式查看当前系统时间：<code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code></p><p>输出结果：<img src="https://img.alicdn.com/tfs/TB1tv9Yc5cKOu4jSZKbXXc19XXa-494-48.png" alt="date format"></p></li><li><p>查看今天是当年中的第几天：<code>date &quot;+%j&quot;</code></p><p>输出结果：<img src="https://img.alicdn.com/tfs/TB1Qq4OHKH2gK0jSZJnXXaT1FXa-492-46.png" alt="date &quot;+%j&quot;"></p></li><li><p>将系统的当前时间设置为指定格式值：<code>date -s &quot;20200220 20:20:20&quot;</code></p><p>输出结果：<img src="https://img.alicdn.com/tfs/TB1sUJGHFY7gK0jSZKzXXaikpXa-576-47.png" alt="date -s"></p></li><li><p>校正系统时间，与网络时间同步</p></li><li><p>安装ntp校时工具：<code>yum -y install ntp</code></p><ul><li>用<code>ntpdate</code>命令从时间服务器更新时间：<code>ntpdate time.nist.gov</code></li></ul><p>输出结果：<img src="https://img.alicdn.com/tfs/TB11jd_Xj39YK4jSZPcXXXrUFXa-728-51.png" alt="ntp"></p></li></ul><h3 id="1-3-wget"><a href="#1-3-wget" class="headerlink" title="1.3 wget"></a>1.3 wget</h3><p>命令描述：在终端中下载文件。</p><p>命令格式：<code>wget [参数] 下载地址</code>。</p><p>参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">-b</td><td style="text-align:left">后台下载</td></tr><tr><td style="text-align:left">-P</td><td style="text-align:left">下载到指定目录</td></tr><tr><td style="text-align:left">-t</td><td style="text-align:left">最大重试次数</td></tr><tr><td style="text-align:left">-c</td><td style="text-align:left">断点续传</td></tr><tr><td style="text-align:left">-p</td><td style="text-align:left">下载页面内所有资源，包括图片、视频等</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:left">递归下载</td></tr></tbody></table><p>命令使用示例：</p><p>下载一张图片到路径<code>/root/static/img/</code>中，<code>-p</code>参数默认值为当前路径，如果指定路径不存在会自动创建。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">wget -P &#x2F;root&#x2F;static&#x2F;img&#x2F; http:&#x2F;&#x2F;img.alicdn.com&#x2F;tfs&#x2F;TB1.R._t7L0gK0jSZFxXXXWHVXa-2666-1500.png</code></pre><p>输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1vQxHHFT7gK0jSZFpXXaTkpXa-1740-257.png" alt="wget -p"></p><h3 id="1-4-ps"><a href="#1-4-ps" class="headerlink" title="1.4 ps"></a>1.4 ps</h3><p>命令描述：ps命令用于查看系统中的进程状态。</p><p>命令格式：<code>ps [参数]</code>。</p><p>命令参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">-a</td><td style="text-align:left">显示现行终端机下的所有程序，包括其他用户的程序</td></tr><tr><td style="text-align:left">-u</td><td style="text-align:left">以用户为主的格式来显示程序状况</td></tr><tr><td style="text-align:left">-x</td><td style="text-align:left">显示没有控制终端的进程，同时显示各个命令的具体路径</td></tr><tr><td style="text-align:left">-e</td><td style="text-align:left">列出程序时，显示每个程序所使用的环境变量</td></tr><tr><td style="text-align:left">-f</td><td style="text-align:left">显示当前所有的进程</td></tr><tr><td style="text-align:left">-t</td><td style="text-align:left">指定终端机编号，并列出属于该终端机的程序的状况</td></tr></tbody></table><p>命令使用示例：<code>ps -ef | grep sshd</code></p><p>输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1PWHcaepyVu4jSZFhXXbBpVXa-588-93.png" alt="ps sshd"></p><h3 id="1-5-top"><a href="#1-5-top" class="headerlink" title="1.5 top"></a>1.5 top</h3><p>命令描述：top命令动态地监视进程活动与系统负载等信息。</p><p>命令使用示例：<code>top</code></p><p>输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1RGHcaepyVu4jSZFhXXbBpVXa-700-345.png" alt="top"></p><p>命令输出参数解释：</p><p>以上命令输出视图中分为两个区域，一个统计信息区，一个进程信息区。</p><ul><li><p>统计信息区</p><ul><li>第一行信息依次为：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</li><li>第二行信息依次为：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</li><li>第三行信息依次为：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。</li><li>第四行信息依次为：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</li><li>第五行信息依次为：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、预加载内存量。</li></ul></li><li><p>进程信息区</p><p>| 列名    | 含义                                                         |<br>| :—— | :———————————————————– |<br>| PID     | 进程ID                                                       |<br>| USER    | 进程所有者的用户名                                           |<br>| PR      | 进程优先级                                                   |<br>| NI      | nice值。负值表示高优先级，正值表示低优先级                   |<br>| VIRT    | 进程使用的虚拟内存总量，单位kb                               |<br>| RES     | 进程使用的、未被换出的物理内存大小，单位kb                   |<br>| SHR     | 共享内存大小，单位kb                                         |<br>| S       | 进程状态D：不可中断的睡眠状态R：正在运行S：睡眠T：停止Z：僵尸进程 |<br>| %CPU    | 上次更新到现在的CPU时间占用百分比                            |<br>| %MEM    | 进程使用的物理内存百分比                                     |<br>| TIME+   | 进程使用的CPU时间总计，单位1/100秒                           |<br>| COMMAND | 命令名                                                       |</p></li></ul><blockquote><p>按<code>q</code>键退出监控页面。</p></blockquote><h3 id="1-6-pidof"><a href="#1-6-pidof" class="headerlink" title="1.6 pidof"></a>1.6 pidof</h3><p>命令描述：pidof命令用于查询指定服务进程的PID值。</p><p>命令格式：<code>pidof [服务名称]</code>。</p><p>命令参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-s</td><td style="text-align:left">仅返回一个进程号</td></tr><tr><td style="text-align:left">-c</td><td style="text-align:left">只显示运行在root目录下的进程，这个选项只对root用户有效</td></tr><tr><td style="text-align:left">-o</td><td style="text-align:left">忽略指定进程号的进程</td></tr><tr><td style="text-align:left">-x</td><td style="text-align:left">显示由脚本开启的进程</td></tr></tbody></table><p>命令使用示例：</p><ul><li><p>查询出crond服务下的所有进程ID：<code>pidof crond</code></p><p>输出结果：<img src="https://img.alicdn.com/tfs/TB1iG8KHQL0gK0jSZFAXXcA9pXa-486-44.png" alt="pidof crond"></p></li></ul><h3 id="1-7-kill"><a href="#1-7-kill" class="headerlink" title="1.7 kill"></a>1.7 kill</h3><p>命令描述：kill命令用于终止指定PID的服务进程。</p><p>kill可将指定的信息送至程序。预设的信息为<code>SIGTERM(15)</code>，可将指定程序终止。若仍无法终止该程序，可使用<code>SIGKILL(9)</code>信息尝试强制删除程序。</p><p>命令格式：<code>kill [参数] [进程PID]</code>。</p><p>命令使用示例：强制终止pid为1247的进程<code>kill -9 1247</code></p><h3 id="1-8-killall"><a href="#1-8-killall" class="headerlink" title="1.8 killall"></a>1.8 killall</h3><p>命令描述：killall命令用于终止指定名称的服务对应的全部进程。</p><p>命令格式：<code>killall [进程名称]</code>。</p><p>命令使用示例：删除crond服务下的所有进程<code>killall crond</code></p><h3 id="1-9-reboot"><a href="#1-9-reboot" class="headerlink" title="1.9 reboot"></a>1.9 reboot</h3><p>命令描述：reboot命令用来重启系统。</p><p>命令格式：<code>reboot [-n] [-w] [-d] [-f] [-i]</code>。</p><p>命令参数说明：</p><ul><li>-n：保存数据后再重新启动系统。</li><li>-w：仅做测试，并不是真的将系统重新开机，只会把重新开机的数据写入记录文件<code>/var/log/wtmp</code>。</li><li>-d：重新启动时不把数据写入记录文件<code>/var/tmp/wtmp</code>。</li><li>-f：强制重新开机，不调用shutdown指令的功能。</li><li>-i：关闭网络设置之后再重新启动系统。</li></ul><p>命令使用示例：<code>reboot</code></p><h3 id="1-10-poweroff"><a href="#1-10-poweroff" class="headerlink" title="1.10 poweroff"></a>1.10 poweroff</h3><p>命令描述：poweroff命令用来关闭系统。</p><p>命令使用示例：<code>poweroff</code></p><h2 id="2-系统状态检测命令"><a href="#2-系统状态检测命令" class="headerlink" title="2. 系统状态检测命令"></a>2. 系统状态检测命令</h2><h3 id="2-1-ifconfig"><a href="#2-1-ifconfig" class="headerlink" title="2.1 ifconfig"></a>2.1 ifconfig</h3><p>命令描述：ifconfig命令用于获取网卡配置与网络状态等信息。</p><p>命令示例：<code>ifconfig</code></p><p><img src="https://img.alicdn.com/tfs/TB1L3dIHUH1gK0jSZSyXXXtlpXa-634-351.png" alt="ifconfig"></p><p>命令输出说明：</p><ul><li>第一部分的第一行显示网卡状态信息。<ul><li>eth0表示第一块网卡。</li><li>UP代表网卡开启状态。</li><li>RUNNING代表网卡的网线被接上。</li><li>MULTICAST表示支持组播。</li></ul></li><li>第二行显示网卡的网络信息。<ul><li>inet（IP地址）：172.16.132.195。</li><li>broadcast（广播地址）：172.16.143.255。</li><li>netmask（掩码地址）：255.255.240.0。</li></ul></li><li>RX表示接收数据包的情况，TX表示发送数据包的情况。</li><li>lo表示主机的回环网卡，是一种特殊的网络接口，不与任何实际设备连接，而是完全由软件实现。与回环地址（127.0.0.0/8 或 ::1/128）不同，回环网卡对系统显示为一块硬件。任何发送到该网卡上的数据都将立刻被同一网卡接收到。</li></ul><h3 id="2-2-uname"><a href="#2-2-uname" class="headerlink" title="2.2 uname"></a>2.2 uname</h3><p>命令描述：uname命令用于查看系统内核与系统版本等信息。</p><p>命令语法：<code>uname [-amnrsv][--help][--version]</code></p><p>命令使用示例：</p><ul><li><p>显示系统信息：<code>uname -a</code></p><p>命令输出结果：</p><p><img src="https://img.alicdn.com/tfs/TB1o7BIHFP7gK0jSZFjXXc5aXXa-889-49.png" alt="uname -a"></p></li><li><p>显示当前系统的硬件架构：<code>uname -i</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB1MgdIHUH1gK0jSZSyXXXtlpXa-669-47.png" alt="uname -i"></p></li><li><p>显示操作系统发行编号：<code>uname -r</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB1FLVAHKL2gK0jSZPhXXahvXXa-528-47.png" alt="uname -r"></p></li><li><p>显示操作系统名称：<code>uname -s</code></p><p>命令输出结果：<img src="https://img.alicdn.com/tfs/TB1xLJSHRr0gK0jSZFnXXbRRXXa-540-48.png" alt="uname -s"></p></li><li><p>显示主机名称：<code>uname -n</code></p></li></ul><h3 id="2-3-uptime"><a href="#2-3-uptime" class="headerlink" title="2.3 uptime"></a>2.3 uptime</h3><p>命令描述：uptime 用于查看<strong>系统的负载信息</strong>。</p><p>命令使用示例：<img src="https://img.alicdn.com/tfs/TB13YVJHHr1gK0jSZFDXXb9yVXa-606-50.png" alt="uptime"></p><p>命令输出说明：</p><table><thead><tr><th style="text-align:left">负载信息</th><th style="text-align:left">命令输出值</th></tr></thead><tbody><tr><td style="text-align:left">当前服务器时间</td><td style="text-align:left">21:59:59</td></tr><tr><td style="text-align:left">当前服务器运行时长</td><td style="text-align:left">5小时11分钟</td></tr><tr><td style="text-align:left">当前用户数</td><td style="text-align:left">0 users</td></tr><tr><td style="text-align:left">当前负载情况</td><td style="text-align:left"><code>load average: 0.52, 0.58, 0.59</code>（分别取1min，5min，15min的均值）</td></tr></tbody></table><h3 id="2-4-free"><a href="#2-4-free" class="headerlink" title="2.4 free"></a>2.4 free</h3><p>命令描述：free用于显示当前系统中内存的使用量信息。</p><p>命令语法：<code>free [-bkmotV][-s &lt;间隔秒数&gt;]</code>。</p><p>命令参数说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-b</td><td style="text-align:left">以Byte为单位显示内存使用情况</td></tr><tr><td style="text-align:left">-k</td><td style="text-align:left">以KB为单位显示内存使用情况</td></tr><tr><td style="text-align:left">-m</td><td style="text-align:left">以MB为单位显示内存使用情况</td></tr><tr><td style="text-align:left">-h</td><td style="text-align:left">以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。</td></tr></tbody></table><p>命令使用示例：</p><p><img src="https://img.alicdn.com/tfs/TB1xm4IHHr1gK0jSZR0XXbP8XXa-747-88.png" alt="free -h"></p><p>命令输出说明：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">total</td><td style="text-align:left">物理内存总数</td></tr><tr><td style="text-align:left">used</td><td style="text-align:left">已经使用的内存数</td></tr><tr><td style="text-align:left">free</td><td style="text-align:left">空间的内存数</td></tr><tr><td style="text-align:left">share</td><td style="text-align:left">多个进程共享的内存总额</td></tr><tr><td style="text-align:left">buff/cache</td><td style="text-align:left">应用使用内存数</td></tr><tr><td style="text-align:left">available</td><td style="text-align:left">可用的内存数</td></tr><tr><td style="text-align:left">Swap</td><td style="text-align:left">虚拟内存（阿里云ECS服务器默认不开启虚拟内存）</td></tr></tbody></table><h3 id="2-5-who"><a href="#2-5-who" class="headerlink" title="2.5 who"></a>2.5 who</h3><p>命令描述：who 命令显示关于当前在本地系统上的所有用户的信息。</p><p>命令使用示例：</p><ul><li>显示当前登录系统的用户：<code>who</code></li></ul><p><img src="https://img.alicdn.com/tfs/TB1sTdKHQY2gK0jSZFgXXc5OFXa-527-69.png" alt="who"></p><ul><li><p>显示用户登录来源：<code>who -l -H</code></p><p>​                       <img src="https://img.alicdn.com/tfs/TB1phBIHKT2gK0jSZFvXXXnFXXa-524-94.png" alt="who -l -H"> </p></li><li><p>只显示当前用户：<code>who -m -H</code></p></li></ul><p><img src="https://img.alicdn.com/tfs/TB1fMFKHO_1gK0jSZFqXXcpaXXa-510-67.png" alt="who -m -H"></p><ul><li>精简模式显示：<code>who -q</code></li></ul><p><img src="https://img.alicdn.com/tfs/TB1saBJHQP2gK0jSZPxXXacQpXa-452-65.png" alt="who -q"></p><h3 id="2-6-last"><a href="#2-6-last" class="headerlink" title="2.6 last"></a>2.6 last</h3><p>命令描述： last 命令用于显示用户最近登录信息。</p><p>命令使用示例：</p><p><img src="https://img.alicdn.com/tfs/TB107xHHQL0gK0jSZFtXXXQCXXa-645-215.png" alt="last"></p><p>由于这些信息都是以日志文件的形式保存在系统中，黑客可以很容易地对内容进行篡改，所以该命令输出的信息并不能作为服务器是否被入侵的依据。</p><h3 id="2-7-history"><a href="#2-7-history" class="headerlink" title="2.7 history"></a>2.7 history</h3><p>命令描述：history命令用于显示历史执行过的命令；bash默认记录1000条执行过的历史命令，被记录在<code>~/.bash_history</code>文件中。</p><p>命令使用示例：</p><ul><li>显示最新10条执行过的命令：<code>history 10</code></li></ul><p><img src="https://img.alicdn.com/tfs/TB1_PNMHHH1gK0jSZFwXXc7aXXa-592-238.png" alt="history 10"></p><ul><li>清除历史记录：<code>history -c</code></li></ul><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>本文内容均<a href="https://developer.aliyun.com/adc/" target="_blank" rel="noopener">来自阿里云开发者云</a>，记录方便速查，仅做学习使用；阿里云的Linux指令入门系列非常适合Linux入门学习者，墙裂推荐去官网学习一遍，受益匪浅。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis事务和主从复制</title>
      <link href="/DataBase/Redis-TransactionAndReplication.html"/>
      <url>/DataBase/Redis-TransactionAndReplication.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Redis的事务"><a href="#1-Redis的事务" class="headerlink" title="1. Redis的事务"></a>1. Redis的事务</h2><p>Redis的事务可以一次执行多个命令，本质是一组命令的集合；一个事务中的所有命令都会序列化，<strong>按顺序地串行化执行而不会被其他命令插入</strong>，不允许加塞。</p><blockquote><p>简言之，Redis的事务就是：在一个队列中，一次性、顺序性、排他性的执行一系列命令</p></blockquote><h3 id="1-1-常用命令"><a href="#1-1-常用命令" class="headerlink" title="1.1 常用命令"></a>1.1 常用命令</h3><p>常用命令表如下：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>DISCARD</td><td>取消事务，放弃执行事务块内的所有命令</td></tr><tr><td>EXEC</td><td>执行所有事务块内的命令</td></tr><tr><td>MULTI</td><td>标记一个事务块的开始</td></tr><tr><td>UNWATCH</td><td>取消WATCH命令对所有key的监视</td></tr><tr><td>WATCH key [key …]</td><td>监视一个或多个key，如果在事务执行之前这些key被其他命令所改动，那么事务将被打断。</td></tr></tbody></table><h4 id="1-1-1-Case1：全体连坐"><a href="#1-1-1-Case1：全体连坐" class="headerlink" title="1.1.1 Case1：全体连坐"></a>1.1.1 Case1：全体连坐</h4><p>发生一个错误，该事务块内所有命令都不执行： </p><p><img src="http://yanxuan.nosdn.127.net/f606718797441c948e816847759a22db.png" alt="连坐机制"></p><h4 id="1-1-2-Case2：冤头债主"><a href="#1-1-2-Case2：冤头债主" class="headerlink" title="1.1.2 Case2：冤头债主"></a>1.1.2 Case2：冤头债主</h4><p>对的执行错的抛出</p><p><img src="http://yanxuan.nosdn.127.net/5b40b8cd1f1650f98e23981e969c1ad4.png" alt="抛出错误"></p><blockquote><p>对于这种运行期才会报错的命令，是不会影响到其他命令继续执行的</p></blockquote><h4 id="1-1-3-Case3：watch监控"><a href="#1-1-3-Case3：watch监控" class="headerlink" title="1.1.3 Case3：watch监控"></a>1.1.3 Case3：watch监控</h4><ul><li>悲观锁：就是很悲观，每次去拿数据时都认为别人会修改，所以每次拿数据时都会上锁，别人想拿数据就会阻塞等待。关系型数据库中很常用这种锁机制，如行锁、表锁等，都是在操作之前先上锁。</li><li><p>乐观锁：就是很乐观，每次去拿数据时都认为别人不会修改，所以不上锁，但是一般会使用到CAS（Check And Set）机制来进行判断，即在更新时会判断一下在此期间别人有没有去更新过这个数据，如使用到版本号机制，提交版本必须大于记录当前版本才能执行更新；乐观锁通常适用于多读的应用类型，可以提高吞吐量。</p></li><li><p>初始化余额和欠额，并使用事务保证两笔金额变动一致</p></li></ul><p><img src="http://yanxuan.nosdn.127.net/f9ae4e95a7ece4d51b720bce6b42b9b3.png" alt="init"></p><ul><li>使用<code>watch</code>监控余额，如果balance被修改了，后一个事务的执行将会失效</li></ul><p><img src="http://yanxuan.nosdn.127.net/bbdd9f9c7096033e4a94185a0998bdc1.png" alt="watch"></p><ul><li>使用<code>unwatch</code>取消监控，事务就能正常执行</li></ul><p><img src="http://yanxuan.nosdn.127.net/b956290a78cedf4f427e2453c8407442.png" alt="UTOOLS1592640014048.png"></p><blockquote><p>执行了exec命令后之前加的监控锁都会被取消掉。</p></blockquote><ul><li>小结</li></ul><p>Watch命令有点类似乐观锁，可同时监控多个keys，事务提交时，如果key值被别人修改过了，那么整个事务队列都不会被执行，返回一个<code>nil</code>提示事务执行失败。</p><ul><li>事务的三个阶段<ul><li>开启：以<code>MULTI</code>开始一个事务；</li><li>入队：将多个命令入队到事务中，这些命令并不会立即执行，而是放到等待执行的事务队列里面；</li><li>执行：使用<code>EXEC</code>命令触发事务，依次执行事务队列中的命令。</li></ul></li><li>事务的三个特性<ul><li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行；事务在执行过程中，不会被其他客户端发送来的命令请求所打断。</li><li>没有隔离级别的操作：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行；因此不存在事务内查询看到事务内的更新，事务外查询不能看到这类问题。</li><li>不保证原子性：Redis同一个事务中如果有一条命令执行失败，其他的命令仍然会被执行，不会回滚。</li></ul></li></ul><h2 id="2-Redis的发布订阅"><a href="#2-Redis的发布订阅" class="headerlink" title="2. Redis的发布订阅"></a>2. Redis的发布订阅</h2><p>Redis的发布订阅是一种进程间的消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。</p><p>相关命令如下：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>PSUBSCRIBE pattern [pattern …]</td><td>订阅一个或多个符合给定模式的频道</td></tr><tr><td>PUBSUB subcommand [argument …]</td><td>查看订阅与发布系统状态</td></tr><tr><td>PUBLISH channel message</td><td>将消息发送到指定的频道</td></tr><tr><td>PUNSUBSCRIBE [pattern …]</td><td>退订所有给定模式的频道</td></tr><tr><td>SUBSCRIBE channel …</td><td>订阅给定的一个或多个频道的消息</td></tr><tr><td>UNSUBSCRIBE channel…</td><td>退订指定频道</td></tr></tbody></table><ul><li>案例<ul><li>客户端1输入<code>SUBSCRIBE c1 c2 c3</code>，同时订阅多个频道</li><li>客户端2输入<code>PUBLISH c2 hello-redis</code>，对c2频道进行消息发布</li></ul></li></ul><blockquote><p>不常用，了解即可。</p></blockquote><h2 id="3-Redis的主从复制（Master-Slave）"><a href="#3-Redis的主从复制（Master-Slave）" class="headerlink" title="3. Redis的主从复制（Master/Slave）"></a>3. Redis的主从复制（Master/Slave）</h2><p>主从复制，即主机数据更新后根据配置和策略，自动同步到备机的master/slave机制，Master以写为主，Slave以读为主。主要功能就是做读写分离和容灾恢复。</p><h3 id="3-1-从库配置"><a href="#3-1-从库配置" class="headerlink" title="3.1 从库配置"></a>3.1 从库配置</h3><p>Redis的主从复制，<strong>配从不配主</strong>。</p><p>从库配置非常简单，使用<code>slaveof masterIP masterPort</code>即可，但每次与master断开之后，都要重新连接，除非将命令配置进redis.conf文件。</p><h4 id="3-1-1-修改配置文件细节"><a href="#3-1-1-修改配置文件细节" class="headerlink" title="3.1.1 修改配置文件细节"></a>3.1.1 修改配置文件细节</h4><ul><li>拷贝三份redis.conf文件</li></ul><p><img src="http://yanxuan.nosdn.127.net/9bfec101e8894da902eb81016148b0e2.png" alt="cp"></p><ul><li>修改每个文件中的一些配置，修改为与文件端口名相同的信息。例如<code>redis6380.conf</code>配置文件，修改如下内容：<ul><li>开启<code>daemonize yes</code></li><li>修改<code>port 6380</code></li><li>修改<code>pidfile /var/run/redis_6380.pid</code></li><li>修改<code>logfile &quot;6380.log&quot;</code></li><li>修改<code>dbfilename dump_6380.rdb</code></li></ul></li></ul><h4 id="3-1-2-常用一主二仆配置"><a href="#3-1-2-常用一主二仆配置" class="headerlink" title="3.1.2 常用一主二仆配置"></a>3.1.2 常用一主二仆配置</h4><ul><li>开启3个不同的窗口，启动3台redis服务器并连接</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">窗口1：redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis6380.confredis-cli -p 6380窗口2：redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis6381.confredis-cli -p 6381窗口3：redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis6382.confredis-cli -p 6382</code></pre><ul><li>使用<code>info replication</code>命令查看当前库复制信息，默认情况下三台都是master角色</li><li>主机6380插入三条数据</li></ul><p><img src="http://yanxuan.nosdn.127.net/634a7d8d0171f468beca1e89df3c6d15.png" alt="master"></p><ul><li>从机6381和6382连接主机，获取主机全部数据</li></ul><p><img src="http://yanxuan.nosdn.127.net/9c044b1fc3b5cdf2f47228991e6953d8.png" alt="slave6381"></p><p><img src="http://yanxuan.nosdn.127.net/211a0d964c434c411f16ab40d71229ce.png" alt="slave6382"></p><ul><li>此时主机6380输入命令<code>info replication</code>，信息如下</li></ul><p><img src="http://yanxuan.nosdn.127.net/6b6d8c34c054c9887eb80526a8007c9e.png" alt="master6380_info"></p><ul><li>从机6381输入<code>info replication</code>，信息如下</li></ul><p><img src="http://yanxuan.nosdn.127.net/a833c590e33629da527e651a2eb496e7.png" alt="slave6381_info"></p><ul><li>如果从机6381想执行写操作命令，是无法执行的，所谓的（从）读（主）写分离</li></ul><p><img src="http://yanxuan.nosdn.127.net/dc1681ee0d14cee181af8642ff67c084.png" alt="READONLY"></p><ul><li>如果此时主机6380宕机了<code>shutdown</code>，那么从机的状态如下，从机会原地待命，等待主机上线。</li></ul><p><img src="http://yanxuan.nosdn.127.net/f3245beb998a748d627c55204cccb718.png" alt="ifmasterdown"></p><ul><li>如果主机重新上线，那么从机会显示主机连接状态为上线状态，并且继续复制主机数据。</li><li>如果某一台从机掉线了，那么当它重启后就不是从机身份了，无法继续复制主机数据；想要获取主机数据需要重新连接。</li></ul><p><img src="http://yanxuan.nosdn.127.net/64c9fea74f79c8027eef01536f8e17e5.png" alt="slave6381_down"></p><h4 id="3-1-3-薪火相传配置"><a href="#3-1-3-薪火相传配置" class="headerlink" title="3.1.3 薪火相传配置"></a>3.1.3 薪火相传配置</h4><p>可以将一台Slave作为下一台slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该Slave作为了链条中的下一个master，可以有效减轻主机的写压力。</p><ul><li>将6382从机连接至6381从机</li></ul><p><img src="http://yanxuan.nosdn.127.net/954cb5078e7e8a69ecb8a6fa15eaf1c9.png" alt="slave6382"></p><ul><li>6381从机信息</li></ul><p><img src="http://yanxuan.nosdn.127.net/fe85bbc83b9e7e53bba72d7cf9b82471.png" alt="6381slave"></p><ul><li>6380主机信息，此时主机执行写操作，2台从机都可以获取</li></ul><p><img src="http://yanxuan.nosdn.127.net/a29eaa5d5851141e7769ceae18093ab6.png" alt="UTOOLS1592727842027.png"></p><h4 id="3-1-4-反客为主配置"><a href="#3-1-4-反客为主配置" class="headerlink" title="3.1.4 反客为主配置"></a>3.1.4 反客为主配置</h4><p>当主机宕机时，从机输入<code>SLAVEOF on one</code>使当前数据库停止与其他数据库的同步，转为主数据库。其他从机需要重新连接至主机。</p><h3 id="3-2-复制的原理"><a href="#3-2-复制的原理" class="headerlink" title="3.2 复制的原理"></a>3.2 复制的原理</h3><ol><li>Slave启动成功连接到Master后会发送一个同步命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕后，master将传送整个数据文件到slave，以完成一次完全同步</li><li>全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中</li><li>增量复制：Master继续将新收集到的写操作命令依次传给slave，完成同步操作</li><li>slave只要重新连接到master，就会执行一次完全同步，进行全量复制</li></ol><h3 id="3-3-哨兵模式（sentinel）"><a href="#3-3-哨兵模式（sentinel）" class="headerlink" title="3.3 哨兵模式（sentinel）"></a>3.3 哨兵模式（sentinel）</h3><p>哨兵模式就是反客为主的自动版，能够在后台监控主机是否故障，如果主机故障了会根据投票数自动选出一台从机将其转换为主库。</p><h4 id="3-3-1-配置"><a href="#3-3-1-配置" class="headerlink" title="3.3.1 配置"></a>3.3.1 配置</h4><ul><li>首先将3台服务器调整为一主二从配置，主机6380从机6381和6382。</li><li>在你的redis配置文件夹内新建<code>sentinel.conf</code>文件，文件名不能错。</li></ul><p><img src="http://yanxuan.nosdn.127.net/8efc5ca09ffc2ec2a488db11ea7381f6.png" alt="sentinel"></p><ul><li>配置哨兵，填写内容，格式如下<ul><li><code>sentinel monitor 监控的数据库名称（自定义） IP port 投票数</code></li></ul></li></ul><p><img src="http://yanxuan.nosdn.127.net/56be22fd529df1eb1ad6342c59964a6d.png" alt="conf"></p><blockquote><p>投票数1表示，主机宕机后，slave投票看看让谁接替成为主机，票数大于1成为主机</p></blockquote><ul><li>启动哨兵，输入<code>redis-sentinel+你的sentinel.conf文件位置</code>命令即可</li></ul><p><img src="http://yanxuan.nosdn.127.net/0be9fa66a2e76fa8bf0339b135c0a48e.png" alt="start"></p><ul><li>此时如果主机6380宕机了，那么哨兵进程就会自动票选出master主机</li></ul><p><img src="http://yanxuan.nosdn.127.net/d5675d0e684414ba299be2fc722173fe.png" alt="vote"></p><ul><li>如果以前的主机6380上线了，哨兵进程监控到就会将其连接到当前master主机，作为当前主机的从机。</li></ul><p><img src="http://yanxuan.nosdn.127.net/e162d9987d91809b58370d7b31c7372e.png" alt="switch"></p><h3 id="3-4-复制的缺点"><a href="#3-4-复制的缺点" class="headerlink" title="3.4 复制的缺点"></a>3.4 复制的缺点</h3><p>主从复制的一个重大缺点就是，复制延时性：由于所有的写操作都是先在Master上操作的，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统繁忙时，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/DataBase/Redis-Persistence.html"/>
      <url>/DataBase/Redis-Persistence.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Redis配置文件解析"><a href="#1-Redis配置文件解析" class="headerlink" title="1. Redis配置文件解析"></a>1. Redis配置文件解析</h2><h3 id="1-1-Units单位"><a href="#1-1-Units单位" class="headerlink" title="1.1 Units单位"></a>1.1 Units单位</h3><p><img src="http://yanxuan.nosdn.127.net/42152b12ec96c818814b3be7222721d0.png" alt="units"></p><p>Redis配置文件中，开头定义了一些基本的度量单位，只支持bytes，不支持bit，且对大小写不敏感。</p><h3 id="1-2-INCLUDES包含"><a href="#1-2-INCLUDES包含" class="headerlink" title="1.2 INCLUDES包含"></a>1.2 INCLUDES包含</h3><p><img src="http://yanxuan.nosdn.127.net/09b2d21d8a851a665019ac91e489d9a2.png" alt="includes"></p><p>可以将当前配置文件作为主配置，用于包含其他配置文件。</p><h3 id="1-3-GENERAL通用"><a href="#1-3-GENERAL通用" class="headerlink" title="1.3 GENERAL通用"></a>1.3 GENERAL通用</h3><p>Redis的一些通用配置</p><ul><li>daemonize：默认情况下，Redis不作为守护进程运行，需要的话设置为yes</li><li>pidfile：pid文件位置</li><li>loglevel：显示的日志级别，Redis默认四个级别（debug、verbose、notice、warning）</li><li>logfile：指定日志文件名，默认为空字符串表示标准输出，如果你使用标准输出但是守护进程，日志将被发送到<code>/dev/null</code></li><li>databases：配置默认数据库数量</li><li>syslog-enabled：是否把日志输出到syslog中</li><li>syslog-ident：指定syslog中的日志标识</li><li>syslog-facility：指定syslog的设备，值可以是USER或LOCAL0-LOCAL7</li></ul><h3 id="1-4-NETWORK网络"><a href="#1-4-NETWORK网络" class="headerlink" title="1.4 NETWORK网络"></a>1.4 NETWORK网络</h3><p>Redis关于网络的一些配置</p><ul><li>bind：如果直接注释掉bind，将会监听所有ip，生产环境建议设置为固定ip</li><li>port：接收指定端口上的连接，默认为6379</li><li>tcp-backlog：设置tcp的连接队列，backlog队列总和=未完成三次握手队列+已完成三次握手队列；在高并发环境下你需要一个高backlog来避免慢客户端连接问题</li><li>timeout：在客户端空闲N秒后关闭连接（0禁用）</li><li>tcp-keepalive：心跳检测时间，单位秒，0表示不检测，官方建议设置为300s</li></ul><h3 id="1-5-SECURITY安全"><a href="#1-5-SECURITY安全" class="headerlink" title="1.5 SECURITY安全"></a>1.5 SECURITY安全</h3><p>Redis关于安全的配置，由于Redis非常快，所以你应该使用非常强的密码，否则会很容易被破解，这里仅做简单介绍和使用。</p><ul><li>config get requirepass：获取当前密码，默认为<code>&quot;&quot;</code></li><li>config set requirepass “youpassword”：设置密码，后续操作需先验证权限</li><li>auth youpassword：输入密码，验证权限</li></ul><blockquote><p>将密码重新修改为<code>&quot;&quot;</code>后，需重启服务器生效。</p></blockquote><h3 id="1-6-LIMITS限制"><a href="#1-6-LIMITS限制" class="headerlink" title="1.6 LIMITS限制"></a>1.6 LIMITS限制</h3><p>主要是一些内存的限制，在vi命令模式下输入下面的配置参数即可找到。</p><ul><li>maxclients：设置redis同时可以连接多少客户端，默认10000</li><li>maxmemory：设置redis可使用的最大内存量，当内存使用达到上限时，redis会实行缓存淘汰策略，根据maxmemory-policy设置的策略来移除数据。</li><li>maxmemory-policy：最大内存的淘汰策略，有以下几种：<ul><li>volatile-lru：加入键时如果过限，首先从设置了过期时间的键集合中移除最久没有使用的键；</li><li>allkeys-lru：加入键如过限，首先通过LRU算法移除最久没有使用的键；</li><li>volatile-lfu：从所有配置了过期时间的键中移除使用频率最少的键；</li><li>allkeys-lfu：从所有键中移除使用频率最少的键；</li><li>volatile-random：从过期键的集合中随机移除键</li><li>allkeys-random：从所有键集合中随机移除；</li><li>volatile-ttl：从配置了过期时间的键中移除将要过期的键；</li><li>noeviction：不进行移除，内存过限将返回错误信息；</li></ul></li><li>maxmemory-samples：设置样本数量，LRU算法和最小TTL算法都并非精确的算法，而是估算值，所以你可以设置样本的大小。</li></ul><p><a href="https://www.jianshu.com/p/c8aeb3eee6bc" target="_blank" rel="noopener">相关文章参考</a></p><h3 id="1-7-SNAPSHOTTING快照"><a href="#1-7-SNAPSHOTTING快照" class="headerlink" title="1.7 SNAPSHOTTING快照"></a>1.7 SNAPSHOTTING快照</h3><p>Redis持久化中RDB持久化的相关配置区</p><ul><li><code>save &lt;秒数&gt; &lt;写操作次数&gt;</code>：快照保存时间与改动次数的设置</li><li><code>stop-writes-on-bgsave-error</code>：如果后台出错是否停止写入或者忽略错误继续写入，默认yes停止写入</li><li>rdbcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。</li><li>rdbchecksum：在存储快照后，可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</li><li>dbfilename：rdb存储文件的名称，默认<code>dump.rdb</code></li><li>dir：当前redis的工作路径，客户端中通过<code>config get dir</code>可获取路径</li></ul><h3 id="1-8-APPEND-ONLY-MODE追加"><a href="#1-8-APPEND-ONLY-MODE追加" class="headerlink" title="1.8 APPEND ONLY MODE追加"></a>1.8 APPEND ONLY MODE追加</h3><p>Redis持久化中AOF持久化的相关配置区</p><ul><li>appendonly：设置是否开启AOF，默认关闭</li><li>appendfilename：设置aof文件名称，默认<code>appendonly.aof</code></li><li>appendfsync：配置数据写入到磁盘的模式，有以下三种<ul><li>Always：同步持久化，即每次发生数据变更会被立即记录到磁盘，性能较差但能保证数据完整性</li><li>Everysec：默认推荐配置，异步操作，每秒记录一次，如果一秒内宕机会有数据丢失</li><li>No： 不同步</li></ul></li><li>no-appendfsync-on-rewrite：重写时是否可以运用appendfsync，默认on关闭，保证数据安全性</li><li>auto-aof-rewrite-percentage：设置重写的百分比基准值</li><li>auto-aof-rewrite-min-size：设置重写文件的最小基准值</li></ul><h3 id="1-9-常用参数配置介绍"><a href="#1-9-常用参数配置介绍" class="headerlink" title="1.9 常用参数配置介绍"></a>1.9 常用参数配置介绍</h3><ol><li><code>daemonize no</code>：Redis默认不是以守护进程方式运行的，可以通过该配置项修改，使用yes启动守护进程。</li><li><code>pidfile /var/run/redis.pid</code>：当Redis以守护进程方式运行时，Redis会默认把pid写入到/var/run/redis.pid文件中，可以通过pidfile指定。</li><li><code>port 6379</code>：指定Redis监听端口，默认端口为6379。</li><li><code>bind 127.0.0.1</code>：绑定的主机地址</li><li><code>timeout 300</code>：当客户端空闲多久后关闭连接，如指定为0则表示关闭该功能。</li><li><code>loglevel verbose</code>：指定日志记录级别，Redis支持四个级别：debug、verbos、notice、warning，默认varbose。</li><li><code>logfile stdout</code>：日志记录方式，默认标准输出，如果配置Redis为守护进程运行，而这里又配置为标准输出，则日志将会发送给/dev/null</li><li><code>database 16</code>：设置数据库的数量</li><li><code>save &lt;seconds&gt; &lt;changes&gt;</code>：指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可多个条件配合；Redis默认配置文件中提供了三个条件：<code>save 900 1</code>，<code>save 300 10</code>，<code>save 60 10000</code>，分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有1w个更改。</li><li><code>rdbcompression yes</code>：指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大。</li><li><code>dbfilename dump.db</code>：指定本地数据库文件名。</li><li><code>dir ./</code>：指定本地数据库存放目录。</li><li><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>：当本机为slave服务时，设置master服务的IP地址及端口号，在Redis启动时，它会自动从master进行数据同步。</li><li><code>masterauth &lt;master-password&gt;</code>：当master服务设置了密码保护时，slave服务连接master的密码。</li><li><code>requirepass foobared</code>：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过<code>AUTH &lt;password&gt;</code>命令提供密码，默认关闭。</li><li><code>maxclients 128</code>：设置同一时间最大客户端连接数，默认无限制。</li><li><code>maxmemory &lt;bytes&gt;</code>：设置Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会启动缓存淘汰机制，尝试清除一些数据。</li><li><code>appendonly no</code>：指定是否在每次更新操作后进行日志记录，Redis默认情况下是异步的把数据写入磁盘，如不开启，可能会在断电时导致数据丢失。</li><li><code>appendfilename appendonly.aof</code>：指定更新日志文件名称。</li><li><code>appendfsync everysec</code>：指定更新日志条件，三个可选值。<ol><li><code>no</code>：表示等操作系统进行数据缓存同步到磁盘（快）</li><li><code>always</code>：表示每次更新操作后手动调用<code>fsync()</code>将数据写到磁盘（慢，安全）</li><li><code>everysec</code>：表示每秒同步一次（折中，默认值）</li></ol></li><li><code>vm-enabled no</code>：指定是否启动虚拟内容机制，默认no；VM机制将数据分页存放，由Redis将访问量较少的页（即冷数据）swap到磁盘上，访问多的页面由磁盘自动换出到内存中</li><li><code>vm-swap-fiel /tmp/redis.swap</code>：虚拟内存文件存储路径，默认值为<code>/tmp/redis.swap</code>，不可与多个Redis实例共享。</li><li><code>vm-max-memory 0</code>：将所有大于<code>vm-max-memory</code>的数据存入虚拟内存，无论该参数设置多小，所有索引数据都是内存存储的（Redis的索引数据就是keys），也即当<code>vm-max-memory</code>设置为0时，其实是所有value都存于磁盘。</li><li><code>vm-page-size 32</code>：Redis swap文件分成了很多的page，一个对象可以保存在多个page上，但一个page不能被多个对象共享，该参数要根据存储的数据大小来设定，官方建议如果存储很多小对象，page大小最好设置为32或64bytes；如果存储大对象，则可以使用更大的page，如不确定就使用默认值即可。</li><li><code>vm-pages 134217728</code>：设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，在磁盘上每8个pages将消耗1byte的内存。</li><li><code>vm-max-threads 4</code>：设置访问swap文件的线程数，默认4；最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。</li><li><code>glueoutputbuf yes</code>：设置在向客户端应答时，是否把较小的包合并为一个包发送，默认开启。</li><li><code>hash-max-zipmap-entries 64</code>，<code>hash-max-zipmap-value 512</code>：指定在超过一定数量或最大元素超过某一临界值时，采用的一种特殊的哈希算法。</li><li><code>activerehasing yes</code>：设置是否激活重置哈希，默认开启</li><li><code>include /path/to/local.conf</code>：指定包含的其他配置文件的路径，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件。</li></ol><h2 id="2-Redis的持久化"><a href="#2-Redis的持久化" class="headerlink" title="2. Redis的持久化"></a>2. Redis的持久化</h2><p>由于Redis的数据都存放在内存中， 如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。Redis的持久化主要有RDB和AOF两种。</p><ul><li>RDB（Redis DataBase）： 将Reids在内存中的数据库记录定时dump到磁盘上；</li><li>AOF（Append Only File）： 将Reids的操作日志以追加的方式写入文件 </li></ul><h3 id="2-1-RDB"><a href="#2-1-RDB" class="headerlink" title="2.1 RDB"></a>2.1 RDB</h3><p>RDB是在指定的时间间隔内将内存中的数据集快照（Snapshot）写入磁盘。</p><h4 id="2-1-1-RDB具体过程"><a href="#2-1-1-RDB具体过程" class="headerlink" title="2.1.1 RDB具体过程"></a>2.1.1 RDB具体过程</h4><p>Redis会单独创建（Fork）一个子进程来进行持久化，将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程不会进行任何IO操作，如此便确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><blockquote><p>RDB保存的是<code>dump.rdb</code>文件</p></blockquote><h4 id="2-1-2-配置和触发RDB快照"><a href="#2-1-2-配置和触发RDB快照" class="headerlink" title="2.1.2 配置和触发RDB快照"></a>2.1.2 配置和触发RDB快照</h4><p>RDB配置位于Redis配置文件的<code>SNAPSHOTTING</code>配置区，配置<code>save &lt;seconds&gt; &lt;changes&gt;</code>参数，该参数根据给定秒数和给定写操作数量进行持久化操作，默认参数如下：</p><ul><li><code>save 900 1</code>：15分钟内改动一次就保存</li><li><code>save 300 10</code>：5分钟内改动10次就保存</li><li><code>save 60 10000</code>：1分钟内改动1万次就保存</li></ul><p>将save参数<code>save 300 10</code>改动为<code>save 120 10</code>，即2分钟内10次改动就持久化，然后重启服务，进入<code>redis-cli</code>，快速插入10条记录，然后exit；随后进入目录<code>/usr/local/bin</code>，等待2分钟到，刷新目录查看是否有<code>dump.rdb</code>文件，如果没有就查看配置文件是否配置成功，服务是否重启。现在使用<code>cp dump.rdb dump_bk.rdb</code>命令对文件进行备份，然后进入redis客户端，使用<code>flushall</code>清空数据，<code>shutdown</code>关闭服务器。然后重启服务器，发现数据并没有被恢复。原因是执行了<code>flushall</code>命令后，也会产生<code>dump.rdb</code>文件，但是该文件是空的，没有意义。接下来使用<code>cp dump_bk.rdb dump.rdb</code>，复制一份备份文件，重启服务，进入客户端就会发现，数据恢复成功了。</p><p>在客户端中也可以使用的RDB相关命令</p><ul><li><code>save</code>：马上执行一次RDB，将数据写入到磁盘</li><li><code>bgsave</code>：redis会后台异步进行快照操作，同时还可以相应客户端请求</li><li><code>lastsave</code>：查看最后一次成功执行的快照时间</li></ul><blockquote><p>注意：dump.rdb文件可能是根据redis启动路径来存放的，客户端中可通过<code>config get dir</code>获取redis工作路径。</p></blockquote><h4 id="2-1-3-RDB的优缺点"><a href="#2-1-3-RDB的优缺点" class="headerlink" title="2.1.3 RDB的优缺点"></a>2.1.3 RDB的优缺点</h4><ul><li>优点：<ul><li>RDB是一个非常紧凑的文件；</li><li>因为RDB保存文件时会fork一个子进程进行操作，因此不会影响父进程做IO操作，故最能发挥Redis的性能；</li><li>适合大规模的数据集恢复；</li><li>适用于对数据完整性和一致性要求不高的场景；</li></ul></li><li>缺点：<ul><li>数据丢失风险大：在一定间隔时间做一次备份，如果redis意外down掉的话，会丢失最后一次快照的所有修改；</li><li>Fork时，内存中的数据被克隆了一份，大概2倍的膨胀性需要考虑到。</li></ul></li></ul><blockquote><p>关于停止RDB，客户端中直接输入<code>config set save &quot;&quot;</code>即可，配置文件中将save参数配置为<code>save &quot;&quot;</code>，注释掉其他save也可。</p></blockquote><h3 id="2-2-AOF"><a href="#2-2-AOF" class="headerlink" title="2.2 AOF"></a>2.2 AOF</h3><p>AOF是<strong>以日志的形式来记录每个写操作</strong>，将Redis执行过的所有写指令记录下来（读操作不记录），只允许追加文件但不可用改写文件，Redis启动时会读取该文件重新构建数据；简单说redis重启时就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h4 id="2-2-1-AOF的配置"><a href="#2-2-1-AOF的配置" class="headerlink" title="2.2.1 AOF的配置"></a>2.2.1 AOF的配置</h4><p>AOF的配置位于Redis配置文件的APPEND ONLY MODE配置区，配置<code>appendonly</code>参数，默认关闭。默认保存文件是<code>appendonly.aof</code>，位于redis启动目录下。</p><h4 id="2-2-2-AOF的启动-修复-恢复"><a href="#2-2-2-AOF的启动-修复-恢复" class="headerlink" title="2.2.2 AOF的启动/修复/恢复"></a>2.2.2 AOF的启动/修复/恢复</h4><ul><li>启动</li></ul><p>开启AOF只需修改参数为<code>appendnoly yes</code>即可，然后启动redis，写入几条数据，刷新启动目录可以看到<code>appendonly.aof</code>文件，此时AOF已经将你的所有写操作备份了。</p><ul><li>恢复</li></ul><p>如果你现在执行<code>flushall</code>，在关闭服务，重启服务后发现数据并没有恢复，原因是AOF备份文件中将<code>flushall</code>命令也执行了一遍，打开aof文件，将<code>flushall</code>命令删除，重启服务即可恢复数据。</p><ul><li>修复</li></ul><p>那么如果AOF文件被损坏了怎么办呢？打开<code>appendonly.aof</code>文件，随便写入一点数据，以模拟一个aof文件损坏场景，重启服务会发现redis服务无法启动，也无法连接到服务器，说明redis服务器启动时会先加载aof文件，如果加载失败，服务不会启动。</p><p>这时就需要用到<code>redis-check-aof</code>工具，这是redis自带的一款AOF文件修复工具，会将所有不符合aof文件语法的数据全部清除，输入<code>redis-check-aof --fix appendonly.aof</code>对损坏的aof文件就行修复。</p><p><img src="http://yanxuan.nosdn.127.net/d49215ec0cc3869d6dd83b7e25df6fff.png" alt="aof"></p><p>再次重启服务器，发现服务器正常启动了，连接后数据也恢复了。</p><h4 id="2-2-3-Rewrite"><a href="#2-2-3-Rewrite" class="headerlink" title="2.2.3 Rewrite"></a>2.2.3 Rewrite</h4><p>AOF采用的文件追加方式，文件会越来越大，为避免出现此种情况，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可使用命令<code>bgrewriteaof</code>手动启动。</p><ul><li>重写机制的原理</li></ul><p>AOF文件持续增长且文件过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有些类似。</p><ul><li>触发机制</li></ul><p>Redis会记录上次重写时的AOF文件大小，默认配置是当AOF文件大小为上次rewrite后大小的一倍且文件大于64MB时触发。</p><h4 id="2-2-4-AOF的优缺点"><a href="#2-2-4-AOF的优缺点" class="headerlink" title="2.2.4 AOF的优缺点"></a>2.2.4 AOF的优缺点</h4><ul><li>优点：<ul><li>秒级同步和修改同步极大的保证了数据的完整性</li><li>Redis可以在aof文件体积过大时，自动后台对aof进行重写</li></ul></li><li>缺点：<ul><li>相同数据集的数据来说，aof文件要远大于rdb文件，恢复速度也慢于rdb</li><li>aof的运行效率要慢于rdb，但每秒同步策略效率较好，不同步效率和rdb相同</li><li>aof文件有序地保存了对数据库执行的所有写操作，这些操作以Redis协议格式保存，因此aof文件内容非常容易被人读懂和修改。</li></ul></li></ul><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储；AOF持久化方式记录每次对服务器的写操作，当服务器重启时会重新执行这些命令来恢复原始数据，AOF命令以redis协议追加保存每次写操作到文件末尾。Redis还能对AOF文件进行重写保证其体积不过大。</p><p>如果只做缓存服务，即希望数据仅在服务器运行时存在，可以不使用任何持久化方式。</p><p>如果同时开启两种方式：这种情况下，当redis重启时会优先加载AOF文件来恢复原始数据，因为通常情况下AOF文件保存的数据集要比RDB文件保存的数据集完整。由于RDB数据集的不实时性，同时使用服务器重启时也只会找AOF文件，那么是否可以只使用AOF呢？官方建议不要这样，因为RDB更适合用于备份数据库（AOF不断变化不好备份），快速重启，且不会有AOF可能存在的bug，留一手以备后患。</p><h4 id="2-3-1-性能建议"><a href="#2-3-1-性能建议" class="headerlink" title="2.3.1 性能建议"></a>2.3.1 性能建议</h4><p>因为RDB文件仅做后备用途，建议只在Slave上持久化RDB文件，且只需15分钟备份一次足够了，即配置文件中仅保留<code>save 900 1</code>这条配置。</p><p>如果开启AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本简单只加载自己的AOF文件即可。代价是带来了持续的IO；其次AOF重写的最后将重写过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘允许，应该尽量减少AOF rewrite的频率，同时AOF重写的基础大小默认值64m太小了，可以设置到5G以上，默认超过原大小100%的设定也可改到适当的数值。</p><p>如果不开启AOF，仅靠主从复制实现高可用性也可以；这样能省下一大笔AOF的IO性能损耗同时也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时宕机，会丢失十几分钟数据，启动脚本也要比较两个Master/Slave中的RDB文件，加载较新的那个。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门</title>
      <link href="/DataBase/Redis-Introduction.html"/>
      <url>/DataBase/Redis-Introduction.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Redis入门概述"><a href="#1-Redis入门概述" class="headerlink" title="1. Redis入门概述"></a>1. Redis入门概述</h2><h3 id="1-1-是什么？"><a href="#1-1-是什么？" class="headerlink" title="1.1 是什么？"></a>1.1 是什么？</h3><p>Redis全称<code>Remote Dictionary Server</code>（远程字典服务器），是一款<strong>完全开源的用C语言编写的遵守BSD协议的高性能分布式内存数据库</strong>。基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为数据结构服务器。</p><p>Redis主要有以下三个特点：</p><ol><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启时可以再次加载进行使用；</li><li>Redis支持丰富的数据类型，不仅支持k-v类型数据，还提供list，set，zset，hash等数据结构的存储；</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ol><h3 id="1-2-能干嘛？"><a href="#1-2-能干嘛？" class="headerlink" title="1.2 能干嘛？"></a>1.2 能干嘛？</h3><ol><li>内存存储和持久化：Redis支持异步将内存中的数据写到硬盘中，同时不影响继续服务；</li><li>取最新数据：例如可以将最新的10条评论的ID放在Redis的List集合中；</li><li>模拟类似于HttpSession这种需要设定过期时间的功能；</li><li>发布、订阅消息系统；</li><li>定时器、计数器</li></ol><h3 id="1-3-怎么下？"><a href="#1-3-怎么下？" class="headerlink" title="1.3 怎么下？"></a>1.3 怎么下？</h3><p>中文官网<a href="http://www.redis.cn/download.html" target="_blank" rel="noopener">下载地址</a></p><h3 id="1-4-怎么用？"><a href="#1-4-怎么用？" class="headerlink" title="1.4 怎么用？"></a>1.4 怎么用？</h3><p>主要使用如下功能：</p><ul><li>数据类型、基本操作和配置</li><li>持久化和复制，RDB/AOF</li><li>事务的控制</li><li>主从复制</li><li>… …</li></ul><h3 id="1-5-Linux版安装"><a href="#1-5-Linux版安装" class="headerlink" title="1.5 Linux版安装"></a>1.5 Linux版安装</h3><ol><li><p>进入<code>/opt</code>目录，该目录是用户软件的安装目录。</p></li><li><p>获取Redis资源</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">   wget http:&#x2F;&#x2F;download.redis.io&#x2F;redis-stable.tar.gz</code></pre></li></ol><ol start="3"><li><p>解压</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">   tar -xzvf redis-stable.tar.gz</code></pre></li></ol><ol start="4"><li><p>进入解压后的文件夹</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">   cd redis-stable</code></pre></li></ol><ol start="5"><li><p>安装，正常步骤</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">   make   cd src   make install </code></pre></li></ol><ol start="6"><li><p>异常步骤：如果没有安装gcc环境，是无法使用<code>make</code>命令编译的，需安装gcc环境</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">   Ubuntu安装gcc   sudo apt install build-essential   CentOS安装gcc   yum install gcc-c++   验证gcc安装   gcc -v   make #再次make时如果提示没有那个文件或目录，运行make distclean清理一下文件夹   cd src   make install</code></pre></li></ol><blockquote><p>安装参考<a href="https://www.cnblogs.com/john-xiong/p/12098827.html" target="_blank" rel="noopener">文章</a></p></blockquote><ol start="7"><li><p>将配置文件备份</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">   cd &#x2F;opt&#x2F;redis-stable   mkdir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc # 配置文件存放位置   cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc # 复制到该文件夹中</code></pre></li></ol><ol start="8"><li><p>配置redis后台启动</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">   vi &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis.conf   输入i进入编辑模式   找到daemonize no   将其改为daemonize yes   输入ESC   组合键Shift和:   然后输入wq 回车</code></pre></li></ol><ol start="9"><li><p>开启远程访问：打开配置文件，注释70行的bind，将90行的<code>protected-mode</code>改为<code>no</code></p></li><li><p>重启redis</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">    # 查询redis的运行状态，找到pid    ps -ef|grep redis    root      5557     1  0 17:42 ?        00:00:00 redis-server 127.0.0.1:6380    # 将其kill掉，然后重启    kill 5557    redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis.conf    # 连接,我自定义了端口6380，默认6379    redis-cli -p 6380</code></pre></li></ol><h3 id="1-6-其他知识点"><a href="#1-6-其他知识点" class="headerlink" title="1.6 其他知识点"></a>1.6 其他知识点</h3><ul><li>Redis是单进程的，默认端口号6379；</li><li>Redis索引默认都是从0开始；</li><li><p>默认有16个数据库，初始使用0号库；</p></li><li><p><code>select</code>：切换数据库，例如<code>select 2</code>切换到3号库；</p></li><li><code>dbsize</code>：查看当前数据库的key数量；</li><li><code>flushdb</code>：清空当前数据库；</li><li><code>flushall</code>：清空全部数据库；</li></ul><h2 id="2-Redis数据类型"><a href="#2-Redis数据类型" class="headerlink" title="2. Redis数据类型"></a>2. Redis数据类型</h2><h3 id="2-1-Redis五大数据类型简介"><a href="#2-1-Redis五大数据类型简介" class="headerlink" title="2.1 Redis五大数据类型简介"></a>2.1 Redis五大数据类型简介</h3><h4 id="2-1-1-String（字符串）"><a href="#2-1-1-String（字符串）" class="headerlink" title="2.1.1 String（字符串）"></a>2.1.1 String（字符串）</h4><p>String是Redis最基本的类型，可以理解为与Memcached一模一样的类型，一个key对应一个value；String类型是二进制安全的，意思该类型可以包含任何数据，例如jpg图片或者序列化的对象；一个Redis中字符串value最大是512MB。</p><h4 id="2-1-2-Hash（哈希）"><a href="#2-1-2-Hash（哈希）" class="headerlink" title="2.1.2 Hash（哈希）"></a>2.1.2 Hash（哈希）</h4><p>哈希，类似Java中的<code>Map&lt;String,Object&gt;</code>；Redis中的hash是一个键值对集合，是String类型的field和value的映射表，特别适合用于存储对象。</p><h4 id="2-1-3-List（列表）"><a href="#2-1-3-List（列表）" class="headerlink" title="2.1.3 List（列表）"></a>2.1.3 List（列表）</h4><p>Redis列表时简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部或者尾部，底层其实是个链表。</p><h4 id="2-1-4-Set（集合）"><a href="#2-1-4-Set（集合）" class="headerlink" title="2.1.4 Set（集合）"></a>2.1.4 Set（集合）</h4><p>Redis的Set是String类型的无序集合，它是通过HashTable实现的，不允许重复。</p><h4 id="2-1-5-Zset（Sorted-Set有序集合）"><a href="#2-1-5-Zset（Sorted-Set有序集合）" class="headerlink" title="2.1.5 Zset（Sorted Set有序集合）"></a>2.1.5 Zset（Sorted Set有序集合）</h4><p>Redis的zset和set一样也是String类型元素的集合，且不允许重复；它与set不同的是每个元素都会关联一个double类型的分数，通过分数来为集合中的成员从小到大进行排序；zset的成员是唯一的，但分数却可以重复。</p><h4 id="2-1-6-Redis命令参考"><a href="#2-1-6-Redis命令参考" class="headerlink" title="2.1.6 Redis命令参考"></a>2.1.6 Redis命令参考</h4><p><a href="http://redisdoc.com/" target="_blank" rel="noopener">命令参考文档</a></p><h3 id="2-2-Redis键（key）"><a href="#2-2-Redis键（key）" class="headerlink" title="2.2 Redis键（key）"></a>2.2 Redis键（key）</h3><p>命令表，常用加粗：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:left">DEL key</td><td style="text-align:center">当key存在时删除key</td></tr><tr><td style="text-align:left">DUMP key</td><td style="text-align:center">序列化给定key，并返回被序列化的值</td></tr><tr><td style="text-align:left"><strong>EXISTS key</strong></td><td style="text-align:center">检查给定key是否存在</td></tr><tr><td style="text-align:left"><strong>EXPIPE key seconds</strong></td><td style="text-align:center">为给定key设置过期时间，单位秒</td></tr><tr><td style="text-align:left">EXPIREAT key timestamp</td><td style="text-align:center">为給定key设置过期时间，单位UNIX时间戳</td></tr><tr><td style="text-align:left">PEXPRRE key milliseconds</td><td style="text-align:center">设置key过期时间，单位毫秒</td></tr><tr><td style="text-align:left">PEXPIREAT key milliseconds-timestamp</td><td style="text-align:center">设置key过期时间的时间戳以毫秒计算</td></tr><tr><td style="text-align:left"><strong>KEYS pattern</strong></td><td style="text-align:center">查找所有符合给定模式（pattern）的key</td></tr><tr><td style="text-align:left"><strong>MOVE key db</strong></td><td style="text-align:center">将当前数据库的key移动到给定数据库db中</td></tr><tr><td style="text-align:left"><strong>PERSIST key</strong></td><td style="text-align:center">移除key的过期时间，key将持久保持</td></tr><tr><td style="text-align:left">PTTL key</td><td style="text-align:center">以毫秒为单位返回key的剩余过期时间</td></tr><tr><td style="text-align:left"><strong>TTL key</strong></td><td style="text-align:center">秒为单位返回key剩余过期时间，-1永不过期，-2已过期</td></tr><tr><td style="text-align:left">RANDOMKEY</td><td style="text-align:center">从当前数据库随机返回一个key</td></tr><tr><td style="text-align:left">RENAME key newkey</td><td style="text-align:center">修改key的名称</td></tr><tr><td style="text-align:left">RENAMENX key newkey</td><td style="text-align:center">仅当newkey不存在时，才会将key改名为newkey</td></tr><tr><td style="text-align:left">SCAN cursor [MATCH pattern] [COUNT count]</td><td style="text-align:center">迭代数据库中的数据库键</td></tr><tr><td style="text-align:left"><strong>TYPE key</strong></td><td style="text-align:center">返回key所存储的值的类型</td></tr></tbody></table><p><a href="https://www.runoob.com/redis/redis-keys.html" target="_blank" rel="noopener">Redis key常用命令表详见</a></p><h3 id="2-3-Redis字符串（String）"><a href="#2-3-Redis字符串（String）" class="headerlink" title="2.3 Redis字符串（String）"></a>2.3 Redis字符串（String）</h3><p>非常常用的一种数据类型，单值对应单value，命令表如下，常用加粗：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>SET key value</strong></td><td style="text-align:center">设置指定key的值</td></tr><tr><td style="text-align:left"><strong>GET key</strong></td><td style="text-align:center">获取指定key的值</td></tr><tr><td style="text-align:left">GETRANGE key start end</td><td style="text-align:center">返回key中字符串值的子字符</td></tr><tr><td style="text-align:left"><strong>GETSET key value</strong></td><td style="text-align:center">将给定key的值设为value，并返回key的旧值</td></tr><tr><td style="text-align:left"><strong>MGET key1 [key2… …]</strong></td><td style="text-align:center">获取一个或多个给定key的值</td></tr><tr><td style="text-align:left">SETBIT key offset value</td><td style="text-align:center">对key所存储的字符串值，设置或清除指定偏移量上的位</td></tr><tr><td style="text-align:left">GETBIT key offset</td><td style="text-align:center">对key所存储的字符串值，获取指定偏移量上的位</td></tr><tr><td style="text-align:left"><strong>SETEX key seconds value</strong></td><td style="text-align:center">将值 value 关联到 key ，并设置key的过期时间，单位秒</td></tr><tr><td style="text-align:left"><strong>SETNX key value</strong></td><td style="text-align:center">仅当key不存在时设置key的值</td></tr><tr><td style="text-align:left">SETRANGE key offset value</td><td style="text-align:center">从偏移量offset开始，用value参数覆写给定key存储的字符串值</td></tr><tr><td style="text-align:left"><strong>STRLEN key</strong></td><td style="text-align:center">返回key字符串值的长度</td></tr><tr><td style="text-align:left"><strong>MSET key value [key value …]</strong></td><td style="text-align:center">同时设置一个或多个k-v键值对</td></tr><tr><td style="text-align:left"><strong>MSETNX key value [key value …]</strong></td><td style="text-align:center">仅当key不存在时，创建多个k-v对</td></tr><tr><td style="text-align:left">PSETEX key milliseconds value</td><td style="text-align:center">创建k-v对，并设置key过期时间，单位毫秒</td></tr><tr><td style="text-align:left"><strong>INCR key</strong></td><td style="text-align:center">将key中存储的数字值+1</td></tr><tr><td style="text-align:left"><strong>INCRBY key increment</strong></td><td style="text-align:center">将key中存储的值加上给定增量值</td></tr><tr><td style="text-align:left"><strong>INCRBYFLOAT key increment</strong></td><td style="text-align:center">将key中存储的值加上给定浮点增量值</td></tr><tr><td style="text-align:left"><strong>DECR key</strong></td><td style="text-align:center">将key中存储的数值减一</td></tr><tr><td style="text-align:left"><strong>DECRBY key decrement</strong></td><td style="text-align:center">将key中存储的值减去给定减量值</td></tr><tr><td style="text-align:left"><strong>APPEND key value</strong></td><td style="text-align:center">如果key存在且是字符串，将指定value追加到key值末尾</td></tr></tbody></table><p><a href="https://www.runoob.com/redis/redis-strings.html" target="_blank" rel="noopener">命令表详见</a></p><h3 id="2-4-Redis列表（List）"><a href="#2-4-Redis列表（List）" class="headerlink" title="2.4 Redis列表（List）"></a>2.4 Redis列表（List）</h3><p>Redis列表是简单的字符串列表，单值对应多value，按照插入顺序排序；你可以添加一个元素到列表的头部（左边）或者尾部（右边）；一个列表最多可以包含 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。常用命令表如下：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>LPUSH key value1 [value2]</strong></td><td style="text-align:center">从列表左侧将一个或多个值插入</td></tr><tr><td style="text-align:left">LPUSHX key value</td><td style="text-align:center">将一个值插入到已存在的列表头部</td></tr><tr><td style="text-align:left">BLPOP key1 [key2] timeout</td><td style="text-align:center">移出列表第一个元素并返回，如果列表为空则阻塞等待到超时或可弹出元素为止</td></tr><tr><td style="text-align:left">BRPOP key1 [key2] timeout</td><td style="text-align:center">移出列表最后一个元素并返回，如果没有元素会阻塞等待到超时或发现可弹出元素为止</td></tr><tr><td style="text-align:left">BRPOPLPUSH source destination timeout</td><td style="text-align:center">从列表弹出一个值，将弹出的元素插入到另一列表中并返回它，没有元素会阻塞超时或发现有元素可弹出为止</td></tr><tr><td style="text-align:left"><strong>LINDEX key index</strong></td><td style="text-align:center">返回指定索引位置的元素，从列表头部开始索引为0</td></tr><tr><td style="text-align:left">[LINSERT key BEFORE\</td><td style="text-align:center">AFTER pivot value](<a href="https://www.runoob.com/redis/lists-linsert.html" target="_blank" rel="noopener">https://www.runoob.com/redis/lists-linsert.html</a>)</td><td>在列表的元素前或后插入元素</td></tr><tr><td style="text-align:left"><strong>LLEN key</strong></td><td style="text-align:center">获取列表长度</td></tr><tr><td style="text-align:left"><strong>LPOP key</strong></td><td style="text-align:center">移出并获取列表的第一个元素</td></tr><tr><td style="text-align:left"><strong>LRANGE key start end</strong></td><td style="text-align:center">获取列表指定范围的元素</td></tr><tr><td style="text-align:left"><strong>LREM key count vlaue</strong></td><td style="text-align:center">移除列表元素</td></tr><tr><td style="text-align:left"><strong>LSET key index value</strong></td><td style="text-align:center">通过索引设置列表元素的值</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-ltrim.html" target="_blank" rel="noopener">LTRIM key start stop</a></td><td style="text-align:center">对一个列表进行修剪（trim），就是让列表只<strong>保留指定区间内</strong>的元素，不在区间内的都删除</td></tr><tr><td style="text-align:left"><strong>RPOP key</strong></td><td style="text-align:center">移除列表最后一个元素并返回</td></tr><tr><td style="text-align:left"><strong>RPOPLPUSH source destination</strong></td><td style="text-align:center">移除列表最后一个元素，将其添加到另一个列表中并返回</td></tr><tr><td style="text-align:left"><strong>RPUSH key value1 [value2]</strong></td><td style="text-align:center">从右侧向列表中添加一个或多个值</td></tr><tr><td style="text-align:left">RPUSHX key value</td><td style="text-align:center">从右侧添加值</td></tr></tbody></table><p><a href="https://www.runoob.com/redis/redis-lists.html" target="_blank" rel="noopener">命令表详见</a></p><h3 id="2-5-Redis集合（Set）"><a href="#2-5-Redis集合（Set）" class="headerlink" title="2.5 Redis集合（Set）"></a>2.5 Redis集合（Set）</h3><p>Redis的Set是String类型的无序集合，不允许重复数据；集合是通过哈希表实现的，所以效率非常好，常用命令表如下：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>SADD key member1 [member2 …]</strong></td><td style="text-align:center">向集合添加一个或多个成员</td></tr><tr><td style="text-align:left"><strong>SCARD key</strong></td><td style="text-align:center">返回集合成员数量</td></tr><tr><td style="text-align:left"><strong>SDIFF key1 [key2]</strong></td><td style="text-align:center">返回差集</td></tr><tr><td style="text-align:left">SDIFFSTORE destination key1 [key2]</td><td style="text-align:center">将给定集合的差集存储到目的地中</td></tr><tr><td style="text-align:left"><strong>SINTER key1 [key2]</strong></td><td style="text-align:center">返回交集</td></tr><tr><td style="text-align:left">SINTERSTORE destination key1 [key2]</td><td style="text-align:center">将给定集合的交集存储到目的地中</td></tr><tr><td style="text-align:left"><strong>SISMEMBER key member</strong></td><td style="text-align:center">判断member是否是集合key的成员</td></tr><tr><td style="text-align:left"><strong>SMEMBERS key</strong></td><td style="text-align:center">返回集合中所有成员</td></tr><tr><td style="text-align:left"><strong>SMOVE source destination member</strong></td><td style="text-align:center">将member元素从source集合移到目的地集合</td></tr><tr><td style="text-align:left"><strong>SPOP key</strong></td><td style="text-align:center">随机移除一个元素并返回</td></tr><tr><td style="text-align:left"><strong>SRANDMEMBER key [count]</strong></td><td style="text-align:center">返回几个随机元素</td></tr><tr><td style="text-align:left"><strong>SREM key member1 [member2]</strong></td><td style="text-align:center">移除集合中一个或多个成员</td></tr><tr><td style="text-align:left"><strong>SUNION key1 [key2]</strong></td><td style="text-align:center">返回并集</td></tr><tr><td style="text-align:left">SUNIONSTORE destionation key1 [key2]</td><td style="text-align:center">返回并集放到目的地集合中</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/redis/sets-sscan.html" target="_blank" rel="noopener">SSCAN key cursor [MATCH pattern]  [COUNT count]</a></td><td style="text-align:center">迭代集合中的元素</td></tr></tbody></table><p><a href="https://www.runoob.com/redis/redis-sets.html" target="_blank" rel="noopener">命令表详见</a></p><h3 id="2-6-Redis哈希（Hash）"><a href="#2-6-Redis哈希（Hash）" class="headerlink" title="2.6 Redis哈希（Hash）"></a>2.6 Redis哈希（Hash）</h3><p>Redis hash是一个string类型的field和value的映射表，特别适合用于存储对象，常见命令如下：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>HSET key field value</strong></td><td style="text-align:center">将哈希表key中的字段field的值设为value</td></tr><tr><td style="text-align:left"><strong>HMSET key field1 value1 [field2 value2]</strong></td><td style="text-align:center">同时设置多个field-value到哈希表key中</td></tr><tr><td style="text-align:left"><strong>HDEL key field1 [field2]</strong></td><td style="text-align:center">删除一个或多个字段</td></tr><tr><td style="text-align:left"><strong>HEXISTS key field</strong></td><td style="text-align:center">查看指定字段是否存在于哈希表中</td></tr><tr><td style="text-align:left"><strong>HGET key field</strong></td><td style="text-align:center">获取存储在哈希表中指定字段的值</td></tr><tr><td style="text-align:left"><strong>HGETALL key</strong></td><td style="text-align:center">获取哈希表中所有字段和值</td></tr><tr><td style="text-align:left"><strong>HINCRBY key field increment</strong></td><td style="text-align:center">为指定字段的值加上指定整数增量值</td></tr><tr><td style="text-align:left"><strong>HINCRBYFLOAT key field increment</strong></td><td style="text-align:center">为指定字段的值加上指定浮点增量值</td></tr><tr><td style="text-align:left"><strong>HKEYS key</strong></td><td style="text-align:center">获取哈希表中所有字段</td></tr><tr><td style="text-align:left"><strong>HLEN key</strong></td><td style="text-align:center">获取哈希表中字段的数量</td></tr><tr><td style="text-align:left"><strong>HMGET key field [field2]</strong></td><td style="text-align:center">获取所有给定字段的值</td></tr><tr><td style="text-align:left"><strong>HSETNX key field value</strong></td><td style="text-align:center">仅当字段field不存在时，设置字段的值</td></tr><tr><td style="text-align:left"><strong>HVALS key</strong></td><td style="text-align:center">获取哈希表中所有值</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hscan.html" target="_blank" rel="noopener">HSCAN key cursor [MATCH pattern] [COUNT count]</a></td><td style="text-align:center">迭代哈希表中的键值对</td></tr></tbody></table><p><a href="https://www.runoob.com/redis/redis-hashes.html" target="_blank" rel="noopener">命令表详见</a></p><h3 id="2-7-Redis有序集合Zset（sorted-set）"><a href="#2-7-Redis有序集合Zset（sorted-set）" class="headerlink" title="2.7 Redis有序集合Zset（sorted set）"></a>2.7 Redis有序集合Zset（sorted set）</h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序；有序集合的成员是唯一的,但分数(score)却可以重复；常用命令如下：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>ZADD key score1 member1 [score2 member2]</strong></td><td style="text-align:center">添加一个或多个成员，或更新已存在成员的分数</td></tr><tr><td style="text-align:left"><strong>ZCARD key</strong></td><td style="text-align:center">获取有序集合的成员数</td></tr><tr><td style="text-align:left"><strong>ZCOUNT key min max</strong></td><td style="text-align:center">计算集合中指定区间分数的成员数量</td></tr><tr><td style="text-align:left">ZINCRBY key increment member</td><td style="text-align:center">对集合中指定成员的分数加上增量值</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html" target="_blank" rel="noopener">ZINTERSTORE destination numkeys key [key …]</a></td><td style="text-align:center">计算多个集合的交集并将结果存储到新集合中</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html" target="_blank" rel="noopener">ZLEXCOUNT key min max</a></td><td style="text-align:center">返回指定字典区间内的成员数量</td></tr><tr><td style="text-align:left"><strong>ZRANGE key start stop [WITHSCORES]</strong></td><td style="text-align:center">返回指定索引区间内的成员</td></tr><tr><td style="text-align:left">ZRANGEBYLEX key min max [LIMIT offset count]</td><td style="text-align:center">返回指定字典区间内的成员</td></tr><tr><td style="text-align:left"><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</strong></td><td style="text-align:center">返回指定分数区间内的成员</td></tr><tr><td style="text-align:left"><strong>ZRANK key member</strong></td><td style="text-align:center">返回集合中指定成员的索引</td></tr><tr><td style="text-align:left"><strong>ZREM key member [member …]</strong></td><td style="text-align:center">移除集合中一个或多个成员</td></tr><tr><td style="text-align:left">ZREMRANGEBYLEX key min max</td><td style="text-align:center">移除指定<strong>字典区间</strong>的所有成员</td></tr><tr><td style="text-align:left">ZREMRANGEBYRANK key start stop</td><td style="text-align:center">移除指定<strong>索引区间</strong>的所有成员</td></tr><tr><td style="text-align:left">ZREMRANGEBYSCORE key min max</td><td style="text-align:center">移除指定<strong>分数区间</strong>的所有成员</td></tr><tr><td style="text-align:left"><strong>ZREVRANGE key start stop [WITHSCORES]</strong></td><td style="text-align:center">返回集合中指定<strong>索引区间</strong>内的成员，分数降序</td></tr><tr><td style="text-align:left"><strong>ZREVRANGEBYSCORE key max min [WITHSCORES]</strong></td><td style="text-align:center">返回集合中指定<strong>分数区间</strong>内的成员，分数降序</td></tr><tr><td style="text-align:left"><strong>ZREVRANK key member</strong></td><td style="text-align:center">按照分数降序排序，返回集合中指定成员的索引</td></tr><tr><td style="text-align:left"><strong>ZSCORE key member</strong></td><td style="text-align:center">返回指定成员的分数值</td></tr><tr><td style="text-align:left">ZUNIONSTORE destination numbers key [key …]</td><td style="text-align:center">计算并集，存储在新集合中</td></tr><tr><td style="text-align:left">ZSCAN key cursor [MATCH pattern] [COUNT count]</td><td style="text-align:center">迭代有序集合中的元素，包括分数</td></tr></tbody></table><p><a href="https://www.runoob.com/redis/redis-sorted-sets.html" target="_blank" rel="noopener">命令表详见</a></p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL概述</title>
      <link href="/DataBase/NoSQL-sum.html"/>
      <url>/DataBase/NoSQL-sum.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-NoSQL入门概述"><a href="#1-NoSQL入门概述" class="headerlink" title="1. NoSQL入门概述"></a>1. NoSQL入门概述</h2><h3 id="1-1-NoSQL数据库的发展历程"><a href="#1-1-NoSQL数据库的发展历程" class="headerlink" title="1.1 NoSQL数据库的发展历程"></a>1.1 NoSQL数据库的发展历程</h3><p>互联网时代背景下，也并非直接出现NoSQL数据库的，而是经过了一些演变过程，随着数据量的不断增大，诞生了许多的技术。</p><h4 id="1-1-1-单机MySQL的时代"><a href="#1-1-1-单机MySQL的时代" class="headerlink" title="1.1.1 单机MySQL的时代"></a>1.1.1 单机MySQL的时代</h4><p>90年代，大部分网站访问量都不大，且使用的都是静态页面，用单个数据库完全可以轻松应付；架构一般为：<code>App--&gt;DAL--&gt;单MySQL实例</code>。</p><p>上述架构下，数据库的瓶颈如下：</p><ol><li>数据量的总大小太大，一台机器放不下时；</li><li>数据的索引一个机器内存放不下时；</li><li>访问量（读写混合）太大一个实例无法承受时。</li></ol><p>当发生上述1个以上情况时，就需要升级。</p><blockquote><p>DAL（Data Access Layer）：数据访问层的缩写，主要功能是负责数据库的访问。</p></blockquote><h4 id="1-1-2-Memcached（缓存）-MySQL-垂直拆分"><a href="#1-1-2-Memcached（缓存）-MySQL-垂直拆分" class="headerlink" title="1.1.2 Memcached（缓存）+MySQL+垂直拆分"></a>1.1.2 Memcached（缓存）+MySQL+垂直拆分</h4><p>随着访问量的上升，大部分使用单MySQL架构的网站在数据库上开始出现了性能问题，Web程序不再仅仅专注于功能上，同时也开始追求性能。程序员开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库压力，但是随着访问量的持续增大时，多台web服务器之间文件缓存不能共享，大量的小文件缓存也带来的较高的IO压力，这时，<code>Memcached</code>就自然的成为了当时非常流行的技术产品。</p><p><img src="http://yanxuan.nosdn.127.net/4fa632a4e2e08b1c2adf14dc9d6d5fdc.png" alt="cached"></p><p>Memcached作为一个独立的分布式缓存服务器，可以为多台Web服务器提供一个共享的高性能缓存服务，在Memcached服务器上，又发展出了根据hash算法来进行多台Memcached缓存服务的扩展，随后又出现了一致性hash来解决增加或减少缓存服务器导致重新hash带来的大量缓存失效的弊端。</p><h4 id="1-1-3-MySQL主从复制读写分离"><a href="#1-1-3-MySQL主从复制读写分离" class="headerlink" title="1.1.3 MySQL主从复制读写分离"></a>1.1.3 MySQL主从复制读写分离</h4><p>随着数据库的写入压力增加，Memcached只能缓解数据库的读取压力，当读写集中在一个数据库上时会导致数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。MySQL的master-slave模式成为主流。</p><p><img src="http://yanxuan.nosdn.127.net/57c167d1d61511cf553a31025b938c80.png" alt="ms"></p><h4 id="1-1-4-分库分表-水平拆分-MySQL集群"><a href="#1-1-4-分库分表-水平拆分-MySQL集群" class="headerlink" title="1.1.4 分库分表+水平拆分+MySQL集群"></a>1.1.4 分库分表+水平拆分+MySQL集群</h4><p>在Memcached的高速缓存，MySQL的主从复制，读写分离技术的基础上，这时的MySQL主库的写压力开始出现瓶颈，而当数据量的持续猛增，由于MyISAM使用表锁，在高并发下就会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎替代MyISAM。</p><p>同时，也开始流行使用分库分表来缓解写压力和数据增长的扩展问题，此时，分库分表成为了一个热门技术，是面试的热门问题也是业界讨论的热门技术点。就在这时，MySQL推出了还不太稳定的表分区技术，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能不足以满足互联网的需求，只是在高可靠性上提供了非常大的保证。</p><p><img src="http://yanxuan.nosdn.127.net/a80781a522296ae7090602feb72aaf79.png" alt="分库分表"></p><h4 id="1-1-5-MySQL的扩展性瓶颈"><a href="#1-1-5-MySQL的扩展性瓶颈" class="headerlink" title="1.1.5 MySQL的扩展性瓶颈"></a>1.1.5 MySQL的扩展性瓶颈</h4><p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常大，在做数据库恢复时就会导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL中省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</p><h4 id="1-1-6-为什么使用NoSQL？"><a href="#1-1-6-为什么使用NoSQL？" class="headerlink" title="1.1.6 为什么使用NoSQL？"></a>1.1.6 为什么使用NoSQL？</h4><p>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。</p><h3 id="1-2-是什么？"><a href="#1-2-是什么？" class="headerlink" title="1.2 是什么？"></a>1.2 是什么？</h3><p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”。</p><p>泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。<strong>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战</strong>，尤其是大数据应用难题，包括<strong>超大规模数据的存储。</strong></p><p>（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p><h3 id="1-3-能干嘛？"><a href="#1-3-能干嘛？" class="headerlink" title="1.3 能干嘛？"></a>1.3 能干嘛？</h3><h4 id="1-3-1-易扩展性"><a href="#1-3-1-易扩展性" class="headerlink" title="1.3.1 易扩展性"></a>1.3.1 易扩展性</h4><p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p><h4 id="1-3-2-大数据量高性能"><a href="#1-3-2-大数据量高性能" class="headerlink" title="1.3.2 大数据量高性能"></a>1.3.2 大数据量高性能</h4><p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。</p><h4 id="1-3-3-灵活多样的数据模型"><a href="#1-3-3-灵活多样的数据模型" class="headerlink" title="1.3.3 灵活多样的数据模型"></a>1.3.3 灵活多样的数据模型</h4><p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。</p><h4 id="1-3-4-传统RDBMS-VS-NoSQL"><a href="#1-3-4-传统RDBMS-VS-NoSQL" class="headerlink" title="1.3.4 传统RDBMS VS NoSQL"></a>1.3.4 传统RDBMS VS NoSQL</h4><blockquote><p>RDBMS： 关系数据库管理系统（ Relational Database Management System ）简称RDBMS。</p></blockquote><ul><li>RDBMS<ul><li>高度组织化结构化数据；</li><li>结构化查询语言（SQL）；</li><li>数据和关系都存储在单独的表中；</li><li>数据操作语言，数据定义语言；</li><li>严格的一致性；</li><li>基础事务。</li></ul></li><li>NoSQL<ul><li>代表不仅仅是SQL；</li><li>没有声明性查询语言；</li><li>没有预定义的模式；</li><li>键值对存储，列存储，文档存储，图形数据库;</li><li>最终一致性，而非ACID属性；</li><li>非结构化和不可预知的数据；</li><li>CAP定理；</li><li>高性能，高可用性和可伸缩性。</li></ul></li></ul><h3 id="1-4-如何下？"><a href="#1-4-如何下？" class="headerlink" title="1.4 如何下？"></a>1.4 如何下？</h3><ul><li>Redis<a href="https://redis.io/download" target="_blank" rel="noopener">下载地址</a></li><li>MemCached<a href="https://memcached.org/downloads" target="_blank" rel="noopener">下载地址</a></li><li>MongDB<a href="https://www.mongodb.com/try/download/community" target="_blank" rel="noopener">下载地址</a></li></ul><h2 id="2-3V和3高"><a href="#2-3V和3高" class="headerlink" title="2. 3V和3高"></a>2. 3V和3高</h2><ul><li>大数据时代的3V<ul><li>海量（Volume）</li><li>多样（Variety）</li><li>实时（Velocity）</li></ul></li><li>互联网需求的3高<ul><li>高并发</li><li>高性能</li><li>高可扩</li></ul></li></ul><h3 id="2-1-NoSQL数据模型"><a href="#2-1-NoSQL数据模型" class="headerlink" title="2.1 NoSQL数据模型"></a>2.1 NoSQL数据模型</h3><p>NoSQL的聚合模型可以使用KV键值，Bson，列簇，图形等方式。</p><p>BSON是一种类似JSON的二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-json">{    &quot;customer&quot;:{        &quot;id&quot;:1136,        &quot;name&quot;:&quot;Z3&quot;,        &quot;billingAddress&quot;:[{&quot;city&quot;:&quot;beijing&quot;}],        &quot;orders&quot;:[            {                &quot;id&quot;:17,                &quot;customerId&quot;:1136,                &quot;orderItems&quot;:  [{&quot;productId&quot;:27,&quot;price&quot;:77.5,&quot;productName&quot;:&quot;thinking in java&quot;}],                &quot;shippingAddress&quot;:[{&quot;city&quot;:&quot;beijing&quot;}]                &quot;orderPayment&quot;:[{&quot;ccinfo&quot;:&quot;111-222-333&quot;,&quot;txnid&quot;:&quot;asdfadcd334&quot;,&quot;billingAddress&quot;:{&quot;city&quot;:&quot;beijing&quot;}}],            }            ]}</code></pre><h2 id="3-NoSQL数据库的四大分类"><a href="#3-NoSQL数据库的四大分类" class="headerlink" title="3. NoSQL数据库的四大分类"></a>3. NoSQL数据库的四大分类</h2><h3 id="3-1-KV键值"><a href="#3-1-KV键值" class="headerlink" title="3.1 KV键值"></a>3.1 KV键值</h3><ul><li>新浪：BerkeleyDB+Redis</li><li>美团：Redis+Tair</li><li>阿里、百度：Memcached+Redis</li></ul><h3 id="3-2-文档型数据库"><a href="#3-2-文档型数据库" class="headerlink" title="3.2 文档型数据库"></a>3.2 文档型数据库</h3><p>使用Bson格式的较多，例如CouchDB和MongoDB。</p><blockquote><p>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为Web应用提供可扩展的高性能数据存储解决方案；它是一款介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p></blockquote><h3 id="3-3-列存储数据库"><a href="#3-3-列存储数据库" class="headerlink" title="3.3 列存储数据库"></a>3.3 列存储数据库</h3><p>Cassandra，HBase，分布式文件系统。</p><h3 id="3-4-图关系数据库"><a href="#3-4-图关系数据库" class="headerlink" title="3.4 图关系数据库"></a>3.4 图关系数据库</h3><p>存放关系网络，例如：朋友圈社交网络，广告推荐系统等，专注于构建关系图谱。相关数据库有Neo4J，InfoGrid等。</p><h3 id="3-5-四者对比"><a href="#3-5-四者对比" class="headerlink" title="3.5 四者对比"></a>3.5 四者对比</h3><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">举例</th><th style="text-align:center">应用场景</th><th style="text-align:center">数据模型</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">键值</td><td style="text-align:center">Tokyo、Redis、Oracle BDB</td><td style="text-align:center">内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等。</td><td style="text-align:center">Key指向Value的键值对，通常用hashTable来实现</td><td style="text-align:center">查找速度快</td><td style="text-align:center">数据无结构化，通常只被当做字符串或二进制数据</td></tr><tr><td style="text-align:center">列存储数据库</td><td style="text-align:center">Cassandra、HBase、Riak</td><td style="text-align:center">分布式文件系统</td><td style="text-align:center">以列簇式存储，将同一列数据存在一起</td><td style="text-align:center">查找速度快，可扩展性强，更容易进行分布式扩展</td><td style="text-align:center">功能相对局限</td></tr><tr><td style="text-align:center">文档型数据库</td><td style="text-align:center">CouchDB、MongoDB</td><td style="text-align:center">Web应用（与键值对类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td><td style="text-align:center">key对应值，Value为结构化数据</td><td style="text-align:center">数据结构要求不严格，表结构可变，无需像关系型数据库一样需要预先定义表结构</td><td style="text-align:center">查询性能不高，且缺乏统一的查询语法</td></tr><tr><td style="text-align:center">图形数据库</td><td style="text-align:center">Neo4J、InfoGird、Infinite Graph</td><td style="text-align:center">社交网络，推荐系统等，专注于构建关系图谱</td><td style="text-align:center">图结构</td><td style="text-align:center">利用图结构相关算法，比如最短路径寻址，N度关系查找等</td><td style="text-align:center">很多时候需要对整个图做计算才能得出需要的信息，且这种结构不太好做分布式集群方案</td></tr></tbody></table><h2 id="4-分布式数据库中CAP原理"><a href="#4-分布式数据库中CAP原理" class="headerlink" title="4. 分布式数据库中CAP原理"></a>4. 分布式数据库中CAP原理</h2><h3 id="4-1-传统的ACID"><a href="#4-1-传统的ACID" class="headerlink" title="4.1 传统的ACID"></a>4.1 传统的ACID</h3><p>关系型数据库遵循ACID原则，具有以下四个特性：</p><ul><li>A（Atomicity）原子性</li><li>C（Consistency）一致性</li><li>I（Isolation）隔离性</li><li>D（Durability）持久性</li></ul><h3 id="4-2-CAP"><a href="#4-2-CAP" class="headerlink" title="4.2 CAP"></a>4.2 CAP</h3><p> CAP原则又称CAP定理，指的是在一个分布式系统中的如下要素。</p><ul><li>C（Consistency）：强一致性</li><li>A（Availability）：高可用性</li><li>P（Partition tolerance）：分区容错性</li></ul><h4 id="4-2-1-CAP理论"><a href="#4-2-1-CAP理论" class="headerlink" title="4.2.1 CAP理论"></a>4.2.1 CAP理论</h4><p>CAP理论的核心是：<strong>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</strong></p><p>因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类：</p><ul><li>CA：单点集群，满足一致性，可用性的系统，通常可扩展性不太强；</li><li>CP：满足一致性和分区容错性的系统，通常性能不是特别高；</li><li>AP：满足可用性和分区容错性的系统，通常对一致性要求低一些。</li></ul><p><img src="http://yanxuan.nosdn.127.net/67ceeee9f63a18db2a0a9d745f8ab1bc.png" alt="CAP"></p><h4 id="4-2-2-CAP的3选2"><a href="#4-2-2-CAP的3选2" class="headerlink" title="4.2.2 CAP的3选2"></a>4.2.2 CAP的3选2</h4><p> CAP理论对应在<strong>分布式存储系统中</strong>，上面三个要素最多只能同时实现两点，不可能三者兼顾；考虑到当前网络硬件肯定会出现的延迟丢包等问题，所以<strong>分区容错性必须要实现</strong>。</p><p>接下来只能在<strong>C一致性和A可用性</strong>之间进行权衡，有如下选择：</p><ul><li>AP：大多数网站架构的选择</li><li>CP：Redis、MongoDB</li></ul><p>分布式架构系统中，大多web应用<strong>并不需要强一致性</strong>，因此牺牲C换取P，是目前分布式数据库产品的方向。</p><h4 id="4-2-3-BASE"><a href="#4-2-3-BASE" class="headerlink" title="4.2.3 BASE"></a>4.2.3 BASE</h4><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p><p>BASE是三个术语的缩写：</p><ul><li>基本可用（Basically Available）</li><li>软状态（Soft State）</li><li>最终一致性（Eventually consistent）</li></ul><p>BASE的基本思想就是通过让系统放松对某一时刻数据一致性的要求，来换取系统整体伸缩性和性能上的改观，就是上面的牺牲C换取AP。</p><p>其原因在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，想要获取这些指标，就必须采用另外一张方式，BASE就是解决这个问题的方法。</p><h3 id="4-3-分布式-集群"><a href="#4-3-分布式-集群" class="headerlink" title="4.3 分布式+集群"></a>4.3 分布式+集群</h3><p>分布式系统（distributed system）是由多台计算机和通信的软件组件通过计算机网络连接（局域网或广域网）组成，分布式系统是建立在网络之上的软件系统；正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统）而不是硬件。分布式系统可以应用在不同的平台上如：PC、工作站、局域网和广域网上等等。</p><p>简单来说：</p><ol><li>分布式：不同的多台服务器上面部署<strong>不同的服务模块</strong>（工程），他们之间通过RPC/PMI通信和调用，对外提供服务和组内协作。</li><li>集群：不同的多台服务器上面部署<strong>相同的服务模块</strong>，通过分布式调度软件进行统一的调度，对外提供服务和访问。</li></ol>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/JavaAdvanced/ThreadPool.html"/>
      <url>/JavaAdvanced/ThreadPool.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><p>线程池的工作就是控制运行的线程数量，处理过程中<strong>将任务放入队列</strong>，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，<strong>超出数量的线程排队等候</strong>，等其他线程执行完毕，再从队列中取出任务来执行。</p><blockquote><p>线程池的主要特点：<font color="red">线程复用；控制并发；线程管理</font></p></blockquote><a id="more"></a><p>优势有以下几点：</p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以无需等待线程创建就能立即执行。</li><li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源。还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><h3 id="1-1-架构图"><a href="#1-1-架构图" class="headerlink" title="1.1 架构图"></a>1.1 架构图</h3><p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。</p><p><img src="http://yanxuan.nosdn.127.net/07c019a277d2d2fdd1fe7eef67fdac6d.png" alt="线程池"></p><h3 id="1-2-线程池三大方法"><a href="#1-2-线程池三大方法" class="headerlink" title="1.2 线程池三大方法"></a>1.2 线程池三大方法</h3><h4 id="1-2-1-固定线程池"><a href="#1-2-1-固定线程池" class="headerlink" title="1.2.1 固定线程池"></a>1.2.1 固定线程池</h4><p>通过<code>Executors.newFixedThreadPool(int)</code>创建一个指定线程数量的线程池，执行长期任务性能好。</p><ul><li>代码示例：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 一池子5个工作线程，类似一个银行有5个受理窗口ExecutorService threadPool = Executors.newFixedThreadPool(5);try{    &#x2F;&#x2F; 模拟有10个顾客来银行办理业务，目前池子里有5个工作人员提供服务    for (int i = 1; i &lt;= 10; i++) {        int finalI = i;        threadPool.execute(()-&gt; System.out.println(Thread.currentThread().getName()+&quot;\t 办理业务&quot;+ finalI));    }            }catch(Exception e){    e.printStackTrace();}finally{    threadPool.shutdown();}</code></pre><ul><li>底层代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}</code></pre><p><code>newFixedThreadPool</code>创建的线程池<code>corePoolSize</code>和<code>maximumPoolSize</code>值是相等的，它使用的是<code>LinkedBlockingQueue</code>。</p><h4 id="1-2-2-单一线程池"><a href="#1-2-2-单一线程池" class="headerlink" title="1.2.2 单一线程池"></a>1.2.2 单一线程池</h4><p>通过<code>Executors.newSingleThreadExecutor()</code>来创建一个单一线程的线程池，一个任务一个任务的执行。</p><ul><li>代码示例：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 一池1个工作线程，类似一个银行有1个受理窗口ExecutorService threadPool = Executors.newSingleThreadExecutor();try{    &#x2F;&#x2F; 10个顾客来银行，只有一个窗口开放    for (int i = 1; i &lt;= 10; i++) {        int finalI = i;        threadPool.execute(()-&gt; System.out.println(Thread.currentThread().getName()+&quot;\t 办理业务&quot;+ finalI));    }            }catch(Exception e){    e.printStackTrace();}finally{    threadPool.shutdown();}</code></pre><ul><li>底层代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static ExecutorService newSingleThreadExecutor() {    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));}</code></pre><p><code>newSingleThreadExecutor</code>创建的线程池<code>corePoolSize</code>和<code>maximumPoolSize</code>值都是1，它使用的也是<code>LinkedBlockingQueue</code></p><h4 id="1-2-3-自动扩容线程池"><a href="#1-2-3-自动扩容线程池" class="headerlink" title="1.2.3 自动扩容线程池"></a>1.2.3 自动扩容线程池</h4><p>通过<code>Executors.newCachedThreadPool();</code>创建一个可自动扩容的线程池，适合执行很多短期异步任务，线程池会根据需求创建新线程。</p><ul><li>代码示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 该线程池会根据线程执行时间，自动扩容ExecutorService threadPool = Executors.newCachedThreadPool();try{    &#x2F;&#x2F; 模拟有10个顾客来银行办理业务    for (int i = 1; i &lt;= 10; i++) {        TimeUnit.SECONDS.sleep(1);        int finalI = i;        threadPool.execute(()-&gt; System.out.println(Thread.currentThread().getName()+&quot;\t 办理业务&quot;+ finalI));    }            }catch(Exception e){    e.printStackTrace();}finally{    threadPool.shutdown();}</code></pre><ul><li>底层代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}</code></pre><p><code>newCachedThreadPool</code>创建的线程池将<code>corePoolSize</code>设置为0，将<code>maximumPoolSize</code>设置为<code>Integer.MAX_VALUE</code>，它使用的是<code>SynchronousQueue</code>；当来任务时就创建线程运行，当线程空闲超过60秒，就销毁线程。</p><h3 id="1-3-线程池七大参数"><a href="#1-3-线程池七大参数" class="headerlink" title="1.3 线程池七大参数"></a>1.3 线程池七大参数</h3><p>线程池全部共有7个参数，下面将会详解这些参数</p><ul><li>源码如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) {    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;}</code></pre><h4 id="1-3-1-corePoolSize"><a href="#1-3-1-corePoolSize" class="headerlink" title="1.3.1 corePoolSize"></a>1.3.1 corePoolSize</h4><p>表示线程池中的常驻<strong>核心线程数</strong></p><h4 id="1-3-1-maximumPoolSize"><a href="#1-3-1-maximumPoolSize" class="headerlink" title="1.3.1 maximumPoolSize"></a>1.3.1 maximumPoolSize</h4><p>表示线程池中能够容纳同时执行的<strong>最大线程数</strong>，此值必须大于等于1</p><h4 id="1-3-1-keepAliveTime"><a href="#1-3-1-keepAliveTime" class="headerlink" title="1.3.1 keepAliveTime"></a>1.3.1 keepAliveTime</h4><p>多余的<strong>空闲线程的存活时间</strong>；就是当线程池中线程数量超过常驻核心线程数时，同时这些线程处于空闲状态，当空闲时间达到keepAliveTime时，多余的线程就会被销毁直到剩下常驻核心线程数量。</p><h4 id="1-3-1-unit"><a href="#1-3-1-unit" class="headerlink" title="1.3.1 unit"></a>1.3.1 unit</h4><p>keepAliveTime的<strong>时间单位</strong>。</p><h4 id="1-3-1-workQueue"><a href="#1-3-1-workQueue" class="headerlink" title="1.3.1 workQueue"></a>1.3.1 workQueue</h4><p><strong>任务队列</strong>，用于存放已提交但尚未被执行的任务。</p><h4 id="1-3-1-threadFactory"><a href="#1-3-1-threadFactory" class="headerlink" title="1.3.1 threadFactory"></a>1.3.1 threadFactory</h4><p>用于生产创建线程池中工作线程的<strong>线程工厂</strong>，一般默认即可。</p><h4 id="1-3-1-handler"><a href="#1-3-1-handler" class="headerlink" title="1.3.1 handler"></a>1.3.1 handler</h4><p>一个<strong>拒绝策略</strong>，表示当任务队列满了，并且工作线程已经大于等于线程池中最大线程数时，应该如果来拒绝后续请求执行的runnable的策略。</p><h3 id="1-4-线程池底层工作原理"><a href="#1-4-线程池底层工作原理" class="headerlink" title="1.4 线程池底层工作原理"></a>1.4 线程池底层工作原理</h3><ul><li>线程池工作流程图如下：</li></ul><p><img src="https://s1.ax1x.com/2020/07/21/U5KXAx.png" alt="线程池工作原理"></p><h3 id="1-5-线程池使用细节"><a href="#1-5-线程池使用细节" class="headerlink" title="1.5 线程池使用细节"></a>1.5 线程池使用细节</h3><ul><li>一般生产环境中都是自定义线程池，禁止使用<code>Executors</code>来创建线程池！</li></ul><p><img src="http://yanxuan.nosdn.127.net/403c569e4bb66c8609a79f608024c525.png" alt="from 阿里Java开发手册"></p><ul><li>CPU密集型线程任务，最大线程数<code>maximumPoolSize</code>一般定义为<strong>CPU核心数+1</strong>，Java中代码获取CPU核心数：<code>Runtime.getRuntime().availableProcessors()</code></li><li>自定义线程池代码示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">ExecutorService threadPool = new ThreadPoolExecutor(    2,    Runtime.getRuntime().availableProcessors(),    2,TimeUnit.SECONDS,    new LinkedBlockingQueue&lt;Runnable&gt;(3),    new ThreadPoolExecutor.AbortPolicy());</code></pre><h3 id="1-6-线程池的拒绝策略"><a href="#1-6-线程池的拒绝策略" class="headerlink" title="1.6 线程池的拒绝策略"></a>1.6 线程池的拒绝策略</h3><p>自定义线程池时，可以选择使用<code>ThreadPoolExecutor</code>内置的拒绝策略，有如下四种：</p><ol><li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li><li>CallerRunsPolicy：“调用者运行”的一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。</li><li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</li></ol><blockquote><p>以上内置拒绝策略均实现了<code>RejectedExecutionHandle</code>接口</p></blockquote><h2 id="2-Stream流式计算"><a href="#2-Stream流式计算" class="headerlink" title="2. Stream流式计算"></a>2. Stream流式计算</h2><p>Stream流式数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。</p><blockquote><p>集合讲的是数据，流讲的是计算！</p></blockquote><p>Stream流具有以下特点：</p><ol><li>不会存储元素；</li><li>不会改变源对象，相反会返回一个持有结果的新Stream；</li><li>延迟执行，意味着会等到需要结果时才执行。</li></ol><p>学习Stream流之前先复习下函数式接口。</p><h3 id="2-1-四大函数式接口"><a href="#2-1-四大函数式接口" class="headerlink" title="2.1 四大函数式接口"></a>2.1 四大函数式接口</h3><table><thead><tr><th>函数式接口</th><th style="text-align:center">参数类型</th><th style="text-align:center">返回类型</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td><code>Function&lt;T,R&gt;</code>函数型接口</td><td style="text-align:center">T</td><td style="text-align:center">R</td><td style="text-align:center">对类型为T的对象应用操作，返回结果为R类型的对象；包含方法：<code>R apply(T t);</code></td></tr><tr><td><code>Predicate&lt;T&gt;</code>断定型接口</td><td style="text-align:center">T</td><td style="text-align:center">boolean</td><td style="text-align:center">确定类型为T的对象是否满足某约束，并返回布尔值；包含方法：<code>boolean test(T t);</code></td></tr><tr><td><code>Consumer&lt;T&gt;</code>消费型接口</td><td style="text-align:center">T</td><td style="text-align:center">void</td><td style="text-align:center">对类型为T的对象应用操作，包含方法：<code>void accept(T t);</code></td></tr><tr><td><code>Supplier&lt;T&gt;</code>供给型接口</td><td style="text-align:center">无</td><td style="text-align:center">T</td><td style="text-align:center">返回类型为T的对象，包含方法：<code>T get();</code></td></tr></tbody></table><ol><li>函数型接口，操作T，返回R，方法apply</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 匿名内部类写法Function&lt;String,Integer&gt; function = new Function&lt;String, Integer&gt;() {    @Override    public Integer apply(String s) {        return s.length();    }};&#x2F;&#x2F; lambda写法Function&lt;String,Integer&gt; function = s -&gt; {return s.length();};System.out.println(function.apply(&quot;hello&quot;));</code></pre><ol start="2"><li>断定型接口，操作T，返回布尔，方法test</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() {    @Override    public boolean test(String s) {        return s.isEmpty();    }};Predicate&lt;String&gt; predicate = s -&gt; { return s.isEmpty(); };System.out.println(predicate.test(&quot;hello&quot;));</code></pre><ol start="3"><li>消费型接口，操作S，无返回，方法accept</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() {    @Override    public void accept(String s) {        System.out.println(s);    }};Consumer&lt;String&gt; consumer = s -&gt; { System.out.println(s); };consumer.accept(&quot;hello&quot;);</code></pre><ol start="4"><li>供给型接口，无输入，返回T，方法get</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {    @Override    public String get() {        return &quot;hello&quot;;    }};Supplier&lt;String&gt; supplier = () -&gt; {return &quot;hello&quot;;};System.out.println(supplier.get());</code></pre><h3 id="2-2-Stream流"><a href="#2-2-Stream流" class="headerlink" title="2.2 Stream流"></a>2.2 Stream流</h3><p>使用流的基本步骤如下：</p><ol><li>创建一个Stream：一个<strong>数据源</strong>，可以是数组、集合；</li><li>中间操作：一个中间操作，<strong>处理</strong>数据源数据；</li><li>终止操作：一个终止操作，<strong>执行</strong>中间操作链，产生结果。</li></ol><p>练习题：请按照给出数据，找出同时满足以下全部条件的用户：偶数ID且年龄大于24且用户名转为大写且用户名字母倒序，最后只输出一个用户名。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class StreamDemo {    public static void main(String[] args) {        User u1 = new User(11,&quot;a&quot;,23);        User u2 = new User(12,&quot;b&quot;,24);        User u3 = new User(13,&quot;c&quot;,22);        User u4 = new User(14,&quot;d&quot;,28);        User u5 = new User(16,&quot;e&quot;,26);        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);        Predicate&lt;User&gt; judgment = user -&gt; { return ((user.getId())%2==0 &amp;&amp; user.getAge() &gt; 24); };        list.stream()            .filter(user -&gt; { return (user.getId() % 2 == 0 &amp;&amp; user.getAge() &gt; 24);})            .map(user -&gt; {return user.getName().toUpperCase();})            .sorted((o1,o2)-&gt;{return o2.compareTo(o1);})            .limit(1)            .forEach(System.out::println);    }}</code></pre><h2 id="3-分支合并框架"><a href="#3-分支合并框架" class="headerlink" title="3. 分支合并框架"></a>3. 分支合并框架</h2><p><img src="http://yanxuan.nosdn.127.net/436984e29e8b6ae442516ccbcd9dd025.png" alt="分支合并框架"></p><p>分支合并的原理在于Fork将一个复杂任务进行拆分，拆分成多个小任务，Join将拆分任务的结果进行合并。</p><p>代码示例如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 这是一个递归任务,继承后可以实现递归(自己调自己)调用的任务class MyTask extends RecursiveTask&lt;Integer&gt;{    private static final Integer ADJUST_VALUE = 10;    private int begin;    private int end;    private int result;    public MyTask(int begin,int end){        this.begin = begin;        this.end = end;    }    @Override    protected Integer compute() {        &#x2F;&#x2F; 拆分为10个一组        if ((end-begin) &lt;= ADJUST_VALUE){            for (int i = begin; i &lt;= end; i++) {                result = result + i;            }        }else {            &#x2F;&#x2F; 获取中间值            int middle = (end + begin) &#x2F; 2;            &#x2F;&#x2F; 新建两个任务，分配任务需求，一人处理一半            MyTask task01 = new MyTask(begin,middle);            MyTask task02 = new MyTask(middle + 1,end);            &#x2F;&#x2F; 继续分支            task01.fork();            task02.fork();            &#x2F;&#x2F; 合并拆分任务的结果值返回            result = task01.join() + task02.join();        }        return result;    }}&#x2F;** * @Author: zero &lt;[email] 1490829140@qq.com&gt; * @Date: Create in 2020&#x2F;5&#x2F;15 9:42 * @Description: 分支合并框架 * *  ForkJoinPool *  ForkJoinTask *  RecursiveTask *&#x2F;public class ForkJoinDemo {    public static void main(String[] args) throws ExecutionException, InterruptedException {        &#x2F;&#x2F; 创建任务        MyTask myTask = new MyTask(0,100);        &#x2F;&#x2F; 创建连接池        ForkJoinPool threadPool = new ForkJoinPool();        &#x2F;&#x2F; 提交任务        ForkJoinTask&lt;Integer&gt; forkJoinTask = threadPool.submit(myTask);        &#x2F;&#x2F; 汇总结果并输出        System.out.println(forkJoinTask.get());        &#x2F;&#x2F; 关闭连接池        threadPool.shutdown();    }}</code></pre><h2 id="4-异步回调"><a href="#4-异步回调" class="headerlink" title="4. 异步回调"></a>4. 异步回调</h2><p>代码示例：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class CompletableFutureDemo {    public static void main(String[] args) throws ExecutionException, InterruptedException {        &#x2F;&#x2F; 异步调用，无返回值        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; System.out.println(Thread.currentThread().getName() + &quot;\t无返回&quot;));        completableFuture.get();        &#x2F;&#x2F;异步回调        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(()-&gt;{            System.out.println(Thread.currentThread().getName()+&quot;\t completableFuture2&quot;);            int i = 10&#x2F;0;            return 1024;        });        Integer result = completableFuture2.whenComplete((t, u) -&gt; {            System.out.println(&quot;&gt;&gt;&gt;&gt;t: &quot; + t); &#x2F;&#x2F; 正常执行            System.out.println(&quot;&gt;&gt;&gt;&gt;u: &quot; + u); &#x2F;&#x2F; 异常执行        }).exceptionally(f -&gt; { &#x2F;&#x2F; 如果出现异常会执行的函数            System.out.println(&quot;&gt;&gt;&gt;&gt;exception:&quot; + f.getMessage());            return 444;        }).get();        System.out.println(result);    }}</code></pre><p>相关文章推荐：</p><p> <a href="https://www.jianshu.com/p/b3c4dd85901e" target="_blank" rel="noopener">https://www.jianshu.com/p/b3c4dd85901e</a> </p><p> <a href="https://www.jianshu.com/p/11327ad1d645" target="_blank" rel="noopener">https://www.jianshu.com/p/11327ad1d645</a> </p><blockquote><p>JUC相关代码见Github：<a href="https://github.com/zero6996/JUC-Demos-Code" target="_blank" rel="noopener">JUC-Demos</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaAdvanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/JavaAdvanced/JUC.html"/>
      <url>/JavaAdvanced/JUC.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-JUC"><a href="#1-JUC" class="headerlink" title="1. JUC"></a>1. JUC</h2><p>JUC是<code>java.util.concurrent</code>工具包的简称，JDK1.5开始出现的，这是一个处理线程的工具包，在此包中有很多在并发编程中很常用的工具类。</p><p>主要由三大包构成：</p><ol><li><code>java.util.concurrent</code>：并发包</li><li><code>java.util.concurrent.atomic</code>：并发原子包</li><li><code>java.util.concurrent.locks</code>：并发锁包</li></ol><h3 id="1-1-进程线程回顾"><a href="#1-1-进程线程回顾" class="headerlink" title="1.1 进程线程回顾"></a>1.1 进程线程回顾</h3><p>在学习JUC之前，复习一些基础概念</p><ol><li>什么是进程/线程？<ul><li>进程：windows打开任务管理器，里面运行的程序就是进程，比如idea.exe就是进程。</li><li>线程：在一个进程下运行的所有程序，就是线程，比如idea中的动态代码检查，语法检查等功能就是线程。</li></ul></li><li>并发/并行？<ul><li>并发：同一时刻多个线程访问同一资源，比如春运抢票，电商的秒杀功能。</li><li>并行：多个处理器同时处理多个任务，比如一个人要吃饭，手机充电这些都可以同时进行。</li></ul></li><li>线程有哪些状态？六种状态：NEW(新建)，RUNNABLE(就绪)，BLOCKED(阻塞)，WAITING(等待)，TIMED_WAITING(计时等待)，TERMINATED(终结)。</li></ol><h2 id="2-Lock接口"><a href="#2-Lock接口" class="headerlink" title="2. Lock接口"></a>2. Lock接口</h2><p>Lock接口是java并发包下的；锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作，它们允许更灵活的结构，可能具有非常不同的数学，且支持多个关联的condition对象。</p><h3 id="2-1-生产者消费者案例"><a href="#2-1-生产者消费者案例" class="headerlink" title="2.1 生产者消费者案例"></a>2.1 生产者消费者案例</h3><p>需求：两个线程，可以操作初始值为零的一个变量，需实现一个线程对该变量加1，一个线程对该变量减1，交替执行10轮，变量初始值为0。在高聚低合前提下，线程操作资源类。</p><ul><li>基础版synchronized代码如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ProdConsumeDemo {    public static void main(String[] args) throws Exception{        Aircondition aircondition = new Aircondition();        new Thread(()-&gt;{            for (int i = 0; i &lt;= 10; i++) {                try {                    Thread.sleep(200);                    aircondition.increment();                } catch (Exception e) {                    e.printStackTrace();                }            }        },&quot;生产者A&quot;).start();        new Thread(()-&gt;{            for (int i = 0; i &lt;= 10; i++) {                try {                    Thread.sleep(300);                    aircondition.decrement();                } catch (Exception e) {                    e.printStackTrace();                }            }        },&quot;消费者B&quot;).start();    }}&#x2F;&#x2F; 空调类class Aircondition{    private int number = 0;    &#x2F;&#x2F; 模拟生产者    public synchronized void increment() throws Exception{        &#x2F;&#x2F; 1. 判断        if (number != 0){            this.wait();        }        &#x2F;&#x2F; 2. 工作        number++;        System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+number);        &#x2F;&#x2F; 3. 通知，唤醒其他等待线程        this.notifyAll();    }    &#x2F;&#x2F; 模拟消费者    public synchronized void decrement() throws Exception{        &#x2F;&#x2F; 1. 判断        if (number == 0){            this.wait();        }        &#x2F;&#x2F; 2. 工作        number--;        System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+number);        &#x2F;&#x2F; 3. 通知        this.notifyAll();    }}</code></pre><p>现在将生产者和消费者都增加一个，共计4个线程，然后执行代码会发现数据错误，这就是多线程的虚假唤醒。原因出在if的使用，多线程判断时，不能用if；使用wait时必须注意，中断和虚假唤醒是可能的，故该方法应该<strong>在循环中使用</strong>；将if改为while即可。</p><ul><li>改进写法，优化多线程情况下可能发生的虚假唤醒</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 将代码添加和修改如下即可&#x2F;&#x2F; 生产者和消费者都增加一个new Thread(()-&gt;{    for (int i = 0; i &lt;= 10; i++) {        try {            Thread.sleep(400);            aircondition.increment();        } catch (Exception e) {            e.printStackTrace();        }    }},&quot;生产者C&quot;).start();new Thread(()-&gt;{    for (int i = 0; i &lt;= 10; i++) {        try {            Thread.sleep(500);            aircondition.decrement();        } catch (Exception e) {            e.printStackTrace();        }    }},&quot;消费者D&quot;).start();&#x2F;&#x2F; 修改if为whilewhile (number != 0){    this.wait();}while (number == 0){    this.wait();}</code></pre><h3 id="2-2-为什么在wait使用if的情况下，会产生虚假唤醒？"><a href="#2-2-为什么在wait使用if的情况下，会产生虚假唤醒？" class="headerlink" title="2.2 为什么在wait使用if的情况下，会产生虚假唤醒？"></a>2.2 为什么在wait使用if的情况下，会产生虚假唤醒？</h3><p>由于cpu的调度是不可控的，所以在生产者A生产完后，下一个可能不是消费者执行，而是生产者B继续执行，如果使用if就会进行判断number!=0，进入wait状态等待，此时生产者A再次获取时间片，执行代码if判断进入wait状态；这样两个生产者同时处于wait状态了，后续如果唤醒就会使number++两次，导致值为2。同理消费者也是。<br>所以要使用while<strong>循环判断条件</strong>是否满足，才可以交替执行生产和消费。</p><h3 id="2-3-新版写法"><a href="#2-3-新版写法" class="headerlink" title="2.3 新版写法"></a>2.3 新版写法</h3><p>使用了condition类的<code>condition.await();</code>进行资源的上锁，<code>condition.signalAll();</code>方法进行资源的唤醒。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 空调类class Aircondition{    private int number = 0;    &#x2F;&#x2F; 新版写法    private Lock lock = new ReentrantLock();    &#x2F;&#x2F; 使用新版的通知唤醒    private Condition condition = lock.newCondition();    &#x2F;&#x2F; 模拟生产者    public void increment(){        lock.lock();        try{            &#x2F;&#x2F; 1. 判断            while (number != 0){                condition.await();            }            &#x2F;&#x2F; 2. 工作            number++;            System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+number);            &#x2F;&#x2F; 3. 通知，唤醒其他等待线程            condition.signalAll();        }catch(Exception e){            e.printStackTrace();        }finally{            lock.unlock();        }    }    &#x2F;&#x2F; 模拟生产者    public void decrement(){        lock.lock();        try{            &#x2F;&#x2F; 1. 判断            while (number == 0){                condition.await();            }            &#x2F;&#x2F; 2. 工作            number--;            System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+number);            &#x2F;&#x2F; 3. 通知，唤醒其他等待线程            condition.signalAll();        }catch(Exception e){            e.printStackTrace();        }finally{            lock.unlock();        }    }}</code></pre><h3 id="2-4-生产者和消费者知识小结"><a href="#2-4-生产者和消费者知识小结" class="headerlink" title="2.4 生产者和消费者知识小结"></a>2.4 生产者和消费者知识小结</h3><ul><li>多线程编程模板：线程-&gt;操作-&gt;资源类，高内聚低耦合</li><li>多线程编程套路：判断-&gt;工作-&gt;通知</li><li>while循环判断(防止虚假唤醒)</li><li>新版写法(lock+condition)</li></ul><h3 id="2-5-面试题，交替打印"><a href="#2-5-面试题，交替打印" class="headerlink" title="2.5 面试题，交替打印"></a>2.5 面试题，交替打印</h3><p>需求：两个线程，一个打印1-26，一个打印A-Z，要求打印顺序为1A2B…26Z</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**ASCII码,A=65，Z=90，故A-Z=65-90(char)65=A*&#x2F;public class printNumberAndtheAlphabet {    public static void main(String[] args) {        printData data = new printData();        new Thread(()-&gt;{            for (int i = 1; i &lt;= 26 ; i++) {                data.printNumber();            }        },&quot;打印数字线程&quot;).start();        new Thread(()-&gt;{            for (int i = 1; i &lt;= 26 ; i++) {                data.printAlphabet();            }        },&quot;打印字母线程&quot;).start();    }}class printData{    int Number = 1;    int ASCIINumber = 65;    int flag = 0;    private Lock lock = new ReentrantLock();    private Condition condition = lock.newCondition();    public void printNumber(){        lock.lock();        try{            while (flag != 0){                condition.await();            }            if (Number&lt;=26) System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+Number);            Number++;            flag++;            condition.signalAll();        }catch(Exception e){            e.printStackTrace();        }finally{            lock.unlock();        }    }    public void printAlphabet(){        lock.lock();        try{            while (flag==0){                condition.await();            }            if (ASCIINumber&lt;=90) System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+(char)ASCIINumber);            ASCIINumber++;            flag--;            condition.signalAll();        }catch(Exception e){            e.printStackTrace();        }finally{            lock.unlock();        }    }}</code></pre><h3 id="2-6-使用Condition精准唤醒，实现线程之间的顺序调度"><a href="#2-6-使用Condition精准唤醒，实现线程之间的顺序调度" class="headerlink" title="2.6 使用Condition精准唤醒，实现线程之间的顺序调度"></a>2.6 使用Condition精准唤醒，实现线程之间的顺序调度</h3><p>要求：多线程之间按顺序调用，实现A-&gt;B-&gt;C；三个线程启动，要求AA打印5次，BB打印10次，CC打印15次，接着AA打印5次，BB打印10次，CC打印15次，共计10轮。代码示例如下：</p><ul><li>资源类，完成打印操作和精准唤醒</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">class ShareData{    &#x2F;&#x2F; 1=A,2=B,3=C    private int number = 1;    private Lock lock = new ReentrantLock();    &#x2F;&#x2F; 精准唤醒    Condition c1 = lock.newCondition();    Condition c2 = lock.newCondition();    Condition c3 = lock.newCondition();    public void print5(){        lock.lock();        try{            &#x2F;&#x2F; 1. 判断            while (number != 1){                c1.await();            }            &#x2F;&#x2F; 工作            for (int i = 0; i &lt; 5 ; i++) {                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + i);            }            &#x2F;&#x2F; 通知            &#x2F;&#x2F; 一定要先改标志位            number = 2;            &#x2F;&#x2F; 通知下一位：精准唤醒下一个线程            c2.signal();        }catch(Exception e){            e.printStackTrace();        }finally{            lock.unlock();        }    }    public void print10(){        lock.lock();        try{            &#x2F;&#x2F; 1. 判断            while (number != 2){                c2.await();            }            &#x2F;&#x2F; 工作            for (int i = 0; i &lt; 10 ; i++) {                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + i);            }            &#x2F;&#x2F; 通知            &#x2F;&#x2F; 一定要先改标志位            number = 3;            c3.signal();        }catch(Exception e){            e.printStackTrace();        }finally{            lock.unlock();        }    }    public void print15(){        lock.lock();        try{            &#x2F;&#x2F; 1. 判断            while (number != 3){                c3.await();            }            &#x2F;&#x2F; 工作            for (int i = 0; i &lt; 15 ; i++) {                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + i);            }            &#x2F;&#x2F; 通知            &#x2F;&#x2F; 一定要先改标志位            number = 1;            c1.signal();        }catch(Exception e){            e.printStackTrace();        }finally{            lock.unlock();        }    }}</code></pre><ul><li>主类，三个线程操作资源类，执行10轮</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ConditionDemo {    public static void main(String[] args) {        ShareData shareData = new ShareData();        new Thread(()-&gt;{            for (int i = 1; i &lt;= 10; i++) {                shareData.print5();            }        },&quot;A&quot;).start();        new Thread(()-&gt;{            for (int i = 1; i &lt;= 10; i++) {                shareData.print10();            }        },&quot;B&quot;).start();        new Thread(()-&gt;{            for (int i = 1; i &lt;= 10; i++) {                shareData.print15();            }        },&quot;C&quot;).start();    }}</code></pre><h2 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3. Lambda表达式"></a>3. Lambda表达式</h2><p>复习lambda表达式</p><ul><li>传统写法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class LambdaExpressDemo {    public static void main(String[] args) {Foo foo = new Foo(){            @Override            public void sayHello(){                System.out.println(&quot;hello world&quot;);            }        }        foo.sayHello();    }}interface Foo{    public void sayHello();}</code></pre><ul><li>lambda写法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Foo foo = (()-&gt;{System.out.println(&quot;hello world&quot;)};);</code></pre><h3 id="3-1-lambda小口诀"><a href="#3-1-lambda小口诀" class="headerlink" title="3.1 lambda小口诀"></a>3.1 lambda小口诀</h3><p>拷贝中括号(就是你要实现的方法的参数列表)，写死右箭头，落地大括号</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">()-&gt;{}</code></pre><h3 id="3-2-函数式接口"><a href="#3-2-函数式接口" class="headerlink" title="3.2 函数式接口"></a>3.2 函数式接口</h3><p><code>@FunctionalInterface</code>注解用于标识该接口是函数式接口，如果该接口中只有一个抽象方法(不包括默认方法和静态方法)，可以不写这个注解，底层会默认加上。</p><h3 id="3-3-default方法"><a href="#3-3-default方法" class="headerlink" title="3.3 default方法"></a>3.3 default方法</h3><p>面试题：接口中是否允许有方法的实现？：Java8以后接口支持默认方法，可以让方法有对应的实现。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@FunctionalInterfaceinterface Foo{    public int add(int x,int y);    public default int mul(int x,int y){        return x * y;}Foo foo = (int x,int y)-&gt; {    System.out.println(&quot;come in add method&quot;);    return x + y;};System.out.println(foo.mul(3,5));</code></pre><p>函数式接口中允许有多个默认方法。</p><h3 id="3-4-static方法"><a href="#3-4-static方法" class="headerlink" title="3.4 static方法"></a>3.4 static方法</h3><p>函数式接口中允许static方法的声明和实现。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@FunctionalInterfaceinterface Foo{    public int add(int x,int y);    public static int diy(int x,int y){        return x&#x2F;y;    }}System.out.println(Foo.diy(6,3));</code></pre><h2 id="4-多线程锁"><a href="#4-多线程锁" class="headerlink" title="4. 多线程锁"></a>4. 多线程锁</h2><h3 id="4-1-八锁"><a href="#4-1-八锁" class="headerlink" title="4.1 八锁"></a>4.1 八锁</h3><p>简单代码举例八锁，基础代码如下，后续案例均修改部分代码即可</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Locks8Demo {    public static void main(String[] args) throws Exception {        Phone phone = new Phone();        Phone phone2 = new Phone();        new Thread(()-&gt;{            try {                phone.sendEmail();            }catch (Exception e){                e.printStackTrace();            }        },&quot;A&quot;).start();        Thread.sleep(100);        new Thread(()-&gt;{            try {                &#x2F;&#x2F;                phone.sendSMS();                &#x2F;&#x2F;                phone.sayHello();                phone2.sendSMS();            }catch (Exception e){                e.printStackTrace();            }        },&quot;B&quot;).start();    }}class Phone{    public  static synchronized void sendEmail() throws Exception{        TimeUnit.SECONDS.sleep(2);        System.out.println(&quot;-----&gt;sendEmail&lt;&quot;);    }    public synchronized void sendSMS() throws Exception{        System.out.println(&quot;-----&gt;sendSMS&lt;&quot;);    }    public void sayHello(){        System.out.println(&quot;-----&gt;sayHello&quot;);    }}</code></pre><ol><li>标准访问，先打印邮件还是短信？</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public synchronized void sendEmail() throws Exception{    System.out.println(&quot;-----&gt;sendEmail&lt;&quot;);}public synchronized void sendSMS() throws Exception{    System.out.println(&quot;-----&gt;sendSMS&lt;&quot;);}Phone phone = new Phone();phone.sendEmail();phone.sendSMS();&#x2F;&#x2F; 邮件&gt;短信</code></pre><ol start="2"><li>在邮件方法中暂停2秒，先打印邮件还是短信？</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public synchronized void sendEmail() throws Exception{    TimeUnit.SECONDS.sleep(2);    System.out.println(&quot;-----&gt;sendEmail&lt;&quot;);}phone.sendEmail();phone.sendSMS();&#x2F;&#x2F; 邮件&gt;短信</code></pre><p>1、2小结：</p><p>同一实例对象里面如果有多个synchronized方法，某一时刻内，只要一个线程去调用其中的一个synchronized方法，其他线程都只能等待，换言之，某一时刻内只能有唯一一个线程去访问这些synchronized方法， “<strong>锁的是当前实例对象this</strong>，被锁定后，其他线程都不能进入到当前对象的其他synchronized方法”。</p><ol start="3"><li>新增普通sayHello方法，先打印邮件还是hello？</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public void sayHello(){    System.out.println(&quot;-----&gt;sayHello&quot;);}phone.sendEmail();phone.sayHello();&#x2F;&#x2F; hello&gt;邮件</code></pre><p>3小结：普通方法与同步锁无关，不会竞争资源</p><ol start="4"><li>两部手机，先邮件还是短信？</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Phone phone = new Phone();Phone phone2 = new Phone();phone.sendEmail();phone2.sendSMS();&#x2F;&#x2F; 短信&gt;邮件</code></pre><p>4小结：不同实例对象不是同一把锁，故不会竞争资源。</p><ol start="5"><li>两个静态同步方法，同一部手机，请问先打印邮件还是短信？</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static synchronized void sendEmail() throws Exception{    TimeUnit.SECONDS.sleep(2);    System.out.println(&quot;-----&gt;sendEmail&lt;&quot;);}public static synchronized void sendSMS() throws Exception{    System.out.println(&quot;-----&gt;sendSMS&lt;&quot;);}phone.sendEmail();phone.sendSMS();&#x2F;&#x2F; 邮件&gt;短信</code></pre><ol start="6"><li>两个静态同步方法，两部手机，请问先打印邮件还是短信？</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">phone.sendEmail();phone2.sendSMS();&#x2F;&#x2F;  邮件&gt;短信</code></pre><p>5和6小结：<strong>静态同步锁=全局锁</strong><br>synchronized实现同步的基础：Java中的每一个对象都可以作为锁，具体表现为以下3种形式：<br>一、对于普通同步方法，锁是当前实例对象(this)<br>二、对于同步方法块，锁的是synchronized括号里配置的对象<br>三、对于静态同步方法，锁的是当前类的Class对象(全局锁)</p><p>因为5和6都是静态同步锁也就是全局锁，实际上他们属于同一个类对象，故会竞争资源。</p><ol start="7"><li>1个静态同步方法，1个普通同步方法，同一部手机，请问先打印邮件还是短信？</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public  static   synchronized void sendEmail() throws Exception{    TimeUnit.SECONDS.sleep(2);    System.out.println(&quot;-----&gt;sendEmail&lt;&quot;);}public  synchronized void sendSMS() throws Exception{    System.out.println(&quot;-----&gt;sendSMS&lt;&quot;);}phone.sendEmail();phone.sendSMS();&#x2F;&#x2F; 短信&gt;邮件</code></pre><p>7小结：静态同步方法和非静态同步方法不是同一把锁，故不冲突。</p><ol start="8"><li>1个静态同步方法，1个普通同步方法，两部手机，请问先打印邮件还是短信？同上。</li></ol><h3 id="4-2-八锁小结"><a href="#4-2-八锁小结" class="headerlink" title="4.2 八锁小结"></a>4.2 八锁小结</h3><p>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法<br>锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法。</p><p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。<br>具体表现为以下3种形式。</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象</li></ul><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><ul><li>非静态同步方法：</li></ul><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。<br>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待锁释放后才能获取锁，其他实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同锁，所以无需等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p><blockquote><p>简言之：非静态同步锁当前对象，其他非静态锁访问同实例变量的锁会产生竞争。</p></blockquote><ul><li>静态同步方法(全局锁)：</li></ul><p>所有的静态同步方法用的是同一把锁—<strong>类对象本身(Class)</strong>；这静态同步锁和非静态同步锁两把锁是锁的两个不同的对象，所以<strong>静态同步方法与非静态同步方法之间是不会有竞态条件的。</strong><br>但是一旦一个静态同步方法获取锁后，其他的当前类对象的所有静态同步方法都必须等待该方法释放锁后才能获取锁，不管是同一个实例对象还是不同实例对象，只要它们是同一个类的实例对象，那么它们的静态同步方法就是同一把锁。</p><blockquote><p>简言之：静态同步锁类对象本身，故称之为全局锁，其他静态同步锁访问同类对象的锁会产生竞争，非静态锁的不同对象故不会产生竞争。</p></blockquote><h2 id="5-线程不安全案例"><a href="#5-线程不安全案例" class="headerlink" title="5. 线程不安全案例"></a>5. 线程不安全案例</h2><h3 id="5-1-ArrayList线程不安全的原因详解"><a href="#5-1-ArrayList线程不安全的原因详解" class="headerlink" title="5.1 ArrayList线程不安全的原因详解"></a>5.1 ArrayList线程不安全的原因详解</h3><p>从以下4个维度解释ArrayList线程不安全的原因</p><h4 id="5-1-1-故障现象"><a href="#5-1-1-故障现象" class="headerlink" title="5.1.1 故障现象"></a>5.1.1 故障现象</h4><p>报<code>java.util.ConcurrentModificationException</code>错误，ArrayList在迭代时如果同时对其进行修改就会抛出并发修改异常。</p><h4 id="5-1-2-导致原因"><a href="#5-1-2-导致原因" class="headerlink" title="5.1.2  导致原因"></a>5.1.2  导致原因</h4><p>多线程情况下同时争抢一个资源类且没有加锁</p><h4 id="5-1-3-解决方法"><a href="#5-1-3-解决方法" class="headerlink" title="5.1.3 解决方法"></a>5.1.3 解决方法</h4><ol><li>使用java自带的<code>new Vector()</code>，代码底层加了synchronized锁保证线程安全；</li><li>使用Collections工具类的<code>synchronizedList(new ArrayList&lt;&gt;())</code></li><li>使用juc包下的<code>new CopyOnWriteArrayList&lt;&gt;();</code>写时复制技术</li></ol><h4 id="5-1-4-代码示例"><a href="#5-1-4-代码示例" class="headerlink" title="5.1.4 代码示例"></a>5.1.4 代码示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class arrayListNotSafe {    public static void main(String[] args) {        mapNotSafe();    }    private static void mapNotSafe() {        Map&lt;String,String&gt; map = new ConcurrentHashMap();&#x2F;&#x2F;new HashMap&lt;&gt;();        for (int i = 1; i &lt;= 100; i++) {            new Thread(()-&gt;{                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,8));                System.out.println(map);            },String.valueOf(i)).start();        }    }    private static void setNotSafe() {        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(new HashSet&lt;&gt;());&#x2F;&#x2F;new HashSet&lt;&gt;();        for (int i = 1; i &lt;= 100; i++) {            new Thread(()-&gt;{                set.add(UUID.randomUUID().toString().substring(0,8));                System.out.println(set);            },String.valueOf(i)).start();        }    }    private static void listNotSafe() {        &#x2F;&#x2F; 分别使用ArrayList、Vector、synchronizedList、CopyOnWriteArrayList进行测试        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();&#x2F;&#x2F; Collections.synchronizedList(new ArrayList&lt;&gt;());&#x2F;&#x2F;new Vector&lt;&gt;();&#x2F;&#x2F;new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= 100; i++) {            new Thread(()-&gt;{                list.add(UUID.randomUUID().toString().substring(0,8));                System.out.println(list);            },String.valueOf(i)).start();        }    }}</code></pre><h3 id="5-2-写时复制技术"><a href="#5-2-写时复制技术" class="headerlink" title="5.2 写时复制技术"></a>5.2 写时复制技术</h3><p>CopyOnWrite容器即写时复制的容器。往一个容器添加元素时，不直接往当前容器Object[]添加，而是先将当前容器进行Copy，复制出一个新的容器Object[] newElements，然后在新容器中添加元素，添加元素之后，将原容器的引用指向新容器setArray(newElements);</p><p>这样做的好处是可以对CopyOnWrite容器进行并发的读而无需加锁，因为当前容器不会添加任何元素，所以CopyOnWrite容器也是一种<strong>读写分离的思想</strong>，读和写不同的容器。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public boolean add(E e) {    final ReentrantLock lock = this.lock;    lock.lock();    try {        Object[] elements = getArray();        int len = elements.length;        Object[] newElements = Arrays.copyOf(elements, len + 1);        newElements[len] = e;        setArray(newElements);        return true;    } finally {        lock.unlock();    }}</code></pre><h2 id="6-Callable接口"><a href="#6-Callable接口" class="headerlink" title="6. Callable接口"></a>6. Callable接口</h2><p>Callable类似于Runnable接口，实现Callable接口的类和实现Runnable的类都是可被其它线程执行的任务，Callable接口可以获取任务执行的返回值，通过与Future结合，可以实现异步计算；Callable经常和java线程池一起使用，同时它也是一个函数式接口。</p><h3 id="6-1-获取多线程的几种方法"><a href="#6-1-获取多线程的几种方法" class="headerlink" title="6.1 获取多线程的几种方法"></a>6.1 获取多线程的几种方法</h3><p>传统的是继承thread类和实现runnable接口，java5之后又可以实现callable接口和java的线程池获取。</p><h3 id="6-2-Callable和Runnable的区别"><a href="#6-2-Callable和Runnable的区别" class="headerlink" title="6.2 Callable和Runnable的区别"></a>6.2 Callable和Runnable的区别</h3><p>主要有两点区别：</p><ol><li>方法不同，一个call()一个run()；</li><li>run方法没有返回值；call方法可以返回执行结果；</li><li>run方法异常只能内部消化，不能往外抛；call方法允许抛出异常。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;Callable 接口public interface Callable&lt;V&gt; {    V call() throws Exception;}&#x2F;&#x2F; Runnable 接口public interface Runnable {    public abstract void run();}</code></pre><h3 id="6-3-FutureTask"><a href="#6-3-FutureTask" class="headerlink" title="6.3 FutureTask"></a>6.3 FutureTask</h3><p>由于Thread类不能直接使用Callable接口，故需要使用到FutureTask做“中间人”， FutureTask类实现RunnableFuture接口，而RunnnableFuture接口继承了Runnable和Future接口，所以说FutureTask是一个提供异步计算的结果的任务。 </p><p>可以使用FutureTask来包装Callable或者Runnable对象，然后交给Thread或线程池做执行，Callable有以下两种执行方式：</p><ul><li>Callable借助FutureTask执行：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义实现Callable接口的实现类class MyThread implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        System.out.println(&quot;come in call Callable()&quot;);        return 1024;    }}public class CallableDemo{    public static void main(String[] args) throws Exception{        &#x2F;&#x2F; 创建FutureTask对象并将callable对象放入        FutureTask&lt;Integer&gt; task = new FutureTask(new MyThread());        &#x2F;&#x2F; 开启线程        new Thread(task,&quot;A&quot;).start();        &#x2F;&#x2F; 获取执行结果        System.out.println(task.get());        System.out.println(Thread.currentThread().getName()+&quot;计算完成&quot;);    }}</code></pre><ul><li>借助线程池来运行</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 创建一个线程池ExecutorService pool = Executors.newCachedThreadPool();&#x2F;&#x2F; 提交一个任务Future&lt;Integer&gt; future = pool.submit(new MyThread());&#x2F;&#x2F; 获取执行结果System.out.println(future.get());&#x2F;&#x2F; 关闭线程池pool.shutdown();</code></pre><h2 id="7-JUC常用辅助类"><a href="#7-JUC常用辅助类" class="headerlink" title="7. JUC常用辅助类"></a>7. JUC常用辅助类</h2><h3 id="7-1-CountDownLatch减法计数器"><a href="#7-1-CountDownLatch减法计数器" class="headerlink" title="7.1 CountDownLatch减法计数器"></a>7.1 <code>CountDownLatch</code>减法计数器</h3><p>案例：下课教室走人场景，有6位同学要走但走的顺序不一定，班长必须等待所有同学走完才允许关门走人。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class CountDownLatchDemo {    public static void main(String[] args) throws InterruptedException {        &#x2F;&#x2F; 使用CountDownLatch计数器来控制线程顺序，定义一个值为6的计数器。        CountDownLatch countDownLatch = new CountDownLatch(6);        for (int i = 0; i &lt; 6; i++) {            new Thread(() -&gt; {                System.out.println(Thread.currentThread().getName() + &quot;\t离开教室&quot;);                countDownLatch.countDown();            }, String.valueOf(i)).start();        }        countDownLatch.await();        System.out.println(Thread.currentThread().getName() + &quot;\t班长关门走人&quot;);    }}</code></pre><p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。其他线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，当计数器的值为0时，被await方法阻塞的线程会被唤醒，继续执行。</p><h3 id="7-2-CyclicBarrier循环屏障"><a href="#7-2-CyclicBarrier循环屏障" class="headerlink" title="7.2 CyclicBarrier循环屏障"></a>7.2 <code>CyclicBarrier</code>循环屏障</h3><p>CyclicBarrier字面意思是可循环的(Cyclic)使用的屏障(Barrier)；主要可以做到让一组线程到达一个屏障(也可叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门让所有被屏障拦截的线程继续工作。</p><ul><li>线程进入屏障使用CyclicBarrier的<code>await()</code>方法，代码案例如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 案例：只有集齐7颗龙珠，才能召唤神龙public class CyclicBarrierDemo {    public static void main(String[] args) {        CyclicBarrier barrier = new CyclicBarrier(7,()-&gt; System.out.println(&quot;&gt;&gt;&gt;7龙珠召唤神龙&lt;&lt;&lt;&quot;));        for (int i = 1; i &lt;= 7; i++) {            final int finalI = i;            new Thread(()-&gt;{                System.out.println(Thread.currentThread().getName()+&quot;\t收集到第：&quot;+ finalI +&quot;颗龙珠&quot;);                try {                    barrier.await();                } catch (InterruptedException e) {                    e.printStackTrace();                } catch (BrokenBarrierException e) {                    e.printStackTrace();                }            },String.valueOf(i)).start();        }    }}</code></pre><h3 id="7-3-Semaphore信号灯"><a href="#7-3-Semaphore信号灯" class="headerlink" title="7.3 Semaphore信号灯"></a>7.3 <code>Semaphore</code>信号灯</h3><p>在信号量上定义两种操作：</p><ul><li><strong>acquire(获取)</strong>：当一个线程调用acquire操作时，它要么成功通过，获取信号量(信号量减1)，要么一直等待下去，直到有线程释放信号量或超时。</li><li><strong>release(释放)</strong>：实际上会将信号量的值加1，然后唤醒等待的线程。</li></ul><blockquote><p><strong>信号量主要用于多个共享资源的互斥使用和对并发线程数的控制。</strong></p></blockquote><p>案例代码如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 模拟抢车位案例public class SemaphoreDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 模拟资源类，有3个空车位        Semaphore semaphore = new Semaphore(3);        for (int i = 1; i &lt;= 6; i++) {            new Thread(()-&gt;{                try {                    &#x2F;&#x2F; 占用                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName()+&quot;\t抢到了车位&quot;);                    TimeUnit.SECONDS.sleep(3);                    &#x2F;&#x2F; 释放                    System.out.println(Thread.currentThread().getName()+&quot;\t离开了车位&quot;);                } catch (InterruptedException e) {                    e.printStackTrace();                }finally {                    semaphore.release();                }            },String.valueOf(i)).start();        }    }}</code></pre><h2 id="8-可重入读写锁ReentrantReadWriteLock"><a href="#8-可重入读写锁ReentrantReadWriteLock" class="headerlink" title="8. 可重入读写锁ReentrantReadWriteLock"></a>8. 可重入读写锁<code>ReentrantReadWriteLock</code></h2><p>当多个线程同时读取一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行；但是，如果有一个线程想去写共享资源时，为了保证数据的一致性，就不应该有其他线程可以同时对该资源进行读写操作了。</p><ul><li>代码案例，使用ReentrantReadWriteLock读写锁对不同的读写资源操作上不同的锁。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 自定义模拟一个缓存类class MyCache{    private volatile Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();        public void put(String key,Object value){        readWriteLock.writeLock().lock();        try{            System.out.println(Thread.currentThread().getName()+&quot;\t&gt;&gt;&gt;开始写入&quot;+key);            &#x2F;&#x2F; 暂停一定毫秒时间            try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }            map.put(key,value);            System.out.println(Thread.currentThread().getName()+&quot;\t&gt;&gt;&gt;写入成功&quot;+key);        }catch(Exception e){            e.printStackTrace();        }finally{            readWriteLock.writeLock().unlock();        }    }    public void get(String key){        readWriteLock.readLock().lock();        try{            System.out.println(Thread.currentThread().getName()+&quot;\t&gt;&gt;&gt;开始获取数据&quot;+key);            &#x2F;&#x2F; 暂停一定时间            try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }            Object o = map.get(key);            System.out.println(Thread.currentThread().getName()+&quot;\t&gt;&gt;&gt;成功获取数据&quot;+o);        }catch(Exception e){            e.printStackTrace();        }finally{            readWriteLock.readLock().unlock();        }    }}public class ReadWriteLockDemo {    public static void main(String[] args) {        MyCache cache = new MyCache();        &#x2F;&#x2F; 模拟并发情况下5个线程写入        for (int i = 1; i &lt;= 5; i++) {            final int finalI = i;            new Thread(()-&gt;{                cache.put(finalI +&quot;&quot;, finalI +&quot;&quot;);            },String.valueOf(i)).start();        }        &#x2F;&#x2F; 模拟并发情况下5个线程读取        for (int i = 1; i &lt;= 5; i++) {            final int finalI = i;            new Thread(()-&gt;{                cache.get(finalI +&quot;&quot;);            },String.valueOf(i)).start();        }    }}</code></pre><blockquote><p>读取资源应该共享读，写操作时应该排他写；以此保证数据的一致性。</p></blockquote><h2 id="9-阻塞队列"><a href="#9-阻塞队列" class="headerlink" title="9. 阻塞队列"></a>9. 阻塞队列</h2><p>阻塞队列<code>BlockingQueue</code>是一个队列，数据结构如下：</p><p><img src="http://yanxuan.nosdn.127.net/9d12e170ba9bc52fa7cfbb7d6bed2d10.png" alt="阻塞队列"></p><p>阻塞队列主要具有这两点特性：</p><ul><li>当队列为空时，从队列中<strong>获取</strong>元素的操作将会被阻塞</li><li>当队列为满时，从队列中<strong>添加</strong>元素的操作将会被阻塞</li></ul><p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素；试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增。</p><blockquote><p>简言之：<font color="red">空时不能消费，满时不能增加</font></p></blockquote><p>阻塞队列的用处：在多线程领域，所谓阻塞，就是在某些情况下会<strong>挂起</strong>线程(即阻塞)，一旦条件满足，被挂起的线程又会被自动<strong>唤醒</strong>。</p><p>concurrent包发布以前，在多线程环境下，我们都必须自己去控制很多细节，尤其还要兼顾效率和线程安全，这对编码带来不小的复杂度；阻塞队列<code>BlockingQueue</code>就可以帮我们很好的解决这些问题，让我们无需关心什么时候需要阻塞线程，什么时候需要唤醒线程。</p><h3 id="9-1-架构介绍"><a href="#9-1-架构介绍" class="headerlink" title="9.1 架构介绍"></a>9.1 架构介绍</h3><p>阻塞队列所有已知实现类架构图如下：</p><p><img src="http://yanxuan.nosdn.127.net/fe2c909a5fdc12c30fe20081a75075af.png" alt="阻塞队列实现类"></p><p>各种实现类分析：</p><ol><li><code>ArrayBlockingQueue</code>：<strong>由数据结构组成的有界阻塞队列</strong></li><li><code>LinkedBlockingQueue</code>：<strong>由链表结构组成的有界阻塞队列(但大小默认值为<code>integer.MAX_VALUE</code>)</strong></li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列</li><li><code>DelayQueue</code>：使用优先级队列实现的延迟无界阻塞队列</li><li><code>SynchronousQueue</code>：<strong>不存储元素的阻塞队列，也即单元素队列</strong></li><li><code>LinkedTransferQueue</code>：由链表组成的无界阻塞队列</li><li><code>LinkedBlockingDeque</code>：由链表组成的双向阻塞队列</li></ol><h3 id="9-2-核心方法"><a href="#9-2-核心方法" class="headerlink" title="9.2 核心方法"></a>9.2 核心方法</h3><table><thead><tr><th style="text-align:center">方法类型</th><th style="text-align:center">抛出异常</th><th style="text-align:center">特殊值</th><th style="text-align:center">阻塞</th><th style="text-align:center">超时</th></tr></thead><tbody><tr><td style="text-align:center">插入</td><td style="text-align:center">add(e)</td><td style="text-align:center">offer(e)</td><td style="text-align:center">put(e)</td><td style="text-align:center">offer(e,time,unit)</td></tr><tr><td style="text-align:center">移除</td><td style="text-align:center">remove()</td><td style="text-align:center">poll()</td><td style="text-align:center">take()</td><td style="text-align:center">poll(time,unit)</td></tr><tr><td style="text-align:center">检查</td><td style="text-align:center">element()</td><td style="text-align:center">peek()</td><td style="text-align:center">不可用</td><td style="text-align:center">不可用</td></tr></tbody></table><ul><li>抛出异常<ul><li>当阻塞队列满时，再往队列中add插入元素会抛出<code>illegalStateException:Queue full</code>异常；</li><li>当阻塞队列空时，再往队列里remove移除元素会抛出<code>NoSuchElementException</code>异常。</li></ul></li><li>特殊值<ul><li>插入方法，成功true失败false</li><li>移除方法，成功返回出队元素，无出队元素返回null</li></ul></li><li>一直阻塞<ul><li>阻塞队列满时，生产者线程继续put元素，队列会一直阻塞生产者线程直到put成功或响应中断退出；</li><li>阻塞队列空时，消费者线程继续take元素，队列会一直阻塞消费者线程直到队列可用。</li></ul></li><li>超时退出<ul><li>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaAdvanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/Algorithm-trip/binary-tree.html"/>
      <url>/Algorithm-trip/binary-tree.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-树结构"><a href="#1-树结构" class="headerlink" title="1. 树结构"></a>1. 树结构</h2><p>树(tree)是n$(n≥0)$个节点的有限集；当n=0时，称为空数；在任意一个非空树中有如下特点：</p><a id="more"></a><ol><li>有且仅有一个特定的称为根的节点。</li><li>当n&gt;1时，其余节点可分为m(m&gt;0)个互不相交的有限集，每个集合本身又是一个树，并称为根的子树。</li></ol><p><img src="http://yanxuan.nosdn.127.net/d84672accd78f59a60e492b13f12b367.png" alt="树结构"></p><p>上图就是一个标准的树结构。其中节点1是<strong>根节点(root)</strong>，节点5、6、7、8、9是树的末端，称为<strong>叶子节点(leaf)。</strong>节点4的上一级节点，是节点4的<strong>父节点(parent)</strong>；从节点4衍生出来的节点，是节点4的<strong>孩子节点(child)</strong>；与节点4同级的，由同一个父节点衍生出来的节点例如5、6是节点4的<strong>兄弟节点(sibling)。</strong>树的最大层级，被称为树的高度或深度，如上图的树高度就是4。</p><h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h2><p>二叉树(binary tree)是树的一种特殊形式，这种树每个节点<strong>最多有2个孩子节点</strong>。二叉树节点的两个孩子节点，一个被称为<strong>左孩子(left child)</strong>，一个被称为右孩子<strong>(right child)</strong>。</p><h3 id="2-1-满二叉树"><a href="#2-1-满二叉树" class="headerlink" title="2.1 满二叉树"></a>2.1 满二叉树</h3><p>一个二叉树的所有非叶子节点都存在左右孩子，且所有叶子节点都在用一层级上，那么这个树就是满二叉树。</p><blockquote><p>简单说就是满二叉树的每一个分支都是满的。</p></blockquote><h3 id="2-2-完全二叉树"><a href="#2-2-完全二叉树" class="headerlink" title="2.2 完全二叉树"></a>2.2 完全二叉树</h3><p>对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号从1到n的节点位置相同，则这个二叉树为完全二叉树。</p><blockquote><p>就是保证1到n之间的节点齐全。</p></blockquote><h3 id="2-3-二叉树在内存中的存储"><a href="#2-3-二叉树在内存中的存储" class="headerlink" title="2.3 二叉树在内存中的存储"></a>2.3 二叉树在内存中的存储</h3><p>二叉树属于逻辑结构，可以通过多种物理结构来表达。二叉树可以使用<strong>链式储结构和数组</strong>进行存储。</p><ul><li>链式存储结构</li></ul><p>链式存储是二叉树最直观的存储方式，一个二叉树的链表节点包含3部分：存储数据的data变量，指向左孩子的left指针，指向右孩子的right指针。</p><ul><li>数组</li></ul><p>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置。假设一个父节点的下标是<code>parent</code>，那么它的左孩子节点下标就是<code>2xparent+1</code>；右孩子节点下标是<code>2xparent+2</code>。</p><p>反之，如果一个左孩子节点的下标是<code>leftChild</code>，那么它父节点下标就是<code>(leftChild-1)/2</code>；右孩子<code>rightChild</code>计算父节点下标是<code>(rightChild-2)/2</code>。</p><p>假如节点5在数组中的下标是4，节点5是节点2的右孩子，故节点2的下标可以通过<code>(4-2)/2=1</code>计算得出。</p><h3 id="2-4-二叉树的应用"><a href="#2-4-二叉树的应用" class="headerlink" title="2.4 二叉树的应用"></a>2.4 二叉树的应用</h3><p>二叉树包含许多特殊的形式，每种形式都有其作用；但最主要的应用还是在于进行<strong>查找操作和维持相对顺序</strong>这两方面</p><h4 id="2-4-1-查找"><a href="#2-4-1-查找" class="headerlink" title="2.4.1 查找"></a>2.4.1 查找</h4><p>二叉树的树形结构使它非常适合做索引。<strong>二叉查找树(binary search tree)</strong>就是一种专门用于查找操作的二叉树。二叉查找树在二叉树的基础上增加了以下几个条件：</p><ul><li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值</li><li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值</li><li>左、右子树也都是二叉查找树</li></ul><p><img src="http://yanxuan.nosdn.127.net/73f7646b5a9928269830a1d59f772912.png" alt="binary search tree"></p><p>上图就是一个标准的二叉查找树。对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是$O(logn)$，和树的深度是一样的。</p><h4 id="2-4-2-维持相对顺序"><a href="#2-4-2-维持相对顺序" class="headerlink" title="2.4.2 维持相对顺序"></a>2.4.2 维持相对顺序</h4><p>二叉查找树要求左子树小于父节点，右子树大于父节点，这样保证了二叉树的有序性。因此二叉查找树还有另一个名字，<strong>二叉排序树(binary sort tree)</strong>。</p><h3 id="2-5-二叉树的遍历"><a href="#2-5-二叉树的遍历" class="headerlink" title="2.5 二叉树的遍历"></a>2.5 二叉树的遍历</h3><p>二叉树的遍历分为4种：</p><ul><li>前序遍历：输出顺序根节点、左子树、右子树</li><li>中序遍历：输出顺序左子树，根节点、右子树</li><li>后序遍历：输出顺序左子树、右子树、根节点</li><li>层序遍历：输出顺序从左到右逐层输出</li></ul><p>宏观角度看，遍历可归结为两大类：</p><ol><li>深度优先遍历(前、中、后序遍历)</li><li>广度优先遍历(层序遍历)</li></ol><h4 id="2-5-1-深度优先遍历"><a href="#2-5-1-深度优先遍历" class="headerlink" title="2.5.1 深度优先遍历"></a>2.5.1 深度优先遍历</h4><p>深度优先遍历的三种遍历方式，代码实现如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class binaryTree {    &#x2F;**     * 构建二叉树     * @param inputList 输入序列     * @return     *&#x2F;    public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inputList){        TreeNode node = null;        if (inputList == null || inputList.isEmpty()){            return null;        }        Integer data = inputList.removeFirst();        if (data != null){            node = new TreeNode(data);            node.leftChild = createBinaryTree(inputList);            node.rightChild = createBinaryTree(inputList);        }        return node;    }    &#x2F;**     * 二叉树前序遍历     * @param node 二叉树节点     *&#x2F;    public static void preOrderTraversal(TreeNode node){        if (node == null){return;}        System.out.println(node.data);        preOrderTraversal(node.leftChild);        preOrderTraversal(node.rightChild);    }    &#x2F;**     * 二叉树中序遍历     * @param node 二叉树节点     *&#x2F;    public static void inOrderTraversal(TreeNode node){        if (node == null){return;}        inOrderTraversal(node.leftChild);        System.out.println(node.data);        inOrderTraversal(node.rightChild);    }    &#x2F;**     * 后序遍历     * @param node 二叉树节点     *&#x2F;    public static void postOrderTraversal(TreeNode node){        if (node == null){return;}        postOrderTraversal(node.leftChild);        postOrderTraversal(node.rightChild);        System.out.println(node.data);    }    &#x2F;**     * 二叉树节点     *&#x2F;    private static class TreeNode{        int data;        TreeNode leftChild;        TreeNode rightChild;        TreeNode(int data){            this.data = data;        }    }    public static void main(String[] args) {        LinkedList&lt;Integer&gt; inputList = new LinkedList&lt;&gt;(Arrays.asList(new Integer[]{3, 2, 9, null, null, 10, null, null, 8, null, 4}));        TreeNode treeNode = createBinaryTree(inputList);        System.out.println(&quot;前序遍历：&quot;);        preOrderTraversal(treeNode);        System.out.println(&quot;中序遍历&quot;);        inOrderTraversal(treeNode);        System.out.println(&quot;后序遍历&quot;);        postOrderTraversal(treeNode);    }}</code></pre><h4 id="2-5-2-广度优先遍历"><a href="#2-5-2-广度优先遍历" class="headerlink" title="2.5.2 广度优先遍历"></a>2.5.2 广度优先遍历</h4><p>广度优先的层序遍历就是按照二叉树从根节点到叶子节点的层次关系，一层一层横向遍历各个节点，需要使用到队列数据结构来实现。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 层序遍历     * @param root 节点     *&#x2F;public static void levelOrderTraversal(TreeNode root){    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    while (!queue.isEmpty()){        TreeNode node = queue.poll();        System.out.println(node.data);        if (node.leftChild != null){            queue.offer(node.leftChild);        }        if (node.rightChild != null){            queue.offer(node.rightChild);        }    }}</code></pre><h2 id="3-二叉堆"><a href="#3-二叉堆" class="headerlink" title="3. 二叉堆"></a>3. 二叉堆</h2><p>二叉堆本质上是一种完全二叉树，分为两个类型：最大堆和最小堆。</p><ul><li>最大堆：任何一个父节点的值，都大于等于其子节点值。</li><li>最小堆：任何一个父节点的值，都小于等于其子节点值。</li></ul><p>二叉堆的根节点叫做<strong>堆顶</strong>。由它们的特点决定了：最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。</p><h3 id="3-1-二叉堆的自我调整"><a href="#3-1-二叉堆的自我调整" class="headerlink" title="3.1 二叉堆的自我调整"></a>3.1 二叉堆的自我调整</h3><p>二叉堆有以下几种操作：</p><ol><li>插入节点</li><li>删除节点</li><li>构建二叉堆</li></ol><p>上述操作都基于堆的自我调整；堆的自我调整就是把一个不符合堆性质的完全二叉树，调整成一个堆。</p><p>以下以最小堆为例，看二叉堆是如何进行自我调整的。</p><h4 id="3-1-1-插入节点"><a href="#3-1-1-插入节点" class="headerlink" title="3.1.1 插入节点"></a>3.1.1 插入节点</h4><p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置，例如插入一个新节点，值为0；</p><p><img src="http://yanxuan.nosdn.127.net/52ed369c9957d72a17cc62103b092cc5.png" alt="堆插入节点"></p><p>此时，新节点的父节点5比0大，不符合最小堆性质，于是让新节点<strong>“上浮”</strong>，和父节点交互位置。</p><p><img src="http://yanxuan.nosdn.127.net/b46f81834ef6a4e37d6a3e6aae8bb9b8.png" alt="上浮"></p><p>继续用节点0和父节点3做比较，父节点3大于0，则让新节点继续<strong>“上浮”</strong>。</p><p><img src="http://yanxuan.nosdn.127.net/5a1ce21c1736d7ecf5ccca243f445814.png" alt="上浮"></p><p>继续比较，最终新节点0上浮到了堆顶位置。</p><p><img src="http://yanxuan.nosdn.127.net/5790ad21fbff5026dea018d0882b89ca.png" alt="上浮"></p><h4 id="3-1-2-删除节点"><a href="#3-1-2-删除节点" class="headerlink" title="3.1.2 删除节点"></a>3.1.2 删除节点</h4><p>二叉堆删除节点的过程首先<strong>删除的是处于堆顶的节点</strong>，例如下述栗子删除最小堆的堆顶节点1；</p><p><img src="http://yanxuan.nosdn.127.net/71a3816e724e4ae8ff92978c6fc15289.png" alt="删除节点"></p><p>此时，为了继续维持完全二叉树的结果，会把堆最后一个节点10临时补到原本堆顶的位置。</p><p><img src="http://yanxuan.nosdn.127.net/d4e3346fb1f3972cd2e435f3f844bea9.png" alt="维护树"></p><p>接下来，让暂处于堆顶位置的节点10和它的左、右孩子进行比价，找到最小的一个节点，让节点10进行<strong>“下沉”</strong>；</p><p><img src="http://yanxuan.nosdn.127.net/bedd9861d36806c93a5923d45e63fc7c.png" alt="下沉"></p><p>继续继续最小节点查找和<strong>下沉</strong>操作，如上最小节点是7，则让10下沉到7的位置；</p><p><img src="http://yanxuan.nosdn.127.net/ae9e12e579d02ae697c8475b0b09ccf5.png" alt="下沉"></p><p>如此便完成了二叉堆的调整。</p><blockquote><p>简言之：最小堆的自我调整就是小的上浮和大的下沉。</p></blockquote><h4 id="3-1-3-构建二叉堆"><a href="#3-1-3-构建二叉堆" class="headerlink" title="3.1.3 构建二叉堆"></a>3.1.3 构建二叉堆</h4><p>构建二叉堆就是把无序的完全二叉树调整为二叉堆，本质就是让所有非叶子节点依次进行多次<strong>下沉</strong>操作。</p><h4 id="3-1-4-堆的时间复杂度"><a href="#3-1-4-堆的时间复杂度" class="headerlink" title="3.1.4 堆的时间复杂度"></a>3.1.4 堆的时间复杂度</h4><p>堆的插入操作是单一节点的<strong>上浮</strong>，删除操作是单一节点的<strong>下沉</strong>，这两个操作的平均交换次数都是堆高度的一半，所以时间复杂度是O(logn)；构建堆的时间复杂度是O(n)。</p><h3 id="3-2-二叉堆的代码实现"><a href="#3-2-二叉堆的代码实现" class="headerlink" title="3.2 二叉堆的代码实现"></a>3.2 二叉堆的代码实现</h3><p>二叉堆虽然是一个完全二叉树，但存储方式并不是链式存储，而是顺序存储，就是所有节点都存储在数组中。</p><p><img src="http://yanxuan.nosdn.127.net/bfbc4cda66adfd26cffb59323ee49ad2.png" alt="数组实现"></p><p>二叉树使用数组结构来存储节点信息，那么节点计算方式就是：假设父节点下标为parent，那么它的左孩子下标就是<code>2xparent+1</code>，右孩子下标就是<code>2xparent+2</code>。如上栗子中，节点6包含9和10两个孩子节点，节点6在数组中的下标是3，那么根据公式就可计算出，左孩子节点9下标为7(<code>3x2+1</code>)，右孩子节点10下标为8(<code>3x2+2</code>)。</p><ul><li>最小堆代码实现如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package tree;import java.util.ArrayList;&#x2F;** * @Author: zero * @Description: 最小堆 * Date: Create in 2020&#x2F;4&#x2F;30 8:56 * Modified By: *&#x2F;public class MinHeap&lt;T extends Comparable&lt;T&gt;&gt; {    public ArrayList&lt;T&gt; mHeap;    public MinHeap(){        this.mHeap = new ArrayList&lt;T&gt;();    }    &#x2F;**     * 上浮调整     * @param start     *&#x2F;    public void upAdjust(int start){        int current = start;        int father = (current - 1) &#x2F; 2;        T cData = this.mHeap.get(current);        while (current &gt; 0){            int cmp = this.mHeap.get(father).compareTo(cData);            if (cmp &lt;= 0){                break;            }else {                this.mHeap.set(current,this.mHeap.get(father));                current = father;                father = (father - 1) &#x2F; 2;            }        }        this.mHeap.set(current,cData);    }    &#x2F;**     * 下沉调整     * @param start     * @param end     *&#x2F;    public void downAdjust(int start,int end){        int current = start;        int left = (current * 2) + 1;        T cData = this.mHeap.get(current);        while (left &lt;= end){            int tmp = this.mHeap.get(left).compareTo(this.mHeap.get(left + 1));            if (left &lt; end &amp;&amp; tmp &gt; 0){                left++;            }            tmp = cData.compareTo(this.mHeap.get(left));            if (tmp &lt;= 0){                break;            } else {                this.mHeap.set(current,this.mHeap.get(left));                current = left;                left = 2 * left + 1;            }        }        this.mHeap.set(current,cData);    }    &#x2F;**     * 插入数据到最小堆     * @param data     *&#x2F;    public void insert(T data){        int size = this.mHeap.size();        this.mHeap.add(data);        this.upAdjust(size);    }    &#x2F;**     * 删除数据     * @param data     * @return     *&#x2F;    public int remove(T data){        if (this.mHeap.isEmpty() == true){            return -1;        }        int index = this.mHeap.indexOf(data);        if (index == 1){            return -1;        }        int size = this.mHeap.size();        this.mHeap.set(index,this.mHeap.get(size - 1));        this.mHeap.remove(size - 1);        if (this.mHeap.size() &gt; 1){            this.downAdjust(index,this.mHeap.size() - 1);        }        return 1;    }    @Override    public String toString() {        StringBuilder builder = new StringBuilder();        for (int i = 0; i &lt; mHeap.size(); i++) {            builder.append(mHeap.get(i)+&quot; &quot;);        }        return builder.toString();    }    public static void main(String[] args) {        int i;        int a[] = {8,4,3,6,9,7,1,5,2};        MinHeap&lt;Integer&gt; heap = new MinHeap&lt;&gt;();        System.out.printf(&quot;== 依次添加:&quot;);        for (int j = 0; j &lt; a.length; j++) {            System.out.printf(&quot;%d &quot;, a[j]);            heap.insert(a[j]);        }        System.out.printf(&quot;\n== 最小堆:%s&quot;,heap);        i = 15;        heap.insert(i);        System.out.printf(&quot;\n== 添加元素：%d&quot;,i);        System.out.printf(&quot;\n== 最小堆：%s&quot;,heap);        i=1;        heap.remove(i);        System.out.printf(&quot;\n== 删除元素：%d&quot;,i);        System.out.printf(&quot;\n== 最小堆：%s&quot;,heap);        System.out.printf(&quot;\n&quot;);    }}</code></pre><p><a href="https://www.cnblogs.com/skywang12345/p/3610390.html" target="_blank" rel="noopener">参考</a></p><h3 id="3-3-优先队列"><a href="#3-3-优先队列" class="headerlink" title="3.3 优先队列"></a>3.3 优先队列</h3><p>队列的特点是先进先出(FIFO)，入队列新元素置于队尾，出队列队头元素先移出。</p><p>优先队列不在遵循先入先出原则，而是分为两种情况：</p><ul><li>最大优先队列，无论入队顺序如何，都是当前最大元素优先出队</li><li>最小优先队列，无论入队顺序如何，都是当前最小元素优先出队</li></ul><h3 id="3-4-二叉堆的优先队列实现"><a href="#3-4-二叉堆的优先队列实现" class="headerlink" title="3.4 二叉堆的优先队列实现"></a>3.4 二叉堆的优先队列实现</h3><p>回顾二叉堆：最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆的最小元素。</p><p>因此可以用最大堆实现最大优先队列，最小堆实现最小优先队列。</p><ul><li>二叉堆实现最大优先队列</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package tree;import java.util.Arrays;&#x2F;** * @Author: zero * @Description: 二叉堆实现最大优先队列 * Date: Create in 2020&#x2F;4&#x2F;30 10:18 * Modified By: *&#x2F;public class PriorityQueue {    private int[] array;    private int size;    public PriorityQueue(){        &#x2F;&#x2F; 初始化队列初始长度32        this.array = new int[32];    }    &#x2F;**     * 入队     * @param key 入队元素     *&#x2F;    public void enQueue(int key){        if (size &gt;= array.length){            resize();        }        array[size++] = key;        upAdjust();    }    &#x2F;**     * 出队     * @throws Exception     *&#x2F;    public int deQueue() throws Exception{        if (size &lt;= 0){            throw new Exception(&quot;The Queue is Empty!&quot;);        }        &#x2F;&#x2F; 获取堆顶元素        int head = array[0];        &#x2F;&#x2F; 让最后一个元素移动到堆顶        array[0] = array[--size];        &#x2F;&#x2F; 进行下沉调整        downAdjust();        return head;    }    &#x2F;**     * 上浮调整     *&#x2F;    private void upAdjust() {        int childIndex = size - 1;        int parentIndex = childIndex &#x2F; 2;        int temp = array[childIndex];        while (childIndex &gt; 0 &amp;&amp; temp &gt; array[parentIndex]){            &#x2F;&#x2F; 无需交换，单向赋值即可            array[childIndex] = array[parentIndex];            childIndex = parentIndex;            parentIndex = parentIndex &#x2F; 2;        }        array[childIndex] = temp;    }    &#x2F;**     * 下沉调整     *&#x2F;    private void downAdjust() {        int parentIndex = 0;        int temp = array[parentIndex];        int childIndex = 1;        while (childIndex &lt; size){            &#x2F;&#x2F; 如果有右孩子，且右孩子大于左孩子值，则定位到右孩子            if (childIndex + 1 &lt; size &amp;&amp; array[childIndex+1] &gt; array[childIndex]){                childIndex++;            }            &#x2F;&#x2F; 如果父节点大于任何一个孩子的值，直接跳出            if (temp &gt;= array[childIndex]){                break;            }            &#x2F;&#x2F; 无需真正交换，单向赋值即可            array[parentIndex] = array[childIndex];            parentIndex = childIndex;            childIndex = 2 * childIndex + 1;        }        array[parentIndex] = temp;    }    &#x2F;**     * 扩容     *&#x2F;    private void resize(){        int newSize = this.size * 2;        this.array = Arrays.copyOf(this.array,newSize);    }    public static void main(String[] args) throws Exception {        PriorityQueue queue = new PriorityQueue();        queue.enQueue(3);        queue.enQueue(5);        queue.enQueue(10);        queue.enQueue(2);        queue.enQueue(7);        System.out.println(&quot;出队元素：&quot;+queue.deQueue());        System.out.println(&quot;出队元素：&quot;+queue.deQueue());        System.out.println(&quot;出队元素：&quot;+queue.deQueue());    }}</code></pre><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><ul><li>什么是树：树是n个节点的有限集，有且仅有一个特定的称为根的节点。当n&gt;1时，其余节点可分为m个互不相交的有限集，每个集合本身又是一个树，称之为根的子树。</li><li>什么是二叉树：二叉树是树的一种特殊形式，每个节点最多有两个孩子节点，二叉树包括满二叉树和完全二叉树两种形式。<ul><li>满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，且所有叶子节点都在同一层级上。</li><li>完全二叉树：对一个有n个节点的二叉树，按层级顺序编号，所有节点与同样深度的满二叉树所有节点位置相同，则这个二叉树称为完全二叉树。</li></ul></li><li>二叉树的遍历方式有几种<ul><li>按遍历节点之间的关系：前序遍历，中序遍历，后序遍历，层序遍历</li><li>按宏观的角度划分：深度优先遍历和广度优先遍历</li></ul></li><li>什么是二叉堆：二叉堆是一种特殊的满二叉树，分为最大堆和最小堆<ul><li>最大堆：任何一个父节点的值，都大于等于它左、右孩子节点的值</li><li>最小堆：任何一个父节点的值，都小于等于它左、右孩子节点的值</li></ul></li><li>什么是优先队列：优先队列分最大优先队列和最小优先队列<ul><li>最大优先队列：无论入队顺序如何，当前最大元素都会优先出队，基于最大堆实现</li><li>最小优先队列：无论入队顺序如何，当前最小元素都会优先出队，基于最小堆实现</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm trip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java工程对象名词</title>
      <link href="/Other/Java-Noun.html"/>
      <url>/Other/Java-Noun.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Java工程中各种O对象的概念"><a href="#Java工程中各种O对象的概念" class="headerlink" title="Java工程中各种O对象的概念"></a>Java工程中各种O对象的概念</h2><h3 id="1-PO"><a href="#1-PO" class="headerlink" title="1. PO"></a>1. PO</h3><p>Persistent Object，持久对象。</p><p><strong>与数据库里表字段一一对应，映射了数据库中对应的表</strong>。PO由一些属性，以及set/get方法组成；一般情况下，一个表对应一个PO。</p><h3 id="2-VO"><a href="#2-VO" class="headerlink" title="2. VO"></a>2. VO</h3><p>Vlue Object，又名表现层对象(View Object)。</p><p>通常用于业务之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象，可以和表对应，也可以不用，具体根据业务的需求。对于<strong>页面上要展示的对象，可以封装成一个VO对象</strong>，将所需数据封装进去。</p><h3 id="3-BO"><a href="#3-BO" class="headerlink" title="3. BO"></a>3. BO</h3><p>Bussiness Object，业务对象。</p><p>封装业务逻辑的Java对象，通过调用DAO方法，结合PO、VO进行业务操作。一个BO对象可以包括多个PO对象。如常见的工作简历栗子，简历可以理解为一个BO，简历中又包括工作经历，项目经历等，这些可以理解为一个个PO，由这些PO组成BO。</p><h3 id="4-DAO"><a href="#4-DAO" class="headerlink" title="4. DAO"></a>4. DAO</h3><p>Data Access Object，数据访问对象。</p><p>此对象专门用于访问数据库，通常和PO结合使用。DAO中包含了各种操作数据库的方法；通过这些方法，结合PO对数据库进行相关的CURD操作，夹在业务逻辑与数据库资源中间。</p><h3 id="5-DTO"><a href="#5-DTO" class="headerlink" title="5. DTO"></a>5. DTO</h3><p>Data Trasfer Object，数据传输对象。</p><p>主要用于远程调用等需要大量传输对象的地方。比如有一张表有100个字段，那么对应的PO就会有100个属性；但是页面上只需显示10个字段，客户端用Web服务来获取数据，没必要将整个PO对象传递到客户端。</p><p>这时就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构，同时达到客户端传输数据的要求。如果用这个对象来对应页面显示，那此时它的身份就转为了VO。</p><h3 id="6-POJO"><a href="#6-POJO" class="headerlink" title="6. POJO"></a>6. POJO</h3><p>Plain Ordinary Java Object，简单无规则的Java对象，就是传统意义上普通的Java对象。</p><p><a href="https://www.cnblogs.com/shilei-ysl/p/11032304.html" target="_blank" rel="noopener">本文摘录自</a></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Noun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引的发展过程</title>
      <link href="/DataBase/Index-evolve.html"/>
      <url>/DataBase/Index-evolve.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="MySQL索引发展过程"><a href="#MySQL索引发展过程" class="headerlink" title="MySQL索引发展过程"></a>MySQL索引发展过程</h1><h2 id="1-索引是什么？"><a href="#1-索引是什么？" class="headerlink" title="1. 索引是什么？"></a>1. 索引是什么？</h2><p>MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构，索引本质：索引是数据结构。可以简单理解为”<strong>排好序的快速查找B+树数据结构</strong>“。</p><a id="more"></a><p>在MySQL5.5以后默认的InnoDB存储引擎，使用的就是B+树。</p><ul><li>B+树中的B代表平衡(balance)而不是二叉(binary)。</li></ul><h3 id="1-1-检索原理"><a href="#1-1-检索原理" class="headerlink" title="1.1 检索原理"></a>1.1 检索原理</h3><p><strong>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</strong></p><h2 id="2-MySQL索引结构"><a href="#2-MySQL索引结构" class="headerlink" title="2. MySQL索引结构"></a>2. MySQL索引结构</h2><h3 id="2-1-BTREE"><a href="#2-1-BTREE" class="headerlink" title="2.1 BTREE"></a>2.1 BTREE</h3><p>B树(Balance Tree多路平衡查找树)</p><blockquote><p>B-树就是B树，中间横线不是减号。</p></blockquote><h3 id="2-2-为什么是B-树？B-树的发展历程"><a href="#2-2-为什么是B-树？B-树的发展历程" class="headerlink" title="2.2 为什么是B+树？B+树的发展历程"></a>2.2 为什么是B+树？B+树的发展历程</h3><p>InnoDB存储引擎并非一开始就选择的B+树，而是经过了以下的迭代过程。</p><h4 id="2-2-1-全部遍历"><a href="#2-2-1-全部遍历" class="headerlink" title="2.2.1 全部遍历"></a>2.2.1 全部遍历</h4><p>没有索引的情况，任何查找都要全表扫描，自然不可能使用这个。</p><h4 id="2-2-2-Hash"><a href="#2-2-2-Hash" class="headerlink" title="2.2.2 Hash"></a>2.2.2 Hash</h4><p>加速查询速度的数据结构，常见的有两类：</p><ul><li>哈希，例如HashMap，CRUD平均时间复杂度是<code>O(1)</code>；意思只要查询一次就能找到，最好的算法。但是，如果SQL语句中使用到<strong>范围查找或排序查找</strong>等SQL条件，哈希索引性能就会退化为<code>O(n)</code>，变成了最差的算法。</li><li>树，例如平衡二叉树，CRUD的平均时间复杂度都是<code>O(log2(n))</code>，不会因为使用到范围/排序等SQL条件的影响，依然保持<code>O(log2(n))</code>的效率，非常稳定。</li></ul><blockquote><p>InnoDB不支持哈希索引</p></blockquote><h4 id="2-2-3-二叉树"><a href="#2-2-3-二叉树" class="headerlink" title="2.2.3 二叉树"></a>2.2.3 二叉树</h4><p>二叉搜索树的特点：</p><ol><li>一个节点只能有两个子节点，就是说一个节点度不能超过2；</li><li>左子节点小于当前节点，右子节点大于等于当前节点。</li></ol><p><img src="http://yanxuan.nosdn.127.net/a20927a4f5a14a3b0885a1d055b5689b.png" alt="二叉搜索树"></p><ul><li>查找时间复杂度<ul><li>深度为1的节点查找次数为1</li><li>深度为2的节点查找次数为2</li><li>深度为N的节点查找次数为N</li></ul></li><li><p>故可得知：二叉搜索树的平均时间复杂度和树的高度成正比，平均时间复杂度为<code>O(logn)</code>。</p></li><li><p>缺点：如果插入的值是持续递增的，那么二叉树就会出现<strong>“右倾”现象</strong>，从树退化成链表结构，导致其时间复杂度退化为了<code>O(n)</code>，这就是二叉搜索树的不平衡。</p></li></ul><p><img src="http://yanxuan.nosdn.127.net/bfefd12b5f3acce916d24da43a4dae65.png" alt="右倾现象"></p><blockquote><p>以上二叉树图均来自于该网站的<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">数据结构可视化</a>，可加深对二叉树的理解。</p></blockquote><h4 id="2-2-4-平衡二叉树-AVL"><a href="#2-2-4-平衡二叉树-AVL" class="headerlink" title="2.2.4 平衡二叉树(AVL)"></a>2.2.4 平衡二叉树(AVL)</h4><p>平衡二叉树（Balanced BinaryTree）又被称为AVL树。它具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 </p><p><img src="http://yanxuan.nosdn.127.net/286847f73a82cfdf691d5fe50e45a4b2.png" alt="AVL树"></p><p>平衡二叉树会在插入数据时维护一个平衡因子，让树在不平衡时进行左旋或右旋，<a href="https://blog.csdn.net/u014634338/article/details/42465089" target="_blank" rel="noopener">具体可见文章</a>。</p><ul><li>缺点：如上图插入10条数据，树的高度就达到了4层；<strong>数据量越多，树高就越高</strong>，树越高，查找次数越多，IO次数也就越多，从而导致系统性能下降。这就是树高度问题导致的磁盘IO过多。</li></ul><p>因此要想办法将树的高度降下来，通过降低树的高度达到减少IO次数。</p><h4 id="2-2-5-B树"><a href="#2-2-5-B树" class="headerlink" title="2.2.5 B树"></a>2.2.5 B树</h4><p>B树(B-Tree)是一种多叉平衡查找树，每个节点可能有两个或三个，如下图所示：</p><p><img src="http://yanxuan.nosdn.127.net/e7a6895bea30c9460d56dbbe35aa0276.png" alt="B-Tree"></p><ul><li>底层原理</li></ul><p>数据库索引是存储在硬盘上的，如果数据量很大，也会导致索引很大，超过几个G；当我们利用索引查询时，不可能将全部几个G的索引都加载进内存的，因此使用的是<strong>逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</strong></p><ul><li>磁盘页/块</li></ul><p>系统从磁盘读取数据到内存时是以磁盘块(block)为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB存储引擎中有页(Page)的概念，页是其磁盘管理的最小单位。系统一个磁盘块的存储空间往往是有限的，因此InnoDB每次申请磁盘空间时都会是<strong>若干地址连续的磁盘块来达到一页的大小16KB</strong>。</p><p>MySQL中使用<code>show global status like &quot;Innodb_page_size;&quot;</code>命令可以查看当前数据库配置的磁盘页大小，默认大小为16KB。</p><p>InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘IO次数，提高查询效率。</p><p>可以把索引文件想象成一本书，而磁盘页就是其中的一页，里面存储的索引信息，写满一页才会写下一页。</p><ul><li>B树检索原理</li></ul><p><img src="https://s1.ax1x.com/2020/07/30/aKXdGq.png" alt="B树检索"></p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。</p><p>以下模拟查找关键字29的过过程：</p><ul><li>根据根节点找到磁盘块1，读入内存；[<strong>磁盘第一次IO</strong>]</li><li>比较关键字29所在区间(在17,35之间)，找到该区间指针磁盘1P2；</li><li>根据P2指针找到磁块3，读入内存；[<strong>磁盘第二次IO</strong>]</li><li>比较关键字29所在区间(26,30之间)，找到该区间指针磁盘3P2；</li><li>根据P2指针找到磁盘8，读入内存。[<strong>磁盘第三次IO</strong>]</li><li>在磁盘8中找到对应关键字29。</li></ul><p>如上过程，发生了3次磁盘I/O操作和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个BTree查找效率的决定因素。BTree相对于ALVTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><blockquote><p>如上操作，B树比AVL树减少了一次IO操作，故取代了它。</p></blockquote><h4 id="2-2-6-B-树"><a href="#2-2-6-B-树" class="headerlink" title="2.2.6 B+树"></a>2.2.6 B+树</h4><p><img src="http://yanxuan.nosdn.127.net/f4d172507b28beab756908d0fdff3d5f.png" alt="B+Tree"></p><p>如图所示，可以看出所有data信息都移动到了叶子节点中，且子节点和子节点之间会有一个指针指向，这也是B+树的核心点，有序的链表结构，这样可以大大提升<strong>范围查询效率</strong>，也方便<strong>遍历</strong>整个树。</p><ul><li>非叶子节点不再存储数据，数据<strong>只存储在同一层的叶子节点</strong>上；</li><li><p>叶子之间，增加了链表，获取所有节点，不再需要<strong>中序遍历</strong>了。</p></li><li><p>中序遍历首先遍历左子树，然后访问根节点，最后遍历右子树；若二叉树为空则结束返回，否则继续。</p><ul><li><blockquote><p>简言之：中序遍历就是左中右</p></blockquote></li></ul></li><li><p><strong>B+树检索原理</strong></p></li></ul><p>由于B+树的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+树后其结构变成如下图所示：</p><p><img src="https://s1.ax1x.com/2020/07/30/aMSmC9.png" alt="B+Tree索引结构"></p><p>在<strong>B树中</strong>，每个节点不仅仅包含数据的key值，还有data值。而每一页的存储空间是有限的，如果data数据较大时将会导致每个节点(即一页)能存储的key的数量很少，当存储的数据量很大时同样会导致B树的深度较大，增大查询IO次数从而影响效率。</p><p>但在<strong>B+树中</strong>，所有数据记录节点都是按照键值大小顺序存放在<strong>同一层的叶子节点上</strong>，而非叶子节点只存储key信息，这样可以大大增加每个节点存储的key值数量，从而降低B+树的高度。</p><ul><li>InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存储键值+指针。</li><li>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中。</li></ul><p>B+树算法：通过继承了B树的特征，B+树相比B树，新增叶子节点和非叶子节点的关系。</p><ul><li>叶子节点中包含了键值和数据；</li><li>非叶子节点中只包含键值和子节点引用，不包含数据；</li><li>通过非叶子节点查询叶子节点获取对应的数据，所有相邻的叶子节点包含非叶子节点使用<strong>有序链表进行结合</strong>，叶子节点是<strong>顺序排序</strong>且相邻节点<strong>有顺序</strong>引用的关系。</li></ul><h2 id="3-面试题"><a href="#3-面试题" class="headerlink" title="3. 面试题"></a>3. 面试题</h2><p>B+树是在B树基础上的一种优化，使其更适合实现外存储索引结构，<strong>InnoDB存储引擎就是使用B+树实现索引结构。</strong></p><h3 id="3-1-B树和B-树的区别"><a href="#3-1-B树和B-树的区别" class="headerlink" title="3.1 B树和B+树的区别"></a>3.1 B树和B+树的区别</h3><ul><li>B树没有叶子节点和非叶子节点之分，故B树的非叶子节点可以存储键值和数据。</li><li>B+树的非叶子节点只存储键值信息，所有数据记录都存放在叶子节点中，故B+树每一页可以存放更多的key信息，从而降低树高。</li><li>B+树的叶子节点之间都有一个链指针。</li></ul><h3 id="3-2-B-树相比B树的优势"><a href="#3-2-B-树相比B树的优势" class="headerlink" title="3.2 B+树相比B树的优势"></a>3.2 B+树相比B树的优势</h3><ol><li>IO次数更少，体现在以下几点：<ol><li>范围查询时，相比于B树查询范围时的中序遍历，B+树只需遍历链表即可完成，IO次数更少；</li><li>由于B+树只在叶子节点存储数据，使得同样大小的磁盘页B+树能容纳更多的节点元素，意味着在数据量相同情况下，B+树结构比B树更“矮胖”，树高更低，因此IO次数也更少。</li></ol></li><li>查询性能稳定：B树由于枝节点也存储数据，所有查询性能不稳定(最优只查根节点、最坏查到叶子节点)，而B+树的每一次查找都是稳定的。</li><li>范围查询简便：有序链表结构，范围查询无需中序遍历。</li></ol><h3 id="3-2-本文基本要求"><a href="#3-2-本文基本要求" class="headerlink" title="3.2 本文基本要求"></a>3.2 本文基本要求</h3><p>要求说出上述所有索引结构，以及各自优缺点。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL Index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO</title>
      <link href="/JavaAdvanced/NIO.html"/>
      <url>/JavaAdvanced/NIO.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="NIO相关API"><a href="#NIO相关API" class="headerlink" title="NIO相关API"></a>NIO相关API</h1><h2 id="1-NIO与IO的区别"><a href="#1-NIO与IO的区别" class="headerlink" title="1. NIO与IO的区别"></a>1. NIO与IO的区别</h2><p>Java NIO(New IO)是从Java1.4 版本开始引入的一个新的IO API，可以代替标准的Java IO API。</p><p>NIO与原来的IO有同样的作用和目的，但是使用方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件读写操作。</p><h3 id="1-1-Java-NIO与IO的主要区别"><a href="#1-1-Java-NIO与IO的主要区别" class="headerlink" title="1.1 Java NIO与IO的主要区别"></a>1.1 Java NIO与IO的主要区别</h3><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(Non Blocking IO)</td></tr><tr><td>无</td><td>选择器(Selectors)</td></tr></tbody></table><h3 id="1-2-通道和缓冲区"><a href="#1-2-通道和缓冲区" class="headerlink" title="1.2 通道和缓冲区"></a>1.2 通道和缓冲区</h3><p>Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到IO设备(例如文件、套接字)的连接。若需使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p><blockquote><p>简言之：Channel负责传输，Buffer负责存储。</p></blockquote><h2 id="2-缓存区-Buffer-的数据存取"><a href="#2-缓存区-Buffer-的数据存取" class="headerlink" title="2. 缓存区(Buffer)的数据存取"></a>2. 缓存区(Buffer)的数据存取</h2><p>缓冲区是一个用于特定基本数据类型的容器，由<code>java.nio</code>包定义的，所有缓冲区都是Buffer抽象类的子类。</p><p>在Java NIO中负责数据的存取，缓冲区就是数组，存储不同数据类型的数据。根据数据类型的不同(除boolean外)，提供了相应类型的缓冲区，以下是Buffer常用子类：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBufer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>上述缓冲区的管理方式几乎一致，通过<code>allocate()</code>获取缓冲区</p><h3 id="2-1-缓冲区操作数据的两个核心方法"><a href="#2-1-缓冲区操作数据的两个核心方法" class="headerlink" title="2.1 缓冲区操作数据的两个核心方法"></a>2.1 缓冲区操作数据的两个核心方法</h3><p>Buffer所有子类提供了两个用于数据操作的方法，get和put；</p><ul><li><p>获取Buffer中的数据</p><ul><li><code>get()</code>：读取单个字节；</li><li><code>get(byte[] dst)</code>：批量读取多个字节到dst中；</li><li><code>get(int index)</code>：读取指定索引位置的字节。</li></ul></li><li><p>存放数据到Buffer中</p><ul><li><code>put(byte b)</code>：将给定的单个字节写入到缓冲区的当前位置；</li><li><code>put(byte[] src)</code>：将src中的字节写入到缓冲区的当前位置；</li><li><code>put(int index,byte b)</code>：将指定字节写入到缓冲区的索引位置。</li></ul></li></ul><h3 id="2-2-缓冲区的四个核心属性"><a href="#2-2-缓冲区的四个核心属性" class="headerlink" title="2.2 缓冲区的四个核心属性"></a>2.2 缓冲区的四个核心属性</h3><ul><li>capacity(容量)：表示缓冲区中最大存储数据的容量，一旦声明不可改变；</li><li>limit(界限)：表示缓冲区中可以操作数据的大小，位于limit后的数据不可读写，不能大于容量；</li><li>position(位置)：表示缓冲区中正在操作数据的位置，不能大于界限；</li><li>mark(标记)与重置(reset)：标记是一个索引，表示记录当前position的位置，可以通过<code>reset()</code>恢复到mark的位置。</li></ul><blockquote><p>以上属性必须遵循：0&lt;=mark &lt;= position &lt;= limit &lt;= capacity</p></blockquote><h3 id="2-3-Buffer常用方法"><a href="#2-3-Buffer常用方法" class="headerlink" title="2.3 Buffer常用方法"></a>2.3 Buffer常用方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>int capacity()</code></td><td>返回Buffer的容量大小；</td></tr><tr><td><code>int limit()</code></td><td>返回Buffer的界限位置；</td></tr><tr><td><code>int position()</code></td><td>返回缓冲区的当前位置；</td></tr><tr><td><code>Buffer limit(int n)</code></td><td>将缓存区界限设置为n，并返回一个具有新limit的缓冲区对象；</td></tr><tr><td><code>Buffer position(int n)</code></td><td>将缓存区的当前位置设置为n，并返回修改后的Buffer对象；</td></tr><tr><td><code>Buffer mark()</code></td><td>对缓冲区设置标记；</td></tr><tr><td><code>Buffer reset()</code></td><td>将当前位置position转到以前设置的mark所在位置；</td></tr><tr><td><code>Buffer flip()</code></td><td>将缓冲区界限设为当前位置，并将当前位置设为0，就是切换到读模式；</td></tr><tr><td><code>Buffer clear()</code></td><td>清空缓冲区并返回对缓冲区的引用；</td></tr><tr><td><code>boolean hasRemaining()</code></td><td>判断缓冲区中是否还有元素；</td></tr><tr><td><code>int remaining()</code></td><td>返回position和limit之间的元素个数，就是返回剩余可读元素个数；</td></tr><tr><td><code>Buffer rewind()</code></td><td>将当前位置设为0，并取消设置的mark。</td></tr></tbody></table><h3 id="2-4-代码案例"><a href="#2-4-代码案例" class="headerlink" title="2.4 代码案例"></a>2.4 代码案例</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class TestBuffer {    @Test    public void test1(){        String str = &quot;abcde&quot;;        &#x2F;&#x2F; 1. 分配一个指定大小的缓冲区        ByteBuffer buf = ByteBuffer.allocate(1024);        showBufferInfo(buf);        &#x2F;&#x2F; 2. 使用put()存入数据到缓冲区中        System.out.println(&quot;==========put()===========&quot;);        buf.put(str.getBytes());        showBufferInfo(buf);        &#x2F;&#x2F; 3. 切换到读取数据模式,不切换get时会报：BufferUnderflowException，缓冲区溢出异常        System.out.println(&quot;==========flip()==========&quot;);        buf.flip();        showBufferInfo(buf);        &#x2F;&#x2F; 4. 利用get()读取缓冲区中的数据        System.out.println(&quot;===========get()===========&quot;);        byte[] dst = new byte[buf.limit()];        buf.get(dst);        System.out.println(new String(dst,0,dst.length));        showBufferInfo(buf);        &#x2F;&#x2F; 5. rewind:可重复读        System.out.println(&quot;===========rewind()===========&quot;);        buf.rewind();        showBufferInfo(buf);        &#x2F;&#x2F; 6. 清空缓冲区,缓冲区中的数据依然存在，但是无指针指向，处于“被遗忘”状态        System.out.println(&quot;===========clear()===========&quot;);        buf.clear();        showBufferInfo(buf);    }    @Test    public void testMark(){        String str = &quot;abcde&quot;;        &#x2F;&#x2F; 1. 分配一个指定大小的缓冲区        ByteBuffer buf = ByteBuffer.allocate(1024);        buf.put(str.getBytes());        buf.flip();        byte[] dst = new byte[buf.limit()];        buf.get(dst,0,2);        System.out.println(new String(dst,0,2));        System.out.println(&quot;当前指针位置:&quot;+buf.position());        &#x2F;&#x2F; mark:标记位置        System.out.println(&quot;==========use mark()===========&quot;);        buf.mark();        buf.get(dst,2,2);        System.out.println(new String(dst,2,2));        System.out.println(&quot;当前指针位置:&quot;+buf.position());        &#x2F;&#x2F; reset():恢复到mark位置        System.out.println(&quot;===========use reset()===========&quot;);        buf.reset();        System.out.println(&quot;当前指针位置:&quot;+buf.position());        &#x2F;&#x2F; 判断缓冲区中是否还有剩余可操作数据        if (buf.hasRemaining()){            &#x2F;&#x2F; 输出可操作数据的数量            System.out.println(&quot;余剩还可操作:&quot;+buf.remaining());        }    }    public static void showBufferInfo(Buffer buffer){        System.out.println(&quot;当前位置:&quot;+buffer.position());        System.out.println(&quot;界限:&quot;+buffer.limit());        System.out.println(&quot;最大容量:&quot;+buffer.capacity());    }}</code></pre><h2 id="3-直接缓冲区与非直接缓冲区"><a href="#3-直接缓冲区与非直接缓冲区" class="headerlink" title="3. 直接缓冲区与非直接缓冲区"></a>3. 直接缓冲区与非直接缓冲区</h2><p>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则Java虚拟机会尽最大努力直接在此缓冲区上执行本机I/O操作。也就是说，在每次调用基础操作系统的一个本机I/O操作之前(或之后)，虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中(或从中间缓冲区中复制内容)。</p><h3 id="3-1-非直接缓冲区"><a href="#3-1-非直接缓冲区" class="headerlink" title="3.1 非直接缓冲区"></a>3.1 非直接缓冲区</h3><p>非直接缓冲区：通过<code>allocate()</code>方法分配缓冲区，将缓冲区建立在JVM的内存中，以下为操作原理图：</p><p><img src="http://yanxuan.nosdn.127.net/b2c1547d89c6ee9b6b0b82d3747e7ab0.png" alt="非直接缓冲区"></p><h3 id="3-2-直接缓冲区"><a href="#3-2-直接缓冲区" class="headerlink" title="3.2 直接缓冲区"></a>3.2 直接缓冲区</h3><p>直接缓冲区：通过<code>allocateDirect()</code>方法分配直接缓冲区，将缓冲区建立在物理内存中，可以提高效率。</p><p><img src="http://yanxuan.nosdn.127.net/74f44e2c46233b635a3fecbc8ce64ee6.png" alt="UTOOLS1586338196458.png"></p><p>此方法返回的缓冲区进行<strong>分配和取消分配所需成本通常高于非直接缓冲区</strong>。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。</p><p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其<code>isDirect()</code>方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。</p><h2 id="4-通道-Channel-的原理与获取"><a href="#4-通道-Channel-的原理与获取" class="headerlink" title="4. 通道(Channel)的原理与获取"></a>4. 通道(Channel)的原理与获取</h2><p>通道由<code>java.nio.channels</code>包定义，表示IO源与目标打开的连接。Channel类似于传统的“流”，只不过Channel本身不能直接访问数据，而是提供了一个通道用以传输数据，Channel只能与Buffer进行交互。</p><p><img src="http://yanxuan.nosdn.127.net/1729e787306e62154017bd3a078b1b65.png" alt="Channel"></p><h3 id="4-1-通道的主要实现类"><a href="#4-1-通道的主要实现类" class="headerlink" title="4.1 通道的主要实现类"></a>4.1 通道的主要实现类</h3><p>Java为Channel接口提供的最主要实现类如下：</p><ul><li>FileChannel：用于读取、写入、映射和操作文件的通道；</li><li>SocketChannel：通过TCP读写网络中的数据；</li><li>ServerSocketChannel：可以监听新进来的TCP连接，对每个新连接都会创建一个SocketChannel；</li><li>DatagramChannel：通过UDP读写网络中的数据通道。</li></ul><h3 id="4-2-获取通道"><a href="#4-2-获取通道" class="headerlink" title="4.2 获取通道"></a>4.2 获取通道</h3><p>Java针对支持通道的类提供了<code>getChannel()</code>方法，支持通道的类如下：</p><ul><li>本地IO<ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li></ul></li><li>网络IO<ul><li>Socket</li><li>ServerSocket</li><li>DatagramSocket</li></ul></li></ul><p>还可使用Files工具类的<code>newByteChannel()</code>方法获取字节通道，或使用通道的静态方法<code>open()</code>打开并返回指定通道。</p><h2 id="5-通道的数据传输与内存映射文件"><a href="#5-通道的数据传输与内存映射文件" class="headerlink" title="5. 通道的数据传输与内存映射文件"></a>5. 通道的数据传输与内存映射文件</h2><h3 id="5-1-使用非直接缓冲区完成文件复制"><a href="#5-1-使用非直接缓冲区完成文件复制" class="headerlink" title="5.1 使用非直接缓冲区完成文件复制"></a>5.1 使用非直接缓冲区完成文件复制</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test1() throws Exception {    long start = System.currentTimeMillis();    &#x2F;&#x2F; 获取文件IO流对象    FileInputStream fis = new FileInputStream(&quot;D:\\bigFile.mp4&quot;);    FileOutputStream fos = new FileOutputStream(&quot;D:\\test1.mp4&quot;);    &#x2F;&#x2F; ① 获取通道    FileChannel inChannel = fis.getChannel();    FileChannel outChannel = fos.getChannel();    &#x2F;&#x2F; ② 分配缓冲区    ByteBuffer buffer = ByteBuffer.allocate(1024);    &#x2F;&#x2F; ③ 将通道中的数据存入缓冲区中    while (inChannel.read(buffer) != -1){        &#x2F;&#x2F; 切换到读数据模式        buffer.flip();        &#x2F;&#x2F; ④ 将缓冲区中的数据写入通道中        outChannel.write(buffer);        &#x2F;&#x2F; 清空缓冲区        buffer.clear();    }    &#x2F;&#x2F; 释放资源    outChannel.close();    inChannel.close();    fos.close();    fis.close();    long end = System.currentTimeMillis();    System.out.println(&quot;耗费时间:&quot; + (end - start)); &#x2F;&#x2F; 17490}</code></pre><h3 id="5-2-使用直接缓冲区完成文件的复制-内存映射文件"><a href="#5-2-使用直接缓冲区完成文件的复制-内存映射文件" class="headerlink" title="5.2 使用直接缓冲区完成文件的复制(内存映射文件)"></a>5.2 使用直接缓冲区完成文件的复制(内存映射文件)</h3><p>直接字节缓冲区还可以通过 FileChannel 的<code>map()</code>方法将文件区域直接映射到内存中来创建。该方法返回<br>MappedByteBuffer 。Java 平台的实现有助于通过JNI(Java本地接口)从本机代码创建直接字节缓冲区。如果以上这些缓冲区 中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test2() throws Exception {    long start = System.currentTimeMillis();    FileChannel inChannel = FileChannel.open(Paths.get(&quot;D:\\bigFile.mp4&quot;), StandardOpenOption.READ);    &#x2F;&#x2F; 创建一个通道，CREATE_NEW:文件不存在则创建，存在则报错    FileChannel outChannel = FileChannel.open(Paths.get(&quot;D:\\test2.mp4&quot;), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE_NEW);    &#x2F;&#x2F; 创建内存映射文件    MappedByteBuffer inMapBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());    MappedByteBuffer outMapBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());    &#x2F;&#x2F; 直接对缓冲区进行数据的读写操作    byte[] dst = new byte[inMapBuffer.limit()];    inMapBuffer.get(dst);    outMapBuffer.put(dst);    &#x2F;&#x2F; 释放资源    inChannel.close();    outChannel.close();    long end = System.currentTimeMillis();    System.out.println(&quot;耗费时间:&quot; + (end - start)); &#x2F;&#x2F; 2854}</code></pre><h3 id="5-3-通道之间的数据传输-直接缓冲区"><a href="#5-3-通道之间的数据传输-直接缓冲区" class="headerlink" title="5.3 通道之间的数据传输(直接缓冲区)"></a>5.3 通道之间的数据传输(直接缓冲区)</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test3 ()throws Exception{    long start = System.currentTimeMillis();    FileChannel inChannel = FileChannel.open(Paths.get(&quot;D:\\bigFile.mp4&quot;), StandardOpenOption.READ);    FileChannel outChannel = FileChannel.open(Paths.get(&quot;D:\\test3.mp4&quot;),StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE);    &#x2F;&#x2F; 将数据源从源通道传输到另一通道    &#x2F;&#x2F;        inChannel.transferTo(0,inChannel.size(),outChannel);    outChannel.transferFrom(inChannel,0,inChannel.size());    inChannel.close();    outChannel.close();    long end = System.currentTimeMillis();    System.out.println(&quot;耗费时间:&quot; + (end - start));}</code></pre><h2 id="6-分散读取与聚集写入"><a href="#6-分散读取与聚集写入" class="headerlink" title="6. 分散读取与聚集写入"></a>6. 分散读取与聚集写入</h2><ul><li>分散读取(Scattering Reads)：指将通道中的读取的数据分散到多个缓冲区中；</li><li>聚集写入(Gathering Writes)：将多个缓冲区中的数据聚集到通道中。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test4() throws Exception{    &#x2F;&#x2F; 一、分散读取    RandomAccessFile file = new RandomAccessFile(&quot;D:\\1.md&quot;, &quot;rw&quot;);    &#x2F;&#x2F; 1. 获取通道    FileChannel channel1 = file.getChannel();    &#x2F;&#x2F; 2. 分配指定大小的缓冲区    ByteBuffer buf1 = ByteBuffer.allocate(250);    ByteBuffer buf2 = ByteBuffer.allocate(1024);    &#x2F;&#x2F; 3. 分散读取    ByteBuffer[] bufs = {buf1,buf2};    channel1.read(bufs);    &#x2F;&#x2F; 4. 将所有缓冲区切换至读模式    for (ByteBuffer byteBuffer:bufs){        byteBuffer.flip();    }    &#x2F;&#x2F; 5. 打印两个缓冲区中的数据内容    System.out.println(new String(bufs[0].array(),0,bufs[0].limit()));    System.out.println(&quot;===============================&quot;);    System.out.println(new String(bufs[1].array(),0,bufs[1].limit()));    &#x2F;&#x2F; 二、聚集写入    RandomAccessFile rw = new RandomAccessFile(&quot;D:\\2.md&quot;, &quot;rw&quot;);    FileChannel channel2 = rw.getChannel();    channel2.write(bufs);}</code></pre><h2 id="7-字符集Charset"><a href="#7-字符集Charset" class="headerlink" title="7. 字符集Charset"></a>7. 字符集Charset</h2><p>Charset字符集对象可以编解码数据，同类型编码的数据只能由同类型解码器解码。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void TestCharset() throws Exception{    &#x2F;&#x2F; 打印所有字符集    &#x2F;&#x2F;        SortedMap&lt;String, Charset&gt; map = Charset.availableCharsets();    &#x2F;&#x2F;        Set&lt;Map.Entry&lt;String, Charset&gt;&gt; set = map.entrySet();    &#x2F;&#x2F;        for ( Map.Entry&lt;String, Charset&gt; entry : set) {    &#x2F;&#x2F;            System.out.println(entry.getKey()+&quot;=&quot;+entry.getValue());    &#x2F;&#x2F;        }    Charset cs1 = Charset.forName(&quot;GBK&quot;);    &#x2F;&#x2F; 获取编解码器    CharsetEncoder ce = cs1.newEncoder();    CharsetDecoder cd = cs1.newDecoder();    &#x2F;&#x2F; 获取字符缓冲区    CharBuffer cBuf = CharBuffer.allocate(1024);    cBuf.put(&quot;字符串编解码&quot;);    cBuf.flip();    &#x2F;&#x2F; 编码    ByteBuffer bBuf = ce.encode(cBuf);    for (int i = 0; i &lt; 12; i++) {        System.out.println(bBuf.get());    }    bBuf.flip();    &#x2F;&#x2F; 解码    CharBuffer cb = cd.decode(bBuf);    System.out.println(cb.toString());    System.out.println(&quot;========GBK编码，UTF-8解码========&quot;);    Charset u8 = Charset.forName(&quot;UTF-8&quot;);    bBuf.flip();    CharBuffer decode = u8.decode(bBuf);    System.out.println(decode.toString());}</code></pre><blockquote><p>注意：编解码前，要将缓冲区设置为读模式，不然读取不到数据。</p></blockquote><h2 id="8-阻塞与非阻塞"><a href="#8-阻塞与非阻塞" class="headerlink" title="8. 阻塞与非阻塞"></a>8. 阻塞与非阻塞</h2><h3 id="8-1-阻塞"><a href="#8-1-阻塞" class="headerlink" title="8.1 阻塞"></a>8.1 阻塞</h3><p>传统的IO流都是阻塞式的。也就是说，当一个线程调用<code>read()</code>或<code>write()</code>时，该线程会被阻塞，直到有些数据被读取或写入，该线程在此期间不能执行其他任务。</p><p>因此，在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端请求时，性能会急剧下降。</p><h3 id="8-2-非阻塞"><a href="#8-2-非阻塞" class="headerlink" title="8.2 非阻塞"></a>8.2 非阻塞</h3><p>Java NIO是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或少数几个线程来同时处理连接到服务器端的所有客户端。</p><h3 id="8-3-选择器-Selector"><a href="#8-3-选择器-Selector" class="headerlink" title="8.3 选择器(Selector)"></a>8.3 选择器(Selector)</h3><p>选择器是SelectableChannle对象的多路复用器，Selector 可 以同时监控多个 SelectableChannel 的IO 状况，也就是说，利用 Selector  可使一个单独的线程管理多个 Channel。<strong>Selector 是非阻塞IO 的核心。</strong></p><h4 id="8-3-1-选择器的应用"><a href="#8-3-1-选择器的应用" class="headerlink" title="8.3.1 选择器的应用"></a>8.3.1 选择器的应用</h4><ul><li>创建Selector：通过调用<code>Selector.open()</code>方法创建一个Selector。</li><li>向选择器注册通道：<code>SelectableChannel.register(Selector sel,int ops)</code></li><li>Selector的常用方法如下：</li></ul><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>Set&lt;SelectionKey&gt; keys()</code></td><td style="text-align:left">所有的 SelectionKey 集合。代表注册在该Selector上的Channel</td></tr><tr><td style="text-align:center">selectedKeys()</td><td style="text-align:left">被选择的 SelectionKey 集合。返回此Selector的已选择键集</td></tr><tr><td style="text-align:center">int select()</td><td style="text-align:left">监控所有注册的Channel，当它们中间有需要处理的 IO 操作时， 该方法返回，并将对应得的 SelectionKey 加入被选择的 SelectionKey 集合中，该方法返回这些 Channel 的数量。</td></tr><tr><td style="text-align:center">int select(long timeout)</td><td style="text-align:left">可以设置超时时长的 select() 操作</td></tr><tr><td style="text-align:center">int selectNow()</td><td style="text-align:left">执行一个立即返回的 select() 操作，该方法不会阻塞线程</td></tr><tr><td style="text-align:center">Selector wakeup()</td><td style="text-align:left">使一个还未返回的 select() 方法立即返回</td></tr><tr><td style="text-align:center">void close()</td><td style="text-align:left">关闭该选择器</td></tr></tbody></table><h4 id="8-3-2-SelectionKey"><a href="#8-3-2-SelectionKey" class="headerlink" title="8.3.2 SelectionKey"></a>8.3.2 SelectionKey</h4><p>SelectionKey表示SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操 作。  </p><ul><li>当调用<code>register(Selector sel,int ops)</code>将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数ops指定。<ul><li>可以监听的事件类型(可使用SelectionKey的四个常量表示)：</li></ul></li><li><p>读：SelectionKey.OP_READ(1)</p></li><li><p>写：SelectionKey.OP_WRITE(4)</p></li><li><p>连接：SelectionKey.OP_CONNECT(8)</p></li><li><p>接收：SelectionKey.OP_ACCEPT(16)</p></li></ul><ul><li><p>若注册时不止监听一个时间，则可以使用“位或”操作符连接：<code>SelectionKey.OP_READ|SelectionKey.OP_WRITE</code></p></li><li><p>SelectionKey的常用方法</p></li></ul><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">int interestOps()</td><td style="text-align:center">获取感兴趣事件集合</td></tr><tr><td style="text-align:center">int readyOps()</td><td style="text-align:center">获取通道已经准备就绪的操作的集合</td></tr><tr><td style="text-align:center">SelectableChannel channel()</td><td style="text-align:center">获取注册通道</td></tr><tr><td style="text-align:center">Selector selector()</td><td style="text-align:center">返回选择器</td></tr><tr><td style="text-align:center">boolean isReadable()</td><td style="text-align:center">检测Channel中读事件是否就绪</td></tr><tr><td style="text-align:center">boolean isWritable()</td><td style="text-align:center">检测Channel中写事件是否就绪</td></tr><tr><td style="text-align:center">boolean isConnectable()</td><td style="text-align:center">检测Channel中连接释放就绪</td></tr><tr><td style="text-align:center">boolean isAcceptable()</td><td style="text-align:center">检测Channel中接收是否就绪</td></tr></tbody></table><h3 id="8-4-SocketChannel"><a href="#8-4-SocketChannel" class="headerlink" title="8.4 SocketChannel"></a>8.4 SocketChannel</h3><ul><li>SocketChannel：在Java NIO中SocketChannel是一个连接到TCP网络套接字的通道。</li><li>ServerSocketChannel ：Java NIO中的 ServerSocketChannel 是一个可以 监听新进来的TCP连接的通道，就像标准IO中 的ServerSocket一样。</li></ul><h2 id="9-阻塞式"><a href="#9-阻塞式" class="headerlink" title="9. 阻塞式"></a>9. 阻塞式</h2><p>网络通信有以下几个核心：</p><ul><li>通道：负责传输数据，来自于<code>java.nio.channels.Channel</code>接口，主要有以下几个实现类<ul><li>SocketChannel</li><li>ServerSocketChannel</li><li>DatagramChannel</li></ul></li><li>缓冲区：负责数据的存取</li><li>选择器(Selector)：是SelectableChannel的多路复用器，用于监控SelectableChannel的IO状况</li></ul><h3 id="9-1-阻塞式简单案例"><a href="#9-1-阻塞式简单案例" class="headerlink" title="9.1 阻塞式简单案例"></a>9.1 阻塞式简单案例</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class TestBlockingNIO {    &#x2F;&#x2F; 客户端    @Test    public void client() throws Exception{        &#x2F;&#x2F; 1. 获取网络通道        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;,8899));        &#x2F;&#x2F; 2. 打开本地文件通道        FileChannel fileChannel = FileChannel.open(Paths.get(&quot;D:\\IDEADemos\\Interview\\src\\Java基础\\Nio\\1.jpg&quot;), StandardOpenOption.READ);        &#x2F;&#x2F; 3. 分配缓冲区        ByteBuffer buffer = ByteBuffer.allocate(1024);        &#x2F;&#x2F; 4. 读取本地文件，通过网络通道发送到服务端        while (fileChannel.read(buffer) != -1){            buffer.flip();            socketChannel.write(buffer);            buffer.clear();        }        &#x2F;&#x2F; 传统IO模式下，传输完毕,需手动关闭连接        socketChannel.shutdownOutput();        &#x2F;&#x2F; 5. 接收来自服务器端的反馈        int len = 0;        while ((len = socketChannel.read(buffer)) != -1){            buffer.flip();            System.out.println(new String(buffer.array(),0,len));            buffer.clear();        }        &#x2F;&#x2F; 6. 释放资源        fileChannel.close();        socketChannel.close();    }    &#x2F;&#x2F; 服务端    @Test    public void server() throws Exception{        System.out.println(&quot;服务器端已启动...监听中&quot;);        &#x2F;&#x2F; 1. 打开服务器网络通道        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        &#x2F;&#x2F; 2. 绑定端口号        serverSocketChannel.bind(new InetSocketAddress(8899));        &#x2F;&#x2F; 3. 获取客户端连接的通道        SocketChannel socketChannel = serverSocketChannel.accept();        &#x2F;&#x2F; 4. 打开本地文件通道        FileChannel fileChannel = FileChannel.open(Paths.get(&quot;D:\\IDEADemos\\Interview\\src\\Java基础\\Nio\\4.jpg&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE);        &#x2F;&#x2F; 5. 分配缓冲区        ByteBuffer buffer = ByteBuffer.allocate(1024);        &#x2F;&#x2F; 6. 接收客户端的数据，并保存到本地        while (socketChannel.read(buffer) != -1){            buffer.flip();            fileChannel.write(buffer);            buffer.clear();        }        &#x2F;&#x2F; 7. 发送反馈给客户端        buffer.put(&quot;服务器接收数据成功！&quot;.getBytes());        buffer.flip();        socketChannel.write(buffer);        &#x2F;&#x2F; 8. 释放资源        fileChannel.close();        socketChannel.close();        serverSocketChannel.close();        System.out.println(&quot;服务器关闭...&quot;);    }}</code></pre><h2 id="10-非阻塞式"><a href="#10-非阻塞式" class="headerlink" title="10. 非阻塞式"></a>10. 非阻塞式</h2><ul><li>Java NIO Demo如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class TestNonBlockingNIO {    &#x2F;&#x2F; 客户端    @Test    public void client() throws Exception{        &#x2F;&#x2F; 1. 获取网络通道        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;,8888));        &#x2F;&#x2F; 2. 切换到非阻塞模式        socketChannel.configureBlocking(false);        &#x2F;&#x2F; 3. 分配缓冲区        ByteBuffer buffer = ByteBuffer.allocate(1024);        &#x2F;&#x2F; 4. 发送数据        Scanner scan = new Scanner(System.in);        while (scan.hasNext()){            String str = scan.next();            buffer.put((new Date().toString() + &quot;\n&quot; + str).getBytes());            buffer.flip();            socketChannel.write(buffer);            buffer.clear();        }        socketChannel.close();    }    &#x2F;&#x2F; 服务端    @Test    public void server() throws Exception{        System.out.println(&quot;服务器端已启动...监听中&quot;);        &#x2F;&#x2F; 1. 打开服务器网络通道        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        &#x2F;&#x2F; 2. 切换到非阻塞模式        serverSocketChannel.configureBlocking(false);        &#x2F;&#x2F; 3. 绑定端口号        serverSocketChannel.bind(new InetSocketAddress(8888));        &#x2F;&#x2F; 4. 获取选择器        Selector selector = Selector.open();        &#x2F;&#x2F; 5. 将通道注册到选择器里，并指定“监听接收事件”        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        &#x2F;&#x2F; 6. 轮询的获取选择器中已经“准备就绪”的事件        while (selector.select() &gt; 0){            &#x2F;&#x2F; 7. 获取选择器中所有的“准备就绪”事件迭代器            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();            while (iterator.hasNext()){                &#x2F;&#x2F; 8. 获取准备就绪的事件                SelectionKey key = iterator.next();                &#x2F;&#x2F; 9. 判断具体是什么事件准备就绪                if (key.isAcceptable()){                    &#x2F;&#x2F; 10. 若是“接收就绪”，则获取客户端连接                    SocketChannel socketChannel = serverSocketChannel.accept();                    &#x2F;&#x2F; 11. 将客户端连接通道也切换为非阻塞模式                    socketChannel.configureBlocking(false);                    &#x2F;&#x2F; 12. 将该通道注册到选择器中                    socketChannel.register(selector,SelectionKey.OP_READ);                }else if (key.isReadable()){                    &#x2F;&#x2F; 13. 获取当前选择器上“读就绪”状态的通道                    SocketChannel sChannel = (SocketChannel) key.channel();                    &#x2F;&#x2F; 14. 分配缓冲区                    ByteBuffer buffer = ByteBuffer.allocate(1024);                    int len = 0;                    while ((len = sChannel.read(buffer)) &gt; 0){                        buffer.flip();                        System.out.println(new String(buffer.array(),0,len));                        buffer.clear();                    }                }                &#x2F;&#x2F; 15. 取消已使用的选择键                iterator.remove();            }        }        System.out.println(&quot;服务器关闭...&quot;);    }}</code></pre><h3 id="10-1-关于IDEA的Junit环境下无法使用Scanner"><a href="#10-1-关于IDEA的Junit环境下无法使用Scanner" class="headerlink" title="10.1 关于IDEA的Junit环境下无法使用Scanner"></a>10.1 关于IDEA的Junit环境下无法使用Scanner</h3><p>打开<code>Help</code>-&gt;<code>Edit Custom VM Options...</code>，在最后加上一句：<code>-Deditable.java.test.console=true</code>，然后重启IDEA即可。</p><h2 id="11-DatagramChannel"><a href="#11-DatagramChannel" class="headerlink" title="11. DatagramChannel"></a>11. DatagramChannel</h2><p>lJava NIO中的DatagramChannel是一个能收发UDP包的通道。</p><h3 id="11-1-简单案例"><a href="#11-1-简单案例" class="headerlink" title="11.1 简单案例"></a>11.1 简单案例</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class TestNonBlockingNIO2 {    @Test    public void send() throws Exception{        DatagramChannel datagramChannel = DatagramChannel.open();        datagramChannel.configureBlocking(false);        ByteBuffer buffer = ByteBuffer.allocate(1024);        Scanner scan = new Scanner(System.in);        while (scan.hasNext()){            String str = scan.next();            buffer.put((new Date().toString()+&quot;:\n&quot;+str).getBytes());            buffer.flip();            datagramChannel.send(buffer,new InetSocketAddress(&quot;127.0.0.1&quot;,8899));            buffer.clear();        }        datagramChannel.close();    }    @Test    public void receive() throws Exception{        DatagramChannel datagramChannel = DatagramChannel.open();        datagramChannel.configureBlocking(false);        datagramChannel.bind(new InetSocketAddress(8899));        Selector selector = Selector.open();        datagramChannel.register(selector,1);        while (selector.select()&gt;0){            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();            while (iterator.hasNext()){                SelectionKey key = iterator.next();                if (key.isReadable()){                    ByteBuffer buffer = ByteBuffer.allocate(1024);                    datagramChannel.receive(buffer);                    buffer.flip();                    System.out.println(new String(buffer.array(),0,buffer.limit()));                    buffer.clear();                }            }            iterator.remove();        }    }}</code></pre><h2 id="12-Pipe管道"><a href="#12-Pipe管道" class="headerlink" title="12. Pipe管道"></a>12. Pipe管道</h2><p>lJava NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p><p><img src="http://yanxuan.nosdn.127.net/9f9acc38a52ad45ebe1b9abb4b4078d2.png" alt="Pipe"></p><h3 id="12-1-通过管道传输数据"><a href="#12-1-通过管道传输数据" class="headerlink" title="12.1 通过管道传输数据"></a>12.1 通过管道传输数据</h3><ul><li>通过<code>pipe.sink()</code>返回一个入口通道，写数据；</li><li>从管道读取数据，需要访问source通道，使用<code>pipe.source()</code>；</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class TestPipe {    public static void main(String[] args) throws Exception{        &#x2F;&#x2F; 1. 获取管道        Pipe pipe = Pipe.open();        &#x2F;&#x2F; 2. 分配缓冲区        ByteBuffer buf = ByteBuffer.allocate(1024);        &#x2F;&#x2F; 3. 将缓冲区中的数据写入管道        Pipe.SinkChannel sink = pipe.sink();        buf.put(&quot;通过单向管道发送数据&quot;.getBytes());        buf.flip();        sink.write(buf);        &#x2F;&#x2F; 4. 读取缓冲区中的数据        Pipe.SourceChannel source = pipe.source();        buf.flip();        int len = source.read(buf);        System.out.println(new String(buf.array(),0,len));        &#x2F;&#x2F; 5. 释放资源        source.close();        sink.close();    }}</code></pre><h2 id="13-BIO、AIO、NIO的区别"><a href="#13-BIO、AIO、NIO的区别" class="headerlink" title="13. BIO、AIO、NIO的区别"></a>13. BIO、AIO、NIO的区别</h2><h3 id="13-1-同步和异步的概念"><a href="#13-1-同步和异步的概念" class="headerlink" title="13.1 同步和异步的概念"></a>13.1 同步和异步的概念</h3><p>同步和异步是针对应用程序和内核交互而言的，同步是指用户进程触发I/O操作并等待或轮询去查看I/O操作是否就绪；而异步是指用户进程触发I/O操作以后便开始做自己的事情，而当I/O操作完成时会得到I/O完毕的通知。</p><h3 id="13-2-阻塞和非阻塞的概念"><a href="#13-2-阻塞和非阻塞的概念" class="headerlink" title="13.2 阻塞和非阻塞的概念"></a>13.2 阻塞和非阻塞的概念</h3><p>阻塞和非阻塞是针对于进程在访问数据时，根据I/O操作的就绪状态来采取不同的方式，简单说就是读取或写入操作函数的一种实现方式；阻塞方式下读写函数一直等待，而非阻塞方式下，读写函数会立即返回一个状态值。</p><h3 id="13-3-三类IO"><a href="#13-3-三类IO" class="headerlink" title="13.3 三类IO"></a>13.3 三类IO</h3><p>所以，I/O操作可分为3类：同步阻塞(即早期的BIO操作)、同步非阻塞(NIO)、异步非阻塞(AIO)。</p><ul><li>同步阻塞(Block IO，简称BIO)<ul><li>此种方式下，用户进程在发起一个I/O操作后，必须等待I/O操作的完成，只有当真正完成了I/O操作之后，用户进程才能运行。Java传统的I/O模式就属于此种方式，特点是模式简单实用方便，但并发处理能力低。</li></ul></li><li>同步非阻塞(New IO，简称NIO)<ul><li>在此种方式下，用户进程发起一个I/O操作后便可以返回做其他事情了，但用户进程需要时不时地去询问I/O操作是否就绪，这就要求用户周期性地去询问，从而引入不必要的CPU资源浪费。目前Java的NIO就属同步非阻塞IO，是传统IO的升级，实现了多路复用，但会占用CPU资源。</li></ul></li><li>异步非阻塞(Asynchronous IO，简称AIO)<ul><li>此种方式下，用户进程发起一个I/O操作后，不必等待内核I/O操作完成，内核完成I/O操作后会主动通知用户进程。此时用户进程只需对数据进行处理即可，无需进行实际的I/O读写操作，真正的I/O读写操作已经由内核完成了。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaAdvanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础</title>
      <link href="/JavaAdvanced/JVM.html"/>
      <url>/JavaAdvanced/JVM.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-JVM体系结构概述"><a href="#1-JVM体系结构概述" class="headerlink" title="1. JVM体系结构概述"></a>1. JVM体系结构概述</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互，下图示JVM体系结构图：</p><a id="more"></a><p><img src="http://yanxuan.nosdn.127.net/12f295b0fb04302be7b78f8f1b07964c.png" alt="JVM体系结构概览"></p><h3 id="1-类装载器-ClassLoader"><a href="#1-类装载器-ClassLoader" class="headerlink" title="1. 类装载器(ClassLoader)"></a>1. 类装载器(ClassLoader)</h3><p>负责加载class文件，class文件在文件开头有特定的文件标识(<code>cafe babe</code>)，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构；并且ClassLoader只负责<strong>class文件的加载</strong>，至于它是否可以运行，则由Execution Engine决定。</p><p><img src="http://yanxuan.nosdn.127.net/1d33cee2d7a76915d726597771876579.png" alt="ClassLoader"></p><h4 id="1-1-类加载器的种类"><a href="#1-1-类加载器的种类" class="headerlink" title="1.1 类加载器的种类"></a>1.1 类加载器的种类</h4><ul><li>虚拟机自带的加载器<ul><li><code>Bootstrap ClassLoader</code>：C++语言写的根平台加载器，系统类加载器</li><li><code>Extension ClassLoader</code>：Java语言写的扩展类加载器，JDK9之后为平台类加载器(PlatformClassLoader)</li><li><code>Application ClassLoader</code>：应用程序类加载器</li></ul></li><li>用户自定义加载器<ul><li><code>Java.lang.ClassLoader</code>的子类，用户可以定制类的加载方式</li></ul></li></ul><h4 id="1-2-双亲委派机制"><a href="#1-2-双亲委派机制" class="headerlink" title="1.2 双亲委派机制"></a>1.2 双亲委派机制</h4><p>当一个类收到了类加载请求，它首先不会去尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一层次类加载器都是如此，因此所有的加载请求都应该传递到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求时(它自己的加载路径下无法找到所需的类)，子类加载器才会尝试自己去加载。</p><ul><li>好处：采用双亲委派的一个好处就是比如加载位于<code>rt.jar</code>包中的类<code>java.lang.Object</code>，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同一个Object对象。</li></ul><blockquote><p>双亲委派机制保证了沙箱安全</p></blockquote><h3 id="2-执行引擎"><a href="#2-执行引擎" class="headerlink" title="2. 执行引擎"></a>2. 执行引擎</h3><p>Execution Engine执行引擎负责解释命令，提交给操作系统执行。输入的是<strong>字节码文件</strong>，处理过程是<strong>字节码解析</strong>，输出的是<strong>执行结果</strong>。</p><h3 id="3-本地接口"><a href="#3-本地接口" class="headerlink" title="3. 本地接口"></a>3. 本地接口</h3><p>Native Interface本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生时正是C/C++横行的时候，要想立足，必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies(本地方法库)。</p><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备；在现在的企业级应用中已经很少见了。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等。</p><h4 id="3-1-Native-Method-Stack"><a href="#3-1-Native-Method-Stack" class="headerlink" title="3.1 Native Method Stack"></a>3.1 Native Method Stack</h4><p>本地方法栈的具体做法是再其方法栈中登记native方法，在Execution Engine执行时加载本地方法库。</p><h3 id="4-程序计数器"><a href="#4-程序计数器" class="headerlink" title="4. 程序计数器"></a>4. 程序计数器</h3><p>程序计数器是每个线程私有的一块非常小的内存空间，可以把它看做当前线程所执行的字节码的行号指示器或者看做一个指针，指向的是当前正在执行的字节码指令，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，完成诸如分支、循环、跳转、异常处理、线程恢复等基础功能。</p><h4 id="4-1-JVM多线程的实现方式"><a href="#4-1-JVM多线程的实现方式" class="headerlink" title="4.1 JVM多线程的实现方式"></a>4.1 JVM多线程的实现方式</h4><p>Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间(时间片轮转算法)的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><h4 id="4-1-程序计数器的特点"><a href="#4-1-程序计数器的特点" class="headerlink" title="4.1 程序计数器的特点"></a>4.1 程序计数器的特点</h4><ol><li>线程隔离性：每个线程工作时都拥有自己独立的计数器；</li><li>执行Java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址；</li><li>执行Native方法时，程序计数器的值为空，因为Native方法不是Java执行，故不会产生相应字节码，也就不需要记录和执行；</li><li>程序计数器占用内存非常小，在进行JVM内存计算时，可以忽略不计；</li><li>程序计数器在Java虚拟机规范中没有规定任何OOMError区域，故不会发生内存溢出(OutOfMemory=OOM)错误。</li></ol><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>供各<strong>线程共享</strong>的运行时内存区域。<font color="red">它存储了每个类的结构信息，就是模板</font>；方法区中存储了例如运行时常量池、类型常量池、类变量、类型信息（方法数据、构造函数和普通方法的字节码内容）等。上面讲的<strong>是规范</strong>，具体实现不同虚拟机是不同的，最典型的就是永久代(PermGen Space)和元空间(Mate Space)。</p><h4 id="5-1-方法区的发展历程"><a href="#5-1-方法区的发展历程" class="headerlink" title="5.1 方法区的发展历程"></a>5.1 方法区的发展历程</h4><ol><li>JDK6：开发者团队开始准备放弃永久代，逐步改为采用本地内存来实现方法区；</li><li>JDK7：将放在永久代里的字符串常量池、静态变量等移出；</li><li>JDK8：完全废除永久代概念，改用本地内存实现元空间，永久代中剩余内容（如运行时常量池）全部移至元空间。</li></ol><h4 id="5-2-Java中几种常量池的区分"><a href="#5-2-Java中几种常量池的区分" class="headerlink" title="5.2 Java中几种常量池的区分"></a>5.2 Java中几种常量池的区分</h4><ol><li>全局字符串池：就是我们常说的字符串常量池，存放的内容是类加载完成后在堆中生成字符串<strong>对象实例的引用值</strong>。</li><li>class文件常量池：class文件除了包含类的模板信息，还包含类常量池，用于存放编译器生成的各种常量和符号引用（描述引用目标）。</li><li>运行时常量池：当类加载到内存中运行时，JVM就会将class常量池中的内容存放到运行时常量池中，运行时常量池每个类都有一个。</li></ol><h3 id="6-Java栈"><a href="#6-Java栈" class="headerlink" title="6. Java栈"></a>6. Java栈</h3><p>栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，<strong>对于栈来说不存在垃圾回收问题</strong>，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。<font color="red">8种基本类型的变量+对象引用的变量+实例方法都是在函数的栈内存中分配的。</font></p><h4 id="6-1-栈帧"><a href="#6-1-栈帧" class="headerlink" title="6.1 栈帧"></a>6.1 栈帧</h4><p>栈帧中主要保存3类数据：</p><ul><li>本地变量(Local Variables)：输入参数和输出参数以及方法内的变量；</li><li>栈操作(Operand Stack)：记录出栈、入栈的操作；</li><li>栈帧数据(Frame Data)：包括类文件、方法等。</li></ul><blockquote><p><strong>栈帧</strong>：在java中的方法，到了栈中就是栈帧；即<strong>方法=栈帧。</strong></p></blockquote><h4 id="6-2-栈运行原理"><a href="#6-2-栈运行原理" class="headerlink" title="6.2 栈运行原理"></a>6.2 栈运行原理</h4><p>栈中的数据都是以栈帧(Stack Frame)的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集；当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，B方法又调用了C方法，于是产生栈帧F3被压入栈，以此类推…；执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧….，遵循“先进后出(Frist In Last Out)”原则。</p><p>每个<strong>方法执行同时都会创建一个栈帧</strong>，用于<strong>存储局部变量表、操作数栈、动态链接、方法出口</strong>等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在<code>256K~756K</code>之间，约等于1MB左右。</p><p><img src="http://yanxuan.nosdn.127.net/680b77fb42288aa335d28704f7f19e7a.png" alt="Java Stack"></p><p>如上图示在一个栈中有两个栈帧：</p><ul><li>栈帧2是最先被调用的方法，先入栈；</li><li>然后方法2又调用了方法1，栈帧1处于栈顶的位置；</li><li>栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2；</li><li>线程结束，栈释放。</li></ul><p>每执行一个方法都会产生一个栈帧，保存到栈的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。</p><h4 id="6-3-堆栈溢出"><a href="#6-3-堆栈溢出" class="headerlink" title="6.3 堆栈溢出"></a>6.3 堆栈溢出</h4><p>Java默认的栈大小是有限的，当一个程序不停的入栈但是不出栈，当<strong>栈被压满</strong>后爆栈了，就会产生<strong>错误</strong>：<code>Exception in thread &quot;main&quot; java.lang.StackOverflowError</code>。</p><h4 id="6-4-堆-栈-方法区的交互关系"><a href="#6-4-堆-栈-方法区的交互关系" class="headerlink" title="6.4 堆+栈+方法区的交互关系"></a>6.4 堆+栈+方法区的交互关系</h4><p><img src="http://yanxuan.nosdn.127.net/d126ec1984e33cd7d4271157e1754e86.png" alt="堆栈方法区"></p><p>HotSpot是使用指针的方式来访问对象的：Java堆中会存放访问类元数据(就是访问方法区的模板)的地址，reference存储的就直接是对象的地址(堆中存放的都是new的实际对象数据)。</p><blockquote><ul><li><p>栈管运行，堆管存储</p></li><li><p>HotSpot是Java目前使用范围最广的Java虚拟机。</p></li></ul></blockquote><h2 id="2-堆体系结构概述"><a href="#2-堆体系结构概述" class="headerlink" title="2. 堆体系结构概述"></a>2. 堆体系结构概述</h2><p>Java堆是垃圾收集器管理的内存区域，从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，因此Java堆中常会出现“新生代”“老年代”这些名词。要注意的是这种区域划分仅仅是部分垃圾收集器的共同特性或者是设计风格而已，而非某个JVM具体实现的固有内存布局。<strong>将Java堆细分的目的只是为了更好的回收内存，或者更快的分配内存。</strong></p><h3 id="2-1-Heap堆结构简介"><a href="#2-1-Heap堆结构简介" class="headerlink" title="2.1 Heap堆结构简介"></a>2.1 Heap堆结构简介</h3><p>一个JVM实例只存在一个堆内存，堆内存的大小是可调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分：</p><ul><li>Young Generation Space(新生区)，简称<strong>Young/New</strong></li><li>Tenure Generation Space(养老区)，简称<strong>Old/Tenure</strong></li><li>Permanent Space(永久区)，简称<strong>Perm</strong></li></ul><p><img src="http://yanxuan.nosdn.127.net/c998367d6099f58618557e3b1010b94d.png" alt="Heap"></p><p>上图就是Java7之前的堆结构体系图，Java8之后<strong>永久存储区改名为了元空间</strong>。</p><h3 id="2-2-Heap堆new对象流程"><a href="#2-2-Heap堆new对象流程" class="headerlink" title="2.2 Heap堆new对象流程"></a>2.2 Heap堆new对象流程</h3><p>新生区是类诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区(Eden Space)和幸存者区(Survivor Space)，所有类都是在伊甸园区被new出来的。幸存者区有两个：0区(Survivor 0 Space)和1区(Survivor 1 Space)。</p><p>当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC，又称轻GC)，将伊甸园区中的无引用对象进行销毁。然后将会将伊甸园中剩余的对象移动到幸存者0区；若幸存者0区也满了，再对该区域进行垃圾回收，然后移动到1区。如果1区也满了，将移动到养老区，若最后养老区也满了，那么这时将产生(Major GC，又叫Full GC)，对养老区的内存进行清理。若养老区多次执行Full GC后依然无法腾出空间进行对象保存，就会产生OOM异常：<code>OutOfMemoryError</code>.</p><blockquote><p>如出现<code>java.lang.OutOfMemoryError:Java heap sapce</code>，说明Java虚拟机的堆内存不够，原因有二：</p><ol><li>Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。</li><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用，故无法GC)。</li></ol></blockquote><h3 id="2-3-TransferValue"><a href="#2-3-TransferValue" class="headerlink" title="2.3 TransferValue"></a>2.3 TransferValue</h3><p>面试题：<code>str</code>打印什么？</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class TestTransferValue {    public void changeValue(String str){        str = &quot;xxx&quot;;    }    public static void main(String[] args) {        String str = &quot;abc&quot;;        test.changeValue(str);        System.out.println(&quot;String------&quot;+str);    }}</code></pre><h3 id="2-4-对象生命周期和GC"><a href="#2-4-对象生命周期和GC" class="headerlink" title="2.4 对象生命周期和GC"></a>2.4 对象生命周期和GC</h3><p>Java堆从GC的角度还可细分为<strong>新生代</strong>(Eden 区、Form Survivor区和To Survivor区)和<strong>老年代</strong>，堆结构如下图：</p><p><img src="http://yanxuan.nosdn.127.net/d4182b6178d78b50471871943b10ac67.png" alt="Heap"></p><h4 id="2-4-1-MinorGC的过程：-复制-gt-清空-gt-互换"><a href="#2-4-1-MinorGC的过程：-复制-gt-清空-gt-互换" class="headerlink" title="2.4.1 MinorGC的过程：(复制-&gt;清空-&gt;互换)"></a>2.4.1 MinorGC的过程：(复制-&gt;清空-&gt;互换)</h4><ul><li>复制：Eden、SurvivorFrom复制到SurvivorTo，年龄+1</li></ul><p>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC时会扫描Eden区和From区，对这两个区域进行垃圾回收；经过这次回收后还存活的对象，则直接<strong>拷贝到To区</strong>(如果有对象年龄达到老年标准，则复制到老年代区)，同时把这些<strong>对象的年龄+1</strong>。</p><ul><li>清空：清空Eden、SurvivorFrom</li></ul><p>复制操作完毕后，会清空Eden和SurvivorFrom中的对象。</p><ul><li>互换：SurvivorTo和SurvivorFrom互换</li></ul><p>最后，SurvivorTo和SurvivorFrom身份互换，即<strong>复制之后有交换，谁空谁是To</strong>，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中来回复制，增加年龄；如此交换15次(由JVM参数<code>MaxTenuringThreshold</code>决定，该参数默认15)，最终还存活的，就会进入老年代。</p><h4 id="2-4-2-HotSpot内存管理"><a href="#2-4-2-HotSpot内存管理" class="headerlink" title="2.4.2 HotSpot内存管理"></a>2.4.2 HotSpot内存管理</h4><p><img src="http://yanxuan.nosdn.127.net/e6fbcbfc76ae8c09b5de10d95a6f9c28.png" alt="分代管理"></p><p>物理</p><p>上堆实际只有新生代和老年代，Java中98%的对象是临时对象，在Eden生Eden死，只有极少数才能到老年代。</p><h3 id="2-5-永久代-元空间"><a href="#2-5-永久代-元空间" class="headerlink" title="2.5 永久代(元空间)"></a>2.5 永久代(元空间)</h3><p>方法区(Method Area)和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，<font color="red">虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。</font></p><p>对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)”，但严格本质上说两者不同，或者说是使用永久代实现方法区而已，<strong>永久代是方法区的一个实现(相当于方法区是一个接口规范，而永久代就是接口实现)</strong>，JDK7的版本中，已经将原本放在永久代的字符串常量池移走，移动到堆中了。</p><h4 id="2-5-1-永久区-Java7之前"><a href="#2-5-1-永久区-Java7之前" class="headerlink" title="2.5.1 永久区(Java7之前)"></a>2.5.1 永久区(Java7之前)</h4><p>永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class，Interface的元数据(比如rt.jar包内容、Spring框架必须jar包等等)，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占有的内存。</p><h2 id="3-堆参数调优入门"><a href="#3-堆参数调优入门" class="headerlink" title="3. 堆参数调优入门"></a>3. 堆参数调优入门</h2><p>以下内容以JDK1.8+Hotspot为例。</p><p><img src="http://yanxuan.nosdn.127.net/f1c18c8ba74c941692faeb8baa895d76.png" alt="Heap"></p><p>JDK1.8后将永久代取消了，由元空间取代，元空间的本质和永久代类似；元空间与永久代之间最大的区别在于：永久代使用的是JVM的堆内存，但Java8以后的<font color="red">元空间并不在虚拟机中而是使用本机物理内存。</font></p><p>因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入Native Memory，字符串池和类的静态变量放入Java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p><h3 id="3-1-堆参数调整"><a href="#3-1-堆参数调整" class="headerlink" title="3.1 堆参数调整"></a>3.1 堆参数调整</h3><p>以下是堆的几个重要的参数：</p><ul><li><code>-Xms</code>：初始大小，默认为物理内存的1/64；</li><li><code>-Xmx</code>：最大分配内存，默认为物理内存的1/4；</li><li><code>-XX:+PrintGCDetails</code>：输出详细的GC处理日志。</li></ul><p>Java将运行时数据区抽象成了一个类：<code>Runtime</code>，使用这个类的一些API可以查看一些堆参数</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class HeapDemo {    public static void main(String[] args) {        System.out.println(&quot;CPU核心数:&quot;+Runtime.getRuntime().availableProcessors());        System.out.println(&quot;-Xms:TOTAL_MEMORY = 虚拟机中的内存总量:&quot;+(Runtime.getRuntime().totalMemory())&#x2F;(double)1024&#x2F;1024+&quot;MB&quot;);        System.out.println(&quot;-Xmx:MAX_MEMORY = 虚拟机试图使用的最大内存量:&quot;+(Runtime.getRuntime().maxMemory()&#x2F;(double)1024&#x2F;1024)+&quot;MB&quot;);    }}</code></pre><h3 id="3-2-GC收集日志信息"><a href="#3-2-GC收集日志信息" class="headerlink" title="3.2 GC收集日志信息"></a>3.2 GC收集日志信息</h3><p>为了清晰明了的查看堆中的各种GC情况，编写以下测试类测试内存溢出，并查看GC详细日志。</p><ul><li>编写测试类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class HeapDemo {    public static void main(String[] args) {        String str = &quot;hello&quot;;        while (true){            &#x2F;&#x2F; Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space            str += str + new Random().nextInt(88888888) + new Random().nextInt(99999999);        }        &#x2F;&#x2F;        byte[] bytes = new byte[40 * 1024 * 1024];    }}</code></pre><ul><li>在IDEA中配置参数：<code>-Xms10m -Xmx10m -XX:+PrintGCDetails</code>，将堆的内存设小。</li></ul><p><img src="http://yanxuan.nosdn.127.net/f2f0399f7a98d26814441c5b04508c2e.png" alt="Heap Parameter"></p><ul><li>运行程序，查看日志信息。</li></ul><p><img src="http://yanxuan.nosdn.127.net/bed54395e723f536a4fa39ba52bcd45d.png" alt="GCLog"></p><ul><li>GC信息查看模板如下：</li></ul><p><img src="http://yanxuan.nosdn.127.net/00ffe9b304ed8429f296989f636b8894.png" alt="GC"></p><ul><li>FGC模板</li></ul><p><img src="http://yanxuan.nosdn.127.net/88e855c3f353edd0ca601221e6332448.png" alt="FGC"></p><h2 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4. 垃圾回收算法"></a>4. 垃圾回收算法</h2><h3 id="4-1-GC是什么-分代收集算法"><a href="#4-1-GC是什么-分代收集算法" class="headerlink" title="4.1 GC是什么(分代收集算法)"></a>4.1 GC是什么(分代收集算法)</h3><p>GC是Java的垃圾回收机制，主要可划分为“引用计数式垃圾收集”和“追踪式垃圾收集”。</p><p>现在主流的商业虚拟机的垃圾收集器，遵循了<strong>“分代收集”的理论</strong>进行设计，建立在两个分代假说之上：</p><ol><li>弱分代假说：绝大多数对象都是朝生夕死的。</li><li>强分代假说：熬过越多次垃圾收集的对象就越难以消亡。</li></ol><p>基于这两个假说奠定了多款常用垃圾收集器的一致设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据年龄分配到不同的区域中存储。</p><p>在Java堆划分出不同的区域之后，垃圾收集器才可根据情况只回收其中部分区域，因此才有了“Minor GC”、“Major GC”、“Full GC”这样的回收类型划分；才能根据不同区域的对象存亡特征选择其合适的垃圾收集器，诸如“标记-复制算法”、“标记-清除算法”、“标记-压缩算法”等。</p><h3 id="4-2-GC算法概述"><a href="#4-2-GC算法概述" class="headerlink" title="4.2 GC算法概述"></a>4.2 GC算法概述</h3><p><img src="http://yanxuan.nosdn.127.net/91c8be58bd03e0baf762d77d33c40890.png" alt="GC概述"></p><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收的都是新生代。因此GC按照回收区域又分了两种类型，一种是普通GC(Minor GC)，一种是全局GC(Major GC or Full GC)。</p><h4 id="4-2-1-回收类型划分"><a href="#4-2-1-回收类型划分" class="headerlink" title="4.2.1 回收类型划分"></a>4.2.1 回收类型划分</h4><ul><li>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中细分如下：<ul><li>新生代收集（Minor GC/Young GC）：指目标仅是新生代的垃圾收集；</li><li>老年代收集（Major GC/Old GC）：指目标仅是老年代的垃圾收集，目前只有CMS收集器会有单独收集老年代的行为。</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集，目前只有G1收集器会有这种行为。</li></ul></li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</li></ul><h4 id="4-2-2-Minor-GC原理"><a href="#4-2-2-Minor-GC原理" class="headerlink" title="4.2.2 Minor GC原理"></a>4.2.2 Minor GC原理</h4><p><img src="http://yanxuan.nosdn.127.net/bf44ebec2b2413603977993ed5683d9b.png" alt="堆结构图"></p><p>Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的存活对象就被移到Old代中，也即一旦收集后，Eden区就变成空的了。当对象在Eden(包括一个Survivor 区域，假设是From区域)出生后，经过一次Minor GC后，如果对象还存活，且能够被另外一块Survivor区域所容纳(上面假设是from区，那么这里就是to区，即to区域有足够的内存空间来存储Eden和from区中存活的对象)，则使用复制算法将这些仍然存活的对象复制到另外一块Survivor区(即to区)中，然后清理所使用过的Eden区以及Survivor区(即from区)， 并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过<code>-XX:MaxTenuringThreshold</code>来设定参数)，这些对象就会成为老年代。</p><ul><li><code>-XX:MaxTenuringThreshold</code> ：设置对象在新生代中存活的次数    </li></ul><h3 id="4-3-判断对象是否存活"><a href="#4-3-判断对象是否存活" class="headerlink" title="4.3 判断对象是否存活"></a>4.3 判断对象是否存活</h3><p>主要有两种方式，引用计数法和根搜索算法。</p><h4 id="4-3-1-引用计数法"><a href="#4-3-1-引用计数法" class="headerlink" title="4.3.1 引用计数法"></a>4.3.1 引用计数法</h4><p><img src="http://yanxuan.nosdn.127.net/8f44594f7894884b1d47abce7b59461a.png" alt="引用计数法"></p><p>该算法给对象添加了一个引用计数器，被引用时，计数器值+1，引用失效时，计数器值-1。</p><p>JVM不使用它的原因是很难解决对象之间的循环引用问题。</p><h4 id="4-3-2-可达性分析算法"><a href="#4-3-2-可达性分析算法" class="headerlink" title="4.3.2 可达性分析算法"></a>4.3.2 可达性分析算法</h4><p>该算法用于判定对象是否存活。这个算法的基本思路就是通过一些的名为“GC Roots”的对象作为起始节点集合，从这些节点开始根据<strong>引用关系</strong>向下搜索，搜索所走过的路径称为<strong>引用链</strong>，如果某个对象到GC Roots间<strong>没有任何引用链相连</strong>时，就是从GC Roots到这个<strong>对象不可达</strong>，则证明此对象是<strong>不可用的</strong>。</p><p>在Java语言中，可作为GC Roots的对象包括以下几种：</p><ol><li>虚拟机栈中引用的对象，如线程调用的方法堆栈中使用到的参数，局部变量，临时变量等；</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用的对象，如字符串常量池里的引用；</li><li>本地方法栈中JNI引用的对象。</li></ol><h4 id="4-3-3-Java四大引用"><a href="#4-3-3-Java四大引用" class="headerlink" title="4.3.3 Java四大引用"></a>4.3.3 Java四大引用</h4><p>JDK1.2版本后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，引用强度依次递增。</p><ol><li>强引用：最传统的引用定义，就是<code>Object obj = new Object()</code>这样在代码中普遍存在的引用赋值，只要强引用关系存在，被引用对象就不会被GC。</li><li>软引用：用于描述一些还有用，但不必要的对象。在系统将要发生OOM异常前，会将这些对象列入回收范围进行二次回收。JDK提供了<code>SoftReference</code>类来实现软引用。</li><li>弱引用：用于描述一些非必须对象，强度比软引用更弱一点；弱引用关联的对象只能生存到下一次GC发生为止，当GC收集器工作时，弱引用关联的对象都会被回收掉。JDK提供<code>WeakRefererence</code>来实现弱引用。</li><li>虚引用：最弱的一种引用关系，对象是否有虚引用不会产生任何影响，设置虚引用的唯一目的就是为了在该对象被GC时收到一个系统通知。JDK提供了<code>PhantomReference</code>来实现虚引用。</li></ol><blockquote><p>简言之：</p><ul><li>强引用对象引用关系存在，不会被回收</li><li>软引用对象系统内存不足时会被GC</li><li>弱引用对象发生GC时必然被回收</li><li>虚引用用于对象被GC时发送系统通知</li></ul></blockquote><h3 id="4-4-三大算法之：复制算法-Copying"><a href="#4-4-三大算法之：复制算法-Copying" class="headerlink" title="4.4 三大算法之：复制算法(Copying)"></a>4.4 三大算法之：复制算法(Copying)</h3><p>复制算法是一种适用于年轻代的GC算法</p><h4 id="4-4-1-复制算法详细运行步骤"><a href="#4-4-1-复制算法详细运行步骤" class="headerlink" title="4.4.1 复制算法详细运行步骤"></a>4.4.1 复制算法详细运行步骤</h4><p><strong>HotSpot JVM</strong>将年轻代分为了三部分：<strong>1个Eden区和2个Survivor区</strong>(分别叫from和to)。默认比例为<strong>8:1:1</strong>（一种更优化的半区复制分代策略，现称为Appel式回收），一般情况下，新创建的对象都会被分配到<strong>Eden区</strong>(大对象会直接移到老年代中)，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到<strong>Survivor区</strong>。</p><p>对象在Survivor区中每熬过一次Minor GC，年龄就会<strong>增加一岁</strong>，当它的年龄到一定程度后，就会被移动到老年代。因为年轻代中的对象基本都是朝生夕死（根据IBM的研究表明，新生代98%以上对象熬不过第一轮收集），所以在<strong>年轻代的垃圾回收算法使用的是复制算法</strong>，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面，因此<strong>复制算法是不会产生内存碎片的。</strong></p><p><img src="http://yanxuan.nosdn.127.net/1941abf352c68e64f498523fecac9094.png" alt="复制算法"></p><p>在GC开始时，对象只会存在于Eden区和名为”From”的Survivor区，Survivor区的”To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到”To”，而在”From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移到到年老代中，没有达到阈值的对象会被复制到”To”区域。</p><p>经过这次GC后，Eden区和From区已经被清空。这时，”From”和”To”会<strong>交换他们的角色</strong>，也就是新的”To”就是上次GC前的”From”，新的”From”就是上次GC前的”To”。</p><p>不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到”To”区被填满。当大量对象在Minor GC后仍然存活的情况下导致”To”区被填满，就需要老年代进行<strong>分配担保</strong>，将Survivor无法容纳的对象直接进入老年代。</p><blockquote><p>分配担保机制：在发生Minor GC之前，JVM会检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果大于那么就可以确保这次Minor GC是安全的；如果小于新生代对象总空间，则JVM会查看<code>-XX:HandlerPromotionFailure</code>参数是否允许担保失败；如果允许就会检查老年代剩余可用空间是否大于历次晋升到老年代对象的平均大小，如果大于则说明老年代可能还是放的下年轻代过来的对象，可能可以继续担保，会尝试进行一次Minor GC，尽管是有风险的；如果小于或者参数设置不允许冒险担保，那么就会改为进行一次Full GC，让老年代腾出空间。</p></blockquote><p><img src="http://yanxuan.nosdn.127.net/cfc8f3ea53603eda81f723d6632cda1c.png" alt="复制算法图示"></p><blockquote><p>上图：绿色是空闲空间，红色是存活对象，黄色是不可用对象。</p></blockquote><p>因为Eden区对象一般存活率较低，通常使用两块10%的内存作为空闲和活动区间，另外80%的内存用于给新建对象分配内存的。</p><p>一旦发生GC，将10%的from活动区间与另外80%中<strong>存活的</strong>Eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，依次类推。</p><h4 id="4-4-2-复制算法的劣势"><a href="#4-4-2-复制算法的劣势" class="headerlink" title="4.4.2 复制算法的劣势"></a>4.4.2 复制算法的劣势</h4><ol><li>它会浪费了一半内存；</li><li>如果对象的存活率过高，假设是100%，那么需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变得不可忽视。</li></ol><blockquote><p>简言之：复制算法优点速度快无内存碎片，缺点耗内存，<strong>空间换时间。</strong></p></blockquote><h3 id="4-5-三大算法之：标记清除-Mark-Sweep"><a href="#4-5-三大算法之：标记清除-Mark-Sweep" class="headerlink" title="4.5 三大算法之：标记清除(Mark-Sweep)"></a>4.5 三大算法之：标记清除(Mark-Sweep)</h3><p><strong>老年代</strong>一般是由标记清除或者是标记清除+标记整理的混合实现。</p><p>标清+标整就是让JVM平时采用标清，暂时容忍内存碎片的存在，当内存碎片的碎片化程度大到影响对象分配时，再采用标整算法收集一次，以获得规整的内存空间。CMS收集器就是使用的这种。</p><h4 id="4-5-1-原理"><a href="#4-5-1-原理" class="headerlink" title="4.5.1 原理"></a>4.5.1 原理</h4><p>算法分成<strong>标记和清除</strong>两个阶段，先标记出要回收的对象，然后统一回收这些对象</p><p><img src="http://yanxuan.nosdn.127.net/08ef0f765737522efedbe254227093eb.png" alt="标记清除"></p><p>用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将<strong>程序暂停</strong>（stop the world），随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。 </p><p>主要进行两项工作，第一项则是标记，第二项则是清除。</p><ul><li>标记：从引用根节点开始遍历所有的GC Roots， 先标记出要回收的对象。</li><li>清除：遍历整个堆，把标记的对象清除。 </li></ul><h4 id="4-5-2-标记清除的优缺点"><a href="#4-5-2-标记清除的优缺点" class="headerlink" title="4.5.2 标记清除的优缺点"></a>4.5.2 标记清除的优缺点</h4><ul><li>优点：不需要额外的空间，节省内存</li><li>缺点：<ul><li>首先，它的缺点就是<strong>执行效率不稳定</strong>（递归与全堆对象遍历），标记和清除的执行效率会随着对象数量增长而降低；而且在进行GC的时候，需要<strong>停止应用程序</strong>，这会导致用户体验非常差劲。</li><li>其次，主要的缺点则是这种方式清理出来的<strong>空闲内存是不连续</strong>的，死亡对象都是随机的出现在内存的各个角落的，现在把它们清除之后，内存的布局会变得乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而在分配数组对象的时候，连续的内存空间寻找会非常麻烦。</li></ul></li></ul><blockquote><p>简言之：标记清除算法优点节省内存，缺点效率不稳定且会产生内存碎片；<strong>时间换空间</strong>。</p></blockquote><h3 id="4-6-三大算法之：标记压缩-Mark-Compact"><a href="#4-6-三大算法之：标记压缩-Mark-Compact" class="headerlink" title="4.6 三大算法之：标记压缩(Mark-Compact)"></a>4.6 三大算法之：标记压缩(Mark-Compact)</h3><p>又称为标记整理算法，适合老年代的垃圾回收算法，与标清类似。</p><h4 id="4-6-1-原理"><a href="#4-6-1-原理" class="headerlink" title="4.6.1 原理"></a>4.6.1 原理</h4><p><img src="http://yanxuan.nosdn.127.net/9e17861745a6a56bc4599b6eb73b3d20.png" alt="标记压缩"></p><p>在整理压缩阶段，不再对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><p>标记-整理算法不仅可以弥补标记-清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价；当然并非没有缺点。</p><h4 id="4-6-2-劣势"><a href="#4-6-2-劣势" class="headerlink" title="4.6.2 劣势"></a>4.6.2 劣势</h4><p>标记/整理算法唯一的缺点就是<strong>效率也不高</strong>，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 </p><blockquote><p>简言之：优点不会产生内存碎片，内存使用率高，缺点效率不高。</p></blockquote><h3 id="4-7-GC小结"><a href="#4-7-GC小结" class="headerlink" title="4.7 GC小结"></a>4.7 GC小结</h3><p>GC算法对比：</p><ul><li>内存效率：复制算法&gt;标记清除算法&gt;标记整理算法(只是简单的对比时间复杂度，实际情况不一定)</li><li>内存整齐度：复制算法=标记整理算法&gt;标记清除算法</li><li>内存利用率：标记整理算法=标记清除算法&gt;复制算法</li></ul><p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程</p><p>难道就没有一种最优算法吗？ 回答：无，没有最好的算法，只有最合适的算法。==========&gt;分代收集算法。 </p><ul><li>年轻代(Young Gen)</li></ul><p>年轻代特点是区域相对老年代较小，对像存活率低。 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><ul><li>老年代(Tenure Gen)</li></ul><p>老年代的特点是区域较大，对像存活率高。 这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</p><p>Mark阶段的开销与存活对像的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。</p><p>Sweep阶段的开销与所管理区域的大小形正相关，但Sweep“就地处决”的特点(原地操作)，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。</p><p>Compact阶段的开销与存活对像的数据成开比，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。</p><p>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。    </p><h2 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5.  垃圾收集器"></a>5.  垃圾收集器</h2><p>如果收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的就具体实现。</p><p><code>HotSpot</code>虚拟机所包含的所有收集器如下：</p><p><img src="http://yanxuan.nosdn.127.net/cb249e5b59351271d034be26a1e9fa81.png" alt="HotSpotJVM1.6的GC收集器"></p><p>上图展示了7种作用不同的分代收集器，如果两个收集器之间存在连线，说明可以搭配使用。</p><p>新生代收集器：Serial、PraNew、Parallel Scavenge</p><p>老年代收集器：Serial Old、Parallel Old、CMS</p><h4 id="5-1-Serial收集器"><a href="#5-1-Serial收集器" class="headerlink" title="5.1. Serial收集器"></a>5.1. Serial收集器</h4><p>最基本、发展历史最久的收集器，这个收集器是一个采用复制算法的单线程收集器，单线程一方面意味着它只会使用一个CPU或者一条线程去完成垃圾收集工作，另一方面也意味着它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。这说明要在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用是难以接受的。</p><p>不过实际上到目前为止，Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器，因为它简单而高效。用户桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大，收集几十兆或几百兆的新生代停顿时间在几十毫秒最多一百毫秒，只要不是频繁发生，这点停顿完全是可以接受的。Serial收集器运行过程如下图：</p><p><img src="http://yanxuan.nosdn.127.net/15d6c3a341a0ceac1812d352514e5ac9.png" alt="Serial"></p><blockquote><p>简言之：Serial是一个采用复制算法的单线程收集器，会产生Stop the World暂停用户线程进行GC操作；是Client模式下默认的新生代收集器，简单而高效。</p></blockquote><h4 id="5-2-ParNew收集器"><a href="#5-2-ParNew收集器" class="headerlink" title="5.2. ParNew收集器"></a>5.2. ParNew收集器</h4><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的算法也是复制算法。</p><p>ParNew收集器除了多线程以外和Serial收集器并没有太多创新的地方，但是它却是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能和CMS收集器配合工作(如图)。</p><p>CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集线程与用户线程基本同时工作。ParNew收集器在单CPU环境中绝对不会比Serial收集器有更好的效果，甚至由于线程交互的开销，该收集器在两个CPU的环境中都不能百分百保证可以超越Serial收集器。当然，随着CPU数量的增加，它对于GC时系统资源的有效利用还有很有好处的。它默认开启的收集线程数与CPU数量相同，在CPU数量非常多的情况下，可以使用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数。ParNew收集器运行过程如下：</p><p><img src="http://yanxuan.nosdn.127.net/731aed54eb8e6ceaffef9e5cf1c46ad7.png" alt="ParNew"></p><blockquote><p>简言之：ParNew是Serial收集器的多线程版本，会暂停所有用户线程执行GC操作；Server模式下首选的新生代收集器，在CPU核心更多的环境下会有更好的性能表现。</p></blockquote><h4 id="5-3-Parallel-Scavenge收集器"><a href="#5-3-Parallel-Scavenge收集器" class="headerlink" title="5.3. Parallel Scavenge收集器"></a>5.3. Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器也是一个新生代收集器，使用的复制算法，也是并行的多线程收集器，但它的特点是它的关注点和其他收集器不同。这个收集器主要引入了一个吞吐量的概念。</p><p>CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，<strong>而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</strong>。所谓吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%。另外，Parallel Scavenge收集器是虚拟机运行在Server面模式下的默认垃圾收集器。</p><p>停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成运算任务，主要适合在后台运算而不需要太多交互的任务。 </p><p> 虚拟机提供了<code>-XX:MaxGCPauseMillis</code>和<code>-XX:GCTimeRatio</code>两个参数来精确控制最大垃圾收集停顿时间和吞吐量大小。不过不要以为前者越小越好，GC停顿时间的缩短是以牺牲吞吐量和新生代空间换取的。由于与吞吐量关系密切，<strong>Parallel Scavenge收集器也被称为“吞吐量优先收集器”</strong>。Parallel Scavenge收集器有一个<code>-XX:+UseAdaptiveSizePolicy</code>参数，这是一个开关参数，这个参数打开之后，就不需要手动指定新生代大小、Eden区和Survivor参数等细节参数了，虚拟机会根据当前系统的运行情况和性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。<strong>如果对于垃圾收集器运作原理不太了解，以至于在优化比较困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择</strong>。 </p><blockquote><p>简言之：Parallel Scavenge收集器是一个新生代复制算法并行的多线程收集器，其与ParNew的区别在于吞吐量的概念和自适应调节策略，该收集器的目的是达到一个可控制的吞吐量，故<strong>Parallel Scavenge收集器也被称为“吞吐量优先收集器”</strong>。</p><blockquote><p>吞吐量：吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，越高越好。</p></blockquote></blockquote><h4 id="5-4-Serial-Old收集器"><a href="#5-4-Serial-Old收集器" class="headerlink" title="5.4. Serial Old收集器"></a>5.4. Serial Old收集器</h4><p><strong>Serial收集器的老年代版本，同样是一个单线程收集器，</strong>使用”<strong>标记-整理算法</strong>“，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。 </p><h4 id="5-5-Parallel-Old收集器"><a href="#5-5-Parallel-Old收集器" class="headerlink" title="5.5. Parallel Old收集器"></a>5.5. Parallel Old收集器</h4><p><strong>Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法</strong>。这个收集器在JDK 1.6之后的出现，“吞吐量优先收集器”终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合。运行过程如下图所示： </p><p><img src="http://yanxuan.nosdn.127.net/ce3e4abdc8039eb7fb15712a0a5376f1.png" alt="Parallel Old"></p><blockquote><p>简言之：Parallel Old是Parallel Scavenge收集器的老年代版本，使用标记整理算法的多线程收集器；适用于吞吐量及CPU资源敏感的场合下与Parallel Scavenge收集器进行组合应用。</p></blockquote><h4 id="5-6-CMS收集器"><a href="#5-6-CMS收集器" class="headerlink" title="5.6. CMS收集器"></a>5.6. CMS收集器</h4><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。使用标记-清除算法，收集过程分如下四步：</p><ol><li><strong>初始标记</strong>，标记GCRoots能直接关联到的对象，时间很短。</li><li><strong>并发标记</strong>，进行GCRoots Tracing(可达性分析)过程，时间很长。</li><li><strong>重新标记</strong>，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。</li><li><strong>并发清除</strong>，回收内存空间，时间很长。</li></ol><p>其中，并发标记和并发清除两个阶段耗时最长，但可以与用户线程并发执行。运行过程如下：</p><p><img src="http://yanxuan.nosdn.127.net/391007eae84e60a1e38faaf2e9683785.png" alt="CMS"></p><p>CMS是一款优秀的收集器，优点在于并发收集，低停顿，官方文档也称之为并发低停顿收集器，但它也有一些缺点：</p><ol><li>对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。</li><li>无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。</li><li>由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了<code>-XX:+UseCMSCompactAtFullCollection</code>参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，<code>-XX:+CMSFullGCsBeforeCompaction</code>，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。 </li></ol><h4 id="5-7-G1-Garbage-First-收集器"><a href="#5-7-G1-Garbage-First-收集器" class="headerlink" title="5.7. G1(Garbage-First)收集器"></a>5.7. G1(Garbage-First)收集器</h4><p>G1是目前收集器技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器；G1是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能。</p><p>与其他GC收集器相比，G1收集器有以下特点：</p><ol><li><strong>并行和并发</strong>：G1能充分利用CPU多核环境下的硬件优势，使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。</li><li><strong>分代收集</strong>：虽然可以独立管理整个GC堆，但是仍然保留了分代的概念，能够采用不同的方式去处理新创建对象和已经存活了一段时间，熬过多次GC的旧对象，以获取更好的收集效果。</li><li><strong>空间整合</strong>：整体来看基于标记-整理算法实现的收集器；从局部来看是基于复制算法实现的，故无内存碎片产生。</li><li><strong>可预测的停顿</strong>：能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li></ol><p>在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。 </p><p>G1收集器运行大致步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率。</p><blockquote><p>使用<code>java -XX:+PrintCommandLineFlags -version</code>命令可以查看当前Java使用的垃圾收集器。</p></blockquote><h2 id="6-JVM小结"><a href="#6-JVM小结" class="headerlink" title="6. JVM小结"></a>6. JVM小结</h2><h3 id="6-1-小结-amp-面试题"><a href="#6-1-小结-amp-面试题" class="headerlink" title="6.1 小结&amp;面试题"></a>6.1 小结&amp;面试题</h3><ol><li>JVM结构<ol><li>有哪几种类加载器？</li><li>双亲委派机制</li><li>沙箱安全</li></ol></li><li>Native<ol><li>native是一个关键字么？</li><li>native方法只有声明，没有实现。</li></ol></li><li>寄存器<ol><li>记录了方法之间的调用和执行情况，类似排班值日表；用来存储指向下一条指令的地址，也即将要执行的指令代码，它是当前线程所执行的字节码的<strong>行号指示器</strong>。</li></ol></li><li>方法区<ol><li>线程共享的运行时内存区域，存储了类的结构信息(模板)</li><li>是一个JVM规范，具体实现不同虚拟机是不同的，例如永久代和元空间</li></ol></li><li>栈<ol><li>栈内存主管Java程序运行，生命周期跟随线程生命周期，不存在GC问题。</li><li>栈帧中主要存储3类数据：本地变量、栈操作、栈帧数据。</li><li>栈运行原理？</li></ol></li><li>堆内存<ol><li>堆内存模型：新生区，养老区、永久代</li><li>堆new对象流程？新生区内存划分</li><li>轻GC的过程</li><li>什么是永久代？</li><li><code>-Xms</code>、<code>-Xmx</code>是干嘛的？</li></ol></li><li>GC<ol><li>GC是什么？</li><li>Minor GC和Full GC的区别？</li><li>Minor GC的工作原理？</li><li>GC有哪些算法？</li><li>垃圾收集器</li><li>GC使用哪个算法最好？</li></ol></li></ol><h2 id="7-JMM"><a href="#7-JMM" class="headerlink" title="7. JMM"></a>7. JMM</h2><p>JMM(Java内存模型Java Memory Model)，是一种抽象的概念<strong>并不真实存在</strong>，它描述的是一组规则或规范，通过这组规范定义了Java虚拟机在计算机内存中的工作方式。JVM是整个计算机虚拟模型，所以JMM隶属于JVM。抽象角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间共享变量存储在主内存中，每个线程都有自己私有的本地内存，本地内存中存储了该线程读写共享变量的副本。</p><p>JMM关于同步规范规定：</p><ol><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li><li>加锁解锁是同一把锁</li></ol><blockquote><p>Java的并发采用的是共享内存模型</p></blockquote><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(或称之为栈空间)，工作内存是每个线程的<strong>私有数据区域</strong>。Java内存模型中规定所有变量都存储在主内存，<strong>主内存是共享内存区域</strong>，所有线程都可以访问。<strong>但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完毕后将变量写回主内存。</strong>不能直接操作主内存中的变量，各个线程中的工作内存中储存着从主内存中变量的副本拷贝，因此不同的线程无法访问对方的工作内存，线程间的通讯(传值)必须通过主内存来完成，其简要访问过程如下图：</p><p><img src="http://yanxuan.nosdn.127.net/84363e8d1797ba915c2b93f7637b360d.png" alt="JMM"></p><h3 id="6-1-JMM的可见性问题"><a href="#6-1-JMM的可见性问题" class="headerlink" title="6.1 JMM的可见性问题"></a>6.1 JMM的可见性问题</h3><p>示例代码如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">class myNumber{    &#x2F;&#x2F; int number = 10;    &#x2F;&#x2F; 使用volatile关键字解决共享对象可见性问题    volatile int number = 10;    public void addNumber(){        this.number = 2020;    }}public class JMMDemo {    public static void main(String[] args) {        myNumber myNumber = new myNumber();        new Thread(()-&gt;{            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            myNumber.addNumber();            System.out.println(Thread.currentThread().getName()+&quot;\t update number,number value:&quot;+myNumber.number);        },&quot;AAA&quot;).start();        &#x2F;&#x2F; 由与JMM的可见性问题，AAA线程修改了number变量，对于其他线程不可见，故main线程while一直处于死循环        while (myNumber.number==10){            &#x2F;&#x2F; 需要一种通知机制告诉main线程，number的值已经修改过了        }        System.out.println(Thread.currentThread().getName()+&quot;\t mission is over&quot;);    }}</code></pre><p>上述代码中有两个线程，AAA线程和main线程，AAA线程会在自己的工作内存中操作number变量，修改其值为2020，main线程会一直循环判断number的值是否修改过，修改过则退出循环。执行代码会发现，AAA线程修改完number的值并写回主内存后，main线程的while一直处于死循环状态，这就是<strong>JMM的可见性问题</strong>。</p><p>解决这个问题很简单，使用<code>volatile</code>修饰number变量，让其保证可见性；这样AAA线程修改完毕后，主内存会通知main线程number变量值已经被修改过了，需更新变量副本为最新值，此时main线程就会去主内存重新获取最新的变量值，这样while就会结束死循环。</p><h2 id="参考与鸣谢"><a href="#参考与鸣谢" class="headerlink" title="参考与鸣谢"></a>参考与鸣谢</h2><p>本文参考了以下文章来帮助学习和了解，特此感谢！</p><ol><li>尚硅谷周阳JVM课程，感谢阳哥！</li><li>《深入理解Java虚拟机》—周志明著</li><li><a href="http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/" target="_blank" rel="noopener">Java中几种常量池区分</a></li><li><a href="https://www.jianshu.com/p/8a58d8335270" target="_blank" rel="noopener">JMM和底层实现原理</a></li><li><a href="https://www.cnblogs.com/xiaoxi/p/6486852.html" target="_blank" rel="noopener">Java垃圾回收机制详解</a></li><li><a href="https://www.cnblogs.com/manayi/p/9290490.html" target="_blank" rel="noopener">程序计数器</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaAdvanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从复制</title>
      <link href="/DataBase/master-slave-replication.html"/>
      <url>/DataBase/master-slave-replication.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p> 主从复制（也称 AB 复制）允许将来自一个MySQL数据库服务器（主服务器）的数据复制到一个或多个MySQL数据库服务器（从服务器）。 </p><a id="more"></a><h2 id="1-复制的基本原理"><a href="#1-复制的基本原理" class="headerlink" title="1. 复制的基本原理"></a>1. 复制的基本原理</h2><p>slave会从master读取binlog来进行数据同步。</p><p><img src="http://yanxuan.nosdn.127.net/dcbb07ac1dc4d00c963fd13165dff0ea.png" alt="复制原理图"></p><p>MySQL复制过程分为三步：</p><ol><li>master将改变记录到二进制日志(binary log)中；这些记录过程叫做二进制日志事件(binary log events)。</li><li>slave将master的binary log events拷贝到它的中继日志(relay log)。</li><li>salve重做中继日志中的事件，将改变应用到自己的数据库中；MySQL的复制是异步的且串行化的。</li></ol><h2 id="2-复制的基本原则"><a href="#2-复制的基本原则" class="headerlink" title="2. 复制的基本原则"></a>2. 复制的基本原则</h2><p>复制需遵从一些基本规则，规则如下：</p><ol><li>每个slave只有一个master</li><li>每个master只能有一个唯一的服务器ID</li><li>每个master可以有多个slave</li></ol><h2 id="3-复制的最大问题"><a href="#3-复制的最大问题" class="headerlink" title="3. 复制的最大问题"></a>3. 复制的最大问题</h2><p>复制的最大问题就是数据复制有<strong>延迟</strong>。</p><h2 id="4-一主一从常见配置"><a href="#4-一主一从常见配置" class="headerlink" title="4. 一主一从常见配置"></a>4. 一主一从常见配置</h2><p>该配置需满足mysql版本一致且后台以服务运行，主从都配置在<code>mysqld</code>结点下，最好小写。</p><h3 id="4-1-主机配置"><a href="#4-1-主机配置" class="headerlink" title="4.1 主机配置"></a>4.1 主机配置</h3><p>我的主机选择的是windows，配置文件是<code>my.ini</code>，参考配置文件如下</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-ini"># configuration a master-salve replication# master server idserver-id=1# enabled binary loglog-bin=D:\MySQL\mysql-5.7.23-winx64\mysqlbin# enabled error log [optional]log-err=D:\MySQL\mysql-5.7.23-winx64\mysqlerr# temp directory [optional]tmpdir=D:\MySQL\mysql-5.7.23-winx64\mysqltmp# close read-onlyread-only=0# set to ignore database [optional]binlog-ignore-db=mysql# set need database [optional]# binlog-do-db=xxx</code></pre><ul><li><code>server-id=1</code>：主服务器唯一ID，[必须]</li><li><code>log-bin=本地路径/mysqlbin</code>：启用二进制日志，[必须]</li><li><code>log-err=本地路径/mysqlerr</code>：启用错误日志，[可选]</li><li><code>tmpdir=本地mysql路径</code>：临时文件目录，[可选]</li><li><code>read-only=0</code>：表示主机读写都可</li><li><code>binlog-ignore-db=mysql</code>：设置不复制的数据库，[可选]</li><li><code>binlog-do-db=xxx</code>：设置需要复制的数据库，[可选]</li></ul><blockquote><p>如WindowsMySQL无法启动，主机配置中仅保留[必须]项即可。</p></blockquote><h3 id="4-2-从机配置"><a href="#4-2-从机配置" class="headerlink" title="4.2 从机配置"></a>4.2 从机配置</h3><p>我的从机使用的是WSL，mysql配置文件位于<code>/etc/mysql</code></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">vim &#x2F;etc&#x2F;mysql&#x2F;my.cnf</code></pre><ul><li>找到里面的<code>server-id</code>选项，开启并设置为2</li><li>找到并开启<code>log_bin</code></li></ul><h3 id="4-3-重启服务和关闭防火墙"><a href="#4-3-重启服务和关闭防火墙" class="headerlink" title="4.3 重启服务和关闭防火墙"></a>4.3 重启服务和关闭防火墙</h3><p>配置过的MySQL都需重启一下服务</p><h3 id="4-4-主机建立账户并授权"><a href="#4-4-主机建立账户并授权" class="headerlink" title="4.4 主机建立账户并授权"></a>4.4 主机建立账户并授权</h3><ul><li>授权</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">GRANT REPLICATION SLAVE ON *.* TO &#39;zero&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><ul><li>刷新权限</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">FLUSH PRIVILEGES;</code></pre><ul><li>查询master状态，记录下<code>File</code>和<code>Position</code>的值</li></ul><p><img src="http://yanxuan.nosdn.127.net/20246fcf4d185ab15fa4562cc0a9e33e.png" alt="master status"></p><h3 id="4-5-从机配置复制的主机"><a href="#4-5-从机配置复制的主机" class="headerlink" title="4.5 从机配置复制的主机"></a>4.5 从机配置复制的主机</h3><ul><li>配置连接到主机，注意：所有参数必须是主机最新参数！</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CHANGE MASTER TO MASTER_HOST=&#39;127.0.0.1&#39;,MASTER_USER=&#39;zero&#39;,MASTER_PASSWORD=&#39;123456&#39;,MASTER_LOG_FILE=&#39;mysqlbin.000001&#39;,MASTER_LOG_POS=1700</code></pre><ul><li>启动从服务器复制功能</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">start slave;</code></pre><ul><li>查看从机状态，看是否配置成功，主要查看<code>Slave_IO_Running:Yes</code>和<code>Slave_SQL_Running:Yes</code>这两个参数，都是Yes代表配置成功。</li></ul><p><img src="http://yanxuan.nosdn.127.net/1d57f2db529f15c5a32f9c4c050e87b7.png" alt="slave状态"></p><h3 id="4-6-建立数据库，测试功能"><a href="#4-6-建立数据库，测试功能" class="headerlink" title="4.6 建立数据库，测试功能"></a>4.6 建立数据库，测试功能</h3><ul><li>主机新建数据库，新建表，插入数据</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE DATABASE test_tmp_db;USE test_tmp_db;CREATE TABLE dog(  id INT NOT NULL,  NAME VARCHAR(20));INSERT INTO dog VALUES(1,&quot;www&quot;);</code></pre><ul><li>从机查看数据库，使用数据库并查询</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SHOW DATABASES;USE test_tmp_db;SELECT * FROM dog;</code></pre><p>可以看到所有操作都同步到从机了。</p><h3 id="4-7-停止复制功能"><a href="#4-7-停止复制功能" class="headerlink" title="4.7 停止复制功能"></a>4.7 停止复制功能</h3><p>使用<code>stop slave;</code>命令停止从主机同步数据。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁机制</title>
      <link href="/DataBase/Lock.html"/>
      <url>/DataBase/Lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-MySQL锁机制"><a href="#1-MySQL锁机制" class="headerlink" title="1. MySQL锁机制"></a>1. MySQL锁机制</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><a id="more"></a><p>在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤为重要，也更加复杂。</p><h2 id="1-1-锁的分类"><a href="#1-1-锁的分类" class="headerlink" title="1.1 锁的分类"></a>1.1 锁的分类</h2><h3 id="1-1-1-按对数据操作的类型分"><a href="#1-1-1-按对数据操作的类型分" class="headerlink" title="1.1.1 按对数据操作的类型分"></a>1.1.1 按对数据操作的类型分</h3><ul><li>读锁(<strong>共享锁</strong>)：其他事务可以读，但不能写。</li><li>写锁(<strong>排它锁</strong>)：其他事务不能读取，也不能写。</li></ul><h3 id="1-1-2-按对数据操作的粒度分"><a href="#1-1-2-按对数据操作的粒度分" class="headerlink" title="1.1.2 按对数据操作的粒度分"></a>1.1.2 按对数据操作的粒度分</h3><p>MySQL不同存储引擎支持不同的锁机制。</p><ul><li>表锁：就是一锁就锁一整张表，表锁定期间，其他事务不能对该表进行操作。</li><li>行锁：就是一锁就锁一行或多行记录。</li></ul><h1 id="2-三锁"><a href="#2-三锁" class="headerlink" title="2. 三锁"></a>2. 三锁</h1><h2 id="2-1-表锁-偏读"><a href="#2-1-表锁-偏读" class="headerlink" title="2.1 表锁(偏读)"></a>2.1 表锁(偏读)</h2><p>偏向MyISAM存储引擎；表级锁开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。表级锁更适合于查询为主，并发用户小，只有少量按索引条件更新数据的应用，如Web应用。</p><p>关于锁操作基本命令：</p><ul><li>查看表是否上锁(1代表上锁)：<code>show open tables;</code></li><li>解锁：<code>unlock tables;</code></li></ul><h3 id="2-1-1-建表"><a href="#2-1-1-建表" class="headerlink" title="2.1.1 建表"></a>2.1.1 建表</h3><p>以下操作要在两个会话中操作，分别是会话1和会话2。</p><ul><li>会话1建表</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE TABLE mylock(  id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,  NAME VARCHAR(20))ENGINE MYISAM;INSERT INTO mylock(NAME) VALUES(&#39;a&#39;),(&#39;b&#39;),(&#39;c&#39;),(&#39;d&#39;),(&#39;e&#39;);</code></pre><h3 id="2-1-2-加读锁"><a href="#2-1-2-加读锁" class="headerlink" title="2.1.2 加读锁"></a>2.1.2 加读锁</h3><ul><li>会话1(当前)加读锁，开启会话2(其他)</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">LOCK TABLE mylock READ;</code></pre><ul><li>当前会话可以查询该表，其他会话也可查询该表</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT * FROM mylock;</code></pre><ul><li>当前会话无法查询其他未锁表，其他会话正常查询或更新其他未锁表</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT * FROM book; &#x2F;*会话1查询未锁表会报错：ERROR 1100 (HY000): Table &#39;book&#39; was not locked with LOCK TABLES*&#x2F;select * from book;&#x2F;*会话2查询未锁表正常*&#x2F;</code></pre><ul><li>当前会话无法更新该表，其他会话更新或插入操作会阻塞等待，直到会话1释放锁(<code>unlock tables;</code>)</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">UPDATE mylock SET NAME=&#39;a2&#39; WHERE id=1; &#x2F;*当前会话更新会报错：ERROR 1099 (HY000): Table &#39;mylock&#39; was locked with a READ lock and can&#39;t be updated*&#x2F;UPDATE mylock SET NAME=&#39;a2&#39; WHERE id=1; &#x2F;*其他会话操作会一直阻塞等待会话1释放锁*&#x2F;</code></pre><h3 id="2-1-3-加写锁"><a href="#2-1-3-加写锁" class="headerlink" title="2.1.3 加写锁"></a>2.1.3 加写锁</h3><ul><li>会话1加写锁，开启会话2</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">lock table mylock write;</code></pre><ul><li>当前会话正常查询、修改该表，不可查询其他未锁表</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">select * from mylock;update mylock set name=&#39;a2&#39; where id=1;select * from book; &#x2F;*报错*&#x2F;</code></pre><ul><li>会话2查询或者修改操作都会阻塞等待释放锁。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">select * from mylock; # 其他查询会阻塞等待释放锁。update mylock set name=&#39;b2&#39; where id=2; # 其他操作会阻塞</code></pre><h3 id="2-1-4-表锁小结"><a href="#2-1-4-表锁小结" class="headerlink" title="2.1.4 表锁小结"></a>2.1.4 表锁小结</h3><p><code>MyISAM</code>在执行查询语句(SELECT)之前，会自动给涉及的所有表加读锁；在执行增删改操作前，会自动给涉及的表加写锁。</p><p>MySQL的表级锁有两种模式：</p><ul><li>表共享读锁(Table Read Lock)</li><li>表独占写锁(Table Write Lock)</li></ul><p>结合上述案例，对MyISAM表进行操作，有如下结论：</p><ol><li>对MyISAM表的读操作(加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求；只有当读锁释放后，才会执行其他进程的写操作。</li><li>对MyISAM表的写操作(加写锁)，会阻塞其他进程对同一表的读和写操作；只有当写锁释放后，才会执行其他进程的读写操作。</li></ol><blockquote><font color="red">简言之：读锁可读不可写；写锁读写会阻塞。</font></blockquote><h3 id="2-1-5-表锁分析"><a href="#2-1-5-表锁分析" class="headerlink" title="2.1.5 表锁分析"></a>2.1.5 表锁分析</h3><p>可以使用SQL：<code>show status like &quot;table%&quot;;</code>来查看表锁定状态，分析系统上的表锁定。下面是两个较为重要的状态变量：</p><ul><li><code>Table_locks_immediate</code>：产生表级锁定的次数，表示可以立即获得锁的查询次数，每立即获取锁值加1。</li><li><code>Table_locks_waitd</code>：出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1)，此值高则说明存在着较严重的表级锁争用情况。</li></ul><blockquote><p>MyISAM的读写锁调度是写优先的，因此MyISAM不适合做写为主的表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，造成永久堵塞。</p></blockquote><h2 id="2-2-行锁-偏写"><a href="#2-2-行锁-偏写" class="headerlink" title="2.2 行锁(偏写)"></a>2.2 行锁(偏写)</h2><p>偏向InnoDB存储引擎；行级锁开销大，加锁慢；会出现死锁；锁定粒度最小，发送锁冲突概率最低，并发度最高。最大程度的支持并发，同时也带来最大的锁开销。</p><p>InnoDB与MyISAM最大的不同有两点：</p><ol><li>InnoDB是支持事务的。</li><li>InnoDB采用了行级锁。</li></ol><h3 id="2-2-1-建表"><a href="#2-2-1-建表" class="headerlink" title="2.2.1 建表"></a>2.2.1 建表</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE TABLE test_innodb_lock(    a INT(11),    b VARCHAR(16))ENGINE=INNODB;INSERT INTO test_innodb_lock VALUES(1,&#39;b2&#39;),(3,&#39;3&#39;),(4,&#39;4000&#39;),(5,&#39;5000&#39;),(6,&#39;6000&#39;),(7,&#39;7000&#39;),(8,&#39;8000&#39;),(9,&#39;9000&#39;),(1,&#39;b1&#39;);CREATE INDEX test_innodb_a_idx ON test_innodb_lock(a);CREATE INDEX test_innodb_b_idx ON test_innodb_lock(b);</code></pre><h3 id="2-2-2-行锁演示"><a href="#2-2-2-行锁演示" class="headerlink" title="2.2.2 行锁演示"></a>2.2.2 行锁演示</h3><ul><li>开启两个会话，会话1和会话2，分别设置关闭自动提交</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SHOW VARIABLES LIKE &quot;autocommit&quot;SET autocommit = 0;</code></pre><ul><li>会话1更新但不提交</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">UPDATE test_innodb_lock SET b=&#39;4001&#39; WHERE a=4;</code></pre><ul><li>会话2更新同字段将被阻塞等待</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">UPDATE test_innodb_lock SET b=&#39;4001&#39; WHERE a=4;</code></pre><ul><li>会话1提交，会话2更新操作才会执行。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">commit;</code></pre><ul><li>如果会话1更新字段和会话2不同，那么不会阻塞操作请求</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">&#x2F;*会话1操作*&#x2F;UPDATE test_innodb_lock SET b=&#39;5001&#39; WHERE a=5;&#x2F;*会话2操作*&#x2F;UPDATE test_innodb_lock SET b=&#39;9001&#39; WHERE a=9;</code></pre><blockquote><p>注意：操作更新完成后，必须提交才能使其他会话看到更新记录；这是因为默认的隔离级别，可重复读的。</p></blockquote><h3 id="2-2-3-行锁索引失效升级为表锁"><a href="#2-2-3-行锁索引失效升级为表锁" class="headerlink" title="2.2.3 行锁索引失效升级为表锁"></a>2.2.3 行锁索引失效升级为表锁</h3><ul><li>会话1执行以下语句</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"> update test_innodb_lock set a=40 where b=4001; &#x2F;*注意此处b字段应该加单引号，故意为加，MySQL将会做自动类型转换，导致索引失效*&#x2F;</code></pre><ul><li>会话2执行非同字段更新操作，会发现被阻塞了</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">update test_innodb_lock set b=&#39;9002&#39; where a=9；</code></pre><ul><li>会话1执行commit操作后，会话2才结束阻塞，正常执行。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">commit;</code></pre><ul><li>可以发现，在索引失效或者没有索引的情况下，行锁是会升级为表锁的，导致其他进程阻塞无法操作。</li></ul><h3 id="2-2-4-间隙锁"><a href="#2-2-4-间隙锁" class="headerlink" title="2.2.4 间隙锁"></a>2.2.4 间隙锁</h3><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做”<strong>间隙(GAP)</strong>“；InnoDB也会对这个“间隙”加锁，这种锁机制就是<strong>间隙锁(Next-Key)锁</strong>。下面开始间隙锁案例：</p><ul><li>查表可知表中没有a=2的记录，会话1做范围更新操作</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">update test_innodb_lock set b=&#39;0329&#39; where a&gt;1 and a&lt;6;</code></pre><ul><li>会话2做插入操作，插入a=2的数据。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">insert into test_innodb_lock values(2,&#39;2000&#39;);</code></pre><p>可以看到会话2的插入操作被阻塞了，只有会话1提交后才能继续执行，这就是间隙锁。</p><p>因为Query在执行过程中通过范围查找的话，会锁定整个范围内的所有索引键值，即使这个键值并不存在；间隙锁的致命弱点就是，当锁定一个范围键值后，即使某些不存在的键值也会被无辜的锁定，从而造成在锁定的时候无法插入锁定键值范围内的任何数据；在某些场景下可能会对性能造成很大的危害。</p><h3 id="2-2-5-面试题：如何锁定一行？"><a href="#2-2-5-面试题：如何锁定一行？" class="headerlink" title="2.2.5 面试题：如何锁定一行？"></a>2.2.5 面试题：如何锁定一行？</h3><p>案例如下：</p><ul><li>会话1操作</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">begin;select * from test_innodb_lock where a = 8 for update;</code></pre><ul><li>会话2操作更新将会阻塞</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">update test_innodb_lock set b=&#39;8888&#39; where a=8;</code></pre><ul><li>直到会话1做提交操作在能执行成功</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">commit;</code></pre><p>如上使用<code>select xxx... for update</code>锁定某一行后，其他的操作会被阻塞，直到锁定行的会话提交commit。</p><h3 id="2-2-6-行锁小结"><a href="#2-2-6-行锁小结" class="headerlink" title="2.2.6 行锁小结"></a>2.2.6 行锁小结</h3><p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。</p><p>当系统并发量较高时，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。但是InnoDB的行级锁定同样有其劣势的一面，当我们使用不当时，可能会让InnoDB的整体性能表现反而比不上MyISAM。</p><h3 id="2-2-7-行锁分析"><a href="#2-2-7-行锁分析" class="headerlink" title="2.2.7 行锁分析"></a>2.2.7 行锁分析</h3><p>通过<code>show status like &quot;innodb_row_lock%&quot;;</code>命令检查<code>InnoDB_row_lock</code>状态变量来分析系统上的行锁争夺情况。各个状态量说明：</p><ul><li><code>Innodb_row_lock_current_waits</code>：当前正在等待锁定的数量；</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；</li><li><code>Innodb_row_lock_time_max</code>：从系统启动到现在等待最长一次所花时间；</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数。</li></ul><p>上述5个状态变量中，比较重要的是这三个：</p><ul><li><code>Innodb_row_lock_time</code>：等待总时长</li><li><code>Innodb_row_lock_time_avg</code>：平均等待时长</li><li><code>Innodb_row_lock_waits</code>：等待总次数</li></ul><p>尤其是当等待次数很高，且每次等待时长也不小时，就需要分析系统中为什么有如此多的等待了，然后根据分析结果制定优化计划。</p><h3 id="2-2-8-行锁优化建议"><a href="#2-2-8-行锁优化建议" class="headerlink" title="2.2.8 行锁优化建议"></a>2.2.8 行锁优化建议</h3><ul><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能较少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可能低级别事务隔离</li></ul><h2 id="2-3-页锁"><a href="#2-3-页锁" class="headerlink" title="2.3 页锁"></a>2.3 页锁</h2><p>页面锁开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL Lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL慢查询日志</title>
      <link href="/DataBase/slow-query-log.html"/>
      <url>/DataBase/slow-query-log.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-慢查询日志"><a href="#1-慢查询日志" class="headerlink" title="1. 慢查询日志"></a>1. 慢查询日志</h2><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，就会被记录到慢查询日志中。</p><a id="more"></a><p>long_query_time的默认值是10，也就是运行10秒以上的语句。通过查看哪些SQL超出了我们的最大查询时间值，可以结合explain进行具体的优化。</p><p>默认情况下，MySQL数据库没有开启慢查询日志，需手动设置参数开启。一般不是调优需要的话，不建议启动该参数，因为开启慢查询日志会带来一定的性能影响；慢查询日志是支持将日志记录写入文件的。</p><h3 id="1-1-查看与启动"><a href="#1-1-查看与启动" class="headerlink" title="1.1 查看与启动"></a>1.1 查看与启动</h3><ul><li>查看：<code>SHOW VARIABLES LIKE &quot;%slow_query_log%&quot;</code></li><li>开启：<code>set global slow_query_log = 1</code></li></ul><blockquote><p>如果想永久生效，需修改配置文件</p></blockquote><h3 id="1-2-慢查询记录标准"><a href="#1-2-慢查询记录标准" class="headerlink" title="1.2 慢查询记录标准"></a>1.2 慢查询记录标准</h3><p>这个是由参数long_query_time控制的，默认情况下该值为10秒。</p><ul><li>查看：<code>SHOW VARIABLES LIKE &quot;%long_query_time%&quot;</code></li></ul><h3 id="1-3-设置阈值参数"><a href="#1-3-设置阈值参数" class="headerlink" title="1.3 设置阈值参数"></a>1.3 设置阈值参数</h3><ul><li>设置：<code>SET GLOBAL long_query_time = 3</code></li></ul><blockquote><p>注意：修改完毕后需重新连接会话</p></blockquote><h3 id="1-4-测试与查看"><a href="#1-4-测试与查看" class="headerlink" title="1.4 测试与查看"></a>1.4 测试与查看</h3><p>输入<code>select sleep(4);</code>来模拟一个慢查询，然后打开<code>slow_query_log_file</code>处的慢查询日志，查看慢查询SQL。</p><ul><li>使用<code>SHOW GLOBAL STATUS LIKE &quot;%slow_queries%&quot;</code>命令查看当前系统中有多少条慢查询记录。</li></ul><h3 id="1-5-配置文件"><a href="#1-5-配置文件" class="headerlink" title="1.5 配置文件"></a>1.5 配置文件</h3><p>如果要写配置文件，配置如下</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-ini">slow_query_log = 1slow_query_log_file=&#x2F;xxx&#x2F;mysql&#x2F;name-slow.loglong_query_time=3log_output=xxx</code></pre><h3 id="1-6-日志分析工具"><a href="#1-6-日志分析工具" class="headerlink" title="1.6 日志分析工具"></a>1.6 日志分析工具</h3><p>在生产环境中，如果要手动分析日志，查找、分析SQL比较麻烦，MySQL提供了日志分析工具<code>mysqldumpslow</code>。</p><h2 id="2-批量数据脚本"><a href="#2-批量数据脚本" class="headerlink" title="2. 批量数据脚本"></a>2. 批量数据脚本</h2><h3 id="2-1-建表"><a href="#2-1-建表" class="headerlink" title="2.1 建表"></a>2.1 建表</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE TABLE dept(    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,    dname VARCHAR(20) NOT NULL DEFAULT &quot;&quot;,    loc VARCHAR(13) NOT NULL DEFAULT &quot;&quot; &#x2F;*楼层*&#x2F;)ENGINE = INNODB DEFAULT CHARSET = GBK;CREATE TABLE emp(    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, &#x2F;*编号*&#x2F;    ename VARCHAR(20) NOT NULL DEFAULT &quot;&quot;,     job VARCHAR(9) NOT NULL DEFAULT &quot;&quot;,    mgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, &#x2F;*上级编号*&#x2F;    hiredate DATE NOT NULL, &#x2F;*入职时间*&#x2F;    sal DECIMAL(7,2) NOT NULL, &#x2F;* 薪水*&#x2F;    comm DECIMAL(7,2) NOT NULL, &#x2F;*红利*&#x2F;    deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0&#x2F;*部门编号*&#x2F;)ENGINE = INNODB DEFAULT CHARSET=GBK;</code></pre><h3 id="2-2-设置参数"><a href="#2-2-设置参数" class="headerlink" title="2.2 设置参数"></a>2.2 设置参数</h3><p>为了避免创建函数时报错<code>This function has none of DETERMINTSTIC....</code>，这里需设置一些参数，具体如下：</p><ul><li>查看：<code>show variables like &quot;%log_bin_trust_function_creators&quot;;</code></li><li>设置：<code>SET GLOBAL log_bin_trust_function_creators = 1;</code></li></ul><h3 id="2-3-创建函数"><a href="#2-3-创建函数" class="headerlink" title="2.3 创建函数"></a>2.3 创建函数</h3><p>需创建随机生成字符串和随机部门编号函数</p><ul><li>随机字符串函数</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">DELIMITER $$ # 设置自定义结束符为$$CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)BEGIN  DECLARE chars_str VARCHAR(100) DEFAULT &#39;abcdefghijklmnobqrstuvxyzABCDEFGHIJKLMNOBQRSTUVWXYZ&#39;;  DECLARE return_str VARCHAR(255) DEFAULT &#39;&#39;;  DECLARE i INT DEFAULT 0;  WHILE i &lt; n DO  SET return_str = CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));  SET i = i + 1;  END WHILE;  RETURN return_str;END $$</code></pre><ul><li>随机部门编号函数</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">DELIMITER $$CREATE FUNCTION rand_num() RETURNS INT(5)BEGIN  DECLARE i INT DEFAULT 0;  SET i = FLOOR(100+RAND()*10);RETURN i;END $$</code></pre><h3 id="2-4-创建存储过程"><a href="#2-4-创建存储过程" class="headerlink" title="2.4 创建存储过程"></a>2.4 创建存储过程</h3><p>为插入数据创建两个存储过程</p><ul><li>员工表插入数据存储过程</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">delimiter $$create procedure insert_emp(in start int(10),in max_num int(10))begindeclare i int default 0;set autocommit = 0; &#x2F;*将自动提交关闭*&#x2F;repeatset i = i + 1;insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values((start+i),rand_string(6),&#39;SALESMAN&#39;,0001,curdate(),2000,400,rand_num());until i = max_numend repeat;commit;end $$</code></pre><ul><li>部门表插数据存储过程</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">delimiter $$create procedure insert_dept(in start int(10),in max_num int(10))begindeclare i int default 0;set autocommit = 0;repeatset i = i + 1;insert into dept(deptno,dname,loc) values((start+i),rand_string(10),rand_string(8));until i = max_numend repeat;commit;end $$</code></pre><h3 id="2-5-调用存储过程"><a href="#2-5-调用存储过程" class="headerlink" title="2.5 调用存储过程"></a>2.5 调用存储过程</h3><p>为了后续学习查询优化，这里模拟100w数据。</p><ul><li>插入10个部门信息</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">DELIMITER ;CALL insert_dept(100,10)</code></pre><ul><li>插入员工信息，或者50w一次分2次。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">DELIMITER ;call insert_emp(100001,1000000);</code></pre><h2 id="3-Show-Profile"><a href="#3-Show-Profile" class="headerlink" title="3. Show Profile"></a>3. Show Profile</h2><p>ShowProfile是MySQL提供可以用来分析当前会话中语句执行的资源消耗情况；可以用于SQL的调优测量。</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/show-profile.html" target="_blank" rel="noopener">官网链接</a></p><h3 id="3-1-分析步骤"><a href="#3-1-分析步骤" class="headerlink" title="3.1 分析步骤"></a>3.1 分析步骤</h3><h4 id="3-1-1-查看与开启"><a href="#3-1-1-查看与开启" class="headerlink" title="3.1.1 查看与开启"></a>3.1.1 查看与开启</h4><ul><li>查看：<code>SHOW VARIABLES LIKE &quot;profiling&quot;;</code></li><li>开启：<code>set profiling=on;</code></li></ul><h4 id="3-1-2-运行SQL"><a href="#3-1-2-运行SQL" class="headerlink" title="3.1.2 运行SQL"></a>3.1.2 运行SQL</h4><ul><li><code>select * from emp group by id%20 order by 5;</code></li></ul><h3 id="3-1-3-查看结果"><a href="#3-1-3-查看结果" class="headerlink" title="3.1.3 查看结果"></a>3.1.3 查看结果</h3><p>Show Profile默认存储最近15次的运行结果。</p><ul><li><code>show profiles;</code></li></ul><h3 id="3-1-4-查看诊断结果"><a href="#3-1-4-查看诊断结果" class="headerlink" title="3.1.4 查看诊断结果"></a>3.1.4 查看诊断结果</h3><ul><li><code>show profile cpu,block io for query</code>+前面查询SQL的<code>Query_ID</code></li></ul><p><img src="http://yanxuan.nosdn.127.net/d3f0a11ecd6d3aeb713d27f669021fe0.png" alt="show profile"></p><ul><li><p>关于诊断参数</p><ul><li>All：显示所有的开销信息</li><li>Block IO：显示块IO相关开销</li><li>Context Switches：上下文切换相关开销</li><li>CPU：显示CPU相关开销信息</li><li>IPC：显示发送和接收相关开销信息</li><li>Memory：显示内存相关开销信息</li><li>Page Faults：显示页面错误相关开销信息</li><li>Source：显示和Source_function、Source_file、Source_line相关开销信息</li><li>Swaps：显示交换次数相关开销信息</li></ul></li><li><p>开发中必须注意的几点Status信息：</p><ul><li>Converting HEAP to MyISAM：查询结果太大，内存不够用往磁盘搬了</li><li>Creating tmp table：创建临时表(拷贝数据到临时表，然后用完再删除)</li><li>Copying to tmp table on disk：把内存中临时表复制到磁盘，危险！</li><li>Locked：上锁了</li></ul></li></ul><h2 id="4-全局查询日志"><a href="#4-全局查询日志" class="headerlink" title="4. 全局查询日志"></a>4. 全局查询日志</h2><p>该选项禁止在生成环境中开启！</p><h3 id="4-1-配置启用"><a href="#4-1-配置启用" class="headerlink" title="4.1 配置启用"></a>4.1 配置启用</h3><p>直接在配置文件中配置如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-ini">#开启general_log=1#记录日志文件的路径general_log_file=xxx #本地文件路径#输出格式log_output=file</code></pre><h3 id="4-2-编码启用"><a href="#4-2-编码启用" class="headerlink" title="4.2 编码启用"></a>4.2 编码启用</h3><p>在MySQL命令行中开启</p><ul><li>查看是否启用：<code>show variables like &quot;%general_log%&quot;;</code></li><li>开启：<code>set global general_log=1;</code></li><li>设置输出格式：<code>set global log_output=&#39;TABLE&#39;;</code></li><li>查看日志：<code>SELECT * FROM mysql.</code>general_log<code>;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Query log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL查询优化</title>
      <link href="/DataBase/Query-optimize.html"/>
      <url>/DataBase/Query-optimize.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><a id="more"></a><h2 id="1-小表驱动大表"><a href="#1-小表驱动大表" class="headerlink" title="1. 小表驱动大表"></a>1. 小表驱动大表</h2><p>小表驱动大表，就是小的数据集驱动大的数据集。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">select * from A where id in (select id from B);等价于：for select id from Bfor select * from A where A.id = B.id</code></pre><ul><li>当B表的数据集小于A表的数据集时，用in优于exists。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">select * from A where exists (select 1 from B where B.id = A.id)等价于for select * from A for select * from B where B.id = A.id</code></pre><ul><li>当A表数据集小于B表的数据集时，用exists优于in。</li></ul><blockquote><p>注意：A表与B表的ID字段应建立索引。</p></blockquote><ul><li>EXISTS</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT xxx FROM table WHERE EXISTS(subQuery);</code></pre><p>该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果(TRUE或FALSE)来决定主查询的数据结果是否得以保留。</p><blockquote><p>EXISTS(subQuery)只返回布尔值，因此子查询中select * 也可以是select 1或select ‘x’，官方说法是实际执行时会忽略SELECT清单，因此没有区别。</p><p>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如担心效率问题可以自行进行实际检验。</p><p>EXISTS子查询往往也可以用条件表达式、其他子查询或JOIN来替代，何种最优需具体问题具体分析。</p></blockquote><h2 id="2-ORDER-BY优化"><a href="#2-ORDER-BY优化" class="headerlink" title="2. ORDER BY优化"></a>2. ORDER BY优化</h2><h3 id="2-1-ORDER-BY子句尽量使用Index方式排序"><a href="#2-1-ORDER-BY子句尽量使用Index方式排序" class="headerlink" title="2.1 ORDER BY子句尽量使用Index方式排序"></a>2.1 ORDER BY子句尽量使用Index方式排序</h3><ul><li>建表插数据建索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE TABLE tbA(    id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,    age INT,    birth TIMESTAMP NOT NULL);INSERT INTO tbA(age,birth) VALUES(22,NOW()),(23,NOW()),(24,NOW());CREATE INDEX idx_tbA_ageBirth ON tbA(age,birth);</code></pre><ul><li>case1：分析下列sql是否产生了filesort，Y代表产生了，N表示未产生。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM tbA WHERE age&gt;20 ORDER BY age; # NEXPLAIN SELECT * FROM tbA WHERE age&gt;20 ORDER BY age,birth; # NEXPLAIN SELECT * FROM tbA WHERE age&gt;20 ORDER BY birth; # YEXPLAIN SELECT * FROM tbA WHERE age&gt;20 ORDER BY birth,age; # Y</code></pre><ul><li>case2：分析下列sql是否产生了filesort。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM tbA ORDER BY birth; # YEXPLAIN SELECT * FROM tbA WHERE birth &gt; &#39;2019-09-28 00:00:00&#39; ORDER BY birth;#YEXPLAIN SELECT * FROM tbA WHERE birth &gt; &#39;2019-09-28 00:00:00&#39; ORDER BY age; # NEXPLAIN SELECT * FROM tbA ORDER BY age ASC, birth DESC; # Y,因为默认排序是ASC，手动指定了DESC必定会产生filesort。</code></pre><ul><li>MySQL支持两种方式的排序，FileSort和Index，Index效率高，它指的是MySQL扫描索引本身完成的排序。FileSort效率较低。</li><li>ORDER BY 满足两情况，会使用Index方式排序：<ul><li>ORDER BY语句使用索引最左前列(<strong>最佳左前缀原则</strong>)。</li><li>使用Where子句与OrderBy子句条件列组合满足索引最左前列。</li></ul></li></ul><h3 id="2-2-尽可能在索引列上完成排序操作"><a href="#2-2-尽可能在索引列上完成排序操作" class="headerlink" title="2.2 尽可能在索引列上完成排序操作"></a>2.2 尽可能在索引列上完成排序操作</h3><p>索引建立时已经排好序了，默认是升序(ASC)，所以ORDER BY尽量使用索引的排序，就可以避免产生FileSort。</p><h3 id="2-3-FileSort的两种算法"><a href="#2-3-FileSort的两种算法" class="headerlink" title="2.3 FileSort的两种算法"></a>2.3 FileSort的两种算法</h3><h4 id="2-3-1-双路排序"><a href="#2-3-1-双路排序" class="headerlink" title="2.3.1 双路排序"></a>2.3.1 双路排序</h4><p>MySQL4.1之前是使用双路排序，就是进行两次扫描磁盘，最终得到数据。读取行指针和OrderBy列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。</p><ul><li>第一次IO：从磁盘读取排序字段，在buffer进行排序。</li><li>第二次IO：根据排序列表从磁盘中读取对应的数据。</li></ul><blockquote><p>取数据时要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在MySQL4.1后，出现了第二张改进算法，就是单路排序。</p></blockquote><h4 id="2-3-2-单路排序"><a href="#2-3-2-单路排序" class="headerlink" title="2.3.2 单路排序"></a>2.3.2 单路排序</h4><p>从磁盘读取查询所需的所有列，按照OrderBy列在buffer对它们进行排序，然后扫描排序后的列表进行输出。该算法效率更快一些，避免了二次读取数据。并且把随机IO变成了顺序IO；缺点是会使用更多的空间，因为它把每一行都保存在内存中了。</p><h4 id="2-3-3-结论和引申出的问题"><a href="#2-3-3-结论和引申出的问题" class="headerlink" title="2.3.3 结论和引申出的问题"></a>2.3.3 结论和引申出的问题</h4><p>单路排序总体而言好过双路，但单路有个问题就是：由于单路排序会一次磁盘读取所有列，当取出的数据总大小超过了sort_buffer容量时，会导致每次只取sort_buffer容量大小的数据进行排序(创建tem文件，多路合并)，排完后再次IO取数据，以此类推。故在读取大量数据时，反而导致了大量的IO操作，得不偿失。</p><h3 id="2-4-优化策略"><a href="#2-4-优化策略" class="headerlink" title="2.4 优化策略"></a>2.4 优化策略</h3><h4 id="2-4-1-增大sort-buffer-size参数的设置"><a href="#2-4-1-增大sort-buffer-size参数的设置" class="headerlink" title="2.4.1 增大sort_buffer_size参数的设置"></a>2.4.1 增大sort_buffer_size参数的设置</h4><h4 id="2-4-2-增大max-length-for-sort-data参数的设置"><a href="#2-4-2-增大max-length-for-sort-data参数的设置" class="headerlink" title="2.4.2 增大max_length_for_sort_data参数的设置"></a>2.4.2 增大max_length_for_sort_data参数的设置</h4><h4 id="2-4-3-提高Order-By的速度"><a href="#2-4-3-提高Order-By的速度" class="headerlink" title="2.4.3 提高Order By的速度"></a>2.4.3 提高Order By的速度</h4><ul><li>Order By时select * 是大忌！只Query需要的字段，这点非常重要。<ul><li>当Query的字段大小总和小于max_length_for_sort_data且排序字段不是TEXT|BLOB类型时，会用改进后的单路排序算法，反正大于则使用老算法多路排序。</li><li>两种算法的数据都可能超过sort_buffer的容量，超过后会创建tem文件进行合并排序，导致多次IO；所以使用单路排序算法的风险更大，因此出现高IO时需提高sort_buffer_size。</li></ul></li><li>尝试提高sort_buffer_size<ul><li>不管用哪种算法，提高该参数都会提高效率；当然具体需根据系统能力去提高，一般由DBA操作。</li></ul></li><li>尝试提高max_length_for_sort_data<ul><li>提高这个参数，会增加用改进算法的效率；但如果设太高，数据总容量超出sort_buffer_size的概率就增大，明显症状就是高磁盘IO活动和低CPU使用率。</li></ul></li></ul><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>使用Order by时，注意以下几点</p><ul><li><p>为排序使用索引</p><ul><li>MySQL两种排序方式：文件排序或扫描有序索引排序</li><li>MySQL能为排序与查询使用相同索引，即在索引列上的数据无需再次排序，提高性能。</li></ul></li><li><p>order by的使用尽量遵循索引最左前缀原则</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">create index idx_abc on table(a,b,c);xxx order by axxx order by a,bxxx order by a,b,cxxx order by a desc,b desc,c desc; &#x2F;*必须使用同一种排序方式，否则会产生filesort*&#x2F;</code></pre><ul><li>如果where使用到了索引的最左前缀定义为常量，则order by能使用到索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">xxx where a = const order by b,cxxx where a = const and b = const order by cxxx where a = const and b &gt; const order by b,c</code></pre><ul><li>不要使用索引进行排序</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">xxx order by a asc,b desc, c desc &#x2F;* 排序不一致*&#x2F;xxx where g = const order by b,c  &#x2F;* 丢失a索引 *&#x2F;xxx where a = const order by c    &#x2F;* 丢失b索引 *&#x2F;xxx where a = const order by a,d  &#x2F;* d非索引列*&#x2F;xxx where a in(...) order by b,c  &#x2F;* 范围查询后面索引失效*&#x2F;</code></pre><h2 id="3-GROUP-BY-优化"><a href="#3-GROUP-BY-优化" class="headerlink" title="3. GROUP BY 优化"></a>3. GROUP BY 优化</h2><p>group by优化跟order by优化大致相同</p><ul><li>group by 实质是先排序后进行分组，同样遵循索引的最佳左前缀原则。</li><li>无法使用索引列时，增大max_length_for_sort_data参数的设置和增加sort_buffer_size参数的设置。</li><li>where高于having，能写在where限定的条件就不要去having限定了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Query optimize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引优化</title>
      <link href="/DataBase/Index-optimize.html"/>
      <url>/DataBase/Index-optimize.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-索引分析"><a href="#1-索引分析" class="headerlink" title="1. 索引分析"></a>1. 索引分析</h2><a id="more"></a><h3 id="1-1-单表优化"><a href="#1-1-单表优化" class="headerlink" title="1.1 单表优化"></a>1.1 单表优化</h3><ul><li>创建表插入数据</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">create table article(    id int(10) unsigned not null primary key auto_increment,    author_id int(10) unsigned not null,    category_id int(10) unsigned not null,    views int(10) unsigned not null,    comments int(10) unsigned not null,    title varbinary(255) not null,    content text not null);insert into article(author_id,category_id,views,comments,title,content) values(1,1,1,1,&#39;1&#39;,&#39;1&#39;),(2,2,2,2,&#39;2&#39;,&#39;2&#39;),(3,1,1,3,&#39;3&#39;,&#39;3&#39;);</code></pre><ul><li>查询category_id为1且comments大于1的情况下，views最多的article_id</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">select id,author_id from article where category_id = 1 and comments &gt; 1 order by views desc limit 1</code></pre><ul><li>查看执行计划，sql分析：type是all表示全表扫描，Extra还出现了filesort，产生了文件内排序，且未使用到索引；必须优化。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">explain select id,author_id from article where category_id = 1 and comments &gt; 1 order by views desc limit 1</code></pre><ul><li>开始优化，创建复合索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE INDEX idx_article_ccv ON article(category_id,comments,views);</code></pre><ul><li>再次查看执行计划，sql分析：type变为了range表示范围内索引，且使用到了建立的复合索引，但还是产生了文件内排序。 但是按照Btree索引的工作原理，先排序category_id,再排序commnets，因为comments字段大于1是一个范围值，导致无法利用索引对后面的views进行检索，索引部分失效了</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1</code></pre><ul><li>优化2，删除非最优索引，绕过comments创建复合索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">drop index idx_article_ccv on article;create index idx_article_cv on article(category_id,views); </code></pre><ul><li>查看执行计划，sql分析：type为ref级别，using filesort也没了，非常理想的优化结果。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1</code></pre><h3 id="1-2-两表优化"><a href="#1-2-两表优化" class="headerlink" title="1.2 两表优化"></a>1.2 两表优化</h3><ul><li>创建表插数据</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">create table class(    id int(10) unsigned not null auto_increment,    card int(10) unsigned not null,    primary key(id));create table book(    bookid int(10) unsigned not null auto_increment,    card int(10) unsigned not null,    primary key(bookid));给两个表各插入20条数据insert into class(card) values(FLOOR(1+(RAND()*20))); # 执行20次insert into book(card) values(FLOOR(1+(RAND()*20))), # 执行20次</code></pre><ul><li>开始explain分析, sql分析：type是all，全表扫描</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM class LEFT JOIN book ON class.`card` = book.`card`;</code></pre><ul><li>添加索引尝试优化</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">ALTER TABLE book ADD INDEX idx_y(card);</code></pre><ul><li>查看计划，sql分析：book表type优化到了ref级别</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">explain select * from class left join book on class.`card` = book.`card`;</code></pre><ul><li>继续尝试优化</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">DROP INDEX idx_y ON book;ALTER TABLE class ADD INDEX idx_y(card); # 给class表加索引</code></pre><ul><li>查看计划，sql分析：class表type仅优化为了index级别，全索引扫描</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM class LEFT JOIN book ON class.`card` = book.`card`;</code></pre><ul><li>小结：由于左连接的特性，决定了左边内容一定都是有的，left join 条件用于确定如何从右表搜索行；所以left join一定要给右表建立索引。</li><li>修改回最优索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">DROP INDEX idx_y ON class;ALTER TABLE book ADD INDEX idx_y(card);</code></pre><ul><li>那么当right join时呢?</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">explain select * from class right join book on class.`card` = book.`card`;</code></pre><ul><li>跟左连接相反，右连接给左表建立索引即可</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">ALTER TABLE class ADD INDEX idx_x(card);</code></pre><ul><li>查看计划，sql分析：可以看到class表优化为了ref级别</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">explain select * from class right join book on class.`card` = book.`card`;</code></pre><ul><li>总结：<strong>左连接给右表建索引，右连接给左边建索引。</strong></li></ul><h3 id="1-3-三表优化"><a href="#1-3-三表优化" class="headerlink" title="1.3 三表优化"></a>1.3 三表优化</h3><ul><li>沿用上两张表的情况下，加入一张表</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE TABLE phone(    phone_id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,    card INT(10) UNSIGNED NOT NULL,    PRIMARY KEY(phone_id))ENGINE=INNODB;INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20))); # 执行20次</code></pre><ul><li>清除上一个case建立的全部索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">drop index idx_y on book;drop index idx_x on class;</code></pre><ul><li>三表查询计划, sql分析：type均为all，必须优化。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">explain select * from class left join book on class.`card`=book.`card` left join phone on book.`card`=phone.`card`;</code></pre><ul><li>根据左连接查询给右表建索引原则，给右边的phone表和book表建立索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">alter table phone add index z(card);ALTER TABLE book ADD INDEX Y(card);</code></pre><ul><li>查看计划，sql分析：book和phone表都优化到了red级别，优化很好，因此索引最好设置在需要经常查询的字段中。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">explain select * from class left join book on class.`card`=book.`card` left join phone on book.`card`=phone.`card`;</code></pre><ul><li>Join语句优化<ul><li>尽可能减少Join语句中的NestedLoop循环总次数； “永远用小结果集驱动大结果集”</li><li>优先优化NestedLoop的内层循环</li><li>保证Join语句中被驱动表上Join条件字段已经被索引</li><li>当无法保证被驱动表的Join条件被索引且内存资源充足的前提下，不必太吝惜JoinBuffer的设置</li></ul></li></ul><h2 id="2-索引失效"><a href="#2-索引失效" class="headerlink" title="2. 索引失效"></a>2. 索引失效</h2><h3 id="2-1-建表"><a href="#2-1-建表" class="headerlink" title="2.1 建表"></a>2.1 建表</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">create table staffs(    id int primary key auto_increment,    name varchar(24) not null default &quot;&quot; comment &#39;姓名&#39;,    age int not null default 0 comment &#39;年龄&#39;,    pos varchar(20) not null default &quot;&quot; comment &#39;职位&#39;,    add_time timestamp not null default current_timestamp comment &#39;入职时间&#39;)charset utf8 comment &#39;员工记录表&#39;;# 插入数据insert into staffs(name,age,pos,add_time)values(&#39;z3&#39;,22,&#39;manager&#39;,now()),(&#39;July&#39;,23,&#39;dev&#39;,now()),(&#39;2000&#39;,23,&#39;dev&#39;,now());# 建立复合索引alter table staffs add index idx_staffs_nameAgePos(name,age,pos);show index from staffs;</code></pre><h3 id="2-2-索引失效案例"><a href="#2-2-索引失效案例" class="headerlink" title="2.2 索引失效案例"></a>2.2 索引失效案例</h3><h4 id="2-2-1-全值匹配"><a href="#2-2-1-全值匹配" class="headerlink" title="2.2.1 全值匹配"></a>2.2.1 全值匹配</h4><p>如果关键列建立了索引，尽量全部都用到。</p><blockquote><p>全值匹配我最爱，最左前缀要遵守</p></blockquote><h4 id="2-2-2-最佳左前缀法则"><a href="#2-2-2-最佳左前缀法则" class="headerlink" title="2.2.2 最佳左前缀法则"></a>2.2.2 最佳左前缀法则</h4><p>如果索引了多列，要遵守最左前缀法则；指的是查询从索引的最左前列开始且不跳过索引中间的列；<strong>即索引的列一个都不要少</strong>。</p><blockquote><p>带头大哥不能死，中间兄弟不能断</p></blockquote><h4 id="2-2-3-不在索引列上做任何操作-计算、函数、自动or手动类型转换-，会导致索引失效而转向全表扫描"><a href="#2-2-3-不在索引列上做任何操作-计算、函数、自动or手动类型转换-，会导致索引失效而转向全表扫描" class="headerlink" title="2.2.3 不在索引列上做任何操作(计算、函数、自动or手动类型转换)，会导致索引失效而转向全表扫描"></a>2.2.3 不在索引列上做任何操作(计算、函数、自动or手动类型转换)，会导致索引失效而转向全表扫描</h4><ul><li>举例如下</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 没在索引列进行函数相关操作，使用到了索引且type为ref级别EXPLAIN SELECT * FROM staffs WHERE NAME = &#39;July&#39;;# 在索引列进行了函数操作，会导致索引失效，type为all全表扫描EXPLAIN SELECT * FROM staffs WHERE LEFT(NAME,4) = &#39;July&#39;;</code></pre><blockquote><p>索引列上少计算</p></blockquote><h4 id="2-2-4-存储引擎不能使用索引中范围条件右边的列"><a href="#2-2-4-存储引擎不能使用索引中范围条件右边的列" class="headerlink" title="2.2.4 存储引擎不能使用索引中范围条件右边的列"></a>2.2.4 存储引擎不能使用索引中范围条件右边的列</h4><ul><li>举例如下操作会让范围后面的pos索引失效，type降低为range类型。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 4.存储引擎不能使用索引中范围条件右边的列EXPLAIN SELECT * FROM staffs WHERE NAME = &#39;July&#39; AND age &gt; 25 AND pos=&#39;manager&#39;</code></pre><blockquote><p>范围之后全失效</p></blockquote><h4 id="2-2-5-尽量使用覆盖索引-索引列和查询列一致-，减少select"><a href="#2-2-5-尽量使用覆盖索引-索引列和查询列一致-，减少select" class="headerlink" title="2.2.5 尽量使用覆盖索引(索引列和查询列一致)，减少select *"></a>2.2.5 尽量使用覆盖索引(索引列和查询列一致)，减少select *</h4><ul><li>这样可以Using index，性能不错</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT NAME,age,pos FROM staffs WHERE NAME = &#39;July&#39; AND age  = 25 AND pos=&#39;dev&#39;;</code></pre><blockquote><p>覆盖索引不写星</p></blockquote><h4 id="2-2-6-mysql在使用不等于-或者-lt-gt-时无法使用索引会导致全表扫描"><a href="#2-2-6-mysql在使用不等于-或者-lt-gt-时无法使用索引会导致全表扫描" class="headerlink" title="2.2.6 mysql在使用不等于(!=或者&lt;&gt;)时无法使用索引会导致全表扫描"></a>2.2.6 mysql在使用不等于(!=或者&lt;&gt;)时无法使用索引会导致全表扫描</h4><ul><li>使用不等也会导致索引失效全表扫描</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM staffs WHERE NAME != &#39;July&#39;;EXPLAIN SELECT * FROM staffs WHERE NAME &lt;&gt; &#39;July&#39;;</code></pre><blockquote><p>不等空值还有or，索引失效要少用</p></blockquote><h4 id="2-2-7-is-null-is-not-null也无法使用索引"><a href="#2-2-7-is-null-is-not-null也无法使用索引" class="headerlink" title="2.2.7 is null,is not null也无法使用索引"></a>2.2.7 is null,is not null也无法使用索引</h4><ul><li>is null 会出现Impossible WHERE情况；is not null会导致索引失效全表扫描</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM staffs WHERE NAME IS NULL;EXPLAIN SELECT * FROM staffs WHERE NAME is not null;</code></pre><blockquote><p>不等空值还有or，索引失效要少用</p></blockquote><h4 id="2-2-8-like以通配符开头-‘-abc…’-也会导致索引失效变成全表扫描。"><a href="#2-2-8-like以通配符开头-‘-abc…’-也会导致索引失效变成全表扫描。" class="headerlink" title="2.2.8 like以通配符开头(‘%abc…’)也会导致索引失效变成全表扫描。"></a>2.2.8 like以通配符开头(‘%abc…’)也会导致索引失效变成全表扫描。</h4><ul><li>百分号尽量写右边，不然会导致索引失效全表扫描，使用覆盖索引关键列可优化到index级别。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM staffs WHERE NAME like &#39;%July%&#39;; # 全表扫描EXPLAIN SELECT * FROM staffs WHERE NAME LIKE &#39;%July&#39;; # 全表扫描EXPLAIN SELECT * FROM staffs WHERE NAME LIKE &#39;July%&#39;; # range范围扫描</code></pre><blockquote><p>Like百分<code>%</code>写最右</p></blockquote><h4 id="2-2-9-字符串不加单引号索引失效"><a href="#2-2-9-字符串不加单引号索引失效" class="headerlink" title="2.2.9 字符串不加单引号索引失效"></a>2.2.9 字符串不加单引号索引失效</h4><ul><li>varchar类型字符串不加引号也会导致索引失效全表扫描</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM staffs WHERE NAME = 2000; #因为name是varchar类型，mysql做了自动类型转换，导致索引失效EXPLAIN SELECT * FROM staffs WHERE NAME = &#39;2000&#39;; # 不会失效</code></pre><blockquote><p>Varchar引号不可丢</p></blockquote><h4 id="2-2-10-少用or，用它连接时会索引失效"><a href="#2-2-10-少用or，用它连接时会索引失效" class="headerlink" title="2.2.10 少用or，用它连接时会索引失效"></a>2.2.10 少用or，用它连接时会索引失效</h4><ul><li>or也会导致索引失效</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM staffs WHERE NAME=&#39;July&#39; OR NAME = &#39;z3&#39;;</code></pre><blockquote><p>不等空值还有or，索引失效要少用</p></blockquote><h3 id="2-3-索引优化分析题"><a href="#2-3-索引优化分析题" class="headerlink" title="2.3 索引优化分析题"></a>2.3 索引优化分析题</h3><h4 id="2-3-1-准备工作"><a href="#2-3-1-准备工作" class="headerlink" title="2.3.1 准备工作"></a>2.3.1 准备工作</h4><ul><li>建立表插数据</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE TABLE ex01(    id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,    c1 CHAR(10),    c2 CHAR(10),    c3 CHAR(10),    c4 CHAR(10),    c5 CHAR(10));INSERT INTO ex01(c1,c2,c3,c4,c5) VALUES(&#39;a1&#39;,&#39;a2&#39;,&#39;a3&#39;,&#39;a4&#39;,&#39;a5&#39;),(&#39;b1&#39;,&#39;b2&#39;,&#39;b3&#39;,&#39;b4&#39;,&#39;b5&#39;),(&#39;c1&#39;,&#39;c2&#39;,&#39;c3&#39;,&#39;c4&#39;,&#39;c5&#39;),(&#39;d1&#39;,&#39;d2&#39;,&#39;d3&#39;,&#39;d4&#39;,&#39;d5&#39;),(&#39;e1&#39;,&#39;e2&#39;,&#39;e3&#39;,&#39;e4&#39;,&#39;e5&#39;);</code></pre><ul><li>建立索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE INDEX idx_ex01_c1234 ON ex01(c1,c2,c3,c4);SHOW INDEX FROM ex01;</code></pre><h4 id="2-3-2-根据以下SQL分析索引的使用情况"><a href="#2-3-2-根据以下SQL分析索引的使用情况" class="headerlink" title="2.3.2 根据以下SQL分析索引的使用情况"></a>2.3.2 根据以下SQL分析索引的使用情况</h4><ul><li>全索引使用，全值匹配，ref级别；顺序改变mysql会自动优化，故以下SQL性能一致。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c2 = &#39;a2&#39; AND c3 = &#39;a3&#39; AND c4 = &#39;a4&#39;;EXPLAIN SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c2 = &#39;a2&#39; AND c4 = &#39;a4&#39; AND c3 = &#39;a3&#39;;EXPLAIN SELECT * FROM ex01 WHERE c4 = &#39;a4&#39; AND c3 = &#39;a3&#39; AND c2 = &#39;a2&#39; AND c1 = &#39;a1&#39;;</code></pre><ul><li>三索引使用，范围匹配，range级别；范围之后全失效。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c2 = &#39;a2&#39; AND c3 &gt; &#39;a3&#39; AND c4 = &#39;a4&#39;;</code></pre><ul><li>全索引使用，范围匹配，range级别。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c2 = &#39;a2&#39; AND c4 &gt; &#39;a4&#39; AND c3 = &#39;a3&#39;;</code></pre><ul><li>两索引使用，c3作用在排序而不是查找</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c2 = &#39;a2&#39; AND c4 = &#39;a4&#39; ORDER BY c3;</code></pre><ul><li>两索引使用，c3在排序用不到索引查找</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">explain SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c2 = &#39;a2&#39; ORDER BY c3;</code></pre><ul><li>两索引使用，因为跳过了c3导致c4无法用到排好序的索引，只能自己排序，从而出现了<code>Using filesort</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c2 = &#39;a2&#39; ORDER BY c4;</code></pre><ul><li>单索引使用，c2、c3在排序</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c5 = &#39;a5&#39; ORDER BY c2,c3;</code></pre><ul><li>单索引使用，因为c3跳过了c2,导致索引没使用到从而自己排序，出现<code>Using filesort</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c5 = &#39;a5&#39; ORDER BY c3,c2;</code></pre><ul><li>两索引使用</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">explain SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c2 = &#39;a2&#39; ORDER BY c2,c3;</code></pre><ul><li>两索引使用，c2、c3用于排序</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c2 = &#39;a2&#39; AND c5 = &#39;a5&#39; ORDER BY c2,c3;</code></pre><ul><li>两索引使用，c1、c2用到了索引，所以c2变成了一个常量，在order by那边常量不用排序，故没有产生文件内排序</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1 = &#39;a1&#39; AND c2 = &#39;a2&#39; AND c5 = &#39;a5&#39; ORDER BY c3,c2;</code></pre><ul><li>单索引使用，c2、c3在排序，c4用不到</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1=&#39;a1&#39; AND c4=&#39;a4&#39; GROUP BY c2,c3;</code></pre><ul><li>单索引使用，c3跳过了c2产生文件内排序，group by还用到了临时表<code>Using temporary</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">EXPLAIN SELECT * FROM ex01 WHERE c1=&#39;a1&#39; AND c4=&#39;a4&#39; GROUP BY c3,c2;</code></pre><ul><li><strong>小结</strong>：定值、范围还是排序，一般order by是给范围排序；group by基本上都会进行排序，会产生临时表，<strong>分组之前必定会排序</strong>。</li></ul><h2 id="3-一般建议"><a href="#3-一般建议" class="headerlink" title="3. 一般建议"></a>3. 一般建议</h2><ol><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引时，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引时，尽量选择可以能够包含当前query中的where子句中更多字段的索引。</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</li></ol><h4 id="3-1-索引优化口诀"><a href="#3-1-索引优化口诀" class="headerlink" title="3.1 索引优化口诀"></a>3.1 索引优化口诀</h4><ul><li><p>全值匹配我最爱，最左前缀要遵守；</p></li><li><p>带头大哥不能死，中间兄弟不能断；</p></li><li><p>索引列上少计算，范围之后全失效；</p></li><li><p>Like百分写最右，覆盖索引不写星；</p></li><li><p>不等空值还有or，索引失效要少用；</p></li><li><p>Varchar引号不可丢，SQL高级也不难！</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Index optimize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之美-[数据结构基础]</title>
      <link href="/Algorithm-trip/Data-structure-basic.html"/>
      <url>/Algorithm-trip/Data-structure-basic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-算法概述"><a href="#1-算法概述" class="headerlink" title="1. 算法概述"></a>1. 算法概述</h2><ul><li>什么是算法$(algorithm)$？<ul><li>在计算机领域里，算法就是一系列程序指令，用于处理特定的运算和逻辑问题。衡量算法优劣的主要标准是时间复杂度和空间复杂度。</li></ul></li></ul><a id="more"></a><ul><li><p>什么是数据结构$(data \ structure)$？</p><ul><li>数据结构是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。</li><li>数据结构包含数组、链表这样的线性数据结构，也包含树、图这样的复杂数据结构。</li></ul></li><li><p>什么是时间复杂度？</p><ul><li>时间复杂度是对一个算法运行时间长短的量度，用大O表示法，记作$T(n)=O(f(n))$。</li><li>常见的时间复杂度按照从低到高的顺序，包括$O(1),O(logn),O(n),O(nlogn),O(n^2)$等。</li></ul></li><li>什么是空间复杂度？<ul><li>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大O表示法，记作$S(n)=O(f(n))$。</li><li>常见的空间复杂度按照从低到高的顺序，包括$O(1),O(N),O(n^2)$等。其中递归算法的空间复杂度和递归深度成正比。</li></ul></li></ul><h2 id="2-数据结构基础"><a href="#2-数据结构基础" class="headerlink" title="2. 数据结构基础"></a>2. 数据结构基础</h2><h3 id="2-1-数组和链表"><a href="#2-1-数组和链表" class="headerlink" title="2.1 数组和链表"></a>2.1 数组和链表</h3><h4 id="2-1-1-数组"><a href="#2-1-1-数组" class="headerlink" title="2.1.1 数组"></a>2.1.1 数组</h4><p>数组是有限个相同类型的变量所组成的<strong>有序集合</strong>，每个数组中的变量被称为元素。数组在内存中是顺序存储的，因此可以很好的实现逻辑上的顺序表。</p><ul><li>数组读取元素和更新元素的时间复杂度都是$O(1)$。</li></ul><p>插入数组元素存在3种情况：</p><ul><li>尾插入：直接把插入的元素放在数组尾部的空闲位置即可，等同于更新元素的操作。复杂度$O(1)$。</li><li>中间插入：由于数组中的每个元素都是其固定的下表，所以不得不首先把插入位置及后面的元素向后移动，腾出地方，再将要插入的元素放到对应的数组位置上。$O(n)$。</li><li>超范围插入：会涉及到数组的扩容，可以创建一个新数组，长度是旧数组的2倍，再把旧数组中的元素全部过去，就实现数组的扩容了。$O(n)$。</li></ul><p>数组删除元素操作和插入操作相反，如果是中间删除，那么其后的元素都要前移。</p><h4 id="2-1-2-数组小结"><a href="#2-1-2-数组小结" class="headerlink" title="2.1.2 数组小结"></a>2.1.2 数组小结</h4><p>数组的插入操作，数组扩容的时间复杂度是$O(n)$，插入并移动元素的时间复杂度也是$O(n)$，综合起来插入操作的时间复杂度为$O(n)$。删除操作只涉及到元素的移动，复杂度也是$O(n)$。</p><ul><li>数组的优势</li></ul><p>数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。有一种高效查找元素的算法叫二分查找法，就是利用了数组的这个优势。</p><ul><li>数组的劣势</li></ul><p>数组的劣势体现在插入和删除元素方面。由于数组元素连续紧密地存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。</p><blockquote><p>数组适合的是读操作多、写操作少的场景。</p></blockquote><h4 id="2-1-3-链表"><a href="#2-1-3-链表" class="headerlink" title="2.1.3  链表"></a>2.1.3  链表</h4><p>链表是一种在物理上非连续、非顺序的数据结构，由若干节点(node)所组成。单向链表的每个节点细分为两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">private static class Node{    int data;    Node next;}</code></pre><p>链表的第一个节点被称为头节点，最后一个节点被称为尾节点，尾节点的next指针指向null。</p><p><img src="http://yanxuan.nosdn.127.net/647d04e70d7c1f9f91ea18c73fe6f56e.png" alt="单向链表"></p><h4 id="2-1-4-双向链表"><a href="#2-1-4-双向链表" class="headerlink" title="2.1.4 双向链表"></a>2.1.4 双向链表</h4><p>双向链表比单向链表稍微复杂一下，它每个节点除了拥有data和next指针，还有指向前置节点的prev指针。</p><p><img src="http://yanxuan.nosdn.127.net/817f9bfb77bc38166e31a06a8779553d.png" alt="双向链表"></p><p>链表在内存中的存储方式是随机存储，链表采用了见缝插针的存储方式，每个节点分布在内存的不同位置，依靠next指针关联起来，这样可以灵活有效地利用零散的碎片空间。</p><p><img src="http://yanxuan.nosdn.127.net/23c7ea33dfe2d88431d5d221d017b777.png" alt="随机存储"></p><ul><li>链表中的数据只能按顺序逐级查找，最坏的时间复杂度是$O(n)$。</li><li>链表的插入和删除操作，复杂度是$O(1)$。</li></ul><h4 id="2-1-5-数组和链表小结"><a href="#2-1-5-数组和链表小结" class="headerlink" title="2.1.5  数组和链表小结"></a>2.1.5  数组和链表小结</h4><p>数组和链表相关操作的性能对比</p><table><thead><tr><th></th><th>查找</th><th>更新</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td>数组</td><td>$O(1)$</td><td>$O(1)$</td><td>$O(n)$</td><td>$O(n)$</td></tr><tr><td>链表</td><td>$O(n)$</td><td>$O(1)$</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table><p>数组的优势在于能快速定位元素，对于读操作多、写操作少的场景非常适合。相反，链表优势在于能够灵活地进行插入和删除操作，如果需在尾部频繁插入、删除元素，用链表更合适。</p><h3 id="2-2-栈和队列"><a href="#2-2-栈和队列" class="headerlink" title="2.2 栈和队列"></a>2.2 栈和队列</h3><h4 id="2-2-1-物理结构和逻辑结构"><a href="#2-2-1-物理结构和逻辑结构" class="headerlink" title="2.2.1 物理结构和逻辑结构"></a>2.2.1 物理结构和逻辑结构</h4><ul><li>物理结构</li></ul><p>如果把数据结构比作人类，那么物理结构就是人的血肉和骨骼，看得见摸得着实实在在的。例如数组和链表都是内存中实实在在的存储结构。</p><ul><li>逻辑结构</li></ul><p>在物质的人体之上，还存在着人的思想和精神，它们看不见、摸不着。提供把物质层面的人体比作数据存储的物理结构，那么精神层面的人格则是数据存储的逻辑结构。逻辑结构是抽象的概念，它依赖于物理结构而存在。</p><p><img src="http://yanxuan.nosdn.127.net/ca51ae48b5472e61aa4f73370ef89a81.png" alt="物理结构与逻辑结构"></p><h4 id="2-2-2-栈"><a href="#2-2-2-栈" class="headerlink" title="2.2.2 栈"></a>2.2.2 栈</h4><p>栈是一种线性数据结构，栈中的元素只能<strong>先入后出</strong>(First In Last Out,简称<strong>FILO</strong>)。最早进入的元素存放位置叫<strong>栈底</strong>(bottom)，最后进入的元素存放位置叫<strong>栈顶</strong>(top)。栈这种数据结构既可以用数组实现，也可以用链表。</p><ul><li>入栈</li></ul><p>入栈操作(push)就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将成为新栈顶。</p><ul><li>出栈</li></ul><p>出栈操作(pop)就是把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶。</p><ul><li>代码实现如下</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * @Author: zero * @Description: 使用数组实现栈的基本操作 * Date: Create in 2020&#x2F;3&#x2F;21 8:40 * Modified By: *&#x2F;public class MyStack {    private int[] array;    private int top;    public MyStack(int capacity){        this.array = new int[capacity];    }    &#x2F;**     * 压栈     * @param element 入栈元素     * @throws Exception     *&#x2F;    public void push(int element) throws Exception {        if (top &gt; array.length){            throw new Exception(&quot;StackOverflowError&quot;);        }        array[top++] = element;    }    &#x2F;**     * 弹栈     * @throws Exception     *&#x2F;    public void pop() throws Exception {        if (top == 0){            throw new Exception(&quot;No ElementError&quot;);        }        delete(top - 1, array);        top--;    }    &#x2F;**     * 栈元素的删除操作     * @param index 出栈元素索引     * @param array 操作数组     *&#x2F;    public void delete(int index, int[] array) {        &#x2F;&#x2F; 新建一个数组为原数组-1        int[] arrNew = new int[array.length - 1];        &#x2F;&#x2F; 打印出栈元素        System.out.println(array[index]);        &#x2F;&#x2F; 数组元素转移，也可以直接调用api        &#x2F;&#x2F; for (int i = 0; i &lt; array.length - 1; i++) {        &#x2F;&#x2F;     arrNew[i] = array[i];        &#x2F;&#x2F; }        &#x2F;&#x2F; 调用api实现数组元素转移        System.arraycopy(array, 0, arrNew, 0, arrNew.length);        this.array = arrNew;    }    public void show(){        System.out.println(Arrays.toString(this.array));    }    public static void main(String[] args) throws Exception {        MyStack myStack = new MyStack(8);        System.out.println(&quot;压栈&quot;);        for (int i = 1; i &lt;= 8; i++) {            myStack.push(i);        }        myStack.show();        for (int i = 0; i &lt;= 7; i++) {            System.out.print(&quot;弹栈&quot;);            myStack.pop();        }        myStack.show();    }}</code></pre><ul><li>出栈入栈只会影响最后一个元素，因此时间复杂度都是${O(1)}$。</li></ul><h4 id="2-2-3-队列"><a href="#2-2-3-队列" class="headerlink" title="2.2.3 队列"></a>2.2.3 队列</h4><p>队列(queue)是一种线性数据结构，它跟单向隧道类似，队列中的元素只能<strong>先入先出</strong>(First In First Out，简称<strong>FIFO</strong>)。队列的出口端叫作<strong>队头</strong>(front)，队列的入口端叫作<strong>队尾</strong>(rear)。</p><ul><li>入队</li></ul><p>入队(enqueue)就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。</p><ul><li>出队</li></ul><p>出队(dequeue)操作就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。</p><ul><li>循环队列</li></ul><p>如果按照上面的方式不断出队，队头指针右移，队头左边的空间就失去作用了，故用数组实现的队列可以采用<strong>循环队列</strong>的方式来维持队列容量的恒定。</p><ul><li>什么是循环队列</li></ul><p>你可以把它理解为一个首尾相连的圆环，其中有两个指针：队头指针和队尾指针。这两个指针始终按照同一个方向前进，两个指针互相追赶着对方；入队操作时队尾指针（队尾指针会占据一个空闲空间）一直前进，直到遇到队头指针便代表空间用完了，停止入队；出队操作就是标记释放空间（数组内实际没有删除元素），队头指针一直前进，直到遇到队尾指针便代表空间释放完了，停止出队。下面就是循环队列的简单示意图：</p><p><img src="http://yanxuan.nosdn.127.net/75ecbfb3ab31063c07762696916e3e2f.png" alt="循环队列"></p><ul><li>循环队列如何实现</li></ul><p>那么如何做到队头队尾指针能持续前进的同时不超过数组大小呢？我们可以用到取余<code>%</code>操作符，当队头或队尾值达到数组最大值时，重新归零，当队头队尾值相同时不做添加删除操作，以实现数组的循环。</p><ul><li><p>实现过程</p><ul><li>入队操作：<code>队尾下标 = (队尾下标+1)%数组长度</code></li><li>出队操作：<code>队头下标 = (队头下标+1)%数组长度</code></li><li>队列空间满的条件：<code>(队尾下标+1)%数组长度==队头下标</code></li></ul></li><li><p>代码实现</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * @Author: zero * @Description: 使用数组实现循环队列 * Date: Create in 2020&#x2F;3&#x2F;23 10:20 * Modified By: *&#x2F;public class MyQueue {    private int[] array;    &#x2F;&#x2F; 队头    private int front;    &#x2F;&#x2F; 队尾    private int rear;    public MyQueue(int capacity){        &#x2F;&#x2F; 因为队尾始终要占一个空间，故这里把空间补上        this.array = new int[capacity + 1];    }    &#x2F;**     * 入队操作     * @param element 入队的元素     *&#x2F;    public void enQueue(int element) throws Exception{        if ((rear + 1) % array.length == front){            throw new Exception(&quot;The Queue is Full!&quot;);        }        array[rear] = element;        rear = (rear + 1) % array.length;    }    &#x2F;**     * 出队操作     * @return     * @throws Exception     *&#x2F;    public int deQueue() throws Exception{        if (rear == front){            throw new Exception(&quot;The Queue is Empty!&quot;);        }        int deQueueElement = array[front];        front = (front + 1) % array.length;        return deQueueElement;    }    &#x2F;**     * 输出队列     *&#x2F;    public void output(){        for (int i = front; i!=rear ; i=(i+1)%array.length) {            System.out.println(array[i]);        }    }    public static void main(String[] args) throws Exception {        MyQueue myQueue = new MyQueue(6);        myQueue.enQueue(3);        myQueue.enQueue(5);        myQueue.enQueue(2);        myQueue.enQueue(7);        myQueue.enQueue(4);        System.out.println(&quot;输出一下&quot;);        myQueue.output();        myQueue.deQueue();        myQueue.deQueue();        System.out.println(&quot;输出二下&quot;);        myQueue.output();        myQueue.enQueue(8);        myQueue.enQueue(6);        myQueue.enQueue(1);        System.out.println(&quot;输出三下&quot;);        myQueue.output();    }}</code></pre><ul><li>循环队列充分利用了数组的空间，也避免了数组元素的整体移动，入队和出队的时间复杂度都是${O(1)}$</li></ul><h3 id="2-3-栈和队列的应用"><a href="#2-3-栈和队列的应用" class="headerlink" title="2.3 栈和队列的应用"></a>2.3 栈和队列的应用</h3><ul><li>栈的应用</li></ul><p>栈的输出顺序和输入顺序<strong>相反</strong>，所以栈通常用于对“历史”的<strong>回溯</strong>，也就是逆流而上追溯“历史”。例如实现递归操作，就可以用栈来代替，因为栈可以回溯方法的调用链。还有一个经典的应用场景就是面包屑导航，使用户在浏览页面时可以轻松地回溯到上一级或更上一级页面。</p><ul><li>队列的应用</li></ul><p>队列的输出顺序和输入顺序<strong>相同</strong>，所有队列通常用于对“历史”的<strong>回放</strong>，也就是按照顺序，把“历史”重演一遍。例如在多线程中争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序。网络爬虫实现网站抓取时，也是把待爬取的网站URL存入队列中，在按照存入的顺序依次抓取和解析的。</p><ul><li>双端队列</li></ul><p>双端队列(deque)这种数据结构，结合了栈和队列的优点，从队头一端可以入队或出队，从队尾一端也可以入队或出队。</p><ul><li>优先队列</li></ul><p>优先队列遵循谁优先级高谁先出队，元素被赋予优先级。当访问元素时，高优先级的优先被访问到。</p><h3 id="2-4-散列表"><a href="#2-4-散列表" class="headerlink" title="2.4 散列表"></a>2.4 散列表</h3><p>散列表也叫做<strong>哈希表</strong>(hash table)，这种数据结构提供了<strong>键(key)</strong>和值<strong>(value)</strong>的映射关系。只要给出一个key，就可以高效查找到它所匹配的value，时间复杂度接近于${O(1)}$。</p><h4 id="2-4-1-哈希函数"><a href="#2-4-1-哈希函数" class="headerlink" title="2.4.1 哈希函数"></a>2.4.1 哈希函数</h4><p>在Java及大多数面向对象的语言中，每个对象都有属于自己的hashcode，这个hashcode是区分不同对象的重要标志。无论对象自身的类型是什么，它的hashcode都是一个整型变量。既然是整型变量那么转化为数组下标也不难实现，最简单的转化方式是按照数组长度进行取模运算。在Java中的哈希函数并没有直接采用取模运算，而是利用了位运算的方式来优化性能。</p><h4 id="2-4-2-散列表的读写"><a href="#2-4-2-散列表的读写" class="headerlink" title="2.4.2 散列表的读写"></a>2.4.2 散列表的读写</h4><h5 id="2-4-2-1-写操作-put"><a href="#2-4-2-1-写操作-put" class="headerlink" title="2.4.2.1 写操作(put)"></a>2.4.2.1 写操作(put)</h5><p>写操作就是在散列表中插入新的键值对(JDK中叫Entry)。例如调用<code>hashMap.put(&quot;002931&quot;,&quot;王五&quot;)</code>，就是插入一组key为002931、value为王五的键值对。具体操作如下：</p><ol><li>通过哈希函数，计算key的哈希值，然后通过取模运算转化为数组的下标5。</li><li>如果数组下标5对应的位置没有元素，就把Entry填充到数组下标5的位置。</li></ol><p>由于数组的长度是有限的，当插入的Entry越来越多时，不同的key通过哈希函数获得的下标可能是相同的。这种情况，就叫作<strong>哈希冲突。</strong></p><p>解决哈希冲突主要有两种方式，开放寻址法和链表法。</p><ul><li>开放寻址法就是当计算出的数组下标相同时，以该冲突下标经过一定算法重新计算一个下标，再尝试放入元素，如果还冲突就如上操作继续计算，直到不冲突为止。</li><li>链表法就是在发生冲突时将具有相同哈希值的元素放到同一个单链表中。</li></ul><p>Java集合类HashMap就是使用链表法解决哈希冲突的，HashMap数组的每个元素不仅是一个Entry对象，还是链表的头节点。当新的Entry映射到冲突的数组位置时，只要插入到对应的链表中即可。</p><h5 id="2-4-2-2-读操作-get"><a href="#2-4-2-2-读操作-get" class="headerlink" title="2.4.2.2 读操作(get)"></a>2.4.2.2 读操作(get)</h5><p>读操作就是通过给定key，在散列表中查找对应的value。具体操作如下：</p><ol><li>通过哈希函数，把key转换为数组下标5。</li><li>找到数组下标5对应的元素，如果这个元素的key为002936，那么就找到了；如果不是，就遍历该位置的链表，看能否找到与key相匹配的元素。</li></ol><h5 id="2-4-2-3-扩容-resize"><a href="#2-4-2-3-扩容-resize" class="headerlink" title="2.4.2.3 扩容(resize)"></a>2.4.2.3 扩容(resize)</h5><p>当经过多次元素插入后，散列表达到一定饱和度时，key映射位置发生冲突的概率会逐渐提高。如此就会形成大量元素拥挤在相同的数组下标位置，形成很长的链表，对插入和查询操作的性能都有很大影响。</p><p>此时，散列表就需要进行扩容操作。对于HashMap来说，影响扩容的因素有两个：</p><ul><li><strong>Capacity</strong>，即HashMap当前的长度</li><li><strong>LoadFactor</strong>，即HashMap的负载因子，默认值为0.75f。</li><li><strong>threshold</strong>，经上述两个值计算出的临界值。</li></ul><p>扩容操作步骤：</p><ol><li><strong>扩容</strong>，创建一个新的Entry空数组，长度是原数组的两倍。</li><li><strong>重新Hash</strong>，遍历原Entry数组，把所有的Entry重新hash到新数组中。</li></ol><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5. 小结"></a>2.5. 小结</h3><ul><li>什么是数组：数组是由有限个相同类型的变量所组成的有序集合，它的物理<strong>存储方式是顺序存储</strong>，<strong>访问方式是随机访问</strong>。利用下标查找数组元素的时间复杂度是${O(1)}$，中间插入、删除数组元素的时间复杂度是${O(n)}$。</li><li>什么是链表：链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。链表的<strong>物理存储方式是随机存储，访问方式是顺序访问</strong>。查找链表节点的时间复杂度是${O(n)}$，中间插入、删除节点的时间复杂度是${O(1)}$。</li><li>什么是栈：栈是一种线性逻辑结构，可以用数组实现也可以用链表实现。栈包含入栈和出栈操作，遵循<strong>先入后出</strong>的原则(FILO)。</li><li>什么是队列：队列也是一种线性逻辑结构，可以用数组和链表实现。队列包含入队和出队操作，遵循<strong>先入先出</strong>原则(FIFO)。</li><li>什么是散列表：散列表也叫哈希表，是存储Key-Value映射的集合。对于某个Key，散列表可以在接近${O(1)}$的时间内进行读写操作。散列表通过哈希函数实现Key和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm trip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL性能分析</title>
      <link href="/DataBase/Explain.html"/>
      <url>/DataBase/Explain.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-MySQL-Query-Optimizer"><a href="#1-MySQL-Query-Optimizer" class="headerlink" title="1. MySQL Query Optimizer"></a>1. MySQL Query Optimizer</h3><p>MySQL查询优化器，是专门负责优化SELECT语句的模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的执行计划(优化器认为最优的数据检索方式，不一定是DBA认为最优的)。</p><a id="more"></a><ul><li>查询优化器工作步骤</li></ul><p>当客户端向MySQL请求一条Query时，命令解析器模块会完成请求分类，区别出是SELECT并转发给MySQL的Query Optimizer时，查询优化器首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析Query中的Hint信息(如果有)，看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息不足以完成确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</p><h3 id="2-MySQL常见瓶颈"><a href="#2-MySQL常见瓶颈" class="headerlink" title="2. MySQL常见瓶颈"></a>2. MySQL常见瓶颈</h3><ol><li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时。</li><li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量时。</li><li>硬件瓶颈：top、free、iostat和vmstat来查看系统的性能状态。</li></ol><h3 id="3-Explain"><a href="#3-Explain" class="headerlink" title="3. Explain"></a>3. Explain</h3><p>Explain可以<strong>查看执行计划</strong>，使用该关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。<a href="https://dev.mysql.com/doc/refman/5.7/en/execution-plan-information.html" target="_blank" rel="noopener">官网链接</a></p><ul><li>使用<code>Explain</code>+SQL语句，就可以查看执行计划。</li></ul><p><img src="http://yanxuan.nosdn.127.net/b6ae9124e0ee1862aac15d572becbb40.png" alt="Explain"></p><p>下面详解<code>Explain</code>输出语句各字段的作用。</p><h4 id="3-1-id"><a href="#3-1-id" class="headerlink" title="3.1 id"></a>3.1 id</h4><p>id是查询的序列号，包含一组数组，表示查询中<strong>执行select子句或操作表的顺序。</strong>分别有三种情况</p><ul><li>id相同，执行顺序由上至下。</li></ul><p><img src="http://yanxuan.nosdn.127.net/7a531e982c87d19e94948db515c7cf48.png" alt="id相同"></p><ul><li>id不同，如果是子查询，id的序号会递增，<strong>id值越大优先级越高，越先被执行。</strong></li></ul><p><img src="http://yanxuan.nosdn.127.net/b55c700308941757050ee7f6893150b0.png" alt="id不同"></p><ul><li>id有相同有不同，id值大的先执行，然后id相同的顺序执行。</li></ul><p><img src="http://yanxuan.nosdn.127.net/eb5e0c6f446958bac4b9bcedc405cbe2.png" alt="id相同不同"></p><blockquote><p><code>&lt;derived2&gt;</code>表示的是衍生表的意思，关联了下方id为2的t3表。</p></blockquote><h4 id="3-2-select-type"><a href="#3-2-select-type" class="headerlink" title="3.2 select_type"></a>3.2 select_type</h4><p>查询类型，主要是用于区别普通查询、联合查询、子查询等复杂查询，共有6种查询类型。</p><ol><li>SIMPLE：简单的select查询，查询中不包含子查询或者UNION。</li><li>PRIMARY：查询中若包含如何复杂的子部分，最外层查询则被标记为</li><li>SUBQUERY：在SELECT或WHERE列表中包含了子查询。</li><li>DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生的)时，MySQL会递归执行这些子查询，把结果放在临时表里。</li><li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED。</li><li>UNION RESULT：从UNION表获取结果的SELECT。</li></ol><h4 id="3-3-table"><a href="#3-3-table" class="headerlink" title="3.3 table"></a>3.3 table</h4><p>显示这一行的数据是关于哪张表的。</p><h4 id="3-4-type"><a href="#3-4-type" class="headerlink" title="3.4 type"></a>3.4 type</h4><p>type显示的是访问类型，显示查询使用了那种类型，判定sql好坏的重要指标；从最好到最差依次是：<font color="red">system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</font>。</p><ul><li>system：<strong>表只有一行记录</strong>(等于系统表)，这是const类型的特例，平时不会出现，可以忽略不计。</li><li>const：表示通过<strong>索引一次就找到</strong>了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快；例如将主键置于where列表中，MySQL就能将该查询转换为一个常量时。</li><li>eq_ref：<strong>唯一性索引扫描</strong>，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</li><li>ref：非唯一性索引扫描，<strong>返回匹配某个单独值的所有行</strong>。本质上也是一种索引访问，它返回所有匹配某个单独值的行；然而它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。</li><li>range：<strong>只检索给定范围的行</strong>，使用一个索引来选择行；key列显示使用了哪个索引，一般是SQL语句where中出现了<code>between、&lt;、&gt;、in</code>等的查询；这种范围扫描索引比全表扫描好一点，因为它只需扫描一定范围内的索引，不用扫描全部索引。</li><li>index：Full Index Scan，index与ALL区别就是index类型<strong>只遍历索引树</strong>；通常比ALL快，因为索引文件通常比数据文件小。(即虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的。)</li><li>all：Full Table Scan，将<strong>遍历全表</strong>以找到匹配的行。</li></ul><blockquote><p>一般来说，保证查询至少达到range级别，最好达到ref。</p></blockquote><h4 id="3-5-possible-keys"><a href="#3-5-possible-keys" class="headerlink" title="3.5 possible_keys"></a>3.5 possible_keys</h4><p>显示SQL优化器认为在该表中<strong>可能用到的索引</strong>列表，查询涉及到的字段上若存在索引，则该索引将被列出，但不代表查询时实际使用到。</p><h4 id="3-6-key"><a href="#3-6-key" class="headerlink" title="3.6 key"></a>3.6 key</h4><p><strong>实际使用到的索引</strong>，如果为NULL表示没有使用到索引。</p><h4 id="3-7-key-len"><a href="#3-7-key-len" class="headerlink" title="3.7 key_len"></a>3.7 key_len</h4><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好。</p><p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度；即key_len是根据表定义计算而得，而非通过表内检索出的。</p><h4 id="3-8-ref"><a href="#3-8-ref" class="headerlink" title="3.8 ref"></a>3.8 ref</h4><p><strong>显示索引的哪一列被使用</strong>了，如果可能的话，是一个常数；哪些列或常量被用于查找索引列上的值。</p><h4 id="3-9-rows"><a href="#3-9-rows" class="headerlink" title="3.9 rows"></a>3.9 rows</h4><p>根据表统计信息及索引选用情况，大致估算出找到所需记录所需读取的行数。</p><h4 id="3-10-Extra"><a href="#3-10-Extra" class="headerlink" title="3.10 Extra"></a>3.10 Extra</h4><p>包含不适合在其他列显示但十分重要的额外信息。主要信息如下</p><ol><li><strong>Using filesort</strong>：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取；MySQL中无法利用索引完成的排序操作称为”<strong>文件排序</strong>“。</li><li><strong>Using temporary</strong>：<strong>使用了临时表</strong>保存中间结果，MySQL在对查询结果排序时使用临时表；常见于排序order by和分组查询group by。</li><li><strong>Using index：</strong><ul><li>表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错。</li><li>如果同时出现using where，表明索引被用来执行索引键值的查找。</li><li>如果没有出现using where，表明索引用来读取数据而非执行查找动作。</li><li>覆盖索引：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件；即查询列要被所建立的索引覆盖。</li></ul></li><li>Using where：表示使用了where过滤。</li><li>Using join buffer：使用了连接缓存。</li><li>Impossible where：表示where子句的值总是false，不能用来获取任何元祖。</li></ol>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Explain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/DataBase/Index.html"/>
      <url>/DataBase/Index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1. 什么是索引"></a>1. 什么是索引</h3><p>索引是帮助MySQL高效获取数据的数据结构，<strong>索引是数据结构</strong>。索引的目的在于提高查询效率，可以理解为：<font color="red">排好序的快速查找数据结构。</font></p><a id="more"></a><p>除了数据本身之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构的基础上实现高级查找算法<strong>，这种数据结构就是索引。</strong>索引以索引文件形式存储在磁盘上。</p><p>我们平常所说的所有，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引（聚簇索引），次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然除了B+树这种类型的索引之外，还有哈希索引(hash index)等。</p><h3 id="2-索引的优劣势"><a href="#2-索引的优劣势" class="headerlink" title="2. 索引的优劣势"></a>2. 索引的优劣势</h3><h4 id="2-1-优势"><a href="#2-1-优势" class="headerlink" title="2.1 优势"></a>2.1 优势</h4><ul><li>类似图书馆建立书目索引，提高数据检索的效率，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li></ul><h4 id="2-2-劣势"><a href="#2-2-劣势" class="headerlink" title="2.2 劣势"></a>2.2 劣势</h4><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所有索引列也是要占用空间的。</li><li>虽然索引大大提交了查询速度，但同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE等写操作。因为更新表，MySQL不仅要保存数据，还要保存索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li><li>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优索引，或优化查询语句。</li></ul><h3 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h3><ol><li>单值索引（普通索引）：即一个索引只包含单个列，一个表可以有多个单列索引，关键词<code>INDEX</code>。</li><li>主键索引：根据主键建立索引，关键词<code>PRIMARY KEY</code>，不允许重复，不允许为空。</li><li>唯一索引：索引列的值必须唯一，但允许有空值，关键词<code>UNIQUE</code>。</li><li>复合索引：即一个索引包含多个列，关键词<code>INDEX</code>。</li><li>全文索引：用大文本对象的列构建的索引，关键词<code>FULLTEXT</code></li></ol><h4 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h4><ul><li>创建索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE [UNIQUE] INDEX indexName ON mytableName(columnName(length));</code></pre><ul><li>查看索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SHOW INDEX FROM table_name;</code></pre><ul><li>删除索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">DROP INDEX index_name ON table_name;</code></pre><ul><li>使用ALTER命令创建索引</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 添加主键索引，该索引值必须唯一且不为nullALTER TABLE table_name ADD PRIMARY KEY(column_list);# 添加唯一索引，允许为nullALTER TABLE table_name ADD UNIQUE INDEX un_dept_2(column_list);# 添加普通索引，索引值允许多次ALTER TABLE table_name ADD INDEX index_name(column_list);# 添加全文索引ALTER TABLE table_name ADD FULLTEXT index_name(column_list);</code></pre><h3 id="4-索引结构"><a href="#4-索引结构" class="headerlink" title="4. 索引结构"></a>4. 索引结构</h3><p>索引的结构包含多种(Btree、Hash、fulltext、RTree)，这里只介绍<code>BTree</code>索引。</p><p><img src="http://yanxuan.nosdn.127.net/5785ffe134a8e5a140efc4f6ff14f8da.png" alt="索引结构"></p><h4 id="4-1-B树检索原理"><a href="#4-1-B树检索原理" class="headerlink" title="4.1 B树检索原理"></a>4.1 B树检索原理</h4><ul><li>B树介绍</li></ul><p>一颗b+树，浅蓝色的块我们称之为一个磁盘块，每个磁盘块包含几个数据项(深蓝色)和指针(黄色)。</p><p>如果磁盘块1包含数据项17和35，包含指针P1、P2、P3；其中P1表示小于17的磁盘块，P2表示介于17和35之间的磁盘块，P3表示大于35的磁盘块。</p><p><font color="red">真实的数据只存在于叶子节点</font>，即最下方的3、5、9、10、13等等。<strong>非叶子节点不存储真实数据</strong>，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><ul><li>查找过程</li></ul><p>举例查找数据29，那么首先会把磁盘块1由磁盘加载到内存，此时<strong>发生第一次IO</strong>；在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，通过P2指针指向的磁盘地址把磁盘块3由磁盘加载到内存，<strong>发生第二次IO</strong>；二分查找确定29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘8到内存，<strong>发生第三次IO</strong>，同时内存中做二分查找找到29，结束查询，共计3次IO。</p><blockquote><p>3层高度的b+树可以表示上百万的数据，如果上百万数据查找只需3次IO，那么性能的提升将是巨大的。</p></blockquote><h3 id="5-创建索引的情况"><a href="#5-创建索引的情况" class="headerlink" title="5. 创建索引的情况"></a>5. 创建索引的情况</h3><h4 id="5-1-哪些情况需要创建索引"><a href="#5-1-哪些情况需要创建索引" class="headerlink" title="5.1 哪些情况需要创建索引"></a>5.1 哪些情况需要创建索引</h4><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合创建索引，因为每次更新不单单更新了表记录，还会更新索引表，增加IO负担。</li><li>Where条件里用不到的字段不创建索引。</li><li>单值/组合索引的选择问题(在高并发下倾向创建组合索引)</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。因为索引本身就是有序的，不会在进行<code>filesort</code>，提高效率。</li><li>查询中统计或分组字段。</li></ol><h4 id="5-2-哪些情况不需要创建索引"><a href="#5-2-哪些情况不需要创建索引" class="headerlink" title="5.2 哪些情况不需要创建索引"></a>5.2 哪些情况不需要创建索引</h4><ol><li>表记录太少</li><li>经常增删改的表，虽然提高了查询速度，但会降低更新表的速度。</li><li>数据重复且分布平均的表字段，没必要建立索引；因此应该只为经常查询和经常排序的数据列建立索引。例如某数据列有10万条记录，其中字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对字段A建立索引就没有太大的实际效果，一般不会提高数据库的查询速度。</li></ol><blockquote><p><strong>索引的选择性</strong>是指索引列中不同值的数目与表中记录数的比。假如一个表中有10000条记录，表索引列有9990个不同的值，那么这个索引的选择性就是9990/10000=0.999。一个索引的选择性越接近于1，这个索引的效率就越高。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL Index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL7种JOIN连接</title>
      <link href="/DataBase/Join.html"/>
      <url>/DataBase/Join.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-MySQL逻辑架构简介"><a href="#1-MySQL逻辑架构简介" class="headerlink" title="1. MySQL逻辑架构简介"></a>1. MySQL逻辑架构简介</h3><p>MySQL的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><a id="more"></a><p><img src="http://yanxuan.nosdn.127.net/2363bb5c93657e9c0e67f1d880868f1b.png" alt="MySQL架构图"></p><h4 id="1-1-连接层"><a href="#1-1-连接层" class="headerlink" title="1.1. 连接层"></a>1.1. 连接层</h4><p>最上层是一些客户端和连接服务，例如连接处理，身份验证，安全性等。</p><h4 id="1-2-服务层"><a href="#1-2-服务层" class="headerlink" title="1.2. 服务层"></a>1.2. 服务层</h4><p>MySQL核心部分，主要完成权限判断，查询缓存，SQL解析及优化等功能。</p><h4 id="1-3-引擎层"><a href="#1-3-引擎层" class="headerlink" title="1.3. 引擎层"></a>1.3. 引擎层</h4><p>存储引擎层负责MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信；不同的存储引擎具有不同的功能特性。</p><h4 id="1-4-存储层"><a href="#1-4-存储层" class="headerlink" title="1.4. 存储层"></a>1.4. 存储层</h4><p>数据存储层主要是将数据存储在运行于裸系统的文件系统上，并完成与存储引擎的交互。</p><p><a href="https://blog.csdn.net/weixin_42358062/article/details/80730694" target="_blank" rel="noopener">补充文章</a></p><h3 id="2-SQL语句执行流程"><a href="#2-SQL语句执行流程" class="headerlink" title="2. SQL语句执行流程"></a>2. SQL语句执行流程</h3><p><img src="http://yanxuan.nosdn.127.net/75f839355a6df8d19c8dc89bed66dddb.png" alt="SQL执行流程图"></p><h3 id="3-MyISAM和InnoDB"><a href="#3-MyISAM和InnoDB" class="headerlink" title="3. MyISAM和InnoDB"></a>3. MyISAM和InnoDB</h3><table>    <tr>    <th>对比项</th>        <th>MyISAM</th>        <th>InnoDB</th>    </tr>    <tr>    <td>主外键</td>        <td>不支持</td>        <td>支持</td>    </tr>    <tr>    <td>事务</td>        <td>不支持</td>        <td>支持</td>    </tr>    <tr>    <td>行表锁</td>        <td>表锁，即操作一条记录就锁住整个表，不适合高并发的操作</td>        <td>行锁，即操作时只锁某一行，不对其他行有影响<br><font color="red">适合高并发的操作</font></td>    </tr>    <tr>    <td>缓存</td>        <td>只缓存索引，不缓存真实数据(时间换空间)</td>        <td>不仅缓存索引还缓存真实数据，对内存要求较高，且内存大小对性能有影响(空间换时间)</td>    </tr>    <tr>    <td>表空间</td>        <td>小</td>        <td>大</td>    </tr>    <tr>    <td>关注点</td>        <td>性能</td>        <td>事务</td>    </tr></table><h3 id="4-SQL性能下降的原因"><a href="#4-SQL性能下降的原因" class="headerlink" title="4. SQL性能下降的原因"></a>4. SQL性能下降的原因</h3><h4 id="4-1-查询语句没写好"><a href="#4-1-查询语句没写好" class="headerlink" title="4.1 查询语句没写好"></a>4.1 查询语句没写好</h4><p>避免<code>select *</code>全表扫描</p><h4 id="4-2-索引失效"><a href="#4-2-索引失效" class="headerlink" title="4.2 索引失效"></a>4.2 索引失效</h4><p>建立好索引，且保证索引不失效，或为热点字段建立索引</p><ul><li>单值索引：<code>create index idx_user_name on user(name);</code></li><li>复合索引：<code>create index idx_user_nameEmail on user(name,email);</code></li></ul><h4 id="4-3-关联查询太多join"><a href="#4-3-关联查询太多join" class="headerlink" title="4.3 关联查询太多join"></a>4.3 关联查询太多join</h4><p>设计缺陷或不得已的必要需求</p><h4 id="4-4-服务器调优及参数设置"><a href="#4-4-服务器调优及参数设置" class="headerlink" title="4.4 服务器调优及参数设置"></a>4.4 服务器调优及参数设置</h4><p>缓冲，线程数等。</p><h3 id="5-Join连接"><a href="#5-Join连接" class="headerlink" title="5. Join连接"></a>5. Join连接</h3><p>完整的SQL Join连接图示如下：</p><p><img src="http://yanxuan.nosdn.127.net/2a211fe3769fa933c5932424ad964b37.png" alt="SQL JOINS"></p><h4 id="5-1-INNER-JOIN-内连接"><a href="#5-1-INNER-JOIN-内连接" class="headerlink" title="5.1 INNER JOIN(内连接)"></a>5.1 INNER JOIN(内连接)</h4><p><img src="http://yanxuan.nosdn.127.net/00e6b1dff50539b0b4c637bd7298eae3.png" alt="INNER JOIN"></p><ul><li>内连接查询返回表A和表B中所有匹配行的结果，示例如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT &lt;select_list&gt;FROM Table_A aINNER JOIN Table_B bON a.key = b.key</code></pre><h4 id="5-2-LEFT-JOIN-左连接"><a href="#5-2-LEFT-JOIN-左连接" class="headerlink" title="5.2 LEFT JOIN(左连接)"></a>5.2 LEFT JOIN(左连接)</h4><p><img src="http://yanxuan.nosdn.127.net/ed92f89d777d459dfaa8c0bfeeb4806e.png" alt="LEFT JOIN"></p><ul><li>左连接查询返回所有表A中的记录，不管是否有匹配记录在表B中(匹配不到的标记为null)，示例如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT &lt;select_list&gt;FROM Table_A aLEFT JOIN Table_B bon a.key = b.key</code></pre><h4 id="5-3-RIGHT-JOIN-右连接"><a href="#5-3-RIGHT-JOIN-右连接" class="headerlink" title="5.3 RIGHT JOIN(右连接)"></a>5.3 RIGHT JOIN(右连接)</h4><p><img src="http://yanxuan.nosdn.127.net/fbfc22bf5858f1319856173a2a04a484.png" alt="RIGHT JOIN"></p><ul><li>和左连接相反，右连接查询会返回所有表B中的记录，不管是否有匹配记录在表A中(无匹配标记null)，示例如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT &lt;select_list&gt;FROM Table_A aRIGHT JOIN Table_B bon a.key = b.key</code></pre><h4 id="5-4-LEFT-Excluding-JOIN"><a href="#5-4-LEFT-Excluding-JOIN" class="headerlink" title="5.4 LEFT Excluding JOIN"></a>5.4 LEFT Excluding JOIN</h4><p><img src="http://yanxuan.nosdn.127.net/aec850dd1fc1da519da079c69300526a.png" alt="LEFT Excluding JOIN"></p><ul><li>左排除右连接，它会返回表A中所有不在表B中的行(返回表A独有部分)，示例：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT &lt;select_list&gt;FROM Table_A aLEFT JOIN Table_B bon a.key = b.keyWHERE b.key IS NULL</code></pre><h4 id="5-5-RIGHT-Excluding-JOIN"><a href="#5-5-RIGHT-Excluding-JOIN" class="headerlink" title="5.5 RIGHT Excluding JOIN"></a>5.5 RIGHT Excluding JOIN</h4><p><img src="http://yanxuan.nosdn.127.net/0877fe10b91eb3e06a76b475bd6f3cd9.png" alt="RIGHT Excluding JOIN"></p><ul><li>右排除左连接，它会返回表B中所有不在表A中的行，示例：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT &lt;select_list&gt;FROM Table_A aRIGHT JOIN Table_B bon a.key = b.keyWHERE a.key IS NULL</code></pre><h4 id="5-6-OUTER-Excluding-JOIN"><a href="#5-6-OUTER-Excluding-JOIN" class="headerlink" title="5.6 OUTER Excluding JOIN"></a>5.6 OUTER Excluding JOIN</h4><p><img src="http://yanxuan.nosdn.127.net/9ed77593405efdf6142bdebebd18a359.png" alt="OUTER Excluding JOIN"></p><ul><li>外连接排除内连接结果，它会返回所有表A和表B中没有匹配的行(返回各自独有部分)，示例：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT &lt;select_list&gt;FROM Table_A AFULL OUTER JOIN Table_B BON A.Key = B.KeyWHERE A.Key IS NULL OR B.Key IS NULL</code></pre><h4 id="5-7-FULL-OUTER-JOIN"><a href="#5-7-FULL-OUTER-JOIN" class="headerlink" title="5.7 FULL OUTER JOIN"></a>5.7 FULL OUTER JOIN</h4><p><img src="http://yanxuan.nosdn.127.net/7eeff04fbda89041e4fdf279991cd9bc.png" alt="FULL JOIN"></p><ul><li>全连接，返回表A和表B中的所有行(匹配不到标记null)，示例如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT &lt;select_list&gt;FROM Table_A aFULL OUTER JOIN Table_B bon a.key = b.key</code></pre><blockquote><p>注意：MySQL天生不支持全连接，你可以使用<code>UNION</code>函数连接两个查询(左连接+右连接)来实现全连接。</p><blockquote><p><code>UNION</code>函数用于合并两个或多个<code>SELECT</code>语句的结果集并去重。</p><blockquote><p><a href="https://www.cnblogs.com/xufeiyang/p/5818571.html" target="_blank" rel="noopener">参考文章</a></p></blockquote></blockquote></blockquote><h4 id="5-8-常规SQL查询语句模板"><a href="#5-8-常规SQL查询语句模板" class="headerlink" title="5.8 常规SQL查询语句模板"></a>5.8 常规SQL查询语句模板</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT DISTINCT&lt;select_list&gt;FROM&lt;left_table&gt; &lt;join_type&gt;JOIN &lt;right_table&gt; on &lt;join_condition&gt;WHERE&lt;where_condition&gt;GROUP BY&lt;group_by_list&gt;HAVING&lt;having_condition&gt;ORDER BY&lt;order_by_condition&gt;LIMIT &lt;limit number&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL Join </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>趟坑之路-[SpringBoot整合Redis做缓存]</title>
      <link href="/FrameWork/Springboot-Integrate-Redis.html"/>
      <url>/FrameWork/Springboot-Integrate-Redis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>redis是一个高性能的非关系型内存数据库，通常被用作数据缓存，此文记录了SpringBoot2.x整合Redis做缓存服务器的常规步骤及排错。</p><hr><a id="more"></a><p>本文使用到的环境：<br><table>    <tr>    <td>OS</td>        <td>win10</td>    </tr>    <tr>    <td>JDK</td>        <td>1.8</td>    </tr>    <tr>    <td>SpringBoot版本</td>        <td>2.2.5.RELEASE</td>    </tr>    <tr>    <td>redis版本</td>        <td>2.x以上</td>    </tr></table><br>下面开始整合redis。</p><h3 id="1-整合Redis步骤"><a href="#1-整合Redis步骤" class="headerlink" title="1. 整合Redis步骤"></a>1. 整合Redis步骤</h3><h4 id="1-1-引入依赖"><a href="#1-1-引入依赖" class="headerlink" title="1.1 引入依赖"></a>1.1 引入依赖</h4><p>在<code>pom.xml</code>文件中引入redis依赖</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!-- redis的支持--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><blockquote><p>1.5版本默认采用的客户端是jedis, 2.x版本默认是lettuce</p><ul><li>jedis：多线程使用同一连接时是线程不安全的，需使用到连接池为每个jedis分配一个连接。</li><li>lettuce：当多线程使用同一连接时，是线程安全的，底层基于Netty的 。</li></ul></blockquote><h4 id="1-2-配置文件中配置redis"><a href="#1-2-配置文件中配置redis" class="headerlink" title="1.2 配置文件中配置redis"></a>1.2 配置文件中配置redis</h4><p>在项目的<code>application.properties</code>配置文件中配置redis，配置如下</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-properties">########redis配置############### Redis数据库索引(默认为0)spring.redis.database=0#服务器地址spring.redis.host=127.0.0.1#连接端口号spring.redis.port=6379#连接密码，默认空spring.redis.password=#连接池最大连接数(负值表示无限制)spring.redis.jedis.pool.max-active=10#连接池最大阻塞等待时间(负值表示无限制)spring.redis.jedis.pool.max-wait=-1#连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=8#连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=0#连接超时时间(毫秒)spring.redis.timeout=5000# 若开启redis方式的session存储，type值应为redisspring.session.store-type=redisspring.session.timeout=10server.servlet.session.timeout=10# 显示hibernate的sql语句,方便查看是否成功缓存spring.jpa.show-sql=true</code></pre><h4 id="1-3-创建一个Redis缓存配置类"><a href="#1-3-创建一个Redis缓存配置类" class="headerlink" title="1.3 创建一个Redis缓存配置类"></a>1.3 创建一个Redis缓存配置类</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Configuration@EnableCachingpublic class RedisConfig {    &#x2F;*        SpringBoot2.x的ReidsCacheManager自定义配置方法        缓存之后,key会多一个前缀,默认是将CacheName作为key的前缀     *&#x2F;    @Bean    public RedisCacheManager redisCacheManager(RedisConnectionFactory connectionFactory) {        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        &#x2F;&#x2F;解决查询缓存转换异常的问题        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        &#x2F;&#x2F; 配置序列化（可解决Redis中非中文的问题，但会导致反序列化异常，原因是PageImpl没有空参构造器导致的，如果只是做缓存        &#x2F;&#x2F; 可以选择不自定义value的序列化规则，因为jackson2的序列化器反序列化时需要序列化类有空参构造，如果没有就会报错        &#x2F;&#x2F; 且不自定义value的序列化规则，不影响其反序列化出来的内容，只是redis中显示非中文，或者使用JDK默认的序列化器）        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()                &#x2F;&#x2F; 缓存有效期60s                .entryTtl(Duration.ofSeconds(60))&#x2F;&#x2F;                &#x2F;&#x2F; 设置key序列化                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))&#x2F;&#x2F;                 &#x2F;&#x2F; 设置value序列化.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))                &#x2F;&#x2F;不缓存null值                .disableCachingNullValues();        RedisCacheManager cacheManager = RedisCacheManager.builder(connectionFactory)                .cacheDefaults(config)                .build();        System.out.println(&quot;ReidsCacheManager自定义配置方法被调用了...&quot;);        return cacheManager;    }}</code></pre><blockquote><p>如果开启设置value序列化，会和我下面自定义的Page类冲突，故如果使用到我自定义的Page类，需要将value序列化关闭。</p></blockquote><h4 id="1-4-在适当的地方加入缓存"><a href="#1-4-在适当的地方加入缓存" class="headerlink" title="1.4 在适当的地方加入缓存"></a>1.4 在适当的地方加入缓存</h4><ul><li>User类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Entity &#x2F;&#x2F; 表示这是个实体类@Table(name = &quot;user_&quot;) &#x2F;&#x2F; 表示该类对应的表名是user@SuppressWarnings(&quot;all&quot;) &#x2F;&#x2F; 压制所有警告@JsonIgnoreProperties({&quot;handler&quot;,&quot;hibernateLazyInitianlizer&quot;})public class User implements Serializable{ &#x2F;&#x2F;注意需实现序列化接口    private static final long serialVersionUID = -6373343588870458520L;    @Id &#x2F;&#x2F; 表明主键    @GeneratedValue(strategy = GenerationType.IDENTITY) &#x2F;&#x2F; 表明自增长方式    @Column(name = &quot;id&quot;) &#x2F;&#x2F; 表名对应的数据库字段名    private int id;    @Column(name = &quot;name&quot;)    private String name;    public User() {    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    @Override    public String toString() {        return &quot;User{&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><ul><li>UserDao</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface UserDao extends JpaRepository&lt;User,Integer&gt; {}</code></pre><ul><li>UserService</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface UserService {    public Page4Navigator&lt;User&gt; getList(Pageable pageable);    public void save(User user);    public void delete(User user);    public User get(int id);}</code></pre><ul><li>UserServiceImpl</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Service&#x2F;&#x2F; 设置缓存名称@CacheConfig(cacheNames = &quot;user&quot;)public class UserServiceImpl implements UserService {    @Autowired UserDao userDao;    @Override    &#x2F;&#x2F; 开启缓存    @Cacheable(key = &quot;&#39;user&#39;+#p0.offset+&#39;-&#39;+#p0.pageSize &quot;)    public Page4Navigator&lt;User&gt; getList(Pageable pageable) {        Page&lt;User&gt; pageFromJPA = userDao.findAll(pageable);        Page4Navigator&lt;User&gt; page = new Page4Navigator&lt;&gt;(pageFromJPA, 5);        return page;    }    @Override    &#x2F;&#x2F; 该方法调用后立即清除缓存    @CacheEvict(allEntries = true)    public void save(User user) {        userDao.save(user);    }    @Override    @CacheEvict(allEntries = true)    public void delete(User user) {        userDao.delete(user);    }    @Override    &#x2F;&#x2F; 将查询结果缓存到redis中， user+#p0指定传入的第一个参数+user做为redis的key    @Cacheable(key = &quot;&#39;user &#39;+ #p0&quot;)    public User get(int id) {        return userDao.findById(id).get();    }}</code></pre><h5 id="Redis注解方式"><a href="#Redis注解方式" class="headerlink" title="Redis注解方式"></a>Redis注解方式</h5><h6 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h6><p>定义该类下所有缓存到redis中的父名称。</p><h6 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h6><p>根据方法的请求参数对其结果进行缓存，根据Key进行判断，如已在缓存中，则不执行方法，直接从redis中查询返回结果。</p><ul><li><code>cacherNames</code>：存储该方法调用结果的缓存名称。</li><li><code>key</code>：缓存的key，可以为空；如果指定要按照SpEL表达式编写，不指定默认按照方法的所有参数进行组合。</li><li><code>cacheManager</code>：指定使用的cacheManager</li><li><code>condition</code>：缓存的条件，可以为空，使用SpEL编写，返回布尔值，只有为true才进行缓存。举例：<code>@Cacheable(cacheNames=“userTemp1”, key = “‘UserId_’ + #id”,condition = “#id&lt;=110”)</code><ul><li>表示判断id值，如果id值小于等于110，在方法执行成功后，缓存到redis中。</li></ul></li></ul><h6 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h6><p>根据方法的请求参数对其结果进行缓存，更新Redis中对应键的值，参数同上。</p><h6 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h6><p>根据一定条件对缓存进行清空，特有参数如下：</p><ul><li><code>allEntries</code>：是否清空所有缓存内容，默认false；指定为true则方法调用后将立即清空所有缓存。</li><li><code>beforeInvocation</code>：是否在方法执行前就清空，默认false；指定为true则方法还未执行时就会清空缓存。缺省清空下如果方法抛出异常，则不会清空缓存。</li></ul><p>其他详细Redis注解内容可见<a href="https://segmentfault.com/a/1190000017057950" target="_blank" rel="noopener">文章</a></p><ul><li>分页工具类Page</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Page4Navigator&lt;T&gt; implements Serializable{    private static final long serialVersionUID = -4042369404722051112L;    Page&lt;T&gt; page4jpa;    int navigatePages;    int totalPages;    int number;    long totalElements;    int size;    int numberOfElements;    List&lt;T&gt; content;    boolean isHasContent;    boolean first;    boolean last;    boolean isHasNext;    boolean isHasPrevious;    int[] navigatepageNums;    public Page4Navigator() {    }    public Page4Navigator(Page&lt;T&gt; page4jpa, int navigatePages) {        this.page4jpa = page4jpa;        this.navigatePages = navigatePages;        totalPages = page4jpa.getTotalPages();        number = page4jpa.getNumber();        totalElements = page4jpa.getTotalElements();        size = page4jpa.getSize();        numberOfElements = page4jpa.getNumberOfElements();        content = page4jpa.getContent();        isHasContent = page4jpa.hasContent();        first = page4jpa.isFirst();        last = page4jpa.isLast();        isHasNext = page4jpa.hasNext();        isHasPrevious = page4jpa.hasPrevious();        calcNavigatepageNums();    }    private void calcNavigatepageNums() {        int navigatepageNums[];        int totalPages = getTotalPages();        int num = getNumber();        &#x2F;&#x2F;当总页数小于或等于导航页码数时        if (totalPages &lt;= navigatePages) {            navigatepageNums = new int[totalPages];            for (int i = 0; i &lt; totalPages; i++) {                navigatepageNums[i] = i + 1;            }        } else { &#x2F;&#x2F;当总页数大于导航页码数时            navigatepageNums = new int[navigatePages];            int startNum = num - navigatePages &#x2F; 2;            int endNum = num + navigatePages &#x2F; 2;            if (startNum &lt; 1) {                startNum = 1;                &#x2F;&#x2F;(最前navigatePages页                for (int i = 0; i &lt; navigatePages; i++) {                    navigatepageNums[i] = startNum++;                }            } else if (endNum &gt; totalPages) {                endNum = totalPages;                &#x2F;&#x2F;最后navigatePages页                for (int i = navigatePages - 1; i &gt;= 0; i--) {                    navigatepageNums[i] = endNum--;                }            } else {                &#x2F;&#x2F;所有中间页                for (int i = 0; i &lt; navigatePages; i++) {                    navigatepageNums[i] = startNum++;                }            }        }        this.navigatepageNums = navigatepageNums;    }    &#x2F;&#x2F;省略get&#x2F;set方法    ... ... }</code></pre><ul><li>控制器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RestControllerpublic class UserController_Json {    @Autowired UserService userService;    &#x2F;**     * 获取全部user对象     * @return     * @throws Exception     *&#x2F;    @GetMapping(&quot;&#x2F;user&quot;)    public List&lt;User&gt; listUser(@RequestParam(value = &quot;start&quot;,defaultValue = &quot;0&quot;) int start,                               @RequestParam(value = &quot;size&quot;,defaultValue = &quot;5&quot;) int size) throws Exception{        start = start &lt; 0?0:start;        new Sort.Order(Sort.Direction.DESC,&quot;id&quot;);        Sort orders = Sort.by(&quot;id&quot;);        &#x2F;&#x2F; 根据start、size和sort创建分页对象        PageRequest pageable = PageRequest.of(start,size,orders);        &#x2F;&#x2F; DAO根据这个分页对象获取结果page,这个page对象里，不仅包含了分页信息，还包含了数据信息,类转换异常？        Page4Navigator&lt;User&gt; list = userService.getList(pageable);        return list.getContent();    }    &#x2F;**     * 获取单个user对象     * @param id     * @return     * @throws Exception     *&#x2F;    @GetMapping(&quot;&#x2F;user&#x2F;{id}&quot;)    @ResponseBody    public User getUser(@PathVariable(&quot;id&quot;) int id,                        HttpServletResponse response) throws Exception{        User user = userService.get(id);        System.out.println(user);        return user;    }    &#x2F;**     * 添加用户     * @param user     * @throws Exception     *&#x2F;    @PutMapping(&quot;&#x2F;user&quot;)    public void addUser(@RequestBody User user) throws Exception{        System.out.println(&quot;SpringBoot接受到浏览器以JSON格式提交的数据：&quot;+user);        userService.save(user);    }}</code></pre><h4 id="1-5-启动redis"><a href="#1-5-启动redis" class="headerlink" title="1.5 启动redis"></a>1.5 启动redis</h4><p>找到<code>redis-server.exe</code>，双击运行。</p><p><img src="http://yanxuan.nosdn.127.net/63d63e531aa2b31f79be985307c226e4.png" alt="redis-server"></p><h4 id="1-6-启动项目"><a href="#1-6-启动项目" class="headerlink" title="1.6 启动项目"></a>1.6 启动项目</h4><p>启动项目测试接口，<a href="http://localhost/user，http://localhost/user/4，查看hql语句输出，可以看到除了第一次访问会查询数据库，后续都没有查询数据库，而是从redis中获取数据。" target="_blank" rel="noopener">http://localhost/user，http://localhost/user/4，查看hql语句输出，可以看到除了第一次访问会查询数据库，后续都没有查询数据库，而是从redis中获取数据。</a></p><p><img src="http://yanxuan.nosdn.127.net/af29a07caeb364eec6d679bec77f91e6.png" alt="test"></p><h3 id="2-踩坑记录"><a href="#2-踩坑记录" class="headerlink" title="2. 踩坑记录"></a>2. 踩坑记录</h3><h4 id="2-1-二次查询报错，PageImpl没有构造方法，导致无法反序列化"><a href="#2-1-二次查询报错，PageImpl没有构造方法，导致无法反序列化" class="headerlink" title="2.1 二次查询报错，PageImpl没有构造方法，导致无法反序列化"></a>2.1 二次查询报错，PageImpl没有构造方法，导致无法反序列化</h4><p>其原因在于我自定义的Page类中有使用到<code>org.springframework.data.domain.Page</code>类，该类有一个实现类<code>PageImpl</code>，此类是没有实现无参构造器的，故从缓存中读取数据反序列化时会报错：<code>org.springframework.data.redis.serializer.SerializationException: Could not read JSON: Can not construct instance of org.springframework.data.domain.PageImpl ....</code></p><p>解决这个问题有两个方法：</p><ol><li>不设置<code>RedisConfig</code>配置类中自定义的value序列化规则，因为使用<code>jackson2JsonRedisSerializer</code>设置value的序列化值就会报错，不设置就不会；不设置的弊端就是，Redis数据库中存储的数据是HEX格式的，也就是16进制数据，不方便查阅。</li><li>可以使用另一个Page类，替换我原本的page类，暂时没有深入研究这两个类的区别，有兴趣的同学可以研究下。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class MyPage&lt;T&gt; implements Iterable&lt;T&gt;, Serializable {    private static final long serialVersionUID = -3720998571176536865L;    private List&lt;T&gt; content = new ArrayList&lt;&gt;();    private long totalElements;    private int pageNumber;    private int pageSize;    private boolean first;    private boolean last;    private boolean empty;    private int totalPages;    private int numberOfElements;    public MyPage() {    }        public MyPage(Page&lt;T&gt; page) {        this.content = page.getContent();        this.totalElements = page.getTotalElements();        this.pageNumber = page.getPageable().getPageNumber();        this.pageSize = page.getPageable().getPageSize();        this.numberOfElements = page.getNumberOfElements();    }        &#x2F;&#x2F; 省略get&#x2F;set方法    ... ...       &#x2F;&#x2F;迭代器    @Override    public Iterator&lt;T&gt; iterator() {        return getContent().iterator();    }}    </code></pre><h4 id="2-2-java-util-LinkedHashMap-cannot-be-cast-to-XXX"><a href="#2-2-java-util-LinkedHashMap-cannot-be-cast-to-XXX" class="headerlink" title="2.2 java.util.LinkedHashMap cannot be cast to XXX"></a>2.2 java.util.LinkedHashMap cannot be cast to XXX</h4><p>发生在读取redis缓存的时候报错，<code>java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to XXX</code>，但是我个人代码中并没有定义和使用到<code>LinkedHashMap</code>，查资料后发现原因是<code>Jackson2JsonRedisSerializer</code>，该序列化器中默认使用的<code>ObjectMapper</code>是直接<code>new ObjectMapper()</code>创建的，这样<code>ObjectMapper</code>会将redis中的字符串反序列化为<code>LinkedHashMap</code>类型，导致后续类型转换错误。</p><p>解决方法，配置<code>objectMapper</code>的默认类型：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer =    new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);ObjectMapper objectMapper = new ObjectMapper();objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);objectMapper.configure(MapperFeature.USE_ANNOTATIONS, false);objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);&#x2F;&#x2F; 配置如下，解决LinkedHashMap转换异常objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</code></pre><h4 id="2-3-redis数据非中文"><a href="#2-3-redis数据非中文" class="headerlink" title="2.3 redis数据非中文"></a>2.3 redis数据非中文</h4><p>只需在<code>redisCacheManager</code>方法中进行redis的缓存配置，设置value序列化。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()    &#x2F;&#x2F; 缓存有效期60s    .entryTtl(Duration.ofSeconds(60))    &#x2F;&#x2F; 设置key序列化    .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))    &#x2F;&#x2F; 设置value序列化    .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))    &#x2F;&#x2F;不缓存null值    .disableCachingNullValues();</code></pre><h4 id="2-4-相同类转换异常"><a href="#2-4-相同类转换异常" class="headerlink" title="2.4 相同类转换异常"></a>2.4 相同类转换异常</h4><p>关闭IDEA的热部署即可，原因和JVM的双亲委派有关，感兴趣的自查。</p>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot简单入门</title>
      <link href="/FrameWork/SpringBoot-Basic.html"/>
      <url>/FrameWork/SpringBoot-Basic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="SpringBoot简单入门"><a href="#SpringBoot简单入门" class="headerlink" title="SpringBoot简单入门"></a>SpringBoot简单入门</h2><p>Spring是一个JavaWeb开发框架，极大的简化开发，降低了对配置文件的要求；能迅速的开发web应用，几行代码就可以开发一个http接口。</p><a id="more"></a><h3 id="1-创建简单项目"><a href="#1-创建简单项目" class="headerlink" title="1. 创建简单项目"></a>1. 创建简单项目</h3><ol><li>点击菜单-&gt;New-&gt;Project-&gt;Spring Initalizr 然后点击Next</li></ol><p><img src="http://yanxuan.nosdn.127.net/b9e28697b634eab06db8a659ccede011.png" alt="New Project"></p><ol start="2"><li>输入如图所示两个地方参数，其他参数一般默认，然后Next</li></ol><p><img src="http://yanxuan.nosdn.127.net/a2e77ddd87976719e7a10347a0927741.png" alt="New Project"></p><ol start="3"><li>接着选择Web,然后勾选Spring Web即可，Next</li></ol><p><img src="http://yanxuan.nosdn.127.net/075b6bf7031e1a28d641e9ee64fc64f7.png" alt="选择Web"></p><ol start="4"><li>最后确认一下项目名称和位置即可，点击Finish完成项目创建。</li><li>项目创建好后，自带一个Application，在里面填写如下内容</li></ol><p><img src="http://yanxuan.nosdn.127.net/cb1facc5ce154216aeae0a72342b3210.png" alt="建立简单映射"></p><ol start="6"><li>启动Application项目，测试访问。</li></ol><h3 id="2-关于打包问题"><a href="#2-关于打包问题" class="headerlink" title="2. 关于打包问题"></a>2. 关于打包问题</h3><p>通常部署SpringBoot项目可以采用两种方式：全部打包成一个jar包，或者打包成一个war包。</p><h4 id="2-1-打包成jar包"><a href="#2-1-打包成jar包" class="headerlink" title="2.1 打包成jar包"></a>2.1 打包成jar包</h4><p>使用IDEA的话非常简单，找到右侧侧边栏的maven图标，点击项目生命周期，然后双击<code>install</code>即可，没问题应该显示<code>BUILD SUCCESS</code>。</p><p><img src="http://yanxuan.nosdn.127.net/1c7d5f6b064fdb92b777e4b6d4485677.png" alt="Maven"></p><blockquote><p>使用maven的<code>mvn install</code>一样可以，该命令需在项目根目录打开命令行窗口下运行。</p></blockquote><p>该命令会在你项目的target目录下生产一个jar文件，使用命令<code>java -jar yourjarName.jar</code>运行该jar文件即可启动项目。</p><p><img src="http://yanxuan.nosdn.127.net/d51e68036cb149702808e7bf79d388e3.png" alt="运行jar"></p><p>这个jar包里面包含项目的全部文件，以及Tomcat服务器，所以无论放到哪里只要有java环境就可以运行启动项目。</p><h4 id="2-2-打包成war包"><a href="#2-2-打包成war包" class="headerlink" title="2.2 打包成war包"></a>2.2 打包成war包</h4><ol><li>修改<code>pom.xml</code>，添加打包类型和依赖</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!-- 打包成war包需加这一行--&gt;&lt;packaging&gt;war&lt;&#x2F;packaging&gt;&lt;!-- 打包从war包时需添加此依赖,防止打包冲突--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;    &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;!-- 表示只在编译和测试过程有效，生成war包不会加入--&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="2"><li>修改启动类文件，继承<code>SpringBootServletInitializer</code></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@SpringBootApplicationpublic class HelloDemoApplication extends SpringBootServletInitializer {@Overrideprotected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {return builder.sources(HelloDemoApplication.class);}public static void main(String[] args) {SpringApplication.run(HelloDemoApplication.class, args);}}</code></pre><blockquote><p>SpringBoot项目想运行在第三方Tomcat上必须实现<code>SpringBootServletInitializer</code>接口的<code>configure</code>方法才能让外部容器运行。</p></blockquote><ol start="3"><li>使用maven的<code>clean</code>命令，然后使用<code>package</code>命令，就会在target目录下生成<code>.war</code>文件</li></ol><p><img src="http://yanxuan.nosdn.127.net/17f5a60920545e0780cf37f492cf7689.png" alt="生成war"></p><ol start="4"><li>将该文件复制到外部Tomcat的webapps目录下，重命名为<code>ROOT.war</code>，方便访问。</li></ol><blockquote><p>不修改为ROOT，需要加项目名称才可以访问。</p></blockquote><p><img src="http://yanxuan.nosdn.127.net/4acfb821a780f0388eb6355810d275dd.png" alt="部署war"></p><ol start="5"><li>bin目录下点击<code>startup.bat</code>文件，启动项目，测试访问。</li></ol><p><img src="http://yanxuan.nosdn.127.net/84c10736da31d123eb3761476362d5af.png" alt="运行war"></p><h3 id="3-关于Tomcat中文乱码问题"><a href="#3-关于Tomcat中文乱码问题" class="headerlink" title="3. 关于Tomcat中文乱码问题"></a>3. 关于Tomcat中文乱码问题</h3><p>在tomcat的conf文件夹下，打开<code>logging.properties</code>文件，将<code>java.util.logging.ConsoleHandler.encoding = UTF-8</code>修改<code>java.util.logging.ConsoleHandler.encoding = GBK</code></p><p><img src="http://yanxuan.nosdn.127.net/cc6dbe40be3cc9beb0dedbd015abfd7c.png" alt="解决乱码"></p><h3 id="4-SpringBoot热部署"><a href="#4-SpringBoot热部署" class="headerlink" title="4. SpringBoot热部署"></a>4. SpringBoot热部署</h3><ol><li>在settings中开启<code>Build project automatically</code>，自动构建项目功能。</li></ol><p><img src="http://yanxuan.nosdn.127.net/8a4d3961d543c268a9f3831b8f8bd043.png" alt="UTOOLS1583487581224.png"></p><ol start="2"><li>开启动态自动编译，同时按住<code>Ctrl+Shift+Alt+/</code>，然后点击<code>Registry</code>，勾选如下参数，并配置时间。</li></ol><p><img src="http://yanxuan.nosdn.127.net/8a6d4c9a57fd673d6f8a11d3b0a6d9fe.png" alt="UTOOLS1583487512368.png"></p><ol start="3"><li>开启项目的热部署策略，在项目配置中选择如下选项即可。</li></ol><p><img src="http://yanxuan.nosdn.127.net/7e0d63ba102733533ac83ee8e86f9efb.png" alt="UTOOLS1583487836015.png"></p><ol start="4"><li>项目添加热部署插件，在xml中配置如下。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!-- 热部署依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;    &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;!-- true才生效 --&gt;    &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;!--仅在运行期有效，不参与打包--&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="5"><li>保险起见，浏览器f12 ✅Disable cache。</li></ol><h3 id="5-关于错误处理"><a href="#5-关于错误处理" class="headerlink" title="5. 关于错误处理"></a>5. 关于错误处理</h3><p>定义一个全局的异常处理器，然后跳转到错误页面</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@ControllerAdvicepublic class GlobalExceptionHandler {    @ExceptionHandler(value = Exception.class)    public ModelAndView defaultErrorHandler(HttpServletRequest req,Exception e) throws Exception{        ModelAndView view = new ModelAndView();        view.addObject(&quot;exception&quot;,e);        view.addObject(&quot;url&quot;,req.getRequestURL());        view.setViewName(&quot;errorPage&quot;);        return view;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI7层模型和TCP/IP四层模型简要总结</title>
      <link href="/Interview/computer-networks.html"/>
      <url>/Interview/computer-networks.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于OSI7层模型相关知识点，以前是总结过一篇<a href="https://zero024.cn/2019/08/02/Interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83/">文章</a>的，但因为太过详细，显的有些繁琐了，今天复习到计网知识，便重新写一篇精简版的，方便回顾记忆。</p><a id="more"></a><h3 id="1-OSI7层模型和TCP4层模型"><a href="#1-OSI7层模型和TCP4层模型" class="headerlink" title="1. OSI7层模型和TCP4层模型"></a>1. OSI7层模型和TCP4层模型</h3><p><img src="http://yanxuan.nosdn.127.net/db1fb1447ca74d3f923d7953ba014a80.png" alt="OSI"></p><h4 id="1-1-模型各层功能"><a href="#1-1-模型各层功能" class="headerlink" title="1.1 模型各层功能"></a>1.1 模型各层功能</h4><table border="1">    <tr>    <th>OSI7层模型</th>        <th>TCP/IP4层模型</th>        <th>功能</th>        <th>各层协议簇</th>    </tr>    <tr>        <td>应用层</td>        <td rowspan="3">应用层</td>        <td>文件传输,电子邮件,文件服务,虚拟终端</td>        <td>TFTP,HTTP,SNMP,FTP,SMTP,DNS,Telent</td>    </tr>    <tr>        <td>表示层</td>        <!-- <td>应用层</td> -->        <td>数据格式化,代码转换,数据加解密</td>        <td>无协议</td>    </tr>    <tr>        <td>会话层</td>        <!-- <td>应用层</td> -->        <td>提供建立或解除连接的方法</td>        <td>无协议</td>    </tr>    <tr>        <td>传输层</td>        <td>传输层</td>        <td>提供端对端的接口</td>        <td>TCP,UDP</td>    </tr>    <tr>        <td>网络层</td>        <td>网络层</td>        <td>为数据包选择路由</td>        <td>IP,ICMP,RIP,OSPF,BCP</td>    </tr>    <tr>        <td>数据链路层</td>        <td rowspan="2">链路层</td>        <td>传输有地址的帧及差错控制等功能，提供可靠的数据传输</td>        <td>SLIP,CSLIP,PPP,ARP,RARP,MTU</td>    </tr>    <tr>        <td>物理层</td>        <!-- <td>链路层</td> -->        <td>利用传输介质以比特流数据形式透明传输数据</td>        <td>ISO2100,IEEE802,IEEE</td>    </tr></table><blockquote><p>简言之：OSI7层模型下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。</p></blockquote><h3 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h3><table border="1">    <tr>        <th rowspan="2">类型</th>        <th colspan="3">特点</th>        <th colspan="2">性能</th>        <th rowspan="2">应用场景</th>        <th rowspan="2">首部字节</th>    </tr>    <tr>        <th>是否面向连接</th>        <th>传输可靠性</th>        <th>传输形式</th>        <th>传输效率</th>        <th>所需资源</th>    </tr>    <tr>    <td>TCP</td>        <td>面向连接</td>        <td>可靠</td>        <td>字节流</td>        <td>慢</td>        <td>多</td>        <td>要求通信数据可靠<br>(如文件传输,邮件收发等)</td>        <td>20-60</td>    </tr>    <tr>    <td>UDP</td>        <td>无连接</td>        <td>不可靠</td>        <td>数据报文段</td>        <td>快</td>        <td>少</td>        <td>要求通信速度高<br>(如视频直播,语音聊天等)</td>        <td>8</td>    </tr></table><ul><li>TCP是面向连接的高可靠性的服务，利用握手确认和重传机制保证数据不丢失，利用序列号保证消息包的顺序交互；因其要保证消息的可靠性和有序性，故传输效率较慢；且消息头最少20字节，资源消耗较多。</li><li>UDP是无连接的不保证数据可靠性的服务，可能会丢失数据且无序；因无需考虑连接和可靠性，故传输效率很快，消息头只需8字节，轻量级。</li></ul><h3 id="3-浏览器输入URL后经历的流程"><a href="#3-浏览器输入URL后经历的流程" class="headerlink" title="3. 浏览器输入URL后经历的流程"></a>3. 浏览器输入URL后经历的流程</h3><ol><li><strong>DNS解析</strong>：首先浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名所对应的IP地址。DNS缓存从近到远依次是：浏览器缓存:arrow_right: 系统hosts文件:arrow_right: 路由器缓存:arrow_right:IPS服务器缓存 :arrow_right:根域名服务器缓存:arrow_right:顶级域名服务器缓存。找到IP则返回，不会查询后续缓存。</li><li><strong>TCP连接</strong>：根据IP地址和默认端口(80)来和服务器建立TCP连接(三次握手)。</li><li><strong>发送HTTP请求</strong>：浏览器发出读取文件的HTTP请求，该请求将发送给服务器。</li><li><strong>服务器处理请求并返回HTTP报文</strong>：服务器对浏览器请求作出响应，并把对应的带有HTML文本的HTTP响应报文发送给浏览器。</li><li><strong>浏览器解析渲染页面</strong>：浏览器接收到HTML，并在显示窗口内渲染它。</li><li><strong>连接结束</strong>：浏览器释放TCP连接(四次挥手)。</li></ol><h3 id="4-TCP三次握手和四次挥手-老面试题了"><a href="#4-TCP三次握手和四次挥手-老面试题了" class="headerlink" title="4. TCP三次握手和四次挥手(老面试题了)"></a>4. TCP三次握手和四次挥手(老面试题了)</h3><h4 id="4-1-三次握手"><a href="#4-1-三次握手" class="headerlink" title="4.1 三次握手"></a>4.1 三次握手</h4><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><p>详细图解如下：</p><p><img src="https://zero024.oss-cn-hangzhou.aliyuncs.com/Figure_bed/2020-03-03/df7235fc411a4c2b88eae79bfe7d3a1f-TCP三次握手.gif" alt="三次握手"></p><p>简单示意图：</p><p><img src="http://yanxuan.nosdn.127.net/06d059232d3b537e997976e0f6066df0.png" alt="三次握手简"></p><ul><li>一次握手：客户端发送带有SYN标志的数据包给服务端；</li><li>二次握手：服务端发送带有SYN/ACK标志的数据包给客户端；</li><li>三次握手：客户端发送带有ACK标志的数据包给服务端，连接建立。</li></ul><h4 id="4-2-为什么要三次握手？"><a href="#4-2-为什么要三次握手？" class="headerlink" title="4.2 为什么要三次握手？"></a>4.2 为什么要三次握手？</h4><p>三次握手的目的是建立可靠的通信信道，通讯就是数据的发送和接收，也就是说三次握手的主要目的是<strong>双方确认自己和对方的发送与接收功能是正常的。</strong>故三次握手的含义如下：</p><ul><li>第一次握手：客户端什么都确认不了；服务端确认了对方发送正常</li><li>第二次握手：客户端可以确认：自己发送、接收正常，对方发送、接收正常；服务端可以确认，自己接收正常，对方发送正常</li><li>第三次握手：客户端已经确认过自己收发正常，对方收发正常；服务器端收到确认包后可以确认，自己发送、接收正常，对方发送接收也正常</li></ul><blockquote><p>所以只需三次握手就能确认双方收发功能是否正常</p></blockquote><h5 id="4-2-1-第二次握手中，传了SYN，为什么还要传ACK"><a href="#4-2-1-第二次握手中，传了SYN，为什么还要传ACK" class="headerlink" title="4.2.1 第二次握手中，传了SYN，为什么还要传ACK"></a>4.2.1 第二次握手中，传了SYN，为什么还要传ACK</h5><p>双方通信无误必须是两者互相发送信息都无误。传了SYN，证明发送方到接收方的通道是没有问题，但是接收方到发送方的通道还需要ACK信号来验证。</p><h4 id="4-3-四次挥手"><a href="#4-3-四次挥手" class="headerlink" title="4.3 四次挥手"></a>4.3 四次挥手</h4><p>断开一个TCP连接需进行“四次挥手”。</p><p>详细图解如下：</p><p><img src="https://zero024.oss-cn-hangzhou.aliyuncs.com/Figure_bed/2020-03-03/fd289bc9b3904ba8831b5dcbb511824d-TCP_四次挥手.gif" alt="四次挥手"></p><p>文字流程：</p><ul><li>客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入<code>FIN_WAIT_1</code>状态；</li><li>服务器收到这个FIN，回发一个ACK，确认序号为收到的序号加1，此时服务器进入<code>CLOSE_WAIT</code>状态，客户端进入<code>FIN_WAIT_2</code>状态。</li><li>服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入<code>LAST_ACK</code>状态。</li><li>客户端收到FIN后，进入<code>TIME_WAIT</code>状态，接着回发一个ACK给服务器；服务器进入<code>CLOSED</code>状态，客户端在经过2MSL后也会进入<code>CLOSED</code>状态，完成四次挥手。</li></ul><p>举个栗子：</p><p>我和朋友打电话，通话即将结束时，我说：“我没啥要说的了”，朋友回答：“好的，我知道了”，但是朋友可能还要话要讲，所以我不能直接挂断电话，于是朋友又说了一些话，最后朋友回答：“我说完了”，我回答：“知道了，那我挂了”，这样通信才算结束。</p>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署至coding</title>
      <link href="/Other/hexo-Deployed-to-coding.html"/>
      <url>/Other/hexo-Deployed-to-coding.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因本人的hexo是部署至github的，现在换了个主题图片有点多，导致访问速度非常慢，故想到部署到国内的服务器上，所以找到了coding，准备把hexo也同步部署到coding上去。</p><a id="more"></a><p>本文章记录了如何将hexo部署至coding，从而加快国内站点的访问，本文前置条件：</p><ol><li>拥有hexo博客，会hexo的基本操作；</li><li>拥有coding账户，且实名(未实名不能创建静态网站)。</li></ol><h3 id="1-coding配置"><a href="#1-coding配置" class="headerlink" title="1. coding配置"></a>1. coding配置</h3><p>首先进行coding的配置，步骤如下：</p><ol><li>打开你的coding页面，新建一个项目；</li></ol><p><img src="https://yanxuan.nosdn.127.net/d518fdebcf6f8b7bd51bc9a9c92a835f.png" alt="选择项目模板.png"></p><blockquote><p>注意：不要选择代码托管，这样不能创建静态页面</p></blockquote><ol start="2"><li>填写项目基本信息；</li></ol><p><img src="https://yanxuan.nosdn.127.net/7574ea9e1ac663cc9f71c8817c8c7324.png" alt="填写项目基本信息.png"></p><p>一般都选择默认配置即可，点击完成创建。</p><ol start="3"><li>进入项目，点击代码仓库，找到项目的https链接，后面会用到。</li></ol><p><img src="https://yanxuan.nosdn.127.net/d1efb6e8e01170c6d47c7bfd65b4cffd.png" alt="coding链接.png"></p><h3 id="2-hexo配置"><a href="#2-hexo配置" class="headerlink" title="2. hexo配置"></a>2. hexo配置</h3><p>接下来到hexo进行相关配置。</p><h4 id="2-1-安装部署服务器插件"><a href="#2-1-安装部署服务器插件" class="headerlink" title="2.1 安装部署服务器插件"></a>2.1 安装部署服务器插件</h4><p>打开你本地的hexo文件夹，然后打开Cmd或者GitBash窗口，输入以下命令安装插件：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">npm install hexo-deployer-git --save</code></pre><p><img src="https://yanxuan.nosdn.127.net/f023d323295d1eabc3a38146fb88abcf.png" alt="安装插件"></p><p>我安装过了所以显示的不一样。</p><blockquote><p>本人使用的cnpm是npm的淘宝镜像源，访问速度比npm快一些，比较推荐更换，<a href="http://npm.taobao.org/" target="_blank" rel="noopener">详见链接</a></p></blockquote><h4 id="2-2-修改站点配置文件"><a href="#2-2-修改站点配置文件" class="headerlink" title="2.2 修改站点配置文件"></a>2.2 修改站点配置文件</h4><p>该文件位于主目录下，名称是<code>_config.yml</code>，使用任意编辑器打开。</p><p><img src="https://yanxuan.nosdn.127.net/ce00ec9be9c7559c78832fdf9b952fa1.png" alt="配置文件"></p><p>打开后找到<code>deploy</code>，修改配置如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-yml"># Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy:  type: git # 部署类型  repo: # 上传仓库地址    github: https:&#x2F;&#x2F;github.com&#x2F;zero6996&#x2F;zero6996.github.io.git # github仓库地址    coding: https:&#x2F;&#x2F;e.coding.net&#x2F;zero024&#x2F;hexo.git # coding仓库地址，将你的coding链接复制到这里。  branch: master # 推送到远程的分支</code></pre><blockquote><p>注意yml的语法，缩进都是空两格，然后<code>：</code>冒号后面要空一格才能生效</p></blockquote><h4 id="2-3-部署项目"><a href="#2-3-部署项目" class="headerlink" title="2.3 部署项目"></a>2.3 部署项目</h4><p>回到命令行窗口，输入<code>hexo d</code>部署项目，如果没有问题的话应该显示有如下关键信息：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">Branch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;https:&#x2F;&#x2F;github.com&#x2F;zero6996&#x2F;zero6996.github.io.git&#39;.Everything up-to-dateBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;https:&#x2F;&#x2F;e.coding.net&#x2F;zero024&#x2F;hexo.git&#39;.Everything up-to-dateINFO  Deploy done: git</code></pre><h4 id="2-4-配置静态网站"><a href="#2-4-配置静态网站" class="headerlink" title="2.4 配置静态网站"></a>2.4 配置静态网站</h4><p>回到coding的hexo项目，刷新一下可以看到代码仓库中已经有代码了，下面找到左侧<code>构建与部署</code>一栏，进行静态网站的相关配置。</p><p><img src="https://yanxuan.nosdn.127.net/3fa30fd26bca77eb12b130b0ebec5c8a.png" alt="构建与部署"></p><p>点击<code>立即发布静态网站</code>，进入新建静态网站页面，网站名称任意，其他选项一般默认即可。</p><p><img src="https://yanxuan.nosdn.127.net/db064e6bcd75810068ae6efe1ca70163.png" alt="新建静态网站"></p><p>保存后点击<code>立即部署</code>，即可部署项目到网站，coding给了个默认地址可以访问，点击即可查看静态网站部署效果。</p><p><img src="https://yanxuan.nosdn.127.net/7a304592937bb1838a379a40fc70a440.png" alt="部署网站"></p><h3 id="3-域名配置"><a href="#3-域名配置" class="headerlink" title="3. 域名配置"></a>3. 域名配置</h3><p>如果你拥有域名的话，可以绑定域名，具体操作如下。</p><h4 id="3-1-域名解析"><a href="#3-1-域名解析" class="headerlink" title="3.1 域名解析"></a>3.1 域名解析</h4><p>本人使用的是阿里的域名，其他服务商的操作也大致相同。</p><p>首先进入域名解析页面，点击添加记录，设置一个CNAME，主机记录www，解析线路默认，记录值为你coding的默认访问地址；</p><p><img src="https://yanxuan.nosdn.127.net/240e822daae179f599361b6a24e8f5e3.png" alt="DNS解析"></p><p>在添加一个CNAME，主机记录@，解析默认，记录值同上；</p><p><img src="https://yanxuan.nosdn.127.net/d7d950a269c87f8f1da8ff6cdde9433d.png" alt="DNS解析"></p><p>这样DNS解析就设置完毕了，回到coding进行域名绑定，点击你的静态网站，右上角有个设置选项，可以进行很多设置。</p><p><img src="https://yanxuan.nosdn.127.net/402a34805f92ad3cebb0cbde31017365.png" alt="域名绑定"></p><p>找到自定义域名，输入你的域名地址进行绑定，添加两个。</p><p><img src="https://yanxuan.nosdn.127.net/245ca3613c374f27bbbaabd507b6ade2.png" alt="域名绑定"></p><p>大功告成！你可以使用你的域名快速的访问你的博客了。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计科04:[二进制]</title>
      <link href="/ComputerScience/binary-system.html"/>
      <url>/ComputerScience/binary-system.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p><a href="https://www.bilibili.com/video/av21376839?p=4" target="_blank" rel="noopener">视频</a></p><h3 id="1-二进制原理"><a href="#1-二进制原理" class="headerlink" title="1. 二进制原理"></a>1. 二进制原理</h3><p>逻辑门可以判断布尔语句，布尔代数只有两个值：True和False，但如果只有两个值，我们该如何表达更多东西？上文提到，1个二进制可以代表1个数，我们可以把真和假，当做1和0，如果想表示更多东西，加位数就行了。</p><a id="more"></a><p>我们熟悉的十进制，只有10个数(0-9)，要表示大于9的数，就需要加位数。拿263举例，这个数字实际代表了：2个100、6个10、3个1，加在一起就是263。每列有不同的乘数(100,10,1)，每个乘数比右边大十倍，如果超过9，就要在下一列进1(满十进一，满二十进二…)，因此叫“基于十的表示法”或<strong>十进制</strong>。</p><p>二进制也是如此，只不过是基于2而已。因为二进制只有两个可能的数，1和0；意味着每个乘数必须是右侧乘数的两倍，就不是十进制的100，10，1了，而是4,2,1。拿二进制数101举例，意味着有1个“4”，0个“2”和1个“1”，加在一起就得到十进制的5。</p><p>为了表示更大的数字，二进制需要更多的位数，拿二进制数10110111举例，可以用相同的方法转成十进制：1 x 128 ，0 x 64 ，1 x 32 ，1 x 16 ，0 x 8 ，1 x 4 ，1 x 2 ，1 x 1，加起来等于183。</p><p><img src="https://i.loli.net/2020/01/22/wrWxRTbvDNFuH1V.png" alt="二进制转十进制"></p><p>二进制的计算也不难，以十进制数183加19举例：首先 3 + 9，得到 12，然后位数记作 2，满10向前进 1；再算 8+1+1=10，所以位数记作0，再满10进 1，最后1+1=2，位数记作2，和就是202。</p><p>二进制的计算：先把19换算为二进制就是00010011，从个位开始计算，1+1=2，但二进制中没有 2，所以位数记作 0 ，进 1；然后1+1，再加上进位的1，等于3，用二进制表示是11，所以位数记作 1，再进 1，以此类推。最后得到的数字，跟十进制的202是一样的。</p><p><img src="https://i.loli.net/2020/01/22/Q5e3uynETFYGADO.png" alt="二进制的计算"></p><p>二进制中，一个1或0叫一“位”，上面的例子我们用了8位，8位能表示的最小数是0(8位都是0)，最大数是255(8位都是1)；能表示256个不同的值，就是2的8次方。</p><p>你可能听过8位机，8位图像，8位音乐，意思是计算机里大部分操作都是8位8位这样处理的；但256个值不算多，意味着8位游戏只能用256种颜色，8位非常常见，以至于有专门的名字：<strong>字节(Byte)</strong>。</p><p>1字节(byte)等于8位(bits)，如果有10个字节，就代表80位。千字节(kb)兆字节(mb)千兆字节(gb)，不同前缀代表不同数量级，就像1千克=1000克，1千字节=1000字节(或8000位)。如今你可能有1TB的硬盘，代表8万亿个1和0。二进制里，1 千字节 = 2的10次方 = 1024 字节，1000 也是千字节（KB）的正确单位，1000 和 1024 都对。</p><h3 id="2-正数、负数、整数、浮点数的表示"><a href="#2-正数、负数、整数、浮点数的表示" class="headerlink" title="2. 正数、负数、整数、浮点数的表示"></a>2. 正数、负数、整数、浮点数的表示</h3><p>你应该听过32位或64位计算机，意思是一块块处理数据，每块是32位或64位。32位表示的最大数是43亿左右，也就是32个1。所以 Instagram 照片很清晰，因为它有上百万种颜色，如今都用32位颜色。当然，不是所有数字都是正数，因此就需要有方法表示正数和负数，大部分计算机用第一位表示正负，即1是负，0是正，用剩下31位来表示数字，能表示的数字范围是正20亿到负20亿，虽然是很大的数，但有时还不够用。</p><p>计算机必须给内存中每一个位置，做一个 “标记”，这个标记叫 <strong>“位址”</strong>, 目的是为了方便存取数据，如今硬盘已经增长到 GB 和 TB，上万亿个字节！内存地址也应该有64位；除了负数和正数，计算机也要处理非整数，比如 12.7 和 3.14，或”星历 43989.1”，这叫<strong>浮点数</strong>。</p><p>因为小数点可以在数字间浮动，所以有好几种方法 表示浮点数，最常见的是 IEEE 754 标准，它用类似科学计数法的方法，来存十进制值；例如，625.9 可以写成 0.6259×10 ^ 3，这里有两个重要数字：.6259 叫 “有效位数” , 3 是指数。在32位浮点数中，第一位表示数字的正负，接下来 8 位存指数，剩下 23 位存有效位数。</p><p><img src="https://i.loli.net/2020/01/22/L6aUtRelxGdgwNF.png" alt="浮点数32位表示"></p><h3 id="3-ASCII"><a href="#3-ASCII" class="headerlink" title="3. ASCII"></a>3. ASCII</h3><p>为了表示文字，最直接的方法是给字母编号：A是1，B是2，C是3，以此类推。著名英国作家 弗朗西斯·培根（Francis Bacon）曾用 5位序列 来编码英文的 26 个字母，在十六世纪传递机密信件。五位（bit）可以存 32 个可能值（2^5） - 这对26个字母够了，但不能表示 标点符号，数字和大小写字母。</p><p><strong>ASCII，美国信息交换标准代码</strong>，发明于 1963 年，ASCII 是 7 位代码，足够存 128 个不同值，范围扩大之后，可以表示大写字母，小写字母,数字 0 到 9, @ 这样的符号, 以及标点符号；举例，小写字母 a 用数字 97 表示，大写字母 A 是 65，: 是58 ，) 是41等等。</p><p>ASCII 甚至有特殊命令符号，比如换行符，用来告诉计算机换行。因为在老计算机系统中，如果没换行符，文字会超出屏幕。</p><p> ASCII 是个很早的标准，故被广泛使用，让不同公司制作的计算机，能互相交换数据，这种通用交换信息的能力叫 “互用性”；但其有个限制：它是为英语设计的。</p><p>好在一个字节有8位，而不是7位，128到 255 的字符渐渐变得常用，这些字符以前是空的，是给各个国家自己  “保留使用的”。在美国，这些额外的数字主要用于编码附加符号，比如数学符号，图形元素和常用的重音字符；另一方面，虽然拉丁字符被普遍使用，但在俄罗斯，他们用这些额外的字符表示西里尔字符；而希腊电脑用希腊字母，等等。这些保留下来给每个国家自己安排的空位，对大部分国家都够用。</p><h3 id="4-Unicode"><a href="#4-Unicode" class="headerlink" title="4. Unicode"></a>4. Unicode</h3><p>随着计算机在亚洲兴起，这种做法彻底失效了，中文和日文这样的语言有数千个字符，根本没办法用 8 位来表示所有字符！</p><p>为了解决这个问题，每个国家都发明了多字节编码方案，但不相互兼容。日本人总是碰到编码问题，以至于专门有词来称呼：”mojibake” 意思是 乱码。</p><p>所以 Unicode 诞生了，它是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求， 设计于 1992 年，解决了不同国家不同标准的问题。最常见的Unicode是16位的，有超过一百万个位置，对所有语言的每个字符都够用了。100多种字母表加起来占了12万个位置。还有位置放数学符号，甚至 Emoji。</p><p>就像 ASCII 用二进制来表示字母或是其他格式，比如MP3或GIF，用二进制编码声音/颜色，表示图片、电影、音乐。重要的是，这些标准归根到底就是一长串位，包括短信， YouTube 视频，整个互联网上的每个网页，甚至操作系统，都只不过是一长串的1和0，二进制能表示一切！</p>]]></content>
      
      
      <categories>
          
          <category> ComputerScience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计科03:[布尔代数和逻辑门]</title>
      <link href="/ComputerScience/logic-gate.html"/>
      <url>/ComputerScience/logic-gate.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="布尔逻辑和逻辑门"><a href="#布尔逻辑和逻辑门" class="headerlink" title="布尔逻辑和逻辑门"></a>布尔逻辑和逻辑门</h2><p><a href="https://www.bilibili.com/video/av21376839?p=3" target="_blank" rel="noopener">视频</a></p><h3 id="1-什么是二进制"><a href="#1-什么是二进制" class="headerlink" title="1. 什么是二进制"></a>1. 什么是二进制</h3><p>计算机是最早的机电设备，一般用十进制计数，比如用齿轮数来代表十进制，再到晶体管计算机。</p><a id="more"></a><p>只用 <strong>开/关</strong>两种状态来代表信息，这叫二进制。如果只需表示true和false，两个值就够了。电路闭合，电流流过，代表“真”；电路断开，无电流通过，代表“假”。二进制也可以写成1和0而不是true和false，只是不同的表达方式罢了。</p><p>晶体管的确可以不只是 开/关，还可以让不同大小的电流通过。一些早期电子计算机是三进制的，有 3 种状态，甚至五进制，5 种状态；问题是，状态越多，越难区分信号。如果手机快没电了或者附近有电噪音，比如有人在用微波炉，信号可能会混在一起，而每秒百万次变化的晶体管会让这个问题变得更糟。所以我们把两种信号尽可能分开，只用”开”和”关”两种状态，可以尽可能减少这类问题。</p><h4 id="1-1-布尔代数"><a href="#1-1-布尔代数" class="headerlink" title="1.1 布尔代数"></a>1.1 布尔代数</h4><p>计算机用二进制的另一个原因是有一整个数学分支存在，专门处理“真”和“假”，它已经解决了所有法则和运算，它叫作<strong>“布尔代数”</strong>。</p><p>乔治·布尔（George Boole）是布尔二字的由来，他是一位19 世纪自学成才的英国数学家。他感兴趣用数学式子扩展亚里士多德基于哲学的逻辑方法，布尔用逻辑方程系统而正式的证明真理(truth)。他在1847 年的第一本书”逻辑的数学分析”中介绍过：在”常规“的代数里，是数字，可以进行加法或乘法之类的操作；但在布尔代数中，变量的值是 true 和 false，能进行逻辑操作。</p><h3 id="2-三个基本操作：NOT-AND-OR"><a href="#2-三个基本操作：NOT-AND-OR" class="headerlink" title="2. 三个基本操作：NOT,AND,OR"></a>2. 三个基本操作：NOT,AND,OR</h3><p>布尔代数中三个基本操作：NOT, AND 和 OR，这些操作都非常有用。</p><h4 id="2-1-NOT"><a href="#2-1-NOT" class="headerlink" title="2.1 NOT"></a>2.1 NOT</h4><p>NOT操作把布尔值反转，把true进行NOT就会变成false，反之亦然。</p><p>根据NOT操作的输入和输出，做出如下表</p><p><img src="https://i.loli.net/2020/01/09/xvNyu1V3968ADIo.png" alt="NOT操作输入输出表" style="zoom:67%;"></p><p>使用晶体管可以轻松实现这个逻辑。晶体管只是电控制的开关，有3根线：2根电极和一根控制线。控制线通电时，电流就可以从一个电极流到另一个电极；就像水龙头一样：打开水龙头，水流出，关掉水龙头，就没水了。</p><p>可以把控制线，当做输入，底部的电极，当做输出，所以一个晶体管，就有一个输入和一个输出。当打开输入时，输出也会打开，因为电流可以通过；如果关闭输入，输出也会关闭，因为电流无法通过。用布尔代数来说，输入为真，输出为真；输入为假，输出为假。这个电路没什么意思，因为它没有做什么事情。</p><p>但稍加修改，即可实现NOT，只要把输出放到上面即可。如下图示：</p><p><img src="https://i.loli.net/2020/01/10/U9uAEVl2vkQoIZn.png" alt="NOT_Gate" style="zoom:30%;"></p><ul><li>当打开输入on，电流可以流过然后“接地”，输出就没有电流了，所以输出是off。</li><li>当输入是off，电流没法接地，就流过了输出，所以输出是on。</li></ul><blockquote><p>接地：大地是一个电阻非常低、电容量非常大的物体，拥有吸收无限电荷的能力，而且在吸收大量电荷后仍能保持电位不变 ，故接地后设备其他线路就不会有电流输出。</p></blockquote><p>如上图示叫非门(NOT gate)，之所以叫门，是因为它能控制电流的路径。</p><h4 id="2-2-AND"><a href="#2-2-AND" class="headerlink" title="2.2 AND"></a>2.2 AND</h4><p>AND操作有两个输入，1个输出，如下表所示：</p><table><thead><tr><th>输入</th><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><ul><li>简单记忆：遇假即假，全真即真。</li></ul><p>为了实现与门(AND gate)，需要两个晶体管连在一起，如下图示：</p><p><img src="https://i.loli.net/2020/01/10/A6iUJflcoh8K9aD.png" alt="AND_Gate.png" style="zoom:25%;"></p><p>这样有2个输入和1个输出，如果只打开A，不打开B，电流无法流到output，所以输出是false；如果只打开B，不开A，也一样，电流无法流到output；只有A和B都打开了，output才有电流。</p><h4 id="2-3-OR"><a href="#2-3-OR" class="headerlink" title="2.3 OR"></a>2.3 OR</h4><p>OR操作也有两个输入，1个输出，其中2个输入里1个是true，输出就是true。如下表所示：</p><table><thead><tr><th>输入</th><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><ul><li>遇真即真，全假即假。</li></ul><p>为了实现或门(OR gate)，除了晶体管还要额外的线，不是串联起来，而是并联。如下图示：</p><p><img src="https://i.loli.net/2020/01/10/wtUjeNZcIHFDysC.png" alt="OR_Gate" style="zoom:25%;"></p><p>左边这条线表示电流输入，如果A和B都是OFF，电流就无法通过任意一条线流到输出，所以输出是OFF；如果只打开A，电流可以流过，输出ON；如果只打开B，电流也可以通过，输出ON；只要A或者B是ON，输出就是ON，如果AB都是ON，那么输出自然是ON。</p><h3 id="3-XOR异或"><a href="#3-XOR异或" class="headerlink" title="3. XOR异或"></a>3. XOR异或</h3><p>异或(XOR)，输入相同时输出false，不同才输出true。如下XOR表：</p><p><img src="https://i.loli.net/2020/01/10/tOUph6iIKxTVQlb.png" alt="XOR_table" style="zoom:50%;"></p><p>如果两个输入都是true，或者都是false，那么XOR输出false；如果一个输入为true，另一个为false，那么XOR输出才会是true。</p><ul><li>相同即假，不同才真。</li></ul><p>用晶体管实现异或门(XOR gate)，需使用到前面提到的三种门来做异或门。墙裂推荐配合<a href="https://www.bilibili.com/video/av21376839?p=3" target="_blank" rel="noopener">视频</a>学习理解(时间07:38)。</p><p><img src="https://i.loli.net/2020/01/10/vueRLdVTzGJnqxl.png" alt="XOR_gate" style="zoom:30%;"></p><p>如上图A和B输入两个true，到下方的OR门，输出依然是true，上方第一个AND门输入两个true，输出也是true，然后电流到NOT门，反转电流高低电平，true变成了false，到最后一个AND门就是输入一个false一个true，输出就是false；如此便满足XOR门第一个条件，输入两个true，输出false，以此类推。</p>]]></content>
      
      
      <categories>
          
          <category> ComputerScience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计科02:[电子计算机]</title>
      <link href="/ComputerScience/electronic-computing.html"/>
      <url>/ComputerScience/electronic-computing.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="电子计算机"><a href="#电子计算机" class="headerlink" title="电子计算机"></a>电子计算机</h2><p><a href="https://www.bilibili.com/video/av21376839?p=2" target="_blank" rel="noopener">视频</a></p><h3 id="1-计算机的发展"><a href="#1-计算机的发展" class="headerlink" title="1. 计算机的发展"></a>1. 计算机的发展</h3><p>20世纪初，早期的计算设备都针对特定用途，比如 制表机，大大推进了政府和企业，它们帮助甚至代替了人工，然而人类社会的规模在以前所未有的速度增长。</p><a id="more"></a><p>20世纪上半叶，世界人口几乎翻倍。一战动员7千万人，二战1亿人，全球贸易和运输更加紧密，工程和科学的复杂度也达到新高，我们甚至开始考虑登陆其他行星。</p><p>复杂度的增高导致数据量暴增，人们需要更多自动化、更强的计算能力。很快，柜子大小的计算机变成房间大小，维护费用高且容易出错，而正是这些机器，为未来的创新打下基础。</p><h3 id="2-哈佛Mark1号"><a href="#2-哈佛Mark1号" class="headerlink" title="2. 哈佛Mark1号"></a>2. 哈佛Mark1号</h3><p>最大的机电计算机之一是：哈佛马克一号。</p><p>IBM在1944完成建造，给二战同盟国建造的，它有76万5千个组件，300万个连接点和500英里长的导线。为了保持内部机械装置同步，它有一个50英尺的传动轴，由一个 5 马力的电机驱动。这台机器最早的用途之一 是给”曼哈顿计划”跑模拟，这台机器的大脑是”继电器”。</p><h3 id="3-继电器"><a href="#3-继电器" class="headerlink" title="3. 继电器"></a>3. 继电器</h3><p>继电器是：用电控制的机械开关，继电器里，有根“控制线路”，控制电路是开还是关。”控制线路” 连着一个线圈，当电流流过线圈，线圈产生电磁场，吸引金属臂，从而闭合电路。你可以把继电器想成水龙头，控制线路就是打开水龙头，水会流出来，关闭水龙头，水就没有了。继电器是一样的，只不过控制的是电子  而不是水。这个控制电路可以连到其他电路，比如马达，马达让计数齿轮+1，就像制表机一样。</p><p>不幸的是，继电器内的机械臂是“有质量的“，因此无法快速开关。1940年代一个好的继电器1秒能翻转50次。看起来好像很快，但还不够快，不足以解决复杂的大问题。哈佛马克一号，1秒能做3次加减法运算，一次乘法要花6秒，除法要花15秒，更复杂的操作比如三角函数，可能要一分钟以上。</p><p>除了速度慢，另一个限制就是齿轮磨损，任何会动的机械都会随时间磨损。有些部件会完全损坏，有些则是变黏，变慢，变的不可靠。并且随着继电器数量增加，故障概率也会增加。</p><p>哈佛马克一号有大约3500个继电器，哪怕假设继电器的使用寿命是10年，也意味着平均每天得换一个故障继电器！</p><p>这个问题很严重，因为有些重要运算要运算好几天，而且还有更多其他问题要考虑。</p><h3 id="4-BUG的由来"><a href="#4-BUG的由来" class="headerlink" title="4. BUG的由来"></a>4. BUG的由来</h3><p>这些巨大、黑色、温暖的机器也会吸引昆虫，1947年9月，哈佛马克2型的操作员从故障继电器中，拔出一只死虫。Grace Hopper曾说：”从那时起，每当电脑出了问题，我们就说它出了bug(虫子)“。这就是术语“bug”的来源。</p><h3 id="5-真空管的出现"><a href="#5-真空管的出现" class="headerlink" title="5. 真空管的出现"></a>5. 真空管的出现</h3><p>如果想进一步提高计算能力，我们需要更快更可靠的东西，来替代继电器。</p><p>在1904年，英国物理学家“约翰·安布罗斯·弗莱明”开发了一种新的电子组件，叫“热电子管”，把两个电极装在一个气密的玻璃灯泡里，这就是世上第一个“真空管”。</p><p>其中一个电极可以加热，从而发射电子，这叫“热电子发射”；另一个电极会吸引电子，形成“电龙头”电流。但只有带正电才行，如果带负电荷或中性电荷，电子就无法被吸引，越过真空区域，因此就没有电流。电流只能单向流动的电子部件叫 “二极管”，但是我们需要的是，一个能开关电流的东西。</p><p>不久之后的1906年，美国发明家 “李·德富雷斯特”在“弗莱明”设计的两个电极之间，加入了第三个”控制“电极，向”控制“电极施加正电荷，它会允许电子流动，但如果施加负电荷，它会阻止电子流动。因此通过控制线路，可以断开或闭合电路。和继电器的功能一样，但重要的是，真空管内没有会动的组件，这意味着更少的磨损，更重要的是，每秒可以开闭数千次。</p><p>因此这些”三极真空管”成为了无线电，长途电话以及其他电子设备的基础，持续了接近半个世纪。</p><p>真空管并不完美，它很脆弱，像灯泡一样会烧坏，但比起机械继电器是一次巨大进步。</p><h3 id="6-巨人1号"><a href="#6-巨人1号" class="headerlink" title="6. 巨人1号"></a>6. 巨人1号</h3><p>第一个大规模使用真空管的计算机是“巨人1号”，由工程师Tommy Flowers 设计，完工于1943年12月。</p><p>巨人1号在英国的”布莱切利园”, 用于破解纳粹通信。2 年前 阿兰·图灵也在”布莱切利园”做了台机电装置，叫 “Bombe”，其设计目的是为了纳粹”英格码”通讯加密设备。但Bombe 严格来说不算计算机，后续文章会谈到这个问题。</p><p>巨人1号有 1600 个真空管，总共造了 10 台巨人计算机，来帮助破解密码。巨人被认为是第一个可编程的电子计算机，编程的方法是把几百根电线插入插板，有点像老电话交换机，这是为了让计算机执行正确操作。</p><h3 id="7-第一个可编程计算机“ENIAC”"><a href="#7-第一个可编程计算机“ENIAC”" class="headerlink" title="7. 第一个可编程计算机“ENIAC”"></a>7. 第一个可编程计算机“ENIAC”</h3><p>几年后在 1946 年，在”宾夕法尼亚大学”，电子数值积分计算机 “ENIAC”完成建造。设计者是John Mauchly 和 J. Presper Eckert。这是世上第一个真正的通用、可编程电子计算机。</p><p>ENIAC 每秒可执行 5000 次十位数加减法，它运作了十年，但因为真空管很多，所以故障很常见。ENIAC 运行半天左右就会出一次故障。</p><h3 id="8-晶体管"><a href="#8-晶体管" class="headerlink" title="8. 晶体管"></a>8. 晶体管</h3><p>到 1950 年代，真空管计算机都达到了极限，美国空军的 AN/FSQ-7 计算机于 1955 年完成，是 “SAGE” 防空计算机系统的一部分。为了降低成本和大小，同时提高可靠性和速度，我们需要一种新的电子开关。</p><p>1947 年，贝尔实验室科学家  John Bardeen，Walter Brattain，William Shockley发明了晶体管，一个全新的计算机时代诞生了！</p><p>晶体管的物理学相当复杂，这里不做概述。晶体管就像之前提过的“继电器”和“真空管”，它是一个开关，可以用来控制线路和控制开或关。</p><p>晶体管有两个电极，电极之间有一种材料隔开它们，这种材料有时候导电，有时不导电，这叫“半导体”。控制线连接到一个”门“电极，通过改变 “门” 的电荷，我们可以控制半导体材料的导电性，来允许或不允许 电流流动。</p><p>贝尔实验室的第一个晶体管就展示了巨大的潜力，每秒可以开关 10,000 次，而且，比起玻璃制成，小心易碎的真空管，晶体管是固态的，体型也可远远小于继电器或真空管，导致更小更便宜的计算机。比如1957年发布的IBM 608，第一个完全用晶体管，而且消费者也可以买到的计算机，它有 3000 个晶体管，每秒能执行 4500 次加法，执行 80 次左右的乘除法。IBM 很快把所有产品都转向了晶体管，把晶体管计算机带入办公室，最终引入家庭。</p><p>晶体管不仅小，还超级快，秒可以切换上百万次，并且能工作几十年。</p><h3 id="9-硅谷的典故和英特尔"><a href="#9-硅谷的典故和英特尔" class="headerlink" title="9. 硅谷的典故和英特尔"></a>9. 硅谷的典故和英特尔</h3><p>很多晶体管和半导体的开发在”圣克拉拉谷”，这个地方在加州，位于”旧金山”和”圣荷西”之间，而生产半导体最常见的材料是 “硅”，而生产半导体最常见的材料是 “硅”。</p><p>甚至 William Shockley 都搬了过去，创立了”肖克利半导体”，里面的员工后来成立了”仙童半导体”，这里面的员工后来创立了<strong>英特尔</strong> - 当今世界上最大的计算机芯片制造商。</p>]]></content>
      
      
      <categories>
          
          <category> ComputerScience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计科01:[计算机早期历史]</title>
      <link href="/ComputerScience/early-computing.html"/>
      <url>/ComputerScience/early-computing.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="计算机早期历史"><a href="#计算机早期历史" class="headerlink" title="计算机早期历史"></a>计算机早期历史</h2><p><a href="https://www.bilibili.com/video/av21376839" target="_blank" rel="noopener">视频</a></p><h3 id="1-最早的计算设备：算盘"><a href="#1-最早的计算设备：算盘" class="headerlink" title="1. 最早的计算设备：算盘"></a>1. 最早的计算设备：算盘</h3><p>公认最早的计算设备是算盘，发明于“美索不达米亚”，大约公元前2500年。它是手动计算器，用来帮助加减数字，它存储着当前的计算状态，类似于如今的硬盘。</p><a id="more"></a><p>人们制造算盘是因为社会的规模已经超出个人心算的能力，例如一个村庄可能有上千个人和上万头牛，如此就需要一些计算工具辅助计算。</p><p>算盘有很多变种，最基础的如下所示：</p><p><img src="https://i.loli.net/2020/01/03/Fyp7X5HGhBnaw3u.png" alt="算盘"></p><p>每行代表10的不同次方，最底下一行，一个珠子代表10的0次方，也就是1。再上面一行是10的1次方(也就是10)，再往上就是10的2次方(以此类推)。</p><p>假设最底部的3颗珠子，代表3头牛，那么有4头牛，只需向右移动4个珠子，就能代表7头牛。但如果再有5头牛，那最底行珠子就不够用了。</p><p>所以把所有珠子移回左边，在把第二排的1颗珠子向右移动，代表10头牛，最底行移动2颗珠子，代表2头牛，合计就是12，如此就可以代表12头牛了。</p><p>在接下来4000年，人类发明了各种巧妙的计算设备。比如星盘，让船只可以在海上计算纬度；或计算尺，帮助计算乘法和除法。</p><p>人们还创造了上百种时钟，算日出、潮汐、天体位置，或者纯粹计时。</p><p>这些设备让原先很费力的事变得更快，更简单，也更精准。</p><h3 id="2-Computer从指代职业变成指代机器"><a href="#2-Computer从指代职业变成指代机器" class="headerlink" title="2. Computer从指代职业变成指代机器"></a>2. Computer从指代职业变成指代机器</h3><ul><li>计算机先驱Charles Babbage说过：”随着知识的增长和新工具的诞生，人工劳力会越来越少。“</li></ul><p>最早使用“计算机”一词的文献来自1613年的一本书，作者Richard Braithwait，但当时指的不是机器，而是一种职业。Braithwait 说：“我听说过的计算者里最厉害的，能把好几天的工作量大大缩减。”</p><p>那时，“Computer”指负责计算的人，“Computer”偶尔会用机器帮忙，但大部分时候靠自己。</p><p>这个职位一直到1800年代还存在，之后“Computer”逐渐开始代表机器。</p><h3 id="3-步进计算器"><a href="#3-步进计算器" class="headerlink" title="3. 步进计算器"></a>3. 步进计算器</h3><p>“步进计算器”，由德国博学家 戈特弗里德·莱布尼茨 建造于 1694 年。</p><p>莱布尼茨说过 “… 让优秀的人浪费时间算数简直侮辱尊严，农民用机器能算得一样准”。</p><p>步进计算器有点像汽车里的里程表，不断累加里程数，它有一连串可以转动的齿轮，每个齿轮有十个齿，代表数字0到9，每当一个齿轮转过 9，它会转回 0，同时让旁边的齿轮前进 1 个齿，就像算盘超过 10 一样。做减法时，机器会反向运作。</p><p>利用一些巧妙的机械结构，步进计算器也能做到乘法和除法。举例：17除以5，只要减5，减5，再减5，直到不能再减5，就知道了17=5x3+2。</p><p>步进计算器可以自动完成这种操作，它是第一台能做到“加减乘除”全部四种运算的机器，它的设计非常成功，以至于沿用了3个世纪。</p><h3 id="4-查表测距"><a href="#4-查表测距" class="headerlink" title="4. 查表测距"></a>4. 查表测距</h3><p>不幸的是，即使有机械计算器，很多现实问题，仍然需要很多步，计算一个结果可能要几小时甚至几天。而且这些手工制作的机器非常昂贵，大部分人买不起。</p><p>所以在20世纪以前，大部分人会用预先算好的计算表，这些计算表由之前说的“人力计算器”编撰。如果你想知道867,5309的平方根，只需要再表中查找即可找到答案。</p><h3 id="5-差分机"><a href="#5-差分机" class="headerlink" title="5. 差分机"></a>5. 差分机</h3><p>Charles Babbage 在 1822 年写了一篇论文，向皇家天文学会指出了这个问题，标题叫：”机械在天文与计算表中的应用“。</p><p>Charles Babbage 提出了一种新型机械装置叫 “差分机”，一个更复杂的机器，能近似多项式。多项式描述了几个变量之间的关系，也可用于近似对数和三角函数。</p><p>Charles Babbage 在 1823 年开始建造差分机，并在接下来二十年，视图制造和组装25000个零件，总重接近15吨，不幸的是，该项目最终放弃了。</p><p>但在1991年，历史学家根据Charles Babbage 的草稿做了一个差分机，而且可以运行。</p><p>更重要的是，在差分机的建造期间，Charles Babbage 构想了一个更复杂的机器 - 分析机。</p><h3 id="6-分析机"><a href="#6-分析机" class="headerlink" title="6. 分析机"></a>6. 分析机</h3><p>不像差分机，步进计算器和以前的其他计算设备，分析机是“通用计算机”，它可以做很多事情，不只是一种特定运算。甚至可以给它数据，然后按顺序执行一系列操作。它有内存，甚至一个很原始的打印机，就像差分机一样，这台机器太超前了，所以没能键成。然而，这种“自动计算机”的概念思想：计算机可以自动完成一些操作。是个跨时代的概念，预示着计算机程序的诞生。</p><p>英国数学家 Ada Lovelace 给分析机写了假想的程序，她说：“未来会诞生一门全新的，强大的，专为分析所用的语言”，因此Ada被认为是世上第一位程序员。</p><p>分析机激励了第一代计算机科学家，这些计算机科学家把很多 Charles Babbage 的点子融入到他们的机器，<strong>所以Charles Babbage 经常被认为是 “计算之父”</strong>。</p><h3 id="7-打孔机"><a href="#7-打孔机" class="headerlink" title="7. 打孔机"></a>7. 打孔机</h3><p>到了19世纪末，为了解决人口普查耗时太长的问题，美国人口普查找了Herman Hollerith，他发明了打孔卡片制表机。他的机器是“电动机械的”，用传统机械来计数，结构类似莱布尼茨的乘法器，但用电动结构连接其他组件。Hollerith 的机器用打孔卡，一种纸卡，上面有网格，用打孔来表示数据。Hollerith 的机器速度是手动的 10 倍左右！</p><p>企业开始意识到计算机的价值，可以提升劳动力以及数据密集型任务，来提升利润。为了满足这一需求，Hollerith 成立了制表机器公司。这家公司后来在1924年与其他机械制造商合并，成为了“国际商业机器公司”，<strong>简称IBM。</strong></p>]]></content>
      
      
      <categories>
          
          <category> ComputerScience </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计科历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客添加live2d动态模型插件</title>
      <link href="/Other/Live2D.html"/>
      <url>/Other/Live2D.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>live2d动态模型插件是一款非常有意思的插件。</p><p>使用和安装<code>helper-live2d</code>动态插件，需具备以下前提条件：</p><a id="more"></a><ol><li>hexo博客，没有搭建的可以看我以前的文章《<a href="https://zero6996.github.io/2018/12/04/Other/hexo-git搭建个人博客/" target="_blank" rel="noopener">hexo+git搭建hexo个人博客</a>》</li><li>Node.js环境和npm</li><li>插件Github地址：<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a></li><li>live2d模型仓库地址：<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">live2d-widget-models</a>以及部分模型<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">预览网址</a></li></ol><h3 id="1-安装模块"><a href="#1-安装模块" class="headerlink" title="1. 安装模块"></a>1. 安装模块</h3><p>在hexo跟目录执行命令</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">cnpm install --save hexo-helper-live2d</code></pre><h3 id="2-下载模型"><a href="#2-下载模型" class="headerlink" title="2. 下载模型"></a>2. 下载模型</h3><p>可先查看模型预览：<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">hexo live2d插件 2.0</a></p><h4 id="2-1-安装模型"><a href="#2-1-安装模型" class="headerlink" title="2.1 安装模型"></a>2.1 安装模型</h4><p>使用<code>npm install {packagename}</code>安装单独模型，包名称列表如下：</p><ul><li><code>live2d-widget-model-chitose</code></li><li><code>live2d-widget-model-epsilon2_1</code></li><li><code>live2d-widget-model-gf</code></li><li><code>live2d-widget-model-haru/01</code>（使用<code>npm install --save live2d-widget-model-haru</code>）</li><li><code>live2d-widget-model-haru/02</code>（使用<code>npm install --save live2d-widget-model-haru</code>）</li><li><code>live2d-widget-model-haruto</code></li><li><code>live2d-widget-model-hibiki</code></li><li><code>live2d-widget-model-hijiki</code></li><li><code>live2d-widget-model-izumi</code></li><li><code>live2d-widget-model-koharu</code></li><li><code>live2d-widget-model-miku</code></li><li><code>live2d-widget-model-ni-j</code></li><li><code>live2d-widget-model-nico</code></li><li><code>live2d-widget-model-nietzsche</code></li><li><code>live2d-widget-model-nipsilon</code></li><li><code>live2d-widget-model-nito</code></li><li><code>live2d-widget-model-shizuku</code></li><li><code>live2d-widget-model-tororo</code></li><li><code>live2d-widget-model-tsumiki</code></li><li><code>live2d-widget-model-unitychan</code></li><li><code>live2d-widget-model-wanko</code></li><li><code>live2d-widget-model-z16</code></li></ul><p>举例本人安装的模型：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">cnpm install live2d-widget-model-tororo</code></pre><h3 id="3-进行详细配置"><a href="#3-进行详细配置" class="headerlink" title="3. 进行详细配置"></a>3. 进行详细配置</h3><p>在Hexo的<code>_config.yml</code>文件下或主题的<code>_config.yml</code>文件中均可配置：</p><p>配置API查看：<a href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" target="_blank" rel="noopener">live2d-widget.js API</a></p><h4 id="3-1-API配置"><a href="#3-1-API配置" class="headerlink" title="3.1 API配置"></a>3.1 API配置</h4><p>本人博客配置文件如下</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-yml"># Live 2D settings## 插件github地址：https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d## API网址：https:&#x2F;&#x2F;l2dwidget.js.org&#x2F;docs&#x2F;class&#x2F;src&#x2F;index.js~L2Dwidget.html#instance-method-initlive2d:    enable: true  scriptFrom: local # 默认  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径  # scriptFrom: jsdelivr # jsdelivr CDN  # scriptFrom: unpkg # unpkg CDN  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中  debug: true # 调试, 是否在控制台输出日志  model:    use: live2d-widget-model-tororo # npm-module package name    # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名    # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径    # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url  display:    position: right    width: 145    height: 315  mobile:    show: true # 是否在移动设备上显示    scale: 0.5 # 移动设备上的缩放         react:    opacityDefault: 0.7    opacityOnHover: 0.8</code></pre><blockquote><p>本文内容参考摘录自文章<a href="https://joeybling.github.io/2019/05/05/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0helper-live2d%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">Hexo博客添加helper-live2d动态模型插件</a>，欢迎大家关注该作者。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Live2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/Other/git-basic.html"/>
      <url>/Other/git-basic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Git简介"><a href="#1-Git简介" class="headerlink" title="1. Git简介"></a>1. Git简介</h2><p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>。</p><a id="more"></a><p>Linus大神为了解决Linux代码管理问题，在2005年花费两周时间用C编写了Git，此后迅速成为最流行的分布式版本控制系统。2008年，GitHub网站上线，它为开源项目免费提供Git存储，无数开源项目迁移至GitHub。</p><blockquote><p>本文仅做Git最基本操作的学习，方便速查。详细教程请看廖雪峰<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></p></blockquote><h3 id="1-1-安装Git"><a href="#1-1-安装Git" class="headerlink" title="1.1 安装Git"></a>1.1 安装Git</h3><p><a href="https://git-scm.com/" target="_blank" rel="noopener">进入官网</a>下载Git安装包，直接默认安装即可。</p><p>打开CMD，输入git，测试是否安装成功。</p><h2 id="2-远程仓库"><a href="#2-远程仓库" class="headerlink" title="2. 远程仓库"></a>2. 远程仓库</h2><p>使用远程仓库，需要先配置SSH。</p><h3 id="2-1-配置SSH"><a href="#2-1-配置SSH" class="headerlink" title="2.1 配置SSH"></a>2.1 配置SSH</h3><p>SSH用于身份验证，我们首先需要生成一个SSH密钥，然后添加到GitHub中。</p><ol><li>打开Git Bash</li><li>输入以下命令生成一个ssh密钥：<code>ssh-keygen -t rsa -C &#39;your email@example.com&#39;</code>，一般情况下无需设置，一路回车就行。</li><li>输入命令<code>cd ~/.ssh/</code>，进入ssh文件夹。里面有两个文件，<code>id_rsa</code>和<code>id_rsa.pub</code>，这两个就是SSH Key的密钥对。其中<code>id_rsa</code>是私钥，不能泄露！<code>id_rsa.pub</code>是公钥，可以公开使用。</li><li>将SSH公钥复制到剪贴板：<code>clip &lt; ~/.ssh/id_rsa.pub</code></li><li>登录GitHub，右上角点击个人头像，然后点击<code>settings</code>进入设置界面。</li><li>点击<code>SSH and GPG keys</code>，然后点击<code>New SSH key</code>，填上任意title，在Key文本框内粘贴<code>id_rsa.pub</code>文件的内容，点击<code>Add Key</code>，就成功添加SSH key了！</li></ol><h3 id="2-2-克隆远程仓库"><a href="#2-2-克隆远程仓库" class="headerlink" title="2.2 克隆远程仓库"></a>2.2 克隆远程仓库</h3><p>首先需要在GitHub创建一个仓库，直接点击<code>New repository</code>，然后根据提示即可创建仓库。接下来我们将远程仓库克隆到本地，进行操作。</p><ol><li>打开GitHub仓库界面，点击右边的<code>clone or download</code>，选择SSH方式，复制仓库地址。</li><li>打开Git Bash</li><li>输入<code>git git@github.com:zero6996/Learn_Git.git</code>，即可将远程仓库克隆到本地。</li></ol><h2 id="3-Git基本操作"><a href="#3-Git基本操作" class="headerlink" title="3. Git基本操作"></a>3. Git基本操作</h2><ul><li><p>初始化git，将当前文件夹交由git管理：<code>git init</code></p></li><li><p>查看当前分支状态：<code>git status</code></p></li><li>提交到暂存区：<code>git add &lt;file&gt;</code></li><li>提交到仓库：<code>git commit file -m &quot;message&quot;</code></li></ul><h3 id="3-1-配置用户信息"><a href="#3-1-配置用户信息" class="headerlink" title="3.1 配置用户信息"></a>3.1 配置用户信息</h3><ul><li>配置全局用户信息：<code>git config --system user.email youremail@email.com</code></li><li>配置当前用户信息：<code>git config --global user.name yourname</code></li></ul><blockquote><p>用户配置文件在<code>.git/config</code></p></blockquote><h3 id="3-2-查看日志"><a href="#3-2-查看日志" class="headerlink" title="3.2 查看日志"></a>3.2 查看日志</h3><ul><li>查看当前工作日志：<code>git log</code></li><li>查看历史工作日志：<code>git reflog</code></li><li>查看更改日志：<code>git diff</code></li></ul><h3 id="3-3-回退版本"><a href="#3-3-回退版本" class="headerlink" title="3.3 回退版本"></a>3.3 回退版本</h3><ul><li>退回到上N个版本：<code>git reset --hard HEAD^</code>，一个<code>^</code>代表退回一个版本，以此类推。</li></ul><blockquote><p>HEAD指向的版本就是当前版本</p></blockquote><ul><li>退回到指定版本：<code>git reset --hard commit_id</code>，<code>commit_id</code>是指定版本号，举例<code>git reset --hard cbc5fdb</code>。</li></ul><h3 id="3-4-文件操作"><a href="#3-4-文件操作" class="headerlink" title="3.4 文件操作"></a>3.4 文件操作</h3><ul><li>移动文件：<code>git mv movefile_name targetdir/</code></li><li>删除文件：<code>git rm filename</code>，如果该文件已提交到版本库中，则直接删除版本库中文件。</li></ul><h2 id="4-分支管理"><a href="#4-分支管理" class="headerlink" title="4. 分支管理"></a>4. 分支管理</h2><h3 id="4-1-分支基本操作"><a href="#4-1-分支基本操作" class="headerlink" title="4.1 分支基本操作"></a>4.1 分支基本操作</h3><ul><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch &lt;name&gt;</code></li><li>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></li><li>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或<code>git switch -c &lt;name&gt;</code></li><li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li><li>删除分支：<code>git branch -d &lt;name&gt;</code></li></ul><h2 id="5-标签管理"><a href="#5-标签管理" class="headerlink" title="5. 标签管理"></a>5. 标签管理</h2><p>标签可以用于给版本库中的版本打标记，方便版本管理。</p><ul><li>命令 <code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit_id。</li><li>命令 <code>git tag -a &lt;tagname&gt; -m &#39;message...</code>可以指定标签信息。</li><li><p>命令<code>git tag</code> 可以查看所有标签。</p></li><li><p>命令 <code>git push origin &lt;tagname&gt;</code> 可以推送一个本地标签到远程</p></li><li>命令 <code>git push origin --tags</code>可以推送本地全部未推送的标签到远程</li><li>命令 <code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签</li><li>命令 <code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li></ul>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合Demo</title>
      <link href="/FrameWork/SSM.html"/>
      <url>/FrameWork/SSM.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-SSM整合项目"><a href="#1-SSM整合项目" class="headerlink" title="1. SSM整合项目"></a>1. SSM整合项目</h2><h3 id="1-1-搭建环境"><a href="#1-1-搭建环境" class="headerlink" title="1.1 搭建环境"></a>1.1 搭建环境</h3><a id="more"></a><ul><li>SSM整合可以使用多种方式，这里选择XML+注解的方式</li><li>整合思路<ul><li>先搭建整合环境</li><li>把Spring的配置搭建完成</li><li>使用Spring整合SpringMVC框架</li><li>最后使用Spring整合MyBatis框架</li></ul></li></ul><h3 id="1-2-基本环境"><a href="#1-2-基本环境" class="headerlink" title="1.2 基本环境"></a>1.2 基本环境</h3><ul><li>创建数据库表和表结构</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">create database ssm01;use ssm01;create table account(id int primary key auto_increment,name varchar(100),money double);</code></pre><ul><li>创建一个Maven工程，在pom.xml文件中引入坐标依赖</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;    &lt;!--设置版本锁定--&gt;    &lt;spring.version&gt;5.0.2.RELEASE&lt;&#x2F;spring.version&gt;    &lt;slf4j.version&gt;1.6.6&lt;&#x2F;slf4j.version&gt;    &lt;log4j.version&gt;1.2.12&lt;&#x2F;log4j.version&gt;    &lt;mysql.version&gt;5.1.6&lt;&#x2F;mysql.version&gt;    &lt;mybatis.version&gt;3.4.5&lt;&#x2F;mybatis.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt;    &lt;!-- spring --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.6.8&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt;        &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;        &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;        &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;        &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;        &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;        &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;        &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;        &lt;version&gt;4.12&lt;&#x2F;version&gt;        &lt;scope&gt;compile&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;        &lt;version&gt;${mysql.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.5&lt;&#x2F;version&gt;        &lt;scope&gt;provided&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.0&lt;&#x2F;version&gt;        &lt;scope&gt;provided&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;jstl&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.2&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!-- log start --&gt;    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;        &lt;version&gt;${log4j.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;${slf4j.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;        &lt;version&gt;${slf4j.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!-- log end --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;        &lt;version&gt;${mybatis.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.3.0&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;        &lt;version&gt;0.9.1.2&lt;&#x2F;version&gt;        &lt;type&gt;jar&lt;&#x2F;type&gt;        &lt;scope&gt;compile&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre><ul><li>创建基础环境，具体如下图所示：</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/09/06/ssm01-1567700025391.jpg" alt="ssm01"></p><ul><li>AccountDao代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 账户dao接口 *&#x2F;public interface AccountDao {    &#x2F;**     * 查询所有用户     * @return     *&#x2F;    public List&lt;Account&gt; findAll();    &#x2F;**     * 保存账户     * @param account     *&#x2F;    public void SaveAccount(Account account);}</code></pre><ul><li>Account实体类代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 账户类 *&#x2F;public class Account implements Serializable {    private Integer id;    private String name;    private Double money;}</code></pre><ul><li>业务层代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class AccountServiceImpl implements AccountService {    @Override    public List&lt;Account&gt; findAll() {        System.out.println(&quot;业务层：查询所有账户....&quot;);        return null;    }    @Override    public void SaveAccount(Account account) {        System.out.println(&quot;业务层：保存账户....&quot;);    }}</code></pre><h2 id="2-Spring框架代码编写"><a href="#2-Spring框架代码编写" class="headerlink" title="2. Spring框架代码编写"></a>2. Spring框架代码编写</h2><h3 id="2-1-搭建和测试Spring开发环境"><a href="#2-1-搭建和测试Spring开发环境" class="headerlink" title="2.1 搭建和测试Spring开发环境"></a>2.1 搭建和测试Spring开发环境</h3><ul><li>在resources项目中创建applicationContext.xml配置文件，编写具体的配置信息。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;       xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;       xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;    &lt;!-- 开启注解扫描，要扫描的是service和dao层的注解        要忽略web层注解，因为web层让SpringMVC框架去管理 --&gt;    &lt;context:component-scan base-package=&quot;com.zero&quot;&gt;        &lt;!-- 配置要忽略的注解 --&gt;        &lt;context:exclude-filter type=&quot;annotation&quot;                             expression=&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;    &lt;&#x2F;context:component-scan&gt;&lt;&#x2F;beans&gt;</code></pre><ul><li>编写一个测试方法进行测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class TestSpring {    @Resource(name = &quot;accountService&quot;)    private AccountService accountService;    @Test    public void test1(){        accountService.findAll();        accountService.SaveAccount(new Account());    }}</code></pre><h2 id="3-Spring整合SpringMVC框架"><a href="#3-Spring整合SpringMVC框架" class="headerlink" title="3. Spring整合SpringMVC框架"></a>3. Spring整合SpringMVC框架</h2><h3 id="3-1-搭建和测试SpringMVC的开发环境"><a href="#3-1-搭建和测试SpringMVC的开发环境" class="headerlink" title="3.1 搭建和测试SpringMVC的开发环境"></a>3.1 搭建和测试SpringMVC的开发环境</h3><ul><li>在web.xml中配置DispatcherServlet前端控制器，中文乱码过滤器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt;  &lt;!--配置DispatcherServlet前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;    &lt;!--配置初始化参数，创建完dispatcherServlet对象后加载springMVC.xml配置文件--&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;      &lt;param-value&gt;classpath:springMVC.xml&lt;&#x2F;param-value&gt;    &lt;&#x2F;init-param&gt;    &lt;!--服务器启动时，就让dispatcherServlet对象创建--&gt;    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;  &lt;&#x2F;servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt;    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;  &lt;&#x2F;servlet-mapping&gt;  &lt;!-- 配置解决中文乱码的过滤器 --&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;      &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;    &lt;&#x2F;init-param&gt;  &lt;&#x2F;filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;  &lt;&#x2F;filter-mapping&gt;&lt;&#x2F;web-app&gt;</code></pre><ul><li>创建springMVC.xml配置文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:mvc=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;       xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;    &lt;!--扫描controller的注解，别的不用扫描--&gt;    &lt;context:component-scan base-package=&quot;com.zero.controller&quot;&gt;        &lt;!-- 配置包含的注解 --&gt;        &lt;context:include-filter type=&quot;annotation&quot;                                expression=&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt;    &lt;&#x2F;context:component-scan&gt;    &lt;!--配置视图解析器--&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!--配置前后缀--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;&quot; &#x2F;&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!--设置静态资源不过滤--&gt;    &lt;mvc:resources mapping=&quot;&#x2F;css&#x2F;**&quot; location=&quot;&#x2F;css&#x2F;&quot;&#x2F;&gt;    &lt;mvc:resources mapping=&quot;&#x2F;images&#x2F;**&quot; location=&quot;&#x2F;images&#x2F;&quot;&#x2F;&gt;    &lt;mvc:resources mapping=&quot;&#x2F;js&#x2F;**&quot; location=&quot;&#x2F;js&#x2F;&quot;&#x2F;&gt;    &lt;!--开启对SpringMVC的注解支持--&gt;    &lt;mvc:annotation-driven&#x2F;&gt;&lt;&#x2F;beans&gt;</code></pre><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;account&quot;)public class AccountController {    @RequestMapping(&quot;&#x2F;findAll&quot;)    public String findAll(){        System.out.println(&quot;表现层：查询所有用户....&quot;);        return &quot;list&quot;;    }}</code></pre><ul><li>jsp：<code>&lt;a href=&quot;/account/findAll&quot;&gt;查询所有用户&lt;/a&gt;</code></li></ul><h3 id="3-2-Spring整合SpringMVC的框架"><a href="#3-2-Spring整合SpringMVC的框架" class="headerlink" title="3.2 Spring整合SpringMVC的框架"></a>3.2 Spring整合SpringMVC的框架</h3><ul><li>目的：能在controller中成功调用service对象中的方法，查询数据。</li><li>在项目启动时，就去加载applicationContext.xml的配置文件，在web.xml中配置<code>ContextLoaderListener</code>监听器（该监听器默认只能加载WEB-INF目录下的applicationContext.xml的配置文件）。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--配置Spring提供的监听器，用于启动服务器时加载容器--&gt;&lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;&lt;&#x2F;listener&gt;&lt;!--手动指定springMVC配置文件位置--&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;&lt;&#x2F;context-param&gt;</code></pre><ul><li>修改控制器代码，注入service属性，调用方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java"> @Controller@RequestMapping(&quot;account&quot;)public class AccountController {    &#x2F;&#x2F; 注入service对象    @Autowired    private AccountService accountService;    @RequestMapping(&quot;&#x2F;findAll&quot;)    public String findAll(){        System.out.println(&quot;表现层：查询所有用户....&quot;);        &#x2F;&#x2F; 调用service的方法        accountService.findAll();        return &quot;list&quot;;    }}</code></pre><ul><li>测试结果</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">表现层：查询所有用户....业务层：查询所有账户....</code></pre><h2 id="4-Spring整合MyBatis框架"><a href="#4-Spring整合MyBatis框架" class="headerlink" title="4. Spring整合MyBatis框架"></a>4. Spring整合MyBatis框架</h2><h3 id="4-1-搭建和测试MyBatis的环境"><a href="#4-1-搭建和测试MyBatis的环境" class="headerlink" title="4.1 搭建和测试MyBatis的环境"></a>4.1 搭建和测试MyBatis的环境</h3><ul><li>在resources资源文件夹下创建SqlMapConfig.xml的配置文件，编写核心配置文件。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;!--MyBatis核心配置文件--&gt;&lt;configuration&gt;    &lt;!--配置数据库环境--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&#x2F;&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;ssm01&quot;&#x2F;&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt;                &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt;            &lt;&#x2F;dataSource&gt;        &lt;&#x2F;environment&gt;    &lt;&#x2F;environments&gt;    &lt;!-- 引入映射配置文件，这里使用的是注解方式 --&gt;    &lt;mappers&gt;        &lt;!--&lt;mapper class=&quot;com.zero.dao.AccountDao&quot;&#x2F;&gt;--&gt;        &lt;!-- 该包下所有的dao接口都可以使用 --&gt;        &lt;package name=&quot;com.zero.dao&quot;&#x2F;&gt;    &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt;</code></pre><ul><li>使用注解方式进行SQL语句编写</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 账户dao接口 *&#x2F;@Resourcepublic interface AccountDao {    &#x2F;**     * 查询所有用户     * @return     *&#x2F;    @Select(&quot;select * from account&quot;)    public List&lt;Account&gt; findAll();    &#x2F;**     * 保存账户     * @param account     *&#x2F;    @Insert(&quot;insert into account (name,money) values(#{name},#{money})&quot;)    public void SaveAccount(Account account);}</code></pre><ul><li>编写测试方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class TestMyBatis {    &#x2F;**     * 测试查询     * @throws Exception     *&#x2F;    @Test    public void test1() throws Exception {        &#x2F;&#x2F; 加载配置文件        InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        &#x2F;&#x2F; 创建工厂        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);        &#x2F;&#x2F; 创建sqlSession对象        SqlSession session = factory.openSession();        &#x2F;&#x2F; 获取代理对象        AccountDao dao = session.getMapper(AccountDao.class);        List&lt;Account&gt; list = dao.findAll();        for (Account account:list){            System.out.println(account);        }        &#x2F;&#x2F; 释放资源        session.close();        inputStream.close();    }    &#x2F;**     * 测试保存     * @throws Exception     *&#x2F;    @Test    public void test2() throws Exception {        Account account = new Account();        account.setName(&quot;小黑&quot;);        account.setMoney(400d);        &#x2F;&#x2F; 加载配置文件        InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        &#x2F;&#x2F; 创建工厂        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);        &#x2F;&#x2F; 创建sqlSession对象        SqlSession session = factory.openSession();        &#x2F;&#x2F; 获取代理对象        AccountDao dao = session.getMapper(AccountDao.class);        dao.SaveAccount(account);        &#x2F;&#x2F; 提交事务        session.commit();        &#x2F;&#x2F; 释放资源        session.close();        inputStream.close();    }}</code></pre><h3 id="4-2-Spring整合MyBatis框架"><a href="#4-2-Spring整合MyBatis框架" class="headerlink" title="4.2 Spring整合MyBatis框架"></a>4.2 Spring整合MyBatis框架</h3><ul><li>目的：把SqlMapConfig.xml配置文件配置到Spring的配置文件中。</li></ul><h4 id="4-2-1-让Spring接管MyBatis的Session工厂"><a href="#4-2-1-让Spring接管MyBatis的Session工厂" class="headerlink" title="4.2.1 让Spring接管MyBatis的Session工厂"></a>4.2.1 让Spring接管MyBatis的Session工厂</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--spring整合MyBatis框架--&gt;&lt;!--配置c3p0连接池--&gt;&lt;bean id=&quot;DataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;    &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;ssm01&quot;&#x2F;&gt;    &lt;property name=&quot;user&quot; value=&quot;root&quot;&#x2F;&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--配置SqlSessionFactory工厂--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;DataSource&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><h4 id="4-2-2-配置自动扫描所有Mapper接口和文件"><a href="#4-2-2-配置自动扫描所有Mapper接口和文件" class="headerlink" title="4.2.2 配置自动扫描所有Mapper接口和文件"></a>4.2.2 配置自动扫描所有Mapper接口和文件</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--配置AccountDao接口所在包--&gt;&lt;!-- 引入映射配置文件--&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.zero.dao&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><h4 id="4-2-4-测试"><a href="#4-2-4-测试" class="headerlink" title="4.2.4 测试"></a>4.2.4 测试</h4><ul><li>在AccountDao接口上添加注解</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 账户dao接口 *&#x2F;@Repositorypublic interface AccountDao {}</code></pre><ul><li>在service层调用Dao</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Service(&quot;accountService&quot;) &#x2F;&#x2F; 将service交由IOC容器管理public class AccountServiceImpl implements AccountService {    &#x2F;&#x2F; 注入Dao接口    @Autowired    private AccountDao accountDao;    @Override    public List&lt;Account&gt; findAll() {        System.out.println(&quot;业务层：查询所有账户....&quot;);        &#x2F;&#x2F; 调用dao查询        return accountDao.findAll();    }    @Override    public void SaveAccount(Account account) {        System.out.println(&quot;业务层：保存账户....&quot;);        accountDao.SaveAccount(account);    }}</code></pre><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;account&quot;)public class AccountController {    &#x2F;&#x2F; 注入service对象    @Autowired    private AccountService accountService;    @RequestMapping(&quot;&#x2F;findAll&quot;)    public String findAll(Model model){        System.out.println(&quot;表现层：查询所有用户....&quot;);        &#x2F;&#x2F; 调用service的方法        List&lt;Account&gt; list = accountService.findAll();        model.addAttribute(&quot;list&quot;,list); &#x2F;&#x2F; 存入request域        return &quot;list&quot;;    }}</code></pre><ul><li><code>list.jsp</code>页面</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户列表&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h3&gt;用户列表&lt;&#x2F;h3&gt;&lt;c:forEach items=&quot;${list}&quot; var=&quot;account&quot;&gt;    用户姓名：${account.name}&lt;br&gt;    余额：${account.money}&lt;br&gt;&lt;&#x2F;c:forEach&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4 id="4-2-5-配置Spring的声明式事务管理"><a href="#4-2-5-配置Spring的声明式事务管理" class="headerlink" title="4.2.5 配置Spring的声明式事务管理"></a>4.2.5 配置Spring的声明式事务管理</h4><ul><li>在<code>applicationContext.xml</code>中配置事务</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--3. 配置Spring框架声明式事务管理--&gt;&lt;!--3.1 配置事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;DataSource&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--3.2 配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;&#x2F;&gt;        &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot;&#x2F;&gt;    &lt;&#x2F;tx:attributes&gt;&lt;&#x2F;tx:advice&gt;&lt;!--3.3 配置AOP增强--&gt;&lt;aop:config&gt;    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.zero.service.Impl.*ServiceImpl.*(..))&quot;&#x2F;&gt;&lt;&#x2F;aop:config&gt;</code></pre><ul><li>控制器新增保存用户方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 保存用户     * @param account     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;save&quot;)public String save(Account account){    System.out.println(&quot;表现层：保存用户....&quot;);    accountService.SaveAccount(account);    return &quot;redirect:findAll&quot;;}</code></pre><ul><li><code>index.jsp</code>中添加代码，提交用户表单</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;保存用户&lt;&#x2F;h3&gt;&lt;form action=&quot;&#x2F;account&#x2F;save&quot; method=&quot;post&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;    金额：&lt;input type=&quot;text&quot; name=&quot;money&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;&#x2F;form&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC学习2</title>
      <link href="/FrameWork/SpringMVC-Response-Data.html"/>
      <url>/FrameWork/SpringMVC-Response-Data.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-响应数据和结果视图"><a href="#1-响应数据和结果视图" class="headerlink" title="1. 响应数据和结果视图"></a>1. 响应数据和结果视图</h2><h3 id="1-1-返回值分类"><a href="#1-1-返回值分类" class="headerlink" title="1.1 返回值分类"></a>1.1 返回值分类</h3><a id="more"></a><h4 id="1-1-1-字符串"><a href="#1-1-1-字符串" class="headerlink" title="1.1.1 字符串"></a>1.1.1 字符串</h4><p>Controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 返回值是字符串@RequestMapping(&quot;&#x2F;testString&quot;)public String testString(Model model){    System.out.println(&quot;testString方法执行了...&quot;);    &#x2F;&#x2F; 模拟从数据库中查询出User对象    User user = new User(&quot;小明&quot;, &quot;123&quot;, 22);    &#x2F;&#x2F; 使用model传递数据    model.addAttribute(&quot;user&quot;,user);    return &quot;success&quot;; &#x2F;&#x2F; 指定逻辑视图名，经过视图解析器解析为jsp物理路径：&#x2F;WEB-INF&#x2F;pages&#x2F;success.jsp}</code></pre><h4 id="1-1-2-void"><a href="#1-1-2-void" class="headerlink" title="1.1.2 void"></a>1.1.2 void</h4><p>上篇文章中学到Servlet原始API可以作为控制器中方法的参数：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RequestMapping(&quot;&#x2F;testReturnVoid&quot;)public void testReturnVoid(HttpServletRequest request,HttpServletResponse response)throws Exception {    xxx}</code></pre><p>所以就可以在controller方法形参上可以定义request和response，使用request或response指定响应结果</p><ul><li>使用request跳转页面：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 通过request跳转页面     * @param request     * @param response     * @throws Exception     *&#x2F;@RequestMapping(&quot;&#x2F;testForward&quot;)public void testForward(HttpServletRequest request,                        HttpServletResponse response) throws Exception {    System.out.println(&quot;testForward方法执行了...&quot;);    request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;success.jsp&quot;).forward(request,response);}</code></pre><ul><li>通过response重定向页面：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 通过response重定向页面     * @param request     * @param response     * @throws Exception     *&#x2F;@RequestMapping(&quot;&#x2F;testRedirect&quot;)public void testRedirect(HttpServletRequest request,                         HttpServletResponse response) throws Exception {    System.out.println(&quot;testRedirect方法执行了...&quot;);    response.sendRedirect(&quot;testString&quot;); &#x2F;&#x2F; 重定向到返回字符串页面}</code></pre><ul><li>通过response指定响应结果：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java"> &#x2F;**     * 通过 response 指定响应结果     * @param request     * @param response     * @throws Exception     *&#x2F;@RequestMapping(&quot;&#x2F;testReturnJson&quot;)public void testReturnJson(HttpServletRequest request,                           HttpServletResponse response) throws Exception {    System.out.println(&quot;testReturnJson方法执行了...&quot;);    &#x2F;&#x2F; 解决中文乱码问题    response.setCharacterEncoding(&quot;utf-8&quot;);    response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);    response.getWriter().write(&quot;响应json串&quot;);}</code></pre><h4 id="1-1-3-ModelAndView"><a href="#1-1-3-ModelAndView" class="headerlink" title="1.1.3 ModelAndView"></a>1.1.3 ModelAndView</h4><ul><li>ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。</li></ul><p>该对象中有两个主要方法</p><ul><li>ModelAndView addObject(String,Object)：添加模型到ModelMap对象中。</li><li><p>void serViewName(String)：用于设置逻辑视图名称，视图解析器会根据名称前往指定视图。</p></li><li><p>示例代码</p><ul><li>控制器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;**       * 返回ModelAndView       * @return       *&#x2F;  @RequestMapping(&quot;&#x2F;testReturnModelAndView&quot;)  public ModelAndView testReturnModelAndView(){      ModelAndView modelAndView = new ModelAndView();      &#x2F;&#x2F; 将user对象存入到modelAndView对象中，底层会把user对象存入request域中      modelAndView.addObject(&quot;user&quot;,new User(&quot;小张&quot;,&quot;222&quot;,21));      modelAndView.setViewName(&quot;success&quot;); &#x2F;&#x2F; 设置视图名称      return modelAndView;  }</code></pre></li></ul><ul><li><p>jsp：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">  &lt;h3&gt;访问成功！&lt;&#x2F;h3&gt;  ${user.username}  ${user.password}  ${user.age}</code></pre></li></ul><h3 id="1-2-转发和重定向"><a href="#1-2-转发和重定向" class="headerlink" title="1.2 转发和重定向"></a>1.2 转发和重定向</h3><h4 id="1-2-1-forward转发"><a href="#1-2-1-forward转发" class="headerlink" title="1.2.1 forward转发"></a>1.2.1 forward转发</h4><p>controller方法提供了String类型的返回值之后，默认就是请求转发。我们也可以写成如下形式：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RequestMapping(&quot;&#x2F;testForward&quot;)    public String testForward()  {        System.out.println(&quot;testForward方法执行了...&quot;);        return &quot;forward:&#x2F;WEB-INF&#x2F;pages&#x2F;success.jsp&quot;; &#x2F;&#x2F; 使用了forward:,路径就必须写成物理视图url    }</code></pre><ul><li>注意：如果用了<code>forward:</code>，则路径必须写成实际视图 URL，不能写逻辑视图。</li><li>它相当于：<code>request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request,response);</code></li><li>使用请求转发，即可以转发到jsp，也可以转发到其他控制器方法。例：<code>return &quot;forward:testString&quot;;</code></li></ul><h4 id="1-2-2-Redirect重定向"><a href="#1-2-2-Redirect重定向" class="headerlink" title="1.2.2 Redirect重定向"></a>1.2.2 Redirect重定向</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RequestMapping(&quot;&#x2F;testRedirect&quot;)public String testRedirect() {    System.out.println(&quot;testRedirect方法执行了...&quot;);    return &quot;redirect:testString&quot;; &#x2F;&#x2F; 重定向到返回字符串页面}</code></pre><ul><li>相当于：<code>response.sendRedirect(&quot;testString&quot;);</code></li><li>注意：如果是重定向到 jsp 页面，则 jsp 页面不能写在 WEB-INF 目录中，否则无法找到。</li></ul><h3 id="1-3-ResponseBody响应Json数据"><a href="#1-3-ResponseBody响应Json数据" class="headerlink" title="1.3 ResponseBody响应Json数据"></a>1.3 ResponseBody响应Json数据</h3><ul><li>作用：该注解用于将Controller的方法返回的对象，通过<code>HttpMessageConverter</code>接口转换为指定格式的数据如：json,xml 等，通过Response响应给客户端。</li></ul><h4 id="1-3-1-关于静态资源拦截问题"><a href="#1-3-1-关于静态资源拦截问题" class="headerlink" title="1.3.1 关于静态资源拦截问题"></a>1.3.1 关于静态资源拦截问题</h4><p><code>DispatcherServlet</code>会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。解决问题就是需要配置静态资源不进行拦截</p><ul><li>方法1：在SpringMVC.xml配置文件内使用<code>mvc:resources</code>标签配置资源文件不拦截<ul><li>location元素表示webapp目录下的包下的所有文件</li><li>mapping元素表示以<code>/static</code>开头的所有请求路径</li></ul></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!-- 设置静态资源不过滤 --&gt;&lt;mvc:resources location=&quot;&#x2F;css&#x2F;&quot; mapping=&quot;&#x2F;css&#x2F;**&quot;&#x2F;&gt; &lt;!-- 样式 --&gt;&lt;mvc:resources location=&quot;&#x2F;images&#x2F;&quot; mapping=&quot;&#x2F;images&#x2F;**&quot;&#x2F;&gt; &lt;!-- 图片 --&gt;&lt;mvc:resources location=&quot;&#x2F;js&#x2F;&quot; mapping=&quot;&#x2F;js&#x2F;**&quot;&#x2F;&gt; &lt;!-- javascript --&gt;</code></pre><ul><li>方法2：在web.xml配置文件中配置如下</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--设置访问静态资源--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;&#x2F;servlet-name&gt;    &lt;url-pattern&gt;*.css&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;&#x2F;servlet-name&gt;    &lt;url-pattern&gt;*.js&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt;</code></pre><h4 id="1-3-2-示例"><a href="#1-3-2-示例" class="headerlink" title="1.3.2 示例"></a>1.3.2 示例</h4><p>简单的获取json数据</p><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 测试响应json数据     * @param     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;testResponseJson&quot;)public void testResponseJson(@RequestBody String body){    System.out.println(&quot;异步请求:&quot;+body);}</code></pre><ul><li>jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;script&gt;    &#x2F;&#x2F; 页面加载,绑定单机事件    $(function () {        $(&quot;#btn&quot;).click(function () {            &#x2F;&#x2F; 发送ajax请求            $.ajax({                type:&quot;post&quot;,                url:&quot;user&#x2F;testResponseJson&quot;,                contentType:&quot;application&#x2F;json;charset=utf-8&quot;,                data:&#39;{&quot;username&quot;:&quot;小明&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:33}&#39;,                dataType:&quot;json&quot;,                success:function (data) {                    alert(data);                }            })        })    })&lt;&#x2F;script&gt;&lt;h3&gt;6. ResponseBody响应Json数据&lt;&#x2F;h3&gt;&lt;button id=&quot;btn&quot;&gt;发送Ajax请求&lt;&#x2F;button&gt;</code></pre><ul><li>测试结果：<code>异步请求:{&quot;username&quot;:&quot;小明&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:33}</code></li></ul><p>如果需要将获取的json格式数据转换为JavaBean对象，则需要导入额外的jar包</p><ul><li>在pom.xml中导入坐标</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--导入json和JavaBean对象相互转换所需jar包：jackson--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ul><li>控制器代码修改</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RequestMapping(&quot;&#x2F;testResponseJson&quot;)public @ResponseBody User testResponseJson(@RequestBody User user){    System.out.println(&quot;异步请求:&quot;+user);    user.setUsername(&quot;花花&quot;);    user.setAge(18);    return user;}</code></pre><ul><li>前端修改js</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;    &#x2F;&#x2F; 页面加载,绑定单机事件    $(function () {    $(&quot;#btn&quot;).click(function () {        &#x2F;&#x2F; 发送ajax请求        $.ajax({            type:&quot;post&quot;,            url:&quot;user&#x2F;testResponseJson&quot;,            contentType:&quot;application&#x2F;json;charset=utf-8&quot;,            data:&#39;{&quot;username&quot;:&quot;小明&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:33}&#39;,            dataType:&quot;json&quot;,            success:function (data) {                &#x2F;&#x2F; data是服务器端响应的json数据                alert(data.username);                alert(data.password);                alert(data.age);            }        })    })})&lt;&#x2F;script&gt;</code></pre><h2 id="2-SpringMVC实现文件上传"><a href="#2-SpringMVC实现文件上传" class="headerlink" title="2. SpringMVC实现文件上传"></a>2. SpringMVC实现文件上传</h2><h3 id="2-1-文件上传回顾"><a href="#2-1-文件上传回顾" class="headerlink" title="2.1 文件上传回顾"></a>2.1 文件上传回顾</h3><h4 id="2-1-1-必要前提"><a href="#2-1-1-必要前提" class="headerlink" title="2.1.1 必要前提"></a>2.1.1 必要前提</h4><ul><li>form表单的enctype(表单请求正文的类型)取值必须是：<code>multipart/form-data</code>，默认值是<code>application/x-www-form-urlencoded</code>。</li><li>method属性取值必须是Post</li><li>提供一个文件选择域<code>&lt;input type=&quot;file&quot;/&gt;</code></li></ul><h4 id="2-1-2-原理分析"><a href="#2-1-2-原理分析" class="headerlink" title="2.1.2 原理分析"></a>2.1.2 原理分析</h4><ul><li>当form表单的enctype取值不是默认值后，<code>request.getParameter()</code>将会失效。</li><li><code>enctype=”application/x-www-form-urlencoded”</code>时，form 表单的正文内容是键值对形式。</li><li>当form表单的enctype取值为<code>multipart/form-data</code>时，请求正文内容就变成：每一部分都是MIME类型描述的正文。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">-----------------------------7de1a433602ac --&gt;分界符Content-Disposition: form-data; name=&quot;userName&quot; --&gt;协议头文件上传测试  --&gt;协议的正文-----------------------------7de1a433602acContent-Disposition: form-data; name=&quot;file&quot;;filename=&quot;C:\Users\zhy\Desktop\fileupload_demofile\b.txt&quot;Content-Type: text&#x2F;plain     --&gt;协议的类型（MIME 类型）文件实际内容xxxxxx-----------------------------7de1a433602ac--</code></pre><h4 id="2-1-3-借助第三方组件实现文件上传"><a href="#2-1-3-借助第三方组件实现文件上传" class="headerlink" title="2.1.3 借助第三方组件实现文件上传"></a>2.1.3 借助第三方组件实现文件上传</h4><p>使用 Commons-fileupload 组件实现文件上传，需要导入该组件相应的支撑 jar 包：<code>Commons-fileupload 和commons-io</code>。commons-io 不属于文件上传组件的开发 jar 文件，但Commons-fileupload 组件从 1.1 版本开始，它工作时需要 commons-io 包的支持。</p><ul><li>在pom.xml中导入所需jar包</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--导入文件上传相关jar包--&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.3.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.4&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><h3 id="2-2-SpringMVC传统方式的文件上传"><a href="#2-2-SpringMVC传统方式的文件上传" class="headerlink" title="2.2 SpringMVC传统方式的文件上传"></a>2.2 SpringMVC传统方式的文件上传</h3><p>传统方式的文件上传，指的是我们上传的文件和访问的应用存在于同一台服务器上。且上传完毕后，浏览器可能跳转。</p><h4 id="2-2-1-编写控制器"><a href="#2-2-1-编写控制器" class="headerlink" title="2.2.1 编写控制器"></a>2.2.1 编写控制器</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;*** SpringMVC框架方式文件上传*&#x2F;@RequestMapping(&quot;&#x2F;MVCfileUpLoad&quot;)public String MVCfileUpLoad(String picname, MultipartFile uploadFile,                            HttpServletRequest request) throws Exception{    System.out.println(&quot;SpringMVC框架方式文件上传&quot;);    &#x2F;&#x2F; 1.定义文件名称    String fileName = &quot;&quot;;    &#x2F;&#x2F; 1.1. 获取原始文件名    String originalFilename = uploadFile.getOriginalFilename();    &#x2F;&#x2F; 1.2. 截取文件扩展名    String extentName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;) + 1,                                                   originalFilename.length());    &#x2F;&#x2F; 1.3. 将文件加上随机数，防止文件重复    String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).toUpperCase();    &#x2F;&#x2F; 1.4. 判断是否输入了文件名    if (!StringUtils.isEmpty(picname)){        fileName = uuid+&quot;_&quot;+picname+&quot;.&quot;+extentName;    }else {        fileName = uuid+&quot;_&quot;+originalFilename;    }    System.out.println(&quot;文件名称：&quot;+fileName);    &#x2F;&#x2F; 2. 获取文件路径    String basePath = request.getSession().getServletContext().getRealPath(&quot;&#x2F;uploads&quot;);    System.out.println(&quot;文件路径：&quot;+basePath);    &#x2F;&#x2F; 3. 解决用一文件夹中文件过多问题    String datePath = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date());    &#x2F;&#x2F; 4. 判断路径是否存在    File file = new File(basePath+&quot;&#x2F;&quot;+datePath);    if (!file.exists()){ &#x2F;&#x2F; 如果文件夹不存在        file.mkdirs(); &#x2F;&#x2F; 创建    }    &#x2F;&#x2F; 5. 使用MultipartFile接口中方法，将上传的文件写到指定位置    uploadFile.transferTo(new File(file,fileName));    return &quot;success&quot;;}</code></pre><h4 id="2-2-2-编写jsp页面"><a href="#2-2-2-编写jsp页面" class="headerlink" title="2.2.2 编写jsp页面"></a>2.2.2 编写jsp页面</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;文件上传&lt;&#x2F;h3&gt;&lt;form action=&quot;&#x2F;file&#x2F;MVCfileUpLoad&quot; method=&quot;post&quot; enctype=&quot;multipart&#x2F;form-data&quot;&gt;    文件名称：&lt;input type=&quot;text&quot; name=&quot;picname&quot;&gt;    选择上传文件:&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&#x2F;&gt; &lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;&#x2F;form&gt;</code></pre><h4 id="2-2-3-配置文件解析器"><a href="#2-2-3-配置文件解析器" class="headerlink" title="2.2.3 配置文件解析器"></a>2.2.3 配置文件解析器</h4><p>在SpringMVC.xml中添加如下配置</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--配置文件上传解析器,id:multipartResolver是固定值--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!--设置上传文件的最大尺寸为 5MB=5*1024*1024=5242880字节 --&gt;    &lt;property name=&quot;maxUploadSize&quot;&gt;        &lt;value&gt;5242880&lt;&#x2F;value&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</code></pre><h3 id="2-3-跨服务器方式的文件上传"><a href="#2-3-跨服务器方式的文件上传" class="headerlink" title="2.3 跨服务器方式的文件上传"></a>2.3 跨服务器方式的文件上传</h3><h4 id="2-3-1-分服务器的目的"><a href="#2-3-1-分服务器的目的" class="headerlink" title="2.3.1 分服务器的目的"></a>2.3.1 分服务器的目的</h4><p>实际开发中，会有很多处理不同功能的服务器，例</p><ul><li>应用服务器：负责部署我们的应用</li><li>数据库服务器：运行数据库</li><li>缓存和消息服务器：负责处理大并发访问的缓存和消息</li><li>文件服务器：负责存储用户上传文件的服务器</li></ul><h4 id="2-3-2-准备文件服务器"><a href="#2-3-2-准备文件服务器" class="headerlink" title="2.3.2 准备文件服务器"></a>2.3.2 准备文件服务器</h4><p>创建一个新的Tomcat服务器，在WEB-INF下创建一个uploads文件夹，用于存放文件</p><h4 id="2-3-3-具体代码"><a href="#2-3-3-具体代码" class="headerlink" title="2.3.3 具体代码"></a>2.3.3 具体代码</h4><ul><li>控制器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 跨服务器文件上传     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;MVCfileUpLoad2&quot;)public String MVCfileUpLoad2(String picname, MultipartFile uploadFile) throws Exception{    System.out.println(&quot;跨服务器文件上传&quot;);    &#x2F;&#x2F; 1.定义文件名称    String fileName = &quot;&quot;;    &#x2F;&#x2F; 1.1. 获取原始文件名    String originalFilename = uploadFile.getOriginalFilename();    System.out.println(originalFilename);    &#x2F;&#x2F; 1.2. 截取文件扩展名    String extentName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;) + 1,                                                   originalFilename.length());    &#x2F;&#x2F; 1.3. 将文件加上随机数，防止文件重复    String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).toUpperCase();    if (!StringUtils.isEmpty(picname)){        fileName = uuid+&quot;_&quot;+picname+&quot;.&quot;+extentName;    }else {        fileName = uuid+&quot;_&quot;+originalFilename;    }    &#x2F;&#x2F; 定义上传文件服务器路径    String path = &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;uploads&#x2F;&quot;;    &#x2F;&#x2F; 完成文件上传，跨服务器版    &#x2F;&#x2F; 创建客户端的对象    Client client = Client.create();    &#x2F;&#x2F; 和文件服务器进行连接    WebResource resource = client.resource(path+ fileName);    &#x2F;&#x2F; 上传文件     todo:中文乱码问题?    resource.put(uploadFile.getBytes());    return &quot;success&quot;;}</code></pre><ul><li>jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;跨服务器文件上传&lt;&#x2F;h3&gt;&lt;form action=&quot;&#x2F;file&#x2F;MVCfileUpLoad2&quot; method=&quot;post&quot; enctype=&quot;multipart&#x2F;form-data&quot;&gt;    文件名称：&lt;input type=&quot;text&quot; name=&quot;picname&quot;&gt;    选择上传文件:&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&#x2F;&gt; &lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;&#x2F;form&gt;</code></pre><ul><li>403Forbidden问题</li></ul><p>上传文件涉及到读写权限，这个报错的意思就是服务器（Tomcat）没有写入的权限，需要在服务器的web.xml文件中找到servlet标签，在servlet里添加如下字段，开启文件读写</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;init-param&gt;    &lt;param-name&gt;readonly&lt;&#x2F;param-name&gt;    &lt;param-value&gt;false&lt;&#x2F;param-value&gt;&lt;&#x2F;init-param&gt;</code></pre><ul><li>409 Conflict 问题</li></ul><p>文件夹未创建，在服务器<code>target\fileUploadServer</code>下创建uploads文件夹即可</p><ul><li>关于中文文件名上传报错问题</li></ul><p><a href="https://yq.aliyun.com/articles/641394" target="_blank" rel="noopener">见文章</a></p><p>Tomcat版本8.5，尚未解决问题</p><h2 id="3-SpringMVC中的异常处理"><a href="#3-SpringMVC中的异常处理" class="headerlink" title="3. SpringMVC中的异常处理"></a>3. SpringMVC中的异常处理</h2><h3 id="3-1-异常处理的思路"><a href="#3-1-异常处理的思路" class="headerlink" title="3.1 异常处理的思路"></a>3.1 异常处理的思路</h3><p>系统中异常包括两类：预期异常和运行时异常<code>RuntimeException</code>，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springMVC前端控制器交由异常处理器进行异常处理，如下图示：</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/09/06/Exception-1567699963265.jpg" alt="Exception"></p><h3 id="3-2-实现步骤"><a href="#3-2-实现步骤" class="headerlink" title="3.2 实现步骤"></a>3.2 实现步骤</h3><ul><li>控制器代码，模拟一个异常</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;user&quot;)public class UserController {    @RequestMapping(&quot;&#x2F;testException&quot;)    public String testException() throws SysException{        System.out.println(&quot;testException.....&quot;);        try {            &#x2F;&#x2F; 模拟异常            int i = 1&#x2F;0;        } catch (Exception e) {            e.printStackTrace();            &#x2F;&#x2F; 抛出自定义异常信息            throw new SysException(&quot;查询错误....&quot;);        }        return &quot;success&quot;;    }}</code></pre><ul><li>jsp访问页面和错误页面</li></ul><p>访问页面：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;异常处理&lt;&#x2F;h3&gt;&lt;a href=&quot;&#x2F;user&#x2F;testException&quot;&gt;测试异常处理&lt;&#x2F;a&gt;</code></pre><p>错误页面：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;出错啦！&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h4&gt;${errorMsg}&lt;&#x2F;h4&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>编写自定义异常类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 自定义异常类 *&#x2F;public class SysException extends Exception {    &#x2F;&#x2F; 存储提示信息的    private String message;    public SysException(String message) {        this.message = message;    }    @Override    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }}</code></pre><ul><li>编写自定义异常解析器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 异常处理类 *&#x2F;public class SysExceptionResolver implements HandlerExceptionResolver {    &#x2F;**     * 处理异常业务逻辑     * @param request     * @param response     * @param handler     * @param ex 当前抛出的异常对象     * @return     *&#x2F;    @Override    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        &#x2F;&#x2F; 获取异常对象        SysException e = null;        &#x2F;&#x2F; 如果抛出的是系统自定义异常则直接转换        if (ex instanceof SysException){ &#x2F;&#x2F; instanceof：判断ex是否是SysException的对象、直接或间接子类、其接口实现类            e = (SysException) ex;        }else {            &#x2F;&#x2F; 如果抛出的不是系统自定义异常则重新构造一个系统错误异常            e = new SysException(&quot;系统维护中....&quot;);        }        &#x2F;&#x2F; 创建ModelAndView对象，跳转页面        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;errorMsg&quot;,e.getMessage()); &#x2F;&#x2F; 获取异常消息，存入对象        modelAndView.setViewName(&quot;error&quot;); &#x2F;&#x2F; 跳转错误页面        return modelAndView;    }}</code></pre><ul><li>在SpringMVC.xml中，配置异常处理器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--配置自定义异常处理器对象--&gt;&lt;bean id=&quot;SysExceptionResolver&quot; class=&quot;cn.zero.exception.SysExceptionResolver&quot;&#x2F;&gt;</code></pre><h2 id="4-SpringMVC中的拦截器"><a href="#4-SpringMVC中的拦截器" class="headerlink" title="4. SpringMVC中的拦截器"></a>4. SpringMVC中的拦截器</h2><h3 id="4-1-拦截器的作用"><a href="#4-1-拦截器的作用" class="headerlink" title="4.1 拦截器的作用"></a>4.1 拦截器的作用</h3><ul><li><p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行<strong>预处理和后处理。</strong></p></li><li><p>可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链<br>中的拦截器会按着定义的顺序执行。</p></li><li>拦截器和过滤器的功能比较类似，区别点如下：<ul><li>过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。</li><li>拦截器是SpringMVC框架独有的。</li><li>过滤器配置了<code>/*</code>，可以拦截任何资源</li><li>拦截器只会对<strong>控制器中的方法进行拦截</strong>，不会拦截类似js、css等资源。</li></ul></li><li>拦截器也是AOP思想的一种实现方式。</li><li>想要自定义拦截器，需要实现<code>HandlerInterceptor</code>接口。</li></ul><h3 id="4-2-自定义拦截器的步骤"><a href="#4-2-自定义拦截器的步骤" class="headerlink" title="4.2 自定义拦截器的步骤"></a>4.2 自定义拦截器的步骤</h3><ul><li>编写拦截器类，实现<code>HandlerInterceptor</code>接口，重写方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 定义拦截器 *&#x2F;public class CustomInterceptor implements HandlerInterceptor {    &#x2F;**     * 预处理，controller方法执行前处理     * return true放行，执行下一个拦截器，如果没有下一拦截器，执行控制器方法     * return false不放行     * @param request     * @param response     * @param handler     * @return     * @throws Exception     *&#x2F;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;CustomInterceptor执行了....预处理&quot;);&#x2F;&#x2F;        request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;error.jsp&quot;).forward(request,response);        return true;    }    &#x2F;**     * 后处理，controller方法执行后处理     * @param request     * @param response     * @param handler     * @param modelAndView     * @throws Exception     *&#x2F;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(&quot;postHandle....后处理&quot;);&#x2F;&#x2F;        request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;error.jsp&quot;).forward(request,response);    }    &#x2F;**     * 结尾处理，最后执行的，success.jsp页面执行完毕后，该方法执行。     * @param request     * @param response     * @param handler     * @param ex     * @throws Exception     *&#x2F;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(&quot;afterCompletion....尾处理&quot;);    }}</code></pre><ul><li>配置拦截器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--要拦截的具体方法--&gt;        &lt;mvc:mapping path=&quot;&#x2F;user&#x2F;*&quot;&#x2F;&gt;        &lt;!--不要拦截的方法--&gt;        &lt;!--&lt;mvc:exclude-mapping path=&quot;&quot;&#x2F;&gt;--&gt;        &lt;!-- 配置拦截器对象--&gt;        &lt;bean class=&quot;com.zero.interceptor.CustomInterceptor&quot;&#x2F;&gt;    &lt;&#x2F;mvc:interceptor&gt;&lt;&#x2F;mvc:interceptors&gt;</code></pre><ul><li>控制器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;user&quot;)public class UserController {    @RequestMapping(&quot;&#x2F;testInterceptor&quot;)    public String testInterceptor(){        System.out.println(&quot;testInterceptor....控制器执行&quot;);        return &quot;success&quot;;    }}</code></pre><ul><li>success.jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;访问成功！&lt;&#x2F;h3&gt;&lt;% System.out.println(&quot;success.jsp执行了.....&quot;);%&gt;</code></pre><ul><li>测试结果</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">CustomInterceptor执行了....预处理testInterceptor....控制器执行postHandle....后处理success.jsp执行了.....afterCompletion....尾处理</code></pre><h3 id="4-3-拦截器简单案例-验证用户是否登录"><a href="#4-3-拦截器简单案例-验证用户是否登录" class="headerlink" title="4.3 拦截器简单案例(验证用户是否登录)"></a>4.3 拦截器简单案例(验证用户是否登录)</h3><h4 id="4-3-1-实现思路"><a href="#4-3-1-实现思路" class="headerlink" title="4.3.1 实现思路"></a>4.3.1 实现思路</h4><ul><li>编写登录页面，需要一个控制器访问页面。</li><li>登录页面有提交表单的动作，需在控制器中处理。<ul><li>判断用户名密码是否正确</li><li>正确，向session中写入用户信息</li><li>返回登录成功</li></ul></li><li>拦截用户请求，判断用户是否登录<ul><li>如已经登录，放行</li><li>如未登录，跳转到登录页面</li></ul></li><li>登录后使用重定向退出，涉及到<code>RedirectView</code>类<ul><li>作用：跟<code>return &quot;redirect:xxx&quot;</code>类似，也是重定向操作。</li><li>重定向相对地址：<code>return new RedirectView(&quot;index.jsp&quot;)</code>，在此请求路径下找相应路。</li><li>重定向绝对路径：<code>return new RedirectView(&quot;/index.jsp&quot;</code>，相当于项目路径+此路径。</li></ul></li></ul><h4 id="4-3-2-核心代码"><a href="#4-3-2-核心代码" class="headerlink" title="4.3.2 核心代码"></a>4.3.2 核心代码</h4><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;user&quot;)public class UserController {        &#x2F;**     * 跳转登录页面     * @param model     * @return     * @throws Exception     *&#x2F;    @RequestMapping(&quot;&#x2F;login&quot;)    public String login(Model model) throws Exception{        return &quot;login&quot;;    }    &#x2F;**     * 登录提交     * @param session     * @param userId 用户账户     * @param pwd 密码     * @return     * @throws Exception     *&#x2F;    @RequestMapping(&quot;&#x2F;loginSubmit&quot;)    public String loginSubmit(HttpSession session,String userId,String pwd) throws Exception{        &#x2F;&#x2F; 在session中记录用户身份信息        session.setAttribute(&quot;activeUser&quot;,userId);        System.out.println(&quot;用户已登录&quot;);        return &quot;success&quot;;    }    &#x2F;**     * 退出     * @param session     * @param request     * @param response     * @return     * @throws Exception     *&#x2F;    @RequestMapping(&quot;&#x2F;logOut&quot;)    public RedirectView logOut(HttpSession session,                         HttpServletRequest request,                         HttpServletResponse response) throws Exception{        &#x2F;&#x2F; 设置session过期        session.invalidate();       &#x2F;&#x2F; return new RedirectView(&quot;index.jsp&quot;); 相当于：localhost&#x2F;user&#x2F;index.jsp        return new RedirectView(&quot;&#x2F;index.jsp&quot;); &#x2F;&#x2F; 相当于：localhost&#x2F;index.jsp    }}</code></pre><ul><li>定义登录拦截器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 登录拦截器 *&#x2F;public class LoginInterceptor implements HandlerInterceptor {    &#x2F;**     * 预处理验证用户是否登录     * @param request     * @param response     * @param handler     * @return     * @throws Exception     *&#x2F;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(&quot;登录拦截器执行&quot;);        &#x2F;&#x2F; 如果是登录页面则放行        if (request.getRequestURI().indexOf(&quot;login&quot;)&gt;=0){            return true;        }        HttpSession session = request.getSession();        &#x2F;&#x2F; 如果用户已登录也放行        if (session.getAttribute(&quot;activeUser&quot;)!=null){            return true;        }        &#x2F;&#x2F; 用户没有登录则跳转到登录页面        request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;login.jsp&quot;).forward(request,response);        System.out.println(&quot;用户尚未登录&quot;);        return false;    }}</code></pre><ul><li>配置拦截器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--配置登录拦截器--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--要拦截的具体方法--&gt;        &lt;mvc:mapping path=&quot;&#x2F;user&#x2F;**&quot;&#x2F;&gt;        &lt;!--不要拦截的方法--&gt;        &lt;!--&lt;mvc:exclude-mapping path=&quot;&quot;&#x2F;&gt;--&gt;        &lt;!-- 配置拦截器对象--&gt;        &lt;bean class=&quot;com.zero.interceptor.LoginInterceptor&quot;&#x2F;&gt;    &lt;&#x2F;mvc:interceptor&gt;&lt;&#x2F;mvc:interceptors&gt;</code></pre><ul><li>jsp登录页面，其他页面就不贴代码了</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;用户登录&lt;&#x2F;h3&gt;&lt;form action=&quot;&#x2F;user&#x2F;loginSubmit&quot; method=&quot;post&quot;&gt;    用户名称：&lt;input type=&quot;text&quot; name=&quot;userId&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;&#x2F;form&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC学习1</title>
      <link href="/FrameWork/SpringMVC-Basic2.html"/>
      <url>/FrameWork/SpringMVC-Basic2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-SpringMVC基本概念"><a href="#1-SpringMVC基本概念" class="headerlink" title="1. SpringMVC基本概念"></a>1. SpringMVC基本概念</h2><h3 id="1-1-关于三层架构和MVC"><a href="#1-1-关于三层架构和MVC" class="headerlink" title="1.1 关于三层架构和MVC"></a>1.1 关于三层架构和MVC</h3><a id="more"></a><h4 id="1-1-1-三层架构"><a href="#1-1-1-三层架构" class="headerlink" title="1.1.1 三层架构"></a>1.1.1 三层架构</h4><ul><li>开发服务器端程序，一般基于两种形式，一种C/S架构程序，一种B/S架构程序</li><li>使用Java语言基本上都是开发B/S架构的程序，B/S架构又分为了三层架构</li><li>三层架构<ol><li>表现层：WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型</li><li>业务层：处理公司具体的业务逻辑</li><li>持久层：用来操作数据库</li></ol></li></ul><h4 id="1-1-2-MVC模型"><a href="#1-1-2-MVC模型" class="headerlink" title="1.1.2 MVC模型"></a>1.1.2 MVC模型</h4><ol><li>MVC全名是<code>Model View Controller</code>模型视图控制器，每个部分各司其职。</li><li>Model：数据模型，JavaBean的类，用来进行数据封装。</li><li>View：指JSP、HTML用来展示数据给用户</li><li>Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。</li></ol><h3 id="1-2-SpringMVC概述"><a href="#1-2-SpringMVC概述" class="headerlink" title="1.2 SpringMVC概述"></a>1.2 SpringMVC概述</h3><h4 id="1-2-1-SpringMVC是什么"><a href="#1-2-1-SpringMVC是什么" class="headerlink" title="1.2.1 SpringMVC是什么"></a>1.2.1 SpringMVC是什么</h4><ol><li>是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级Web框架。</li><li>Spring MVC属于SpringFrameWork的后续产品，已经融合在SpringWebFlow里面。Spring框架提供了构建 Web 应用程序的全功能MVC模块。</li><li>使用Spring可插入的MVC架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2等。</li><li>它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持<br> RESTful 编程风格的请求。</li></ol><h4 id="1-2-2-SpringMVC在三层架构的位置"><a href="#1-2-2-SpringMVC在三层架构的位置" class="headerlink" title="1.2.2 SpringMVC在三层架构的位置"></a>1.2.2 SpringMVC在三层架构的位置</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/09/06/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84-1567699806413.jpg" alt="三层架构"></p><h4 id="1-2-3-SpringMVC的优势"><a href="#1-2-3-SpringMVC的优势" class="headerlink" title="1.2.3 SpringMVC的优势"></a>1.2.3 SpringMVC的优势</h4><ul><li>清晰的角色划分：<ul><li>前端控制器（DispatcherServlet）</li><li>请求到处理器映射（HandlerMapping）</li><li>处理器适配器（HandlerAdapter）</li><li>视图解析器（ViewResolver）</li><li>处理器或页面控制器（Controller）</li><li>验证器（ Validator）</li><li>命令对象（Command 请求参数绑定到的对象就叫命令对象）</li><li>表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。</li></ul></li><li>分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。</li><li>由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。</li><li>和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。</li><li>可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。</li><li>可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。</li><li>功能强大的数据验证、格式化、绑定机制。</li><li>利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。</li><li>本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</li><li><p>强大的 JSP 标签库，使 JSP 编写更容易。</p></li><li><p>支持RESTful风格的编程支持</p></li></ul><h4 id="1-2-4-SpringMVC和Struts2的优劣分析-了解"><a href="#1-2-4-SpringMVC和Struts2的优劣分析-了解" class="headerlink" title="1.2.4 SpringMVC和Struts2的优劣分析[了解]"></a>1.2.4 SpringMVC和Struts2的优劣分析[了解]</h4><ul><li>共同点：<ul><li>都是表现层框架，基于MVC模型编写的。</li><li>底层都离不开原始ServletAPI。</li><li>它们处理请求的机制都是一个核心控制器。</li></ul></li><li>区别：<ul><li>Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter。</li><li>Spring MVC 是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。所以 Spring MVC 会稍微比 Struts2 快些。</li><li>Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便。</li><li>Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提<br>升，尤其是 Struts2 的表单标签，远没有 html 执行效率高。</li></ul></li></ul><blockquote><p>OGNL是对象 - 图形导航语言的缩写，它是一种功能强大的表达式语言，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。</p></blockquote><h2 id="2-SpringMVC入门"><a href="#2-SpringMVC入门" class="headerlink" title="2. SpringMVC入门"></a>2. SpringMVC入门</h2><h3 id="2-1-SpringMVC入门案例"><a href="#2-1-SpringMVC入门案例" class="headerlink" title="2.1 SpringMVC入门案例"></a>2.1 SpringMVC入门案例</h3><h4 id="1-创建Web工程，引入开发相关的jar包"><a href="#1-创建Web工程，引入开发相关的jar包" class="headerlink" title="1. 创建Web工程，引入开发相关的jar包"></a>1. 创建Web工程，引入开发相关的jar包</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;    &lt;!--版本锁定--&gt;    &lt;spring.version&gt;5.0.2.RELEASE&lt;&#x2F;spring.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt;    &lt;!--引入spring相关jar包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;        &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;        &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;        &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.5&lt;&#x2F;version&gt;        &lt;scope&gt;provided&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.0&lt;&#x2F;version&gt;        &lt;scope&gt;provided&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre><h4 id="2-配置核心控制器-DispatcherServlet"><a href="#2-配置核心控制器-DispatcherServlet" class="headerlink" title="2. 配置核心控制器(DispatcherServlet)"></a>2. 配置核心控制器(DispatcherServlet)</h4><ul><li>在web.xml中配置前端控制器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--配置核心前端控制器--&gt;&lt;servlet&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;    &lt;!--加载mvc配置文件--&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;        &lt;param-value&gt;classpath:SpringMVC.xml&lt;&#x2F;param-value&gt;    &lt;&#x2F;init-param&gt;    &lt;!--启动服务器就自动加载配置文件，生成对象--&gt;    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;&lt;&#x2F;servlet&gt;&lt;!--配置控制器映射，拦截所有请求--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt;</code></pre><h4 id="3-编写SpringMVC-xml的配置文件"><a href="#3-编写SpringMVC-xml的配置文件" class="headerlink" title="3. 编写SpringMVC.xml的配置文件"></a>3. 编写SpringMVC.xml的配置文件</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:mvc=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;       xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation=&quot;        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;    &lt;!--开启注解扫描--&gt;    &lt;context:component-scan base-package=&quot;cn.zero.controller&quot;&#x2F;&gt;    &lt;!--配置视图解析器对象--&gt;    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!--配置前缀后缀，访问路径等于：&#x2F;WEB-INF&#x2F;pages&#x2F;xxx.jsp--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;&quot;&#x2F;&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!--开启SpringMVC框架注解的支持--&gt;    &lt;mvc:annotation-driven&#x2F;&gt;&lt;&#x2F;beans&gt;</code></pre><h4 id="4-编写index-jsp和HelloController控制器类"><a href="#4-编写index-jsp和HelloController控制器类" class="headerlink" title="4. 编写index.jsp和HelloController控制器类"></a>4. 编写index.jsp和HelloController控制器类</h4><ul><li>index.jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;主页&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h3&gt;SpringMVC快速入门&lt;&#x2F;h3&gt;&lt;a href=&quot;&#x2F;hello&quot;&gt;入门程序&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>HelloController</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 控制器类@Controllerpublic class HelloController {        @RequestMapping(&quot;&#x2F;hello&quot;)    public String sayHello(){        System.out.println(&quot;Hello SpringMVC!&quot;);        return &quot;success&quot;;    }}</code></pre><h4 id="5-在WEB-INF下创建pages文件夹，编写success-jsp的成功页面"><a href="#5-在WEB-INF下创建pages文件夹，编写success-jsp的成功页面" class="headerlink" title="5. 在WEB-INF下创建pages文件夹，编写success.jsp的成功页面"></a>5. 在WEB-INF下创建pages文件夹，编写success.jsp的成功页面</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;访问成功&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h3&gt;入门程序访问成功&lt;&#x2F;h3&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4 id="6-启动服务器"><a href="#6-启动服务器" class="headerlink" title="6. 启动服务器"></a>6. 启动服务器</h4><p>访问localhost/index.jsp，点击入门程序，查看是否正常跳转。</p><h3 id="2-2-入门案例的执行过程及原理分析"><a href="#2-2-入门案例的执行过程及原理分析" class="headerlink" title="2.2 入门案例的执行过程及原理分析"></a>2.2 入门案例的执行过程及原理分析</h3><h4 id="2-2-1-入门案例的执行流程"><a href="#2-2-1-入门案例的执行流程" class="headerlink" title="2.2.1 入门案例的执行流程"></a>2.2.1 入门案例的执行流程</h4><ol><li>当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，<br>就会加载springmvc.xml配置文件</li><li>开启了注解扫描，那么HelloController对象就会被创建</li><li>从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解<br> 找到执行的具体方法</li><li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件</li><li>Tomcat服务器渲染页面，做出响应</li><li>如下图示流程图：</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/09/06/flowChart-1567699840232.jpg" alt="flowChart"></p><h4 id="2-2-2-SpringMVC的请求响应流程"><a href="#2-2-2-SpringMVC的请求响应流程" class="headerlink" title="2.2.2 SpringMVC的请求响应流程"></a>2.2.2 SpringMVC的请求响应流程</h4><ul><li>官方完整流程图：</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/29/mvc-1567090970613.jpg" alt="mvc"></p><h3 id="2-3-组件详解"><a href="#2-3-组件详解" class="headerlink" title="2.3 组件详解"></a>2.3 组件详解</h3><ul><li>前端控制器(DispatcherServlet)<ul><li>用户请求到达前端控制器，它相当于mvc模式中的c。DispatcherServlet 是<strong>整个流程控制的中心</strong>，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的<strong>耦合性</strong>。</li></ul></li><li>处理器映射器(HandlerMapping)<ul><li>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li></ul></li><li>处理器(Handler)<ul><li>它就是我们开发中要编写的具体<strong>业务控制器</strong>。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。</li></ul></li><li>处理器适配器(HandlerAdapter)<ul><li>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</li></ul></li><li>视图解析器(ViewResolver)<ul><li>View Resolver 负责将处理结果生成 View 视图，View Resolver首先根据逻辑视图名解析成物理视图名<br>即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</li></ul></li><li>视图(View)<ul><li>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView<br>等。我们最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li></ul></li></ul><h4 id="2-3-1-lt-mvc-annotation-driven-gt"><a href="#2-3-1-lt-mvc-annotation-driven-gt" class="headerlink" title="2.3.1 &lt;mvc:annotation-driven/&gt;"></a>2.3.1 <code>&lt;mvc:annotation-driven/&gt;</code></h4><p>在SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为SpringMVC的三大组件。</p><p>使用自动加载 RequestMappingHandlerMapping(处理映射器)和RequestMappingHandlerAdapter(处 理 适 配 器)， 可用在SpringMVC.xml配置文件中使用替代注解处理器和适配器的配置。</p><h3 id="2-4-RequestMapping注解详解"><a href="#2-4-RequestMapping注解详解" class="headerlink" title="2.4 @RequestMapping注解详解"></a>2.4 @RequestMapping注解详解</h3><ol><li>RequestMapping注解的作用是<strong>建立请求URL和处理方法之间的对应关系</strong></li><li>RequestMapping注解可以作用在方法和类上<ol><li>作用在类上：第一级的访问目录</li><li>作用在方法上：第二级的访问目录</li><li>细节：前端路径可以不写 <code>/</code> 表示应用的根目录开始</li><li>细节：<code>${pageContext.request.contextPath}</code>也可以省略不写，但是路径上不能写 /</li></ol></li><li>RequestMapping的属性<ol><li>path：指定请求路径的url</li><li>value：value属性等同于path属性，指定请求路径url</li><li>mthod：指定该方法的请求方式</li><li>params：指定限制请求参数的条件，允许简单的表达式，例<code>params={“money!100”}</code>表示请求参数中money不能是100。</li><li>headers：发送的请求中必须包含的请求头</li></ol></li></ol><blockquote><p>以上属性出现两个以上时，他们的关系是&amp;&amp;逻辑与关系</p></blockquote><h2 id="3-请求参数的绑定-重点"><a href="#3-请求参数的绑定-重点" class="headerlink" title="3. 请求参数的绑定[重点]"></a>3. 请求参数的绑定[重点]</h2><h3 id="3-1-绑定说明"><a href="#3-1-绑定说明" class="headerlink" title="3.1 绑定说明"></a>3.1 绑定说明</h3><h4 id="3-1-1-绑定的机制"><a href="#3-1-1-绑定的机制" class="headerlink" title="3.1.1 绑定的机制"></a>3.1.1 绑定的机制</h4><ul><li>表单提交的数据都是key=value格式的，例：username=xiaoming&amp;password=123456</li><li>SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的</li><li>要求：提交表单的name和参数的名称必须是相同的</li></ul><h4 id="3-1-2-支持的数据类型"><a href="#3-1-2-支持的数据类型" class="headerlink" title="3.1.2 支持的数据类型"></a>3.1.2 支持的数据类型</h4><ul><li>基本类型参数：包括基本类型和String类型</li><li>POJO类型参数：包括实体类，以及关联的实体类</li><li>数组和集合类型参数：包括List结构和Map结构的集合(包括数组)</li></ul><h4 id="3-1-3-使用要求"><a href="#3-1-3-使用要求" class="headerlink" title="3.1.3 使用要求"></a>3.1.3 使用要求</h4><ul><li>如果是基本类型或String类型<ul><li>要求参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写)</li></ul></li><li>如果是 POJO 类型，或者它的关联对象<ul><li>要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。</li></ul></li><li>如果是集合类型,有两种方式：<ul><li>要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。给 List 集合中的元素赋值，使用下标。给 Map 集合中的元素赋值，使用键值对。</li><li>接收的请求参数是 json 格式数据。需要借助一个注解实现。</li></ul></li></ul><h4 id="3-1-4-绑定参数示例"><a href="#3-1-4-绑定参数示例" class="headerlink" title="3.1.4 绑定参数示例"></a>3.1.4 绑定参数示例</h4><h5 id="1-基本类型和String类型作为参数"><a href="#1-基本类型和String类型作为参数" class="headerlink" title="1. 基本类型和String类型作为参数"></a>1. 基本类型和String类型作为参数</h5><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RequestMapping(&quot;&#x2F;testParam&quot;)public String testParam(String username){    System.out.println(&quot;用户名：&quot;+username);    return &quot;success&quot;;}</code></pre><ul><li>jsp代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;a href=&quot;param&#x2F;testParam?username=xiaoming&quot;&gt;请求参数绑定&lt;&#x2F;a&gt;</code></pre><h5 id="2-POJO类型作为参数"><a href="#2-POJO类型作为参数" class="headerlink" title="2. POJO类型作为参数"></a>2. POJO类型作为参数</h5><ul><li>需创建实体类Account和User，User类作为账户类的参数。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Account implements Serializable {    private String username;    private String password;    private Double money;    private User user;}public class User {    private String name;    private Integer age;}</code></pre><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 接收参数，封装为POJO类型     * @param account     * @return     *&#x2F;@RequestMapping(value = &quot;&#x2F;testPojo&quot;,method = RequestMethod.POST)public String testPojo(Account account){    System.out.println(account);    return &quot;success&quot;;}</code></pre><ul><li>Jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;form action=&quot;&#x2F;param&#x2F;testPojo&quot; method=&quot;post&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    余额：&lt;input type=&quot;text&quot; name=&quot;money&quot;&gt;&lt;br&gt;    真实姓名：&lt;input type=&quot;text&quot; name=&quot;user.name&quot;&gt;&lt;br&gt;    年龄：&lt;input type=&quot;text&quot; name=&quot;user.age&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;&#x2F;form&gt;</code></pre><ul><li>访问结果：<code>Account{username=&#39;admin&#39;, password=&#39;123&#39;, money=333.0, user=User{name=&#39;xiaoming&#39;, age=22}}</code></li></ul><h5 id="3-POJO类中包含集合类型参数"><a href="#3-POJO类中包含集合类型参数" class="headerlink" title="3. POJO类中包含集合类型参数"></a>3. POJO类中包含集合类型参数</h5><ul><li>修改Account类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Account implements Serializable {    private String username;    private String password;    private Double money;    &#x2F;&#x2F; 演示绑定POJO对象&#x2F;&#x2F;    private User user;    &#x2F;&#x2F; POJO类中包含集合类型参数    private List&lt;User&gt; list;    private Map&lt;String,User&gt; map;}</code></pre><ul><li>控制器添加方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * POJO类中包含集合类型参数     *&#x2F;@RequestMapping(value = &quot;&#x2F;testSetType&quot;,method = RequestMethod.POST)public String testSetType(Account account){    System.out.println(account);    return &quot;success&quot;;}</code></pre><ul><li>Jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;POJO类中包含集合类型参数&lt;&#x2F;h3&gt;&lt;form action=&quot;&#x2F;param&#x2F;testSetType&quot; method=&quot;post&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    余额：&lt;input type=&quot;text&quot; name=&quot;money&quot;&gt;&lt;br&gt;    &lt;h4&gt;封装到list集合中&lt;&#x2F;h4&gt;    真实姓名：&lt;input type=&quot;text&quot; name=&quot;list[0].name&quot;&gt;&lt;br&gt;    年龄：&lt;input type=&quot;text&quot; name=&quot;list[0].age&quot;&gt;&lt;br&gt;    &lt;h4&gt;封装到map集合中&lt;&#x2F;h4&gt;    真实姓名：&lt;input type=&quot;text&quot; name=&quot;map[&#39;user&#39;].name&quot;&gt;&lt;br&gt;    年龄：&lt;input type=&quot;text&quot; name=&quot;map[&#39;user&#39;].age&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;&#x2F;form&gt;</code></pre><ul><li>访问结果：<code>Account{username=&#39;admin&#39;, password=&#39;111&#39;, money=333.0, list=[User{name=&#39;小明&#39;, age=22}], map={user=User{name=&#39;小李&#39;, age=21}}}</code></li></ul><h5 id="4-POST请求参数中文乱码问题"><a href="#4-POST请求参数中文乱码问题" class="headerlink" title="4. POST请求参数中文乱码问题"></a>4. POST请求参数中文乱码问题</h5><p>在web.xml中，添加过滤器</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--添加过滤器，解决POST中文乱码问题--&gt;&lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;        &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;    &lt;&#x2F;init-param&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&lt;&#x2F;filter-mapping&gt;</code></pre><h3 id="3-2-特殊情况"><a href="#3-2-特殊情况" class="headerlink" title="3.2 特殊情况"></a>3.2 特殊情况</h3><p>如果User类中有一个Date参数，在表单提交时日期格式不正确，封装POJO对象就会失败，这时就需要自己定义一个类型转换器。 </p><h4 id="3-2-1-自定义类型转换器"><a href="#3-2-1-自定义类型转换器" class="headerlink" title="3.2.1 自定义类型转换器"></a>3.2.1 自定义类型转换器</h4><p>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换。如果想自定义数据类型转换，可以实现Converter的接口</p><h5 id="1-第一步：定义一个类，实现Converter接口，该接口有两个泛型。"><a href="#1-第一步：定义一个类，实现Converter接口，该接口有两个泛型。" class="headerlink" title="1. 第一步：定义一个类，实现Converter接口，该接口有两个泛型。"></a>1. 第一步：定义一个类，实现Converter接口，该接口有两个泛型。</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 将字符串类型转换为日期格式 *&#x2F;public class StringToDateConverter implements Converter&lt;String, Date&gt; {    &#x2F;**     * @param source 传入的字符串参数     * @return     *&#x2F;    @Override    public Date convert(String source) {        if (source == null){            throw new RuntimeException(&quot;please entry param！&quot;);        }        DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        &#x2F;&#x2F; 把字符串转换为日期        try {            return df.parse(source);        } catch (Exception e) {            throw new RuntimeException(&quot;Data switch Error！&quot;);        }    }}</code></pre><h5 id="2-在SpringMVC-xml中配置类型转换器"><a href="#2-在SpringMVC-xml中配置类型转换器" class="headerlink" title="2. 在SpringMVC.xml中配置类型转换器"></a>2. 在SpringMVC.xml中配置类型转换器</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--配置自定义类型转换器--&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;    &lt;!--注册转换器类--&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;set&gt;            &lt;bean class=&quot;cn.zero.utils.StringToDateConverter&quot;&#x2F;&gt;        &lt;&#x2F;set&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;!--开启SpringMVC框架注解的支持配置一下让转换器生效--&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&#x2F;&gt;</code></pre><ul><li>重启服务器在测试一下，就支持<code>yyyy-MM-dd</code>的日期格式了。</li></ul><h4 id="3-2-2-使用ServletAPI对象作为方法参数"><a href="#3-2-2-使用ServletAPI对象作为方法参数" class="headerlink" title="3.2.2 使用ServletAPI对象作为方法参数"></a>3.2.2 使用ServletAPI对象作为方法参数</h4><ul><li><p>示例获取Servlet对象</p><ul><li>在控制器中新增方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;**       * 测试获取ServetlAPI       * @param request       * @param response       * @param session       * @return       *&#x2F;  @RequestMapping(&quot;&#x2F;testServletAPI&quot;)  public String testServletAPI(HttpServletRequest request,                               HttpServletResponse response,                               HttpSession session){      System.out.println(request);      System.out.println(response);      System.out.println(session);      return &quot;success&quot;;  }</code></pre></li></ul><ul><li>jsp代码：<code>&lt;a href=&quot;/param/testServletAPI&quot;&gt;测试访问ServletAPI&lt;/a&gt;</code></li></ul><h2 id="4-常用注解"><a href="#4-常用注解" class="headerlink" title="4. 常用注解"></a>4. 常用注解</h2><h3 id="4-1-RequestParam"><a href="#4-1-RequestParam" class="headerlink" title="4.1 @RequestParam"></a>4.1 @RequestParam</h3><h4 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h4><ul><li>作用：把请求中指定名称的参数给控制器中的形参赋值</li><li>属性：<ul><li>value：请求参数中的名称</li><li>required：请求参数中是否必须提供此参数。默认为true，表示必须提供，不提供将报错。</li></ul></li></ul><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h4><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;anno&quot;)public class AnnotationController {    @RequestMapping(&quot;&#x2F;useRequestParam&quot;)    public String useRequestParam(@RequestParam(&quot;name&quot;) String username,                                  @RequestParam(value = &quot;age&quot;,required = false) Integer age){        System.out.println(username+&quot;:&quot;+age);        return &quot;success&quot;;    }}</code></pre><ul><li>jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;常用注解测试&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h2&gt;1. 测试requestParam注解的使用&lt;&#x2F;h2&gt;&lt;a href=&quot;&#x2F;anno&#x2F;useRequestParam?name=xiaoming&quot;&gt;@RequestParam注解&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>结果：<code>xiaoming:null</code>，因配置了required=false，故请求参数中无age不会报错。</li></ul><h3 id="4-2-RequestBody"><a href="#4-2-RequestBody" class="headerlink" title="4.2 @RequestBody"></a>4.2 @RequestBody</h3><h4 id="1-使用说明-1"><a href="#1-使用说明-1" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h4><ul><li>作用：用于获取请求体内容。直接使用得到是key=value&amp;key=value结构的数据。get请求方式不适用。</li><li>属性：<ul><li>required：是否必须有请求体。默认值true，表示必须有请求体，故get请求方式会报错。如取值为false，get请求得到的是null。</li></ul></li></ul><h4 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="2. 示例"></a>2. 示例</h4><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * RequestBody:用于获取请求体内容。     * @param body     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;useRequestBody&quot;)public String useRequestBody(@RequestBody(required = false) String body){    System.out.println(body);    return &quot;success&quot;;}</code></pre><ul><li>jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;2. 测试@RequestBody注解使用&lt;&#x2F;h3&gt;&lt;h5&gt;POST请求测试&lt;&#x2F;h5&gt;&lt;form action=&quot;&#x2F;anno&#x2F;useRequestBody&quot; method=&quot;post&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;    年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;&#x2F;form&gt;&lt;h5&gt;GET请求测试&lt;&#x2F;h5&gt;&lt;a href=&quot;&#x2F;anno&#x2F;useRequestBody?body=test&quot;&gt;requestBody注解get请求&lt;&#x2F;a&gt;</code></pre><ul><li>测试结果：<ul><li>POST请求：<code>name=xiaoming&amp;age=1</code></li><li>GET请求：<code>null</code></li></ul></li></ul><h3 id="4-3-ResponseBody"><a href="#4-3-ResponseBody" class="headerlink" title="4.3 @ResponseBody"></a>4.3 @ResponseBody</h3><h4 id="1-使用说明-2"><a href="#1-使用说明-2" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h4><p>该注解的作用是将控制器方法返回的对象通过适当的转换器转换为指定格式之后，写入到response对象的body区，通常用来<strong>返回JSON数据</strong>或者是XML数据。</p><ul><li>注意：使用此注解后不会在走视图解析器，而是直接将数据写入到输出流中，效果等同于通过response对象输出指定格式数据(<code>response.getWriter.write(JSONObject.fromObject(user).toString());</code>)。</li></ul><h4 id="2-示例-2"><a href="#2-示例-2" class="headerlink" title="2. 示例"></a>2. 示例</h4><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RequestMapping(&quot;&#x2F;testResponseBody&quot;)@ResponseBodypublic Student testResponseBody(){    return new Student(&quot;小明&quot;,&quot;男&quot;);}</code></pre><ul><li>访问页面结果：<code>{&quot;name&quot;:&quot;小明&quot;,&quot;sex&quot;:&quot;男&quot;}</code></li><li>因返回值满足key-value(对象或map)格式，所以会自动将响应头的Content-Type设置为了<code>application/html;charset=utf-8</code>，然后把转换后的内容以输出流的形式响应给客户端。</li></ul><blockquote><p>注意：使用该注解返回json数据还需额外jar包：jackson，依赖坐标如下</p><pre><code class="xml">&lt;!--添加对json数据的支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt;&lt;/dependency&gt;</code></pre></blockquote><ul><li>如果返回是字符串类型，控制器代码如下</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RequestMapping(value = &quot;&#x2F;testResponseBody&quot;,produces = &quot;text&#x2F;html;charset=utf-8&quot;) @ResponseBodypublic String testResponseBody(){    return &quot;你好!&quot;;}</code></pre><ul><li>访问结果：<code>你好!</code></li><li>如果返回值不能解析为json格式，注解就会将其直接以输出流形式输出到页面上。</li></ul><blockquote><p>注：使用produces设置响应头Content-Type为<code>text/html;charset=utf-8</code>解决中文乱码问题。</p></blockquote><h3 id="4-4-PathVaribale"><a href="#4-4-PathVaribale" class="headerlink" title="4.4 @PathVaribale"></a>4.4 @PathVaribale</h3><h4 id="1-使用说明-3"><a href="#1-使用说明-3" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h4><p>路径变量，用于绑定 url 中的占位符。例如：请求url中/delete/{id}，这个{id}就是url占位符。url 支持占位符是 Spring3.0 之后加入的，是 SpringMVC支持<strong>REST风格</strong>URL的一个重要标志。</p><ul><li>属性<ul><li>value：用于指定url中占位符名称。</li><li>required：是否必须提供占位符。</li></ul></li></ul><h4 id="2-示例-3"><a href="#2-示例-3" class="headerlink" title="2. 示例"></a>2. 示例</h4><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * PathVaribale：用于绑定 url 中的占位符     *&#x2F;@RequestMapping(&quot;&#x2F;usePathVariable&#x2F;{id}&quot;)public String usePathVariable(@PathVariable(&quot;id&quot;) Integer id){    System.out.println(id);    return &quot;success&quot;;}</code></pre><ul><li>jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;3. 测试@PathVaribale注解&lt;&#x2F;h3&gt;&lt;a href=&quot;&#x2F;anno&#x2F;usePathVariable&#x2F;100&quot;&gt;PathVariable注解的使用&lt;&#x2F;a&gt;</code></pre><ul><li>测试结构：<code>100</code></li></ul><h4 id="3-关于REST风格URL"><a href="#3-关于REST风格URL" class="headerlink" title="3. 关于REST风格URL"></a>3. 关于REST风格URL</h4><ul><li>什么是REST：<ul><li><strong>表现层状态转换</strong>（REST，英文：<strong>Representational State Transfer</strong>），一种万维网软件架构风格，目的是便于不同软件/程序在网络中互相传递信息。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。</li></ul></li></ul><p><a href="https://www.jianshu.com/p/c5c83872dad2" target="_blank" rel="noopener">详细内容见文章</a></p><ul><li>RESTful的优点：结构清晰、符合标准、易于理解、扩展方便。RESTful可以通过一套统一的接口为 Web、iOS和Android提供服务，另外对于很多平台来说（比如像Facebook，Twiter、微博、微信等开放平台），它们不需要有显式的前端，只需要一套提供服务的接口，于是RESTful便是它们最好的选择。</li><li>RESTful的特性<ul><li><strong>资源(Resources)</strong>：网络上的一个实体，或说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。通过一个URI来指向它。</li><li><strong>表现层(Representation)</strong>：把资源具体呈现出来的形式，叫做它的表现层。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。</li><li><strong>状态转化(Status Transfer)</strong>：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”。而这种转化是建立在表现层上的。所以就是“表现层状态转化”。具体说，就是HTTP协议里面，四个表示操作方式的动词以及对应的基本操作：GET(获取资源)、POST(新建资源)、PUT(更新资源)、DELETE(删除资源)。</li></ul></li></ul><h4 id="4-基于HiddentHttpMethodFilter的REST风格示例-了解"><a href="#4-基于HiddentHttpMethodFilter的REST风格示例-了解" class="headerlink" title="4. 基于HiddentHttpMethodFilter的REST风格示例[了解]"></a>4. 基于HiddentHttpMethodFilter的REST风格示例[了解]</h4><ul><li><p>作用：</p><ul><li>由于浏览器form表单只支持GET和POST请求，而DELETE、PUT等method并不支持，Spring3.0添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持DELETE和PUT请求。</li></ul></li><li><p>使用步骤：</p><ul><li>第一步：在web.xml中配置该过滤器</li><li>第二步：请求方式必须使用POST请求</li><li>第三部：按照要求提供_method请求参数，该参数的取值就是我们需要的请求方式。</li></ul></li><li><p>示例代码</p><ul><li>jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">  &lt;!-- 更新 --&gt;  &lt;form action=&quot;springmvc&#x2F;testRestPUT&#x2F;1&quot; method=&quot;post&quot;&gt;      用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&#x2F;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt;      &lt;input type=&quot;submit&quot; value=&quot;更新&quot;&gt;  &lt;&#x2F;form&gt;</code></pre></li></ul><ul><li><p>控制器</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;**  * put 请求：更新  * @param username  * @return  *&#x2F;  @RequestMapping(value=&quot;&#x2F;testRestPUT&#x2F;{id}&quot;,method=RequestMethod.PUT)  public String testRestfulURLPUT(@PathVariable(&quot;id&quot;)Integer id,User user){      System.out.println(&quot;rest put &quot;+id+&quot;,&quot;+user);      return &quot;success&quot;;  }</code></pre></li></ul><h3 id="4-5-RequestHeader"><a href="#4-5-RequestHeader" class="headerlink" title="4.5 @RequestHeader"></a>4.5 @RequestHeader</h3><h4 id="1-使用说明-4"><a href="#1-使用说明-4" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h4><ul><li>作用：用于获取请求消息头</li><li>属性<ul><li>value：提供消息头名称</li><li>required：是否必须有此消息头</li></ul></li></ul><blockquote><p>了解即可，一般不用</p></blockquote><h4 id="2-示例-4"><a href="#2-示例-4" class="headerlink" title="2. 示例"></a>2. 示例</h4><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * RequestHeader：用于获取请求消息头。     *&#x2F;@RequestMapping(&quot;&#x2F;useRequestHeader&quot;)public String useRequestHeader(@RequestHeader(value = &quot;Accept-Language&quot;,required = false)String requestHeader){    System.out.println(requestHeader);    return &quot;success&quot;;}</code></pre><ul><li>jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;4. 测试@RequestHeader注解&lt;&#x2F;h3&gt;&lt;a href=&quot;&#x2F;anno&#x2F;useRequestHeader&quot;&gt;获取请求消息头&lt;&#x2F;a&gt;</code></pre><ul><li>结果：<code>zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7</code></li></ul><h3 id="4-6-CookieValue"><a href="#4-6-CookieValue" class="headerlink" title="4.6 @CookieValue"></a>4.6 @CookieValue</h3><h4 id="1-使用说明-5"><a href="#1-使用说明-5" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h4><ul><li>作用：用于把指定cookie名称的值传入控制器方法参数</li><li>属性：<ul><li>value：指定cookie的名称</li><li>required：是否必须有此cookie</li></ul></li></ul><h4 id="2-示例-5"><a href="#2-示例-5" class="headerlink" title="2. 示例"></a>2. 示例</h4><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * @CookieValue：用于把指定cookie名称的值传入控制器方法参数。     * @param cookieValue     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;useCookieValue&quot;)public String useCookieValue(@CookieValue(value = &quot;JSESSIONID&quot;,required = false)String cookieValue){    System.out.println(cookieValue);    return &quot;success&quot;;}</code></pre><ul><li>jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;5. 测试@CookieValue&lt;&#x2F;h3&gt;&lt;a href=&quot;&#x2F;anno&#x2F;useCookieValue&quot;&gt;绑定cookie的值&lt;&#x2F;a&gt;</code></pre><ul><li>结果：<code>C8001453C280DF881950883018287F9C</code></li></ul><h3 id="4-7-ModelAttribute"><a href="#4-7-ModelAttribute" class="headerlink" title="4.7 @ModelAttribute"></a>4.7 @ModelAttribute</h3><h4 id="1-使用说明-6"><a href="#1-使用说明-6" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h4><ul><li>作用：该注解是SpringMVC4.3版本以后新加入的。它可以用于修饰方法和参数。<ul><li><strong>出现在方法上</strong>，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰有具体返回值的方法，也可以修饰没有返回值的方法。</li><li><strong>出现在参数上</strong>，获取指定的数据给参数赋值。</li></ul></li><li>属性：<ul><li>value：用于获取数据的key。key可以是POJO的属性名称，也可以是map结构的key。</li></ul></li><li>应用场景<ul><li>当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。</li></ul></li></ul><h4 id="2-示例-6"><a href="#2-示例-6" class="headerlink" title="2. 示例"></a>2. 示例</h4><ul><li><p>基于POJO属性的基本使用</p><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;**       * 出现在方法上：       *    被ModelAttribute 修饰的方法       *    当前方法会在控制器的方法执行之前，先执行。       * @param user       *&#x2F;  @ModelAttribute  public void showModel(User user){      System.out.println(&quot;执行了showModel方法&quot;+user.getName());  }    &#x2F;**       * 接收请求的方法       * @param user       * @return       *&#x2F;  @RequestMapping(&quot;&#x2F;testModelAttribute&quot;)  public String testModelAttribute(User user) {      System.out.println(&quot;执行了控制器的方法&quot;+user.getName());      return &quot;success&quot;;  }</code></pre></li></ul><ul><li><p>jsp</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">  &lt;h3&gt;6. 测试@ModelAttribute&lt;&#x2F;h3&gt;  &lt;a href=&quot;&#x2F;anno&#x2F;testModelAttribute?name=test&quot;&gt;测试ModelAttribute注解的使用&lt;&#x2F;a&gt;</code></pre></li></ul><ul><li>测试结果：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">  执行了showModel方法test  执行了控制器的方法test</code></pre></li></ul><ul><li><p>基于Map的应用场景示例：修饰方法带返回值</p><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;**       * 出现在方法上：       *    被ModelAttribute 修饰的方法       *    当前方法会在控制器的方法执行之前，先执行。       *    在控制器执行前，查询数据库中用户信息       * @param name       *&#x2F;  @ModelAttribute  public User showModel(String name){      &#x2F;&#x2F; 调用数据库查询方法，返回用户对象      User user = findUserByName(name);      System.out.println(&quot;执行了findUser方法&quot;+user);      return user;  }    &#x2F;**       * 模拟修改用户方法       * @param user       * @return       *&#x2F;  @RequestMapping(&quot;&#x2F;updateUser&quot;)  public String updateUser(User user) {      System.out.println(&quot;控制器中处理请求的方法：修改用户&quot;+user);      return &quot;success&quot;;  }    &#x2F;**       * 模拟数据库查询操作       * @param name       * @return       *&#x2F;  private User findUserByName(String name) {      User user = new User();      user.setName(name);      user.setAge(19);      user.setDate(new Date());      return user;  }</code></pre></li></ul><ul><li><p>jsp</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">  &lt;h4&gt;6.1 2 基于Map应用场景示例：修饰方法带返回值&lt;&#x2F;h4&gt;  &lt;form action=&quot;&#x2F;anno&#x2F;updateUser&quot; method=&quot;post&quot;&gt;      用户名称：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;      年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;      &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;  &lt;&#x2F;form&gt;</code></pre></li></ul><ul><li><p>测试结果：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">  执行了findUser方法User{name=&#39;小王&#39;, age=19, date=Sun Sep 01 17:02:46 CST 2019}  控制器中处理请求的方法：修改用户User{name=&#39;小王&#39;, age=11, date=Sun Sep 01 17:02:46 CST 2019}</code></pre></li></ul><ul><li><p>基于Map的应用场景示例：修饰方法不带返回值</p><ul><li>前端代码不变，修改控制器方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @ModelAttribute  public void showModel(String name, Map&lt;String,User&gt; map){      &#x2F;&#x2F; 调用数据库查询方法，返回用户对象      User user = findUserByName(name);      System.out.println(&quot;showModel&quot;+System.identityHashCode(user));      System.out.println(&quot;执行了findUser方法&quot;+user);      map.put(&quot;user&quot;,user);  }    @RequestMapping(&quot;&#x2F;updateUser&quot;)      public String updateUser(@ModelAttribute(&quot;user&quot;) User user) {          System.out.println(&quot;update&quot;+System.identityHashCode(user));          System.out.println(&quot;控制器中处理请求的方法：修改用户&quot;+user);          return &quot;success&quot;;      }</code></pre></li></ul><h3 id="4-8-SessionAttribute"><a href="#4-8-SessionAttribute" class="headerlink" title="4.8 @SessionAttribute"></a>4.8 @SessionAttribute</h3><h4 id="1-使用说明-7"><a href="#1-使用说明-7" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h4><ul><li>作用：用于多次执行控制器方法间的参数共享</li><li>属性<ul><li>value：用于指定存入的属性名称</li><li>type：用于指定存入的数据类型</li></ul></li></ul><h4 id="2-示例-7"><a href="#2-示例-7" class="headerlink" title="2. 示例"></a>2. 示例</h4><h5 id="2-1-存储值"><a href="#2-1-存储值" class="headerlink" title="2.1 存储值"></a>2.1 存储值</h5><ul><li>控制器代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;anno&quot;)@SessionAttributes(value = {&quot;msg&quot;}) &#x2F;&#x2F; @SessionAttributes该注解只能作用在类上，这里使用效果是将msg再存一份到session域中public class AnnotationController {    &#x2F;**     * SessionAttribute注解     * 将值存储到request域中     * @return     *&#x2F;    @RequestMapping(&quot;&#x2F;useSessionAttribute&quot;)    public String useSessionAttribute(Model model) {        &#x2F;&#x2F; 底层会存储到request域对象中        model.addAttribute(&quot;msg&quot;,&quot;小明&quot;);        return &quot;success&quot;;    }}</code></pre><ul><li>Anno.jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h3&gt;7. 测试@SessionAttribute&lt;&#x2F;h3&gt;&lt;a href=&quot;&#x2F;anno&#x2F;useSessionAttribute&quot;&gt;使用SessionAttribute存储值&lt;&#x2F;a&gt;&lt;br&gt;</code></pre><ul><li>success.jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;body&gt;&lt;h3&gt;测试程序访问成功&lt;&#x2F;h3&gt;存储到request域中：${msg}&lt;br&gt;存储到session域中：${sessionScope}&lt;&#x2F;body&gt;</code></pre><ul><li>测试结果：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">测试程序访问成功存储到request域中：小明 存储到session域中：{msg=小明}</code></pre><h5 id="2-2-获取值"><a href="#2-2-获取值" class="headerlink" title="2.2 获取值"></a>2.2 获取值</h5><ul><li>控制器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 获取值     * @param map     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;getSessionAttribute&quot;)public String getSessionAttribute(ModelMap map) { &#x2F;&#x2F; model无法获取，只能通过它的实现类ModelMap来获取    System.out.println(&quot;getSessionAttribute....&quot;);    &#x2F;&#x2F; 获取存储在request域中的数据    String msg = (String) map.get(&quot;msg&quot;);    System.out.println(msg);    return &quot;success&quot;;}</code></pre><ul><li>jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;a href=&quot;&#x2F;anno&#x2F;getSessionAttribute&quot;&gt;获取值&lt;&#x2F;a&gt;&lt;br&gt;</code></pre><ul><li>测试结果，后台显示：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">getSessionAttribute....小明</code></pre><h5 id="2-3-清除值"><a href="#2-3-清除值" class="headerlink" title="2.3 清除值"></a>2.3 清除值</h5><ul><li>控制器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 删除值     * @param status     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;delSessionAttribute&quot;)public String delSessionAttribute(SessionStatus status) {    System.out.println(&quot;delSessionAttribute....&quot;);    status.setComplete(); &#x2F;&#x2F; 删除session域中存储的值    return &quot;success&quot;;}</code></pre><ul><li>jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;a href=&quot;&#x2F;anno&#x2F;delSessionAttribute&quot;&gt;删除值&lt;&#x2F;a&gt;</code></pre><ul><li>测试结果，后台显示：<code>delSessionAttribute....</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC入门</title>
      <link href="/FrameWork/SpringMVC-Basic.html"/>
      <url>/FrameWork/SpringMVC-Basic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-SpringMVC-入门"><a href="#1-SpringMVC-入门" class="headerlink" title="1. SpringMVC 入门"></a>1. SpringMVC 入门</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>Spring MVC是Spring提供的一个强大而灵活的web框架，目前最好的实现MVC设计模式的框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，提供Spring的依赖注入功能，这些bean被注入到控制器中。</p><a id="more"></a><p>Spring MVC主要由DispatcherServlet、处理器映射、适配器、控制器、视图解析器、视图组成。</p><h3 id="1-2-MVC设计模式"><a href="#1-2-MVC设计模式" class="headerlink" title="1.2 MVC设计模式"></a>1.2 MVC设计模式</h3><p> MVC是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式。</p><ul><li>Controller：负责接收并处理用户请求，响应客户端。</li><li>Model：模型数据，业务逻辑。</li><li>View：展示模型，与用户进行交互。</li></ul><h3 id="1-3-SpringMVC核心组件"><a href="#1-3-SpringMVC核心组件" class="headerlink" title="1.3 SpringMVC核心组件"></a>1.3 SpringMVC核心组件</h3><ol><li>DispatcherServlet：前置控制器。</li><li>HandlerMapping：将请求映射到Handler。</li><li>Handler：后端控制器，完成具体业务逻辑。</li><li>HandlerInterceptor：处理器拦截器。</li><li>HandlerExecutionChain：处理器执行链。</li><li>HandlerAdapter：处理器适配器。</li><li>ModelAndView：装载模型数据和视图信息。</li><li>ViewResolver：视图解析器。</li></ol><h3 id="1-4-SpringMVC实现流程"><a href="#1-4-SpringMVC实现流程" class="headerlink" title="1.4 SpringMVC实现流程"></a>1.4 SpringMVC实现流程</h3><ol><li>客户端请求被DispatcherServlet接收。</li><li>DispatcherServlet将请求映射到Handler。</li><li>生成Handler以及HandlerInterceptor。</li><li>返回HandlerExecutionChain(Handler+HandlerInterceptor)。</li><li>DispatcherServlet通过HandlerAdapter执行Handler。</li><li>返回一个ModelAndView。</li><li>DispatcherServlet通过ViewResolver进行解析。</li><li>返回填充了模型数据的View，响应给客户端。</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/29/mvc-1567090970613.jpg" alt="mvc"></p><h2 id="2-SpringMVC快速开发"><a href="#2-SpringMVC快速开发" class="headerlink" title="2. SpringMVC快速开发"></a>2. SpringMVC快速开发</h2><p>大部分组件由框架提供，开发者只需通过配置进行关联。开发者只需手动编写Handler和View。</p><h3 id="2-1-基于XML配置的使用"><a href="#2-1-基于XML配置的使用" class="headerlink" title="2.1 基于XML配置的使用"></a>2.1 基于XML配置的使用</h3><ol><li>SpringMVC基础配置</li><li>XML配置Controller，HandlerMapping组件映射。</li><li>XML配置ViewResolver组件映射。</li></ol><h4 id="2-1-1-示例"><a href="#2-1-1-示例" class="headerlink" title="2.1.1 示例"></a>2.1.1 示例</h4><ul><li>使用maven创建一个简单的web项目，修改pom包导入相关jar包</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;        &lt;version&gt;4.12&lt;&#x2F;version&gt;        &lt;scope&gt;test&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;    &lt;!--导入SpringMVC所需jar包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;        &lt;version&gt;4.3.1.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--导入servlet相关jar包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.1.0&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre><ul><li>创建MyHandler控制器，完成具体业务逻辑</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class MyHandler implements Controller {    @Override    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception {        &#x2F;&#x2F; 装载模型数据和逻辑视图        ModelAndView modelAndView = new ModelAndView();        &#x2F;&#x2F; 添加模型数据        modelAndView.addObject(&quot;name&quot;,&quot;Tom&quot;);        &#x2F;&#x2F; 添加逻辑视图        modelAndView.setViewName(&quot;show&quot;);        return modelAndView;    }}</code></pre><ul><li>创建show.jsp，做前端显示</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    ${name}&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>资源文件夹resources下创建springmvc.xml的配置文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;    &lt;!--URL处理映射的方式有三种：1. BeanNameUrlHandlerMapping：通过url名字，找到对应的bean的name的控制器2. 在SimpleUrlHandlerMapping中配置：通过key找到bean3. ControllerClassNameHandlerMapping：通过类名--&gt;    &lt;!--1. 配置HandlerMapping，将url请求映射到Handler--&gt;    &lt;bean id=&quot;handlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;        &lt;!--配置简单url映射--&gt;        &lt;property name=&quot;mappings&quot;&gt;            &lt;props&gt;                &lt;!--2. 配置test请求对应的handler--&gt;                &lt;prop key=&quot;&#x2F;test&quot;&gt;testHandler&lt;&#x2F;prop&gt;            &lt;&#x2F;props&gt;        &lt;&#x2F;property&gt;    &lt;&#x2F;bean&gt;    &lt;!--3. 配置控制器--&gt;    &lt;bean id=&quot;testHandler&quot; class=&quot;com.zero.handler.MyHandler&quot;&#x2F;&gt;    &lt;!--4. 配置视图解析器--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!--配置前缀--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;&#x2F;&quot;&#x2F;&gt;        &lt;!--配置后缀--&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><ul><li>在web.xml下配置DispatcherServlet</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;         xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot;         version=&quot;3.1&quot;&gt;  &lt;!-- 配置：所有请求由SpringMVC管理 --&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;  &lt;&#x2F;servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;    &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt;  &lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt;</code></pre><ul><li>启动服务器，访问/test.do路径资源，查看是否显示姓名。</li></ul><h3 id="2-2-基于注解方式的使用-重要"><a href="#2-2-基于注解方式的使用-重要" class="headerlink" title="2.2 基于注解方式的使用[重要]"></a>2.2 基于注解方式的使用[重要]</h3><ol><li>SpringMVC基础配置。</li><li>Controller，HandlerMapping通过<strong>注解进行映射。</strong></li><li>XML中配置ViewResolver组件映射。</li></ol><h4 id="2-2-1-示例"><a href="#2-2-1-示例" class="headerlink" title="2.2.1 示例"></a>2.2.1 示例</h4><ul><li>其余配置不变，新建一个控制器类，使用注解声明</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 基于注解实现映射@Controllerpublic class AnnotationHandler {    &#x2F;**     * 业务方法1：ModelAndView完成数据的传递，视图的解析     *&#x2F;    @RequestMapping(&quot;&#x2F;modelAndViewTest&quot;)    public ModelAndView modelAndViewTest(){        &#x2F;&#x2F; 创建ModelAndView对象        ModelAndView modelAndView = new ModelAndView();        &#x2F;&#x2F; 填充模型数据        modelAndView.addObject(&quot;name&quot;,&quot;Tom&quot;);        &#x2F;&#x2F; 设置逻辑视图        modelAndView.setViewName(&quot;show&quot;);        return modelAndView;    }    &#x2F;**     * 业务方法2：Model传值，String进行视图解析     * @return     *&#x2F;    @RequestMapping(&quot;&#x2F;modelTest&quot;)    public String ModelTest(Model model){        &#x2F;&#x2F; 填充模型数据        model.addAttribute(&quot;name&quot;,&quot;Jerry&quot;);        &#x2F;&#x2F; 设置逻辑视图        return &quot;show&quot;;    }    &#x2F;**     * 业务方法3：Map传值，String进行视图解析     *&#x2F;    @RequestMapping(&quot;&#x2F;mapTest&quot;)    public String MapTest(Map&lt;String,String&gt; map){        &#x2F;&#x2F; 填充模型数据        map.put(&quot;name&quot;,&quot;Cat&quot;);        &#x2F;&#x2F; 设置逻辑视图        return &quot;show&quot;;    }}</code></pre><ul><li>mvc配置文件中，开启自动扫描，并删除前面配置的两个bean对象即可</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--1. 配置自动扫描包--&gt;&lt;context:component-scan base-package=&quot;com.zero.backoffice.web.controller&quot;&#x2F;&gt;</code></pre><ul><li>重启服务器，访问<code>/modelAndViewTest</code>等资源路径，测试是否成功。</li></ul><h3 id="2-3-URL处理器映射-了解"><a href="#2-3-URL处理器映射-了解" class="headerlink" title="2.3 URL处理器映射[了解]"></a>2.3 URL处理器映射[了解]</h3><ul><li><p>BeanNameUrlHandlerMapping</p><ul><li>功能：寻找controller，根据url请求去匹配bean的name属性，找到对应的控制器。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;!-- 1. 配置处理器映射，mvc默认的处理器映射器       BeanNameUrlHandlerMapping:根据bean的name属性的url去找Controller --&gt;      &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&#x2F;&gt;    &lt;bean name=&quot;&#x2F;user.do&quot; class=&quot;com.zero.backoffice.web.controller.UserController&quot;&#x2F;&gt;</code></pre></li></ul><ul><li><p>SimpleUrlHandlerMapping</p><ul><li>功能：寻找controller，根据浏览器url匹配简单url的key，key就是通过controller的id找到对应的Controller</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;      &lt;property name=&quot;mappings&quot;&gt;      &lt;props&gt;          &lt;prop key=&quot;&#x2F;user1.do&quot;&gt;userController&lt;&#x2F;prop&gt;          &lt;&#x2F;props&gt;      &lt;&#x2F;property&gt;  &lt;&#x2F;bean&gt;  &lt;bean id=&quot;userController&quot; name=&quot;&#x2F;user.do&quot; class=&quot;com.zero.web.controller.UserController&quot;&#x2F;&gt;</code></pre></li></ul><ul><li><p>ControllerClassNameHandlerMapping</p><ul><li>功能：寻找controller，根据类名.do来访问，类名首字母小写。如下访问路径就是<code>userController.do</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;bean class=&quot;org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping&quot;&#x2F;&gt;  &lt;bean class=&quot;com.zero.backoffice.web.controller.UserController&quot;&#x2F;&gt;</code></pre></li></ul><h3 id="2-4-处理器适配器"><a href="#2-4-处理器适配器" class="headerlink" title="2.4 处理器适配器"></a>2.4 处理器适配器</h3><ul><li><p>SimpleControllerHandlerAdapter</p><ul><li>功能：执行controller，调用controller里面的方法，返回ModelAndView</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&#x2F;&gt;</code></pre></li></ul><ul><li><p>HttpRequestHandlerAdapter</p><ul><li>执行控制器：负责调用实现HttpRequestHandler接口的控制器</li></ul></li></ul><h3 id="2-5-乱码问题"><a href="#2-5-乱码问题" class="headerlink" title="2.5 乱码问题"></a>2.5 乱码问题</h3><ul><li>POST请求乱码，需在web.xml中配置编码过滤器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!-- 配置编码过滤器  --&gt;&lt;filter&gt;    &lt;filter-name&gt;EncodingFilter&lt;&#x2F;filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;        &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;    &lt;&#x2F;init-param&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;EncodingFilter&lt;&#x2F;filter-name&gt;&lt;&#x2F;filter-mapping&gt;</code></pre><ul><li>GET请求乱码：Tomcat8默认进行了url编码，故get请求不会乱码，tomcat7会乱码。</li></ul><h2 id="3-SpringMVC接收请求参数"><a href="#3-SpringMVC接收请求参数" class="headerlink" title="3. SpringMVC接收请求参数"></a>3. SpringMVC接收请求参数</h2><h3 id="3-1-封装参数分析"><a href="#3-1-封装参数分析" class="headerlink" title="3.1 封装参数分析"></a>3.1 封装参数分析</h3><ul><li>常用的数据绑定类型<ul><li>基本数据类型</li><li>包装类</li><li>数组</li><li>对象(POJO)</li><li>集合(List、Set、Map)</li><li>JSON</li></ul></li></ul><h3 id="3-2-接收基本数据类型"><a href="#3-2-接收基本数据类型" class="headerlink" title="3.2 接收基本数据类型"></a>3.2 接收基本数据类型</h3><ul><li>编写一个注册类register.jsp</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;body&gt;    &lt;form action=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;register.do&quot; method=&quot;post&quot;&gt;        用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;        密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt;        性别:&lt;input type=&quot;text&quot; name=&quot;gender&quot;&gt;&lt;br&gt;        年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;        生日:&lt;input type=&quot;text&quot; name=&quot;birthday&quot;&gt;&lt;br&gt;        爱好:&lt;input type=&quot;checkbox&quot; name=&quot;hobbyIds&quot; value=&quot;1&quot;&gt;打球             &lt;input type=&quot;checkbox&quot; name=&quot;hobbyIds&quot; value=&quot;2&quot;&gt;看书             &lt;input type=&quot;checkbox&quot; name=&quot;hobbyIds&quot; value=&quot;3&quot;&gt;玩游戏&lt;br&gt;        &lt;input type=&quot;submit&quot;&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;</code></pre><ul><li>控制器中新增注册方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;user&quot;)public class UserController{    @RequestMapping(&quot;&#x2F;toRegister&quot;)    public String toRegister(){        return &quot;user&#x2F;register&quot;;    }    &#x2F;**     * 第一种接收表单参数的方式：     *      直接在形参列表写要接受的参数     *      默认日期格式： MM&#x2F;DD&#x2F;YYYY     * @return     *&#x2F;    @RequestMapping(&quot;&#x2F;register&quot;)    public String register(String username, String password,                           int age, String gender, Date birthday,                           String[] hobbyIds){        System.out.println(username);        return &quot;user&#x2F;info&quot;;    }}</code></pre><h3 id="3-3-接收POJO类型"><a href="#3-3-接收POJO类型" class="headerlink" title="3.3 接收POJO类型"></a>3.3 接收POJO类型</h3><ul><li>模型类User新增对应属性</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class User {    private String username;    private String password;    private String gender;    private int age;    private String birthday;    private String[] hobbyIds;}</code></pre><ul><li>控制器中新增方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 第二种接收表单参数的方式：     *     使用POJO对象接收     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;register2&quot;)public String register2(User user){    System.out.println(user);    return &quot;user&#x2F;info&quot;;}</code></pre><ul><li><p>register.jsp中修改<code>&lt;form action=&quot;${pageContext.request.contextPath}/user/register.do&quot; method=&quot;post&quot;&gt;</code></p></li><li><p>info.jsp做数据展示</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;body&gt;&lt;h4&gt;用户信息&lt;&#x2F;h4&gt;用户名:${user.username}&lt;br&gt;密码:${user.password}&lt;br&gt;性别:${user.gender}&lt;br&gt;年龄:${user.age}&lt;br&gt;生日:${user.birthday}&lt;br&gt;爱好:${user.hobbyIds}&lt;br&gt;&lt;&#x2F;body&gt;</code></pre><h3 id="3-4-接收包装类型参数"><a href="#3-4-接收包装类型参数" class="headerlink" title="3.4 接收包装类型参数"></a>3.4 接收包装类型参数</h3><ul><li>创建UserExt类，把User写成一个类的属性，模型里面有模型</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserExt {    private User user;    @Override    public String toString() {        return &quot;UserExt{&quot; +                &quot;user=&quot; + user +                &#39;}&#39;;    }    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}</code></pre><ul><li>控制器添加注册方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 第三种接收表单参数的方式：接收包装类型参数     *     使用包装类，相当于模型里面有模型     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;register3&quot;)public String register3(UserExt user){    System.out.println(user);    return &quot;user&#x2F;info&quot;;}</code></pre><ul><li>修改form表单</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;body&gt;    &lt;form action=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;register3.do&quot; method=&quot;post&quot;&gt;        用户名:&lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt;&lt;br&gt;        密码:&lt;input type=&quot;text&quot; name=&quot;user.password&quot;&gt;&lt;br&gt;        性别:&lt;input type=&quot;text&quot; name=&quot;user.gender&quot;&gt;&lt;br&gt;        年龄:&lt;input type=&quot;text&quot; name=&quot;user.age&quot;&gt;&lt;br&gt;        生日:&lt;input type=&quot;text&quot; name=&quot;user.birthday&quot;&gt;&lt;br&gt;        爱好:&lt;input type=&quot;checkbox&quot; name=&quot;user.hobbyIds&quot; value=&quot;1&quot;&gt;打球             &lt;input type=&quot;checkbox&quot; name=&quot;user.hobbyIds&quot; value=&quot;2&quot;&gt;看书             &lt;input type=&quot;checkbox&quot; name=&quot;user.hobbyIds&quot; value=&quot;3&quot;&gt;玩游戏&lt;br&gt;        &lt;input type=&quot;submit&quot;&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;</code></pre><h3 id="3-5-接收List集合类型参数"><a href="#3-5-接收List集合类型参数" class="headerlink" title="3.5 接收List集合类型参数"></a>3.5 接收List集合类型参数</h3><ul><li>修改UserExt类，添加list集合属性</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserExt {    private User user;    private List&lt;User&gt; users = new ArrayList&lt;&gt;();    @Override    public String toString() {        return &quot;UserExt{&quot; +                &quot;user=&quot; + user +                &quot;, users=&quot; + users +                &#39;}&#39;;    }    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }    public List&lt;User&gt; getUsers() {        return users;    }    public void setUsers(List&lt;User&gt; users) {        this.users = users;    }}</code></pre><ul><li>register.jsp中新增一个测试form表单</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h4&gt;接收集合类型的参数&lt;&#x2F;h4&gt;&lt;form action=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;register4.do&quot; method=&quot;post&quot;&gt;    用户名1:&lt;input type=&quot;text&quot; name=&quot;users[0].username&quot;&gt;&lt;br&gt;    密码1:&lt;input type=&quot;text&quot; name=&quot;users[0].password&quot;&gt;&lt;br&gt;    &lt;hr&gt;    用户名2:&lt;input type=&quot;text&quot; name=&quot;users[1].username&quot;&gt;&lt;br&gt;    密码2:&lt;input type=&quot;text&quot; name=&quot;users[1].password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;&#x2F;form&gt;</code></pre><ul><li>添加注册方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 第四种接收表单参数的方式：接收List集合类型参数     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;register4&quot;)public String register4(UserExt user){    System.out.println(user.getUsers());    return &quot;user&#x2F;info&quot;;}</code></pre><h3 id="3-6-接收Map集合类型参数"><a href="#3-6-接收Map集合类型参数" class="headerlink" title="3.6 接收Map集合类型参数"></a>3.6 接收Map集合类型参数</h3><ul><li>UserExt添加一个map集合属性</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserExt {    private User user;    private List&lt;User&gt; users = new ArrayList&lt;&gt;();    private Map&lt;String,Object&gt; infos = new HashMap&lt;String,Object&gt;(); &#x2F;&#x2F; 使用map来接收参数}</code></pre><ul><li>添加注册方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 第五种接收表单参数的方式：接收Map集合类型参数     * @return     *&#x2F;@RequestMapping(&quot;&#x2F;register5&quot;)public String register5(UserExt user){    System.out.println(user.getInfos());    return &quot;user&#x2F;info&quot;;}</code></pre><ul><li>修改表单</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;h4&gt;    表单数据用map接收&lt;&#x2F;h4&gt;&lt;form action=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;register5.do&quot; method=&quot;post&quot;&gt;        用户名:&lt;input type=&quot;text&quot; name=&quot;infos[&#39;username&#39;]&quot;&gt;&lt;br&gt;        密码:&lt;input type=&quot;text&quot; name=&quot;infos[&#39;password&#39;]&quot;&gt;&lt;br&gt;        性别:&lt;input type=&quot;text&quot; name=&quot;infos[&#39;gender&#39;]&quot;&gt;&lt;br&gt;        年龄:&lt;input type=&quot;text&quot; name=&quot;infos[&#39;age&#39;]&quot;&gt;&lt;br&gt;        &lt;input type=&quot;submit&quot;&gt;&lt;&#x2F;form&gt;</code></pre><h2 id="4-页面回显"><a href="#4-页面回显" class="headerlink" title="4. 页面回显"></a>4. 页面回显</h2><ul><li>控制器配置一个列表方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RequestMapping(&quot;&#x2F;list&quot;)    public String userlist(Model model){        &#x2F;&#x2F; 1. 模拟一个数据库中的数据        List&lt;User&gt; users = new ArrayList&lt;&gt;();        users.add(new User(&quot;小明&quot;,&quot;male&quot;,22,&quot;2018&quot;));        users.add(new User(&quot;小李&quot;,&quot;male&quot;,12,&quot;2019&quot;));        users.add(new User(&quot;小哈&quot;,&quot;male&quot;,32,&quot;2014&quot;));        &#x2F;&#x2F; 将数据存储到model中        model.addAttribute(&quot;userList&quot;,users);        return &quot;user&#x2F;userList&quot;;    }</code></pre><ul><li>前端jsp展示数据</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;UserList&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;用户列表:&lt;table border=&quot;1&quot;&gt;    &lt;tr&gt;        &lt;td&gt;姓名：&lt;&#x2F;td&gt;        &lt;td&gt;年龄&lt;&#x2F;td&gt;        &lt;td&gt;性别&lt;&#x2F;td&gt;        &lt;td&gt;生日&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;    &lt;c:forEach items=&quot;${userList}&quot; var=&quot;user&quot;&gt;        &lt;tr&gt;            &lt;td&gt;${user.username}&lt;&#x2F;td&gt;            &lt;td&gt;${user.age}&lt;&#x2F;td&gt;            &lt;td&gt;${user.gender}&lt;&#x2F;td&gt;            &lt;td&gt;${user.birthday}&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;c:forEach&gt;&lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>修改用户方法示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 编辑页面@RequestMapping(&quot;&#x2F;edit&quot;)public String edit(Integer id, Model model){    &#x2F;&#x2F; 模拟通过id在数据库中查询数据,返回一个user对象，再将user对象存入model    System.out.println(&quot;修改的用户id:&quot;+id);    User user = new User(id, &quot;小明&quot;, &quot;male&quot;, 22, &quot;2018&quot;);    model.addAttribute(&quot;user&quot;,user);    return &quot;user&#x2F;userEdit&quot;;}&#x2F;&#x2F; 修改用户信息@RequestMapping(&quot;&#x2F;update&quot;)public String update(Integer id,Model model){    System.out.println(&quot;修改的用户id:&quot;+id);    return &quot;user&#x2F;userList&quot;;}</code></pre><ul><li>编辑jsp界面</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Edit&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form action=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;update.do?id=${user.id}&quot; method=&quot;post&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;${user.username}&quot;&gt;&lt;br&gt;    年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;${user.age}&quot;&gt;&lt;br&gt;    性别：&lt;input type=&quot;text&quot; name=&quot;gender&quot; value=&quot;${user.gender}&quot;&gt;&lt;br&gt;    生日：&lt;input type=&quot;text&quot; name=&quot;birthday&quot; value=&quot;${user.birthday}&quot;&gt;&lt;br&gt;    &lt;button type=&quot;submit&quot; value=&quot;提交修改&quot;&#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="5-URL模板映射"><a href="#5-URL模板映射" class="headerlink" title="5. URL模板映射"></a>5. URL模板映射</h2><p>模板映射可以RESTful软件架构风格。</p><ul><li>修改url格式，体验RESTful</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;a href=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;edit1&#x2F;${user.id}.do&quot;&gt;RESTful修改&lt;&#x2F;a&gt;&lt;!--配置接收url模板映射：{}：匹配接收页面url路径参数--&gt;</code></pre><ul><li>控制器中添加方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 编辑页面,使用RESTful风格。{id}里面参数通过@PathVariable注入到后面参数Integer id中去@RequestMapping(&quot;&#x2F;edit1&#x2F;{id}&quot;)public String edit1(@PathVariable Integer id, Model model){    &#x2F;&#x2F; 模拟通过id在数据库中查询数据,返回一个user对象，再将user对象存入model    System.out.println(&quot;修改的用户id:&quot;+id);    User user = new User(id, &quot;小明&quot;, &quot;male&quot;, 22, &quot;2018&quot;);    model.addAttribute(&quot;user&quot;,user);    return &quot;user&#x2F;userEdit&quot;;}</code></pre><ul><li>需在web.xml中配置rest路径</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;servlet-mapping&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;    &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt;&lt;!--RESTful风格--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;    &lt;url-pattern&gt;&#x2F;rest&#x2F;*&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt;</code></pre><ul><li>测试页面，<code>http://localhost/rest/user/edit1/1</code></li></ul><h2 id="6-转发和重定向"><a href="#6-转发和重定向" class="headerlink" title="6. 转发和重定向"></a>6. 转发和重定向</h2><ul><li>转发到同一个控制器的方法：<code>forward</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 示例转发到list.do。同一个控制器中转发@RequestMapping(&quot;&#x2F;test1&quot;)public String test1(){    return &quot;forward:list.do&quot;;}</code></pre><ul><li>转发到不同的控制器</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;stu&quot;)public class StudentController {    &#x2F;&#x2F; 示例转发到list.do。不同控制器中转发,加上域名&#x2F;user即可    @RequestMapping(&quot;&#x2F;test1&quot;)    public String test1(){        return &quot;forward:&#x2F;user&#x2F;list.do&quot;;    }}</code></pre><ul><li>重定向，只需改成<code>redirect</code>即可</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;stu&quot;)public class StudentController {    &#x2F;&#x2F; 示例重定向到list.do。不同控制器中转发    @RequestMapping(&quot;&#x2F;test1&quot;)    public String test1(){        return &quot;redirect:&#x2F;user&#x2F;list.do&quot;;    }}</code></pre><h2 id="7-RequestParam"><a href="#7-RequestParam" class="headerlink" title="7. RequestParam"></a>7. RequestParam</h2><ul><li>该注解是对参数的一些说明描述<ul><li>value：参数名称</li><li>defaultValue：默认值</li><li>required：参数是否必须有值。如果为true，参数又是空且未定义默认值，则会报错。</li></ul></li></ul><ul><li>示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Controller@RequestMapping(&quot;stu&quot;)public class StudentController {    &#x2F;&#x2F; 示例注解请求参数配置    @RequestMapping(&quot;&#x2F;test1&quot;)    public String test1(@RequestParam(value = &quot;uid&quot;,required = true,defaultValue = &quot;1&quot;)Integer uid){        System.out.println(uid);        return &quot;redirect:&#x2F;user&#x2F;list.do&quot;;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis进阶</title>
      <link href="/FrameWork/MyBatis-advanced.html"/>
      <url>/FrameWork/MyBatis-advanced.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-MyBatis的关联查询"><a href="#1-MyBatis的关联查询" class="headerlink" title="1. MyBatis的关联查询"></a>1. MyBatis的关联查询</h2><h3 id="1-1-案例：用户和订单"><a href="#1-1-案例：用户和订单" class="headerlink" title="1.1 案例：用户和订单"></a>1.1 案例：用户和订单</h3><p>表结构如下：</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/25/user_orders-1566663584689.jpg" alt="user_orders"></p><ul><li>user和orders<ul><li>user与orders：一个用户可以创建多个订单，<strong>一对多。</strong></li><li>orders与user：多个订单只由一个用户创建，<strong>多对一</strong>。</li></ul></li><li>orders和orderdetail<ul><li>orders与orderdetail：一个订单可以包括多个订单明细，因为一个订单可以购买多个商品，每个商品购买信息在orderdetail记录，<strong>一对多关系</strong>。</li><li>orderdetail与orders：多个订单明细包括在一个订单中，<strong>多对一</strong>。</li></ul></li><li>orderdetail和items<ul><li>orderdetail与items：多个订单明细只对应一个商品信息，<strong>多对一</strong>。</li><li>items与orderdetail：一个商品可以包括在多个订单明细中，<strong>一对多</strong>。</li></ul></li></ul><h3 id="1-2-一对一：resultType实现"><a href="#1-2-一对一：resultType实现" class="headerlink" title="1.2 一对一：resultType实现"></a>1.2 一对一：resultType实现</h3><p>复杂查询时，单表对应的PO类已经不能满足结果集的映射。所以要根据需求<strong>建立一个扩展类</strong>来作为resultType的类型。</p><ul><li>创建订单类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Orders {    private int id;    private int user_id;    private String number;    private Date createtime;    private String note;&#x2F;&#x2F; 省略get&#x2F;set，toString}</code></pre><ul><li>创建订单类的扩展类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; Orders扩展类public class OrdersExt extends Orders {    private String username;    private String address;    @Override    public String toString() {        return &quot;OrdersExt{&quot; +                &quot;username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39; + super.toString();    }&#x2F;&#x2F; 省略get&#x2F;set}</code></pre><ul><li>声明订单接口</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface OrderMapper {    public OrdersExt findOrderById(int id);}</code></pre><ul><li>声明订单映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!--OrderMapper接口映射文件--&gt;&lt;mapper namespace=&quot;com.zero.mapper.OrderMapper&quot;&gt;    &lt;select id=&quot;findOrderById&quot; parameterType=&quot;int&quot; resultType=&quot;ordersExt&quot;&gt;        select            u.username,u.address,o.*        from            orders o,user u        where            u.`id`=o.`user_id`            and o.id = #{id}    &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre><ul><li>加载映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;mappers&gt;&lt;package name=&quot;com.zero.mapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class OrderMapperTest {    private SqlSession session = null;    @Before    public void before() throws IOException {        System.out.println(&quot;before:获取session&quot;);        &#x2F;&#x2F;1. 读取配置文件        InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;);        &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);        session = sessionFactory.openSession();    }    @After    public void after(){        System.out.println(&quot;after:关闭会话&quot;);        &#x2F;&#x2F;5. 关闭会话。        session.commit();        session.close();    }    &#x2F;&#x2F; 测试复杂查询一对一    @Test    public void test1(){        OrderMapper mapper = session.getMapper(OrderMapper.class);        OrdersExt order = mapper.findOrderById(3);        System.out.println(order);    }}</code></pre><h3 id="1-3-一对一：resultMap实现"><a href="#1-3-一对一：resultMap实现" class="headerlink" title="1.3 一对一：resultMap实现"></a>1.3 一对一：resultMap实现</h3><ul><li>Orders类中新增user属性，添加get/set方法，以存储订单所属用户</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Orders {    private Integer id;    private Integer user_id;    private String number;    private Date createtime;    private String note;    private User user; &#x2F;&#x2F; 订单所属用户        public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }    &#x2F;&#x2F; 注意toString方法要添加user信息}</code></pre><ul><li>mapper接口新增方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public Orders findOrderById2(int id);</code></pre><ul><li>映射文件中添加查询，使用resultMap</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--如果模型里面有模型，使用resultMap--&gt;&lt;resultMap id=&quot;orderRslMap&quot; type=&quot;orders&quot;&gt;    &lt;!--往orders的模型匹配数据--&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;&#x2F;&gt;    &lt;id property=&quot;number&quot; column=&quot;number&quot;&#x2F;&gt;    &lt;id property=&quot;createtime&quot; column=&quot;createtime&quot;&#x2F;&gt;    &lt;id property=&quot;note&quot; column=&quot;note&quot;&#x2F;&gt;    &lt;!--往orders中的user匹配数据            使用association进行配置--&gt;    &lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;user_id&quot;&#x2F;&gt;        &lt;id property=&quot;username&quot; column=&quot;username&quot;&#x2F;&gt;        &lt;id property=&quot;address&quot; column=&quot;address&quot;&#x2F;&gt;    &lt;&#x2F;association&gt;&lt;&#x2F;resultMap&gt;&lt;select id=&quot;findOrderById2&quot; parameterType=&quot;int&quot; resultMap=&quot;orderRslMap&quot;&gt;    select    u.username,u.address,o.*    from    orders o,user u    where    u.`id`=o.`user_id`    and o.id = #{id}&lt;&#x2F;select&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 测试resultMap一对一@Testpublic void test2(){    OrderMapper mapper = session.getMapper(OrderMapper.class);    Orders order = mapper.findOrderById2(3);    System.out.println(order);}</code></pre><ul><li>小结：<ul><li>resultType：使用resultType实现较为简单，如果POJO中没有包括查询出来的列名， 则必须增加列名对应的属性，才可完成映射。<strong>如果没有查询结果的特殊要求建议使用resultType</strong>。</li><li>resultMap：需单独定义resultMap，实现较麻烦，如果对<strong>查询结果有特殊的要求</strong>，使用resultMap可以完成将关联查询映射到POJO的对象属性中。</li><li>resultMap可以实现延迟加载，resultType无法实现延迟加载。</li></ul></li></ul><h3 id="1-4-一对多"><a href="#1-4-一对多" class="headerlink" title="1.4 一对多"></a>1.4 一对多</h3><ul><li>需求：根据订单ID查找订单信息、用户信息和订单明细信息。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 根据订单ID查找订单信息、用户信息和订单明细信息。select   u.`username`,  u.`address`,  o.*,  od.id detail_id,  od.items_id,  od.items_numfrom   user u,  orders o,  orderdetail odwhere   u.`id`=o.`user_id`   and o.`id`=od.orders_id  and o.`id` = 3;</code></pre><ul><li>新建OrderDetail类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 订单详情实体类public class OrderDetail {    private Integer id; &#x2F;&#x2F; 订单详情id    private Integer items_id; &#x2F;&#x2F; 商品id    private Integer items_num; &#x2F;&#x2F; 商品数量&#x2F;&#x2F; 省略get&#x2F;set，toString}</code></pre><ul><li>修改Orders类，添加订单明细属性</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Orders {    private Integer id;    private Integer user_id;    private String number;    private Date createtime;    private String note;    private User user; &#x2F;&#x2F; 订单所属用户    &#x2F;&#x2F; 一对多数据封装：订单明细    private List&lt;OrderDetail&gt; orderDetails;}</code></pre><ul><li>mapper接口</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface OrderMapper {    public OrdersExt findOrderById(int id);    public Orders findOrderById2(int id);    &#x2F;&#x2F; 一对多关系映射配置    public Orders findOrderById3(int id);}</code></pre><ul><li>映射文件添加查询,resultMap中有个extends属性，可继承父类配置的数据映射关系。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!-- =========== 一对多 ============= --&gt;&lt;resultMap id=&quot;orderRslMap2&quot; type=&quot;orders&quot; extends=&quot;orderRslMap&quot;&gt; &lt;!--如果继承了orderRslMap 下面的orders和user模型无需再次编写。--&gt;    &lt;!--往orders的模型匹配数据--&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;&#x2F;&gt;    &lt;id property=&quot;number&quot; column=&quot;number&quot;&#x2F;&gt;    &lt;id property=&quot;createtime&quot; column=&quot;createtime&quot;&#x2F;&gt;    &lt;id property=&quot;note&quot; column=&quot;note&quot;&#x2F;&gt;    &lt;!--往orders中的user匹配数据            使用association进行配置--&gt;    &lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;user_id&quot;&#x2F;&gt;        &lt;id property=&quot;username&quot; column=&quot;username&quot;&#x2F;&gt;        &lt;id property=&quot;address&quot; column=&quot;address&quot;&#x2F;&gt;    &lt;&#x2F;association&gt;    &lt;!-- 一对多匹配：往orders中的orderDetails匹配数据            注意：集合里类型需使用ofType，而不是javaType--&gt;    &lt;collection property=&quot;orderDetails&quot; ofType=&quot;orderDetail&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;detail_id&quot;&#x2F;&gt;        &lt;id property=&quot;items_id&quot; column=&quot;items_id&quot;&#x2F;&gt;        &lt;id property=&quot;items_num&quot; column=&quot;items_num&quot;&#x2F;&gt;    &lt;&#x2F;collection&gt;&lt;&#x2F;resultMap&gt;&lt;select id=&quot;findOrderById3&quot; parameterType=&quot;int&quot; resultMap=&quot;orderRslMap2&quot;&gt;    select        u.`username`,        u.`address`,        o.*,        od.id detail_id,        od.items_id,        od.items_num    from        user u,        orders o,        orderdetail od    where        u.`id`=o.`user_id`        and o.`id`=od.orders_id        and o.`id` = #{id};&lt;&#x2F;select&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 测试resultMap一对一@Testpublic void test3(){    OrderMapper mapper = session.getMapper(OrderMapper.class);    Orders order = mapper.findOrderById3(3);    System.out.println(order);}</code></pre><h4 id="1-4-1-小结"><a href="#1-4-1-小结" class="headerlink" title="1.4.1 小结"></a>1.4.1 小结</h4><p>Mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。</p><h3 id="1-5-多对多"><a href="#1-5-多对多" class="headerlink" title="1.5 多对多"></a>1.5 多对多</h3><ul><li>需求：查询用户信息及用户购买的商品信息，要求将关系信息映射到主POJO的POJO属性中。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT   u.`id`,  u.`username`,  u.`address`,  o.`id` order_id,  o.`number`,  o.`createtime`,  o.`note`,  od.`id` detail_id,  od.`items_id`,  od.`items_num`,  it.`name`,  it.`price`,  it.`detail`FROM   user u,  orders o,  orderdetail od,  items itWHERE   u.`id` = o.`user_id`  and o.`id` = od.`orders_id`  and od.`items_id` = it.`id`;</code></pre><ul><li>映射思路<ul><li>将用户信息映射到user中。</li><li>在user类中添加订单列表属性<code>List&lt;Orders&gt; orderslist</code>，将用户创建的订单映射到orderslist中。</li><li>在Orders中添加订单明细列表属性<code>List&lt;Orderdetail&gt; detailList</code>，将订单的明细映射到detailList中。</li><li>在Orderdetail中添加Items属性，将订单明细所对应的商品映射到Items中。</li></ul></li></ul><ul><li>mapper中添加方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface UserMapper {&#x2F;&#x2F; 多对多查询:查询用户信息及用户购买的商品信息    public List&lt;User&gt; findUserAndOrderInfo();}</code></pre><ul><li>在user类中添加订单列表属性<code>List&lt;Orders&gt; orderslist</code>，将用户创建的订单映射到orderslist中。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class User implements Serializable {    private int id;    private String username;    private String sex;    private Date birthday;    private String address;    private List&lt;Orders&gt; orderList; &#x2F;&#x2F; 一个用户有多张订单}</code></pre><ul><li>在Orders中添加订单明细列表属性<code>List&lt;Orderdetail&gt; detailList</code>，将订单的明细映射到detailList中。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Orders {    private Integer id;    private Integer user_id;    private String number;    private Date createtime;    private String note;    private User user; &#x2F;&#x2F; 订单所属用户    &#x2F;&#x2F; 一对多数据封装：订单明细    private List&lt;OrderDetail&gt; orderDetails;}</code></pre><ul><li>新建items类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Items {    private Integer id;    private String name;    private Float price;    private String detail;}</code></pre><ul><li>在Orderdetail中添加Items属性，将订单明细所对应的商品映射到Items中。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class OrderDetail {    private Integer id; &#x2F;&#x2F; 订单详情id    private Integer items_id; &#x2F;&#x2F; 商品id    private Integer items_num; &#x2F;&#x2F; 商品数量    private Items items; &#x2F;&#x2F; 订单详情}</code></pre><ul><li>映射文件中配置映射关系，查询方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!-- 多对多查询:查询用户信息及用户购买的商品信息 --&gt;&lt;resultMap id=&quot;userRslMap&quot; type=&quot;user&quot;&gt;    &lt;!--1. 配置user属性--&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;&#x2F;&gt;    &lt;result property=&quot;username&quot; column=&quot;username&quot;&#x2F;&gt;    &lt;result property=&quot;address&quot; column=&quot;address&quot;&#x2F;&gt;    &lt;!--2. 配置user的orderList--&gt;    &lt;collection property=&quot;orderList&quot; ofType=&quot;orders&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;order_id&quot;&#x2F;&gt;        &lt;result property=&quot;number&quot; column=&quot;number&quot;&#x2F;&gt;        &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;&#x2F;&gt;        &lt;result property=&quot;note&quot; column=&quot;note&quot;&#x2F;&gt;        &lt;!--3. 配置orders的orderDetail--&gt;        &lt;collection property=&quot;orderDetails&quot; ofType=&quot;orderDetail&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;detail_id&quot;&#x2F;&gt;            &lt;result property=&quot;items_id&quot; column=&quot;items_id&quot;&#x2F;&gt;            &lt;result property=&quot;items_num&quot; column=&quot;items_num&quot;&#x2F;&gt;            &lt;!--4. 匹配订单详情的商品信息：在Orderdetail中添加Items属性，将订单明细所对应的商品映射到Items中。--&gt;            &lt;association property=&quot;items&quot; javaType=&quot;items&quot;&gt;                &lt;id property=&quot;id&quot; column=&quot;items_id&quot;&#x2F;&gt;                &lt;result property=&quot;name&quot; column=&quot;name&quot;&#x2F;&gt;                &lt;result property=&quot;price&quot; column=&quot;price&quot;&#x2F;&gt;                &lt;result property=&quot;detail&quot; column=&quot;detail&quot;&#x2F;&gt;            &lt;&#x2F;association&gt;        &lt;&#x2F;collection&gt;    &lt;&#x2F;collection&gt;&lt;&#x2F;resultMap&gt;&lt;select id=&quot;findUserAndOrderInfo&quot; resultMap=&quot;userRslMap&quot;&gt;    SELECT        u.`id`,        u.`username`,        u.`address`,        o.`id` order_id,        o.`number`,        o.`createtime`,        o.`note`,        od.`id` detail_id,        od.`items_id`,        od.`items_num`,        it.`name`,        it.`price`,        it.`detail`    FROM        user u,        orders o,        orderdetail od,        items it    WHERE        u.`id` = o.`user_id`        and o.`id` = od.`orders_id`        and od.`items_id` = it.`id`&lt;&#x2F;select&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 多对多查询信息：查询用户信息及用户购买的商品信息 *&#x2F;@Testpublic void test2() {    UserMapper mapper = session.getMapper(UserMapper.class);    List&lt;User&gt; infos = mapper.findUserAndOrderInfo();    for (User user:infos){        System.out.println(&quot;用户信息：&quot;+user);        for (Orders order:user.getOrderList()){            System.out.println(&quot;订单信息：&quot;+order);            for (OrderDetail od:order.getOrderDetails()){                System.out.println(&quot;订单详情：&quot; + od);            }            System.out.println(&quot;&lt;---------------------------------&gt;&quot;);        }    }}</code></pre><ul><li>输出结果</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">用户信息：User{id=1, username=&#39;赵六&#39;, sex=&#39;null&#39;, birthday=null, address=&#39;杭州市&#39;}订单信息：Orders{id=3, user_id=null, number=&#39;1000010&#39;, createtime=Wed Feb 04 13:22:35 CST 2015, note=&#39;null&#39;, user=null, orderDetails=[OrderDetail{id=1, items_id=1, items_num=1, items=Items{id=1, name=&#39;台式机&#39;, price=3000.0, detail=&#39;该电脑质量非常好！！！！&#39;}}, OrderDetail{id=2, items_id=2, items_num=3, items=Items{id=2, name=&#39;笔记本&#39;, price=6000.0, detail=&#39;笔记本性能好，质量好！！！！！&#39;}}]}订单详情：OrderDetail{id=1, items_id=1, items_num=1, items=Items{id=1, name=&#39;台式机&#39;, price=3000.0, detail=&#39;该电脑质量非常好！！！！&#39;}}订单详情：OrderDetail{id=2, items_id=2, items_num=3, items=Items{id=2, name=&#39;笔记本&#39;, price=6000.0, detail=&#39;笔记本性能好，质量好！！！！！&#39;}}&lt;---------------------------------&gt;订单信息：Orders{id=4, user_id=null, number=&#39;1000011&#39;, createtime=Tue Feb 03 13:22:41 CST 2015, note=&#39;null&#39;, user=null, orderDetails=[OrderDetail{id=3, items_id=3, items_num=4, items=Items{id=3, name=&#39;背包&#39;, price=200.0, detail=&#39;名牌背包，容量大质量好！！！！&#39;}}, OrderDetail{id=4, items_id=2, items_num=3, items=Items{id=2, name=&#39;笔记本&#39;, price=6000.0, detail=&#39;笔记本性能好，质量好！！！！！&#39;}}]}订单详情：OrderDetail{id=3, items_id=3, items_num=4, items=Items{id=3, name=&#39;背包&#39;, price=200.0, detail=&#39;名牌背包，容量大质量好！！！！&#39;}}订单详情：OrderDetail{id=4, items_id=2, items_num=3, items=Items{id=2, name=&#39;笔记本&#39;, price=6000.0, detail=&#39;笔记本性能好，质量好！！！！！&#39;}}&lt;---------------------------------&gt;</code></pre><h4 id="1-5-1-小结"><a href="#1-5-1-小结" class="headerlink" title="1.5.1 小结"></a>1.5.1 小结</h4><ul><li>resultType：将查询结果安装sql列名和POJO属性名一致性映射到POJO中。</li><li>resultMap：使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）<ul><li>association：将关联查询信息映射到一个POJO对象中。</li><li>collection：将关联查询信息映射到一个list集合中。</li></ul></li></ul><blockquote><ul><li>模型里面有模型，用association</li><li>模型里面有集合，用collection</li></ul></blockquote><h2 id="2-延时加载"><a href="#2-延时加载" class="headerlink" title="2. 延时加载"></a>2. 延时加载</h2><p>延迟加载又叫懒加载，也叫按需加载。即先加载主信息，在需要的时候，再去加载从信息。</p><p>在Mybatis中，resultMap标签的association标签和collection标签具有延迟加载的功能。</p><ul><li>分别在两个接口中添加方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface UserMapper {    public User findUserById(int id);}public interface OrderMapper {&#x2F;&#x2F; 懒加载订单的用户数据public List&lt;Orders&gt; findOrderAndUserByLazyloading();}</code></pre><ul><li>映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--UserMapper映射文件--&gt;&lt;mapper namespace=&quot;com.zero.mapper.UserMapper&quot;&gt;&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;SELECT * FROM USER WHERE id = #{id}&lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;&lt;!--OrderMapper接口映射文件--&gt;&lt;mapper namespace=&quot;com.zero.mapper.OrderMapper&quot;&gt;&lt;!-- =========== 懒加载 ============= --&gt;    &lt;resultMap id=&quot;orderLazyloadingRslMap&quot; type=&quot;orders&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot;&#x2F;&gt;        &lt;result property=&quot;note&quot; column=&quot;note&quot;&#x2F;&gt;        &lt;result property=&quot;number&quot; column=&quot;number&quot;&#x2F;&gt;        &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;&#x2F;&gt;        &lt;!-- 配置懒加载查询语句，column是子查询所需参数--&gt;        &lt;association property=&quot;user&quot; select=&quot;com.zero.mapper.UserMapper.findUserById&quot; column=&quot;user_id&quot;&#x2F;&gt;    &lt;&#x2F;resultMap&gt;    &lt;select id=&quot;findOrderAndUserByLazyloading&quot; resultMap=&quot;orderLazyloadingRslMap&quot;&gt;        select * from orders    &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 懒加载@Testpublic void test４(){    OrderMapper mapper = session.getMapper(OrderMapper.class);    List&lt;Orders&gt; orders = mapper.findOrderAndUserByLazyloading();    for (Orders order:orders){        System.out.println(&quot;订单信息：&quot;+order);        System.out.println(&quot;订单用户：&quot;+order.getUser());    }}</code></pre><ul><li>全局配置文件中配置懒加载</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;configuration&gt;    &lt;!--懒加载配置--&gt;    &lt;settings&gt;        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;&#x2F;&gt;    &lt;&#x2F;settings&gt;&lt;&#x2F;configuration&gt;</code></pre><h2 id="3-查询缓存"><a href="#3-查询缓存" class="headerlink" title="3. 查询缓存"></a>3. 查询缓存</h2><p>Mybatis提供查询缓存，用于减轻数据压力，提高数据库抗压力。</p><p>Mybatis的缓存，包括<strong>一级缓存和二级缓存</strong>，一级缓存是默认使用的。二级缓存需手动开启。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/25/cache-1566663654286.jpg" alt="cache"></p><p>在操作数据库时需构造SqlSession对象，在对象中有一个数据结构(HashMap)用于缓存数据。不同的SqlSession之间的缓存数据区域是互不影响的。</p><ul><li>Mybatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。</li><li>Mybatis二级缓存是<strong>多个SqlSession共享</strong>的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存，需要在setting全局参数中配置开启二级缓存。</li></ul><h3 id="3-1-一级缓存原理"><a href="#3-1-一级缓存原理" class="headerlink" title="3. 1 一级缓存原理"></a>3. 1 一级缓存原理</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/25/OneLevelCache-1566663673662.jpg" alt="OneLevelCache"></p><ul><li><p>第一次发起查询，会先去找缓存中是否有id为1的用户信息，如果没有，从数据库中查询用户信息。获取信息后再将用户信息存储到一级缓存中。</p></li><li><p>第二次发起查询用户id为1的用户信息时，先去缓存中找，如缓存中有，直接从缓存中获取用户信息。</p></li><li>如果SqlSession执行了commit操作(执行插入、更新、删除)，会清空SqlSession中的一级缓存，以确保缓存中存储的是最新数据，避免脏读。</li><li>Mybatis内部存储缓存使用一个HashMap。key为HashCode+sqlId+Sql语句，value是查询出来映射生成的java对象。</li></ul><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test1() throws IOException {    &#x2F;&#x2F;1. 读取配置文件    InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;);    &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。    SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);    &#x2F;&#x2F; 3. 会话    SqlSession session = sessionFactory.openSession();    &#x2F;&#x2F; 4. 通过会话获取dao接口    UserMapper mapper = session.getMapper(UserMapper.class);    &#x2F;**         * 默认情况下，一级缓存也就是session级别缓存是开启的         * 保存、删除、更新操作，一级缓存数据会自动清空         *&#x2F;    User user1 = mapper.findUserById(1);    System.out.println(&quot;user1&quot;+user1);    &#x2F;&#x2F; 保存用户,测试缓存是否清空    mapper.save(new User(&quot;小花&quot;,&quot;1&quot;,null,&quot;杭州&quot;));    session.commit();    User user2 = mapper.findUserById(1);    System.out.println(&quot;user2&quot;+user1);}</code></pre><h3 id="3-2-二级缓存原理"><a href="#3-2-二级缓存原理" class="headerlink" title="3.2 二级缓存原理"></a>3.2 二级缓存原理</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/25/TwoLevelCache-1566663699382.jpg" alt="TwoLevelCache"></p><ul><li>SqlSession1去查询用户id为1的用户信息，查询到用户信息后会将查询数据存储到二级缓存中。</li><li>SqlSession2去查询用户id为1的用户信息时，会先去缓存中找是否有数据，有则直接从缓存中取。</li><li>二级缓存区域是根据mapper的namespace划分的，同一个namespace的mapper查询数据放在同一个区域，如果使用mapper代理方法每个mapper的namespace都不同，此时可以理解为二级缓存区域是根据mapper划分。</li><li>每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。</li><li>sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。</li><li>开启二级缓存需在配置文件中手动配置。</li></ul><h4 id="3-2-1-代码示例"><a href="#3-2-1-代码示例" class="headerlink" title="3.2.1 代码示例"></a>3.2.1 代码示例</h4><ul><li>开启二级缓存总开关</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;settings&gt;    &lt;!--懒加载配置--&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;&#x2F;&gt;    &lt;!--开启二级缓存--&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;&#x2F;&gt;&lt;&#x2F;settings&gt;</code></pre><ul><li>在UserMapper中配置二级缓存</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;mapper namespace=&quot;com.zero.mapper.UserMapper&quot;&gt;    &lt;!-- 配置缓存：该类下所有查询方法都使用二级缓存        type不写，默认使用的是mybatis自带的缓存技术：perpetualCache --&gt;    &lt;cache&gt;&lt;&#x2F;cache&gt;&lt;&#x2F;mapper&gt;</code></pre><ul><li>User类序列化</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class User implements Serializable {}</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 二级缓存@Testpublic void test2() throws IOException {    &#x2F;&#x2F;1. 读取配置文件    InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;);    &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。    SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);    &#x2F;&#x2F; 3. 会话    SqlSession session1 = sessionFactory.openSession();    SqlSession session2 = sessionFactory.openSession();    SqlSession session3 = sessionFactory.openSession();    &#x2F;&#x2F; 4. 通过会话获取dao接口    UserMapper mapper1 = session1.getMapper(UserMapper.class);    UserMapper mapper2 = session2.getMapper(UserMapper.class);    UserMapper mapper3 = session3.getMapper(UserMapper.class);    User user1 = mapper1.findUserById(1);    System.out.println(&quot;user1&quot;+user1);    &#x2F;&#x2F; session关闭后才会写入二级缓存    session1.close();    &#x2F;&#x2F; 执行修改更新删除等操作，提交后，会清空二级缓存    mapper3.save(user1);    session3.commit();    User user2 = mapper2.findUserById(1);    System.out.println(&quot;user2&quot;+user2);    session3.close();}</code></pre><ul><li>关于禁用指定方法二级缓存</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot; useCache=&quot;false&quot;&gt;     SELECT * FROM USER WHERE id = #{id}&lt;&#x2F;select&gt;</code></pre><ul><li>关于刷新缓存</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--        默认情况下，插入、更新、删除会清空二级缓存        默认flushCache=&quot;true&quot;        如果设置为false，插入、更新、删除就不会清空二级缓存    --&gt;&lt;insert id=&quot;save&quot; parameterType=&quot;user&quot; flushCache=&quot;false&quot;&gt;    INSERT into user (username,sex,birthday,address)    values (#{username},#{sex},#{birthday},#{address})&lt;&#x2F;insert&gt;</code></pre><h3 id="3-3-整合Ehcache"><a href="#3-3-整合Ehcache" class="headerlink" title="3.3 整合Ehcache"></a>3.3 整合Ehcache</h3><p>EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是一个分布式的缓存框架。</p><p>Mybatis本身是一个持久层框架，它不是专门的缓存框架，所以它对缓存的实现不够好，不能支持分布式。</p><ul><li><p>分布式：系统为了提高性能，通常会对系统采用分布式部署(集群部署方式)</p></li><li><p>整合思路</p><ul><li>Cache是一个借口，它的默认实现是mybatis的PerpetualCache。如果想整合mybatis的二级缓存，那么实现Cache接口即可。</li></ul></li><li><p>实现步骤：</p><ul><li>先添加jar包</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/25/ehcache-1566663742344.jpg" alt="ehcache"></p><ul><li>设置映射文件中的cache标签的type值为ehcache的实现类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;mapper namespace=&quot;com.zero.mapper.UserMapper&quot;&gt;      &lt;!-- 配置缓存：该类下所有查询方法都使用二级缓存          type不写，默认使用的是mybatis自带的缓存技术：perpetualCache --&gt;      &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;&#x2F;cache&gt;  &lt;&#x2F;mapper&gt;</code></pre></li></ul><ul><li><p>在src下添加ehcache的配置文件</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;ehcache xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;..&#x2F;config&#x2F;ehcache.xsd&quot;&gt;            &lt;diskStore path=&quot;java.io.tmpdir&quot;&#x2F;&gt;      &lt;!--      maxElementsInMemory :设置基于内存的缓存中可存放的对象最大数目      eternal:设置对象是否为永久的,true表示永不过期,此时将忽略      timeToIdleSeconds 和 timeToLiveSeconds属性; 默认值是false      timeToIdleSeconds:设置对象空闲最长时间,以秒为单位, 超过这个时间,对象过期。          当对象过期时,EHCache会把它从缓存中清除。如果此值为0,表示对象可以无限期地处于空闲状态。      timeToLiveSeconds:设置对象生存最长时间,超过这个时间,对象过期。          如果此值为0,表示对象可以无限期地存在于缓存中. 该属性值必须大于或等于 timeToIdleSeconds 属性值      overflowToDisk:设置基于内在的缓存中的对象数目达到上限后,是否把溢出的对象写到基于硬盘的缓存中      diskPersistent 当jvm结束时是否持久化对象 true false 默认是false      diskExpiryThreadIntervalSeconds 指定专门用于清除过期对象的监听线程的轮询时间          memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候，          移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）      --&gt;      &lt;defaultCache              maxElementsInMemory=&quot;10000&quot;              eternal=&quot;false&quot;              timeToIdleSeconds=&quot;120&quot;              timeToLiveSeconds=&quot;120&quot;              maxElementsOnDisk=&quot;10000000&quot;              diskExpiryThreadIntervalSeconds=&quot;120&quot;              memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;          &lt;persistence strategy=&quot;localTempSwap&quot;&#x2F;&gt;      &lt;&#x2F;defaultCache&gt;  &lt;&#x2F;ehcache&gt;</code></pre></li></ul><ul><li>测试：用上一个二级缓存案例即可</li></ul><ul><li><p>二级缓存应用场景</p><ul><li>对于访问响应速度要求高，但是实时性不高的查询，可以采用二级缓存技术。</li></ul></li></ul><h2 id="4-MyBatis整合Spring"><a href="#4-MyBatis整合Spring" class="headerlink" title="4. MyBatis整合Spring"></a>4. MyBatis整合Spring</h2><h3 id="4-1-创建工程导包"><a href="#4-1-创建工程导包" class="headerlink" title="4.1 创建工程导包"></a>4.1 创建工程导包</h3><ul><li>导入Mybatis包及依赖包</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/25/mybatis-1566663766728.jpg" alt="mybatis"></p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/25/mybatis_relyon-1566663784695.jpg" alt="mybatis_relyon"></p><ul><li><p>导入mysql数据库驱动：<code>mysql-connector-java-5.1.7-bin.jar</code></p></li><li><p>DBCP连接池相关包：<code>commons-dbcp-1.4.jar</code>和<code>commons-pool-1.6.jar</code></p></li><li>spring+mvc相关包：</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/25/spring_mvc-1566663800152.jpg" alt="spring_mvc"></p><ul><li>Mybatis-spring整合包：<code>mybatis-spring-1.2.2.jar</code></li></ul><h3 id="4-2-配置mybatis的核心配置文件"><a href="#4-2-配置mybatis的核心配置文件" class="headerlink" title="4.2 配置mybatis的核心配置文件"></a>4.2 配置mybatis的核心配置文件</h3><ul><li>创建核心配置文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--加载配置文件--&gt;&lt;!--    &lt;properties resource=&quot;db.properties&quot;&#x2F;&gt;--&gt;    &lt;!--别名配置--&gt;    &lt;typeAliases&gt;        &lt;!-- 批量配置别名--&gt;        &lt;!-- [name]：指定批量定义别名的类包，别名为类名，第一个字母小写--&gt;        &lt;package name=&quot;com.zero.sm.model&quot;&#x2F;&gt;    &lt;&#x2F;typeAliases&gt;        &lt;!--加载映射文件--&gt;    &lt;mappers&gt;        &lt;package name=&quot;com&#x2F;zero&#x2F;sm&#x2F;sqlmap&#x2F;User.xml&quot;&#x2F;&gt;        &lt;!-- 加载mapper包下所有映射文件--&gt;        &lt;package name=&quot;com.zero.sm.mapper&quot;&#x2F;&gt;    &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt;</code></pre><ul><li>创建User模型</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class User implements Serializable {    private int id;    private String username;    private String sex;    private Date birthday;    private String address;&#x2F;&#x2F; 省略get、set、toString}</code></pre><ul><li>User映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;user&quot;&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot; &gt;SELECT * FROM USER WHERE id = #{id}&lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre><h3 id="4-3-配置spring数据源"><a href="#4-3-配置spring数据源" class="headerlink" title="4.3 配置spring数据源"></a>4.3 配置spring数据源</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:mvc=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;       xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;       xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beanshttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.2.xsdhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvchttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc-3.2.xsdhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;contexthttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-3.2.xsdhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aophttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-3.2.xsdhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;txhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 1.配置数据库，dbcp数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;mybatis01?useUnicode=true&amp;amp;characterEncoding=utf8&quot;&#x2F;&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt;&lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt;&lt;!-- 最大连接  --&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;&#x2F;&gt;        &lt;!--最大空闲数  --&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><h3 id="4-4-spring配置SqlSessionFactory"><a href="#4-4-spring配置SqlSessionFactory" class="headerlink" title="4.4 spring配置SqlSessionFactory"></a>4.4 spring配置SqlSessionFactory</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml"> &lt;!--2. 配置会话工厂--&gt;&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;!--引用数据源--&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;    &lt;!--设置全局配置文件路径--&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapconfig.xml&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><h3 id="4-5-编写UserDaoImpl，省略接口"><a href="#4-5-编写UserDaoImpl，省略接口" class="headerlink" title="4.5 编写UserDaoImpl，省略接口"></a>4.5 编写UserDaoImpl，省略接口</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao {    @Override    public User findUserById(int id) {        return getSqlSession().selectOne(&quot;user.findUserById&quot;,id); &#x2F;&#x2F; 调用父类方法获取会话对象，然后执行方法    }}</code></pre><h3 id="4-6-spring中配置daobean"><a href="#4-6-spring中配置daobean" class="headerlink" title="4.6 spring中配置daobean"></a>4.6 spring中配置daobean</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&lt;!--3. 配置dao--&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.zero.sm.dao.Impl.UserDaoImpl&quot;&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sessionFactory&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><h3 id="4-7-测试"><a href="#4-7-测试" class="headerlink" title="4.7 测试"></a>4.7 测试</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo01 {    @Test    public void test1(){        &#x2F;&#x2F; 1. 加载spring的配置文件        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;);        &#x2F;&#x2F; 2. 获取dao的bean        UserDao userDao = (UserDao) context.getBean(&quot;userDao&quot;);        &#x2F;&#x2F; 3. 调用dao方法        User user = userDao.findUserById(1);        System.out.println(user);    }}</code></pre><h3 id="4-8-换成Mapper接口整合dao"><a href="#4-8-换成Mapper接口整合dao" class="headerlink" title="4.8 换成Mapper接口整合dao"></a>4.8 换成Mapper接口整合dao</h3><ul><li>创建Mapper映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.zero.sm.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot; &gt;SELECT * FROM USER WHERE id = #{id}&lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre><ul><li>加载映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;mappers&gt;    &lt;mapper resource=&quot;com&#x2F;zero&#x2F;sm&#x2F;sqlmap&#x2F;User.xml&quot;&#x2F;&gt;    &lt;!-- 加载mapper包下所有映射文件--&gt;    &lt;package name=&quot;com.zero.sm.mapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><ul><li>spring配置MapperFactoryBean</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!-- 第二种方法--&gt;&lt;!--4. 使用工厂Bean生成userMapper对象--&gt;&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sessionFactory&quot;&#x2F;&gt;    &lt;property name=&quot;mapperInterface&quot; value=&quot;com.zero.sm.mapper.UserMapper&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java"> @Testpublic void test2() {    &#x2F;&#x2F; 1. 加载spring的配置文件    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;);    &#x2F;&#x2F; 2. 获取dao的bean    UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;);    User us = userMapper.findUserById(1);    System.out.println(us);}</code></pre><h3 id="4-9-使用MapperScannerConfigurer批量扫描创建代理对象"><a href="#4-9-使用MapperScannerConfigurer批量扫描创建代理对象" class="headerlink" title="4.9 使用MapperScannerConfigurer批量扫描创建代理对象"></a>4.9 使用<code>MapperScannerConfigurer</code>批量扫描创建代理对象</h3><p>mapper代理开发方式批量mapper配置  ,内部会扫描指定包下的mapper，创建代理对象，bean的名字默认为mapper接口类名的首字母小写。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml"> &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;     &lt;property name=&quot;basePackage&quot; value=&quot;com.zero.sm.mapper&quot;&#x2F;&gt;     &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sessionFactory&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><p>测试方法同上案例。</p><blockquote><p>Notice：JDK1.8以上使用该方式，无法创建bean，改成JDK1.7即可；或spring版本3.2.9以上。</p></blockquote><h2 id="5-逆向工程"><a href="#5-逆向工程" class="headerlink" title="5. 逆向工程"></a>5. 逆向工程</h2><h3 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h3><p>简单的说，就是通过数据库中的表单，自动生成java代码。</p><p>Mybatis官方提供了逆向工程，可以针对单表自动生成Mybatis代码(<code>mapper.java\mapper.xml\po类</code>)</p><ul><li><a href="https://github.com/mybatis/generator/releases" target="_blank" rel="noopener">下载地址</a></li></ul><h3 id="5-2-使用方法"><a href="#5-2-使用方法" class="headerlink" title="5.2 使用方法"></a>5.2 使用方法</h3><ol><li>创建简单的java项目；</li><li>导入jar包，创建generator配置文件；</li><li>使用java类来执行逆向工程；</li><li>把生成的代码拷贝到项目中；</li><li>在正式项目中使用逆向工程生成的代码。</li></ol><h3 id="5-3-案例示范"><a href="#5-3-案例示范" class="headerlink" title="5.3 案例示范"></a>5.3 案例示范</h3><h4 id="5-3-1-第一步：创建generator配置文件"><a href="#5-3-1-第一步：创建generator配置文件" class="headerlink" title="5.3.1  第一步：创建generator配置文件"></a>5.3.1  第一步：创建generator配置文件</h4><p>在src下，创建generator配置文件，文件内容可以从官方docs目录下的index.html中找到相关代码</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;mysqlTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;!--数据库配置--&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;mybatis01&quot;                        userId=&quot;root&quot;                        password=&quot;123456&quot;&gt;        &lt;&#x2F;jdbcConnection&gt;        &lt;!--java类型解析--&gt;        &lt;javaTypeResolver &gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; &#x2F;&gt;        &lt;&#x2F;javaTypeResolver&gt;        &lt;!--模型生成包名--&gt;        &lt;javaModelGenerator targetPackage=&quot;com.zero.sm.model&quot; targetProject=&quot;.\src&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; &#x2F;&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; &#x2F;&gt;        &lt;&#x2F;javaModelGenerator&gt;        &lt;!--mybatis的映射 .xml--&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.zero.sm.mapper&quot;  targetProject=&quot;.\src&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; &#x2F;&gt;        &lt;&#x2F;sqlMapGenerator&gt;        &lt;!--mybatis的mapper接口生成包路径--&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.zero.sm.mapper&quot;  targetProject=&quot;.\src&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; &#x2F;&gt;        &lt;&#x2F;javaClientGenerator&gt;        &lt;!-- 配置生成表的模型            domainObjectName: 默认会根据表名生成，首字母自动大写            --&gt;        &lt;table tableName=&quot;items&quot;&#x2F;&gt;        &lt;table tableName=&quot;orderdetail&quot; domainObjectName=&quot;OrderDetail&quot;&#x2F;&gt;        &lt;table tableName=&quot;orders&quot;&#x2F;&gt;        &lt;table tableName=&quot;user&quot;&#x2F;&gt;    &lt;&#x2F;context&gt;&lt;&#x2F;generatorConfiguration&gt;</code></pre><h4 id="5-3-2-第二步：使用java类来执行逆向工程"><a href="#5-3-2-第二步：使用java类来执行逆向工程" class="headerlink" title="5.3.2  第二步：使用java类来执行逆向工程"></a>5.3.2  第二步：使用java类来执行逆向工程</h4><p>需导入mysql驱动包和mybatis的逆向工程包</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Main {    public static void main(String[] args)  throws Exception{        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();        boolean overwrite = true;        File configFile = new File(&quot;src&#x2F;generator.xml&quot;);        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(configFile);        DefaultShellCallback callback = new DefaultShellCallback(overwrite);        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,                callback, warnings);        myBatisGenerator.generate(null);    }}</code></pre><h4 id="5-3-3-第三步：把生成的代码拷贝到项目中"><a href="#5-3-3-第三步：把生成的代码拷贝到项目中" class="headerlink" title="5.3.3  第三步：把生成的代码拷贝到项目中"></a>5.3.3  第三步：把生成的代码拷贝到项目中</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/25/AutoGenerator-1566663834855.jpg" alt="AutoGenerator"></p><h4 id="5-3-4-第四步：测试"><a href="#5-3-4-第四步：测试" class="headerlink" title="5.3.4  第四步：测试"></a>5.3.4  第四步：测试</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 测试基本查询@Testpublic void test2() {    &#x2F;&#x2F; 1. 加载spring的配置文件    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;);    &#x2F;&#x2F; 2. 获取dao的bean    UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;);    &#x2F;&#x2F; 3. 通过主键查询对象    User user = userMapper.selectByPrimaryKey(1);    System.out.println(user);}&#x2F;&#x2F; 测试Example@Testpublic void test3() {    &#x2F;&#x2F; 自动生成的Example是用于查询的    &#x2F;&#x2F; 1. 加载spring的配置文件    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;);    &#x2F;&#x2F; 2. 获取dao的bean    UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;);    UserExample example = new UserExample();    &#x2F;&#x2F; 封装查询条件    UserExample.Criteria criteria = example.createCriteria();    criteria.andSexEqualTo(&quot;1&quot;); &#x2F;&#x2F; 查询男性用户    &#x2F;&#x2F; 通过封装后的查询条件查询    List&lt;User&gt; users = userMapper.selectByExample(example);    System.out.println(users);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis基础入门</title>
      <link href="/FrameWork/MyBatis-Basic.html"/>
      <url>/FrameWork/MyBatis-Basic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-MyBatis简介"><a href="#1-MyBatis简介" class="headerlink" title="1. MyBatis简介"></a>1. MyBatis简介</h2><p>MyBatis本是apache的一个开源项目iBatis，2010年这个项目由 apache software foundation迁移到了google code，并改名为MyBatis，实质上MyBatis是对iBatis进行进行了一些改进。</p><a id="more"></a><ul><li>Mybatis是一个优秀的持久层框架，它对jdbc的操作数据库过程进行封装，使开发者只需要关注SQL本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。</li><li>对jdbc封装的框架有：Hibernate、DBUtils、jdbcTemplate、Mybatis</li><li>Mybatis原理：<ul><li>通过<strong>XML或注解</strong>的方式将要执行的各种statement(preparedStatement)配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象返回。</li></ul></li><li>MyBatis框架核心<ol><li>mybatis配置文件：包括全局配置文件和映射文件。其中全局配置文件配置了数据源、事务等信息；映射文件配置了SQL执行相关的信息。</li><li>mybatis通过读取配置文件信息(全局配置文件和映射文件)，构造出SQLSessionFactory，即会话工厂。</li><li>通过SQLSessionFactory，可以创建SQLSession(会话)。Mybatis是通过SQLSession来操作数据库的。</li><li>SQLSession本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个普通执行器，一个是缓存执行器(默认)。</li><li>Executor执行器要处理的SQL信息是封装到一个底层对象MappedStatement中。该对象包括：SQL语句、输入参数映射信息、输出信息集映射信息。其中输入参数和输出结果的映射类型包括HashMap集合对象、POJO对象类型。</li></ol></li></ul><blockquote><p>POJO：Plain Ordinary Java Object，简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称</p></blockquote><h2 id="2-MyBatis入门"><a href="#2-MyBatis入门" class="headerlink" title="2. MyBatis入门"></a>2. MyBatis入门</h2><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><ul><li>下载Mybatis<ul><li><a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">下载地址</a></li></ul></li><li>创建项目导包</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/21/mybatis-1566398238994.jpg" alt="mybatis"></p><ul><li><p>添加日志配置</p><ul><li>项目src下创建log4j.properties文件，内容如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-properties">  # Global logging configuration  log4j.rootLogger=DEBUG, stdout  # Console output...  log4j.appender.stdout=org.apache.log4j.ConsoleAppender  log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre></li></ul><h3 id="2-2-开发步骤"><a href="#2-2-开发步骤" class="headerlink" title="2.2 开发步骤"></a>2.2 开发步骤</h3><ol><li>根据需求创建PO类</li><li>创建全局配置文件：SqlMapConfig.xml</li><li>编写映射文件</li><li>在SqlMapConfig.xml中加载映射文件</li><li>编写测试代码，连接并操作数据库<ul><li>读取配置文件</li><li>通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。</li><li>通过SqlSessionFactory创建SqlSession。</li><li>调用SqlSession的操作数据库方法。</li><li>关闭会话。</li></ul></li></ol><h4 id="2-2-1-创建PO类"><a href="#2-2-1-创建PO类" class="headerlink" title="2.2.1 创建PO类"></a>2.2.1 创建PO类</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class User implements Serializable {    private int id;    private String username;    private String sex;    private Date birthday;    private String address;&#x2F;&#x2F; 省略get&#x2F;set    &#x2F;&#x2F; 省略toString}</code></pre><h4 id="2-2-2-创建全局配置文件"><a href="#2-2-2-创建全局配置文件" class="headerlink" title="2.2.2 创建全局配置文件"></a>2.2.2 创建全局配置文件</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 配置mybatis的环境信息 --&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;            &lt;!-- 配置数据源，采用dbcp连接池 --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;mybatis01?useUnicode=true&amp;amp;characterEncoding=utf8&quot;&#x2F;&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt;                &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt;            &lt;&#x2F;dataSource&gt;        &lt;&#x2F;environment&gt;    &lt;&#x2F;environments&gt;&lt;&#x2F;configuration&gt;</code></pre><h4 id="2-2-3-编写映射文件"><a href="#2-2-3-编写映射文件" class="headerlink" title="2.2.3 编写映射文件"></a>2.2.3 编写映射文件</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace：命名空间，它的作用就是对SQL进行分类化管理，可以理解为SQL隔离注意：使用mapper代理开发时，namespace有特殊且重要的作用 --&gt;&lt;mapper namespace=&quot;test&quot;&gt;    &lt;!--        [id]：statement的id，要求在命名空间内唯一        [parameterType]：参数输入类型        [resultType]：查询出的单条结果集对应的java类型，返回值类型        [#{}]： 表示一个占位符?        [#{id}]：表示该占位符待接收参数的名称为id。            注意：如果参数为简单类型时，#{}里面的参数名称可以是任意定义     --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.zero.model.User&quot;&gt;SELECT * FROM USER WHERE id = #{id1}&lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre><h4 id="2-2-4-加载映射文件"><a href="#2-2-4-加载映射文件" class="headerlink" title="2.2.4 加载映射文件"></a>2.2.4 加载映射文件</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--加载映射文件--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;com&#x2F;zero&#x2F;sqlmap&#x2F;User.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><h4 id="2-2-5-编写测试"><a href="#2-2-5-编写测试" class="headerlink" title="2.2.5 编写测试"></a>2.2.5 编写测试</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserTest {    @Test    public void test1() throws IOException {        &#x2F;&#x2F;1. 读取配置文件        InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;);        &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);        &#x2F;&#x2F;3. 通过SqlSessionFactory创建SqlSession。        SqlSession session = sessionFactory.openSession();        &#x2F;&#x2F;4. 调用SqlSession的操作数据库方法。        User user = session.selectOne(&quot;findUserById&quot;,10);        System.out.println(user);        &#x2F;&#x2F;5. 关闭会话。        session.commit();    }}</code></pre><blockquote><p>junit4.12可能会报<code>java.lang.NoClassDefFoundError: org/hamcrest/SelfDescribing</code>，版本切换为5.4后不会报错。</p></blockquote><h4 id="2-2-6-查询案例"><a href="#2-2-6-查询案例" class="headerlink" title="2.2.6 查询案例"></a>2.2.6 查询案例</h4><h5 id="1-模糊查询"><a href="#1-模糊查询" class="headerlink" title="1. 模糊查询"></a>1. 模糊查询</h5><ul><li>模糊查询，修改映射文件，添加如下内容：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--        模糊查询用户信息：            [${}]：表示拼接SQL字符串             [${value}]：表示要拼接的是简单类型参数。             注意：            1、如果参数为简单类型时，${}里面的参数名称必须为value            2、${}会引起SQL注入，一般情况下不推荐使用。但是有些场景必须使用${}，比如order by ${colname}        --&gt;&lt;select id=&quot;findUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;com.zero.model.User&quot;&gt;    SELECT * FROM USER WHERE username like &#39;%${value}%&#39;&lt;&#x2F;select&gt;</code></pre><ul><li>测试文件添加查询语句</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 通过姓名模糊查询用户集合List&lt;User&gt; users = session.selectList(&quot;findUserByName&quot;, &quot;张&quot;);System.out.println(users);</code></pre><h5 id="2-添加用户"><a href="#2-添加用户" class="headerlink" title="2. 添加用户"></a>2. 添加用户</h5><ul><li>修改映射文件，添加内容</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--插入用户信息--&gt;&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.zero.model.User&quot;&gt;    &lt;!--如果主键的值是通过MySQL自增机制生成的，那么我们此处无需再‘显式’的给ID赋值--&gt;    INSERT into user (username,sex,birthday,address) values (#{username},#{sex},#{birthday},#{address})&lt;&#x2F;insert&gt;</code></pre><ul><li>测试代码，注意：需在PO类User中添加一个没有id属性的全参构造方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 插入用户session.insert(&quot;insertUser&quot;,new User(&quot;zero&quot;,&quot;男&quot;,new Date(),&quot;杭州&quot;));</code></pre><h5 id="3-删除用户"><a href="#3-删除用户" class="headerlink" title="3. 删除用户"></a>3. 删除用户</h5><ul><li>修改映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--通过id删除用户--&gt;&lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt;    delete from user where id = #{id}&lt;&#x2F;delete&gt;&lt;!--通过姓名删除用户--&gt;&lt;delete id=&quot;deleteUserByName&quot; parameterType=&quot;String&quot;&gt;    delete from user where username = #{name}&lt;&#x2F;delete&gt;</code></pre><ul><li>测试代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 通过id删除用户session.delete(&quot;deleteUserById&quot;,28);&#x2F;&#x2F; 通过姓名删除用户，test是映射文件的命名空间session.delete(&quot;test.deleteUserByName&quot;,&quot;张小明&quot;);</code></pre><h5 id="4-更新用户"><a href="#4-更新用户" class="headerlink" title="4. 更新用户"></a>4. 更新用户</h5><ul><li>映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--通过id更新用户--&gt;&lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.zero.model.User&quot;&gt;    update user set username=#{username},sex=#{sex} where id=#{id}&lt;&#x2F;update&gt;</code></pre><ul><li>测试代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 通过id更新用户User upUser = new User();upUser.setId(1); &#x2F;&#x2F; 输入要修改的用户idupUser.setUsername(&quot;赵六儿&quot;);&#x2F;&#x2F; 需修改的用户姓名upUser.setSex(&quot;女&quot;);session.update(&quot;updateUserById&quot;,upUser);</code></pre><h4 id="2-2-7-返回MySQL自增主键"><a href="#2-2-7-返回MySQL自增主键" class="headerlink" title="2.2.7 返回MySQL自增主键"></a>2.2.7 返回MySQL自增主键</h4><ul><li>MySQL自增主键，是指在insert之前MySQL会自动生成一个自增的主键</li><li><p>可以通过MySQL的函数获取刚插入的自增主键：<code>select LAST_INSERT_ID()</code>，该函数在insert语句之后调用。</p></li><li><p>修改映射文件添加用户内容</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--插入用户信息--&gt;&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.zero.model.User&quot;&gt;    &lt;!--   [selectKey标签]：通过select查询来生成主键   [keyProperty]：指定存放生成主键的属性   [resultType]：生成主键所对应的Java类型   [order]：指定该查询主键SQL语句的执行顺序，相对于insert语句   [last_insert_id]：MySQL的函数，要配合insert语句一起使用 --&gt;    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;        SELECT LAST_INSERT_ID()    &lt;&#x2F;selectKey&gt;    &lt;!--如果主键的值是通过MySQL自增机制生成的，那么我们此处无需再‘显式’的给ID赋值--&gt;    INSERT into user (username,sex,birthday,address) values (#{username},#{sex},#{birthday},#{address})&lt;&#x2F;insert&gt;</code></pre><ul><li>使用Junit4的注解功能，抽取重复代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">private SqlSession session = null;@Beforepublic void before() throws IOException {    System.out.println(&quot;before:获取session&quot;);    &#x2F;&#x2F;1. 读取配置文件    InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;);    &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。    SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);    &#x2F;&#x2F;3. 通过SqlSessionFactory创建SqlSession。    session = sessionFactory.openSession();}@Afterpublic void after(){    System.out.println(&quot;after:关闭会话&quot;);    &#x2F;&#x2F;5. 关闭会话。    session.close();}</code></pre><ul><li>测试代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java"> &#x2F;&#x2F; 插入用户后，将主键返回，设置到模型id中@Testpublic void test2(){    User user = new User(&quot;zero001&quot;, &quot;男&quot;, new Date(), &quot;杭州&quot;);    int Row = session.insert(&quot;insertUser&quot;, user);    session.commit();    System.out.println(&quot;受影响行数：&quot;+Row);    System.out.println(&quot;用户ID:&quot;+user.getId());}</code></pre><h4 id="2-2-8-返回MySQL自增UUID"><a href="#2-2-8-返回MySQL自增UUID" class="headerlink" title="2.2.8 返回MySQL自增UUID"></a>2.2.8 返回MySQL自增UUID</h4><ul><li>映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.gyf.domain.User&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;String&quot; order=&quot;BEFORE&quot;&gt;        SELECT UUID()    &lt;&#x2F;selectKey&gt;    INSERT INTO USER (username,sex,birthday,address)     VALUES(#{username},#{sex},#{birthday},#{address})&lt;&#x2F;insert&gt;</code></pre><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><ul><li><code>parameterType</code>和<code>resultType</code><ul><li><code>parameterType</code>：指定输入参数的java类型，可以填写别名或Java类的全限定名(就是全类名)。</li><li><code>resultType</code>：指定输出结果的java类型，可以填写别名或Java类的全限定名。</li></ul></li><li><code>#{}</code>和<code>${}</code><ul><li><code>#{}</code>：相当于预处理中的占位符<ul><li><code>#{}</code>里面的参数表示接受java输入参数的名称</li><li><code>#{}</code>可以接受HashMap、POJO类型的参数。当接受简单类型参数时，里面可以是vlaue，也可以是其他。</li><li><code>#{}</code>可以防止SQL注入</li></ul></li><li><code>${}</code>：相当于拼接SQL串，对传入的值不做任何解释的原样输出。<ul><li>会引起SQL注入，所有需谨慎使用</li><li>可以接受HashMap、POJO类型的参数。当接受简单类型的参数时，<code>${}</code>里面只能是value。</li></ul></li></ul></li><li><code>selectOne</code>和<code>selectList</code><ul><li><code>selectOne</code>：只能查询0或1条记录，大于1条记录就会报错。</li><li><code>selectList</code>：可以查询0条或N条记录。</li></ul></li></ul><h3 id="2-4-MyBatis的Dao编写-了解即可"><a href="#2-4-MyBatis的Dao编写-了解即可" class="headerlink" title="2.4 MyBatis的Dao编写(了解即可)"></a>2.4 MyBatis的Dao编写(了解即可)</h3><ul><li>Dao层</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserDaoImpl  implements UserDao {    private SqlSessionFactory ssf;    public UserDaoImpl() {    }    public UserDaoImpl(SqlSessionFactory ssf) {        this.ssf = ssf;    }    @Override    public void save(User user) {        &#x2F;&#x2F; 获取session        SqlSession session = ssf.openSession();        &#x2F;&#x2F; 插入用户        session.insert(&quot;insertUset&quot;,user);        session.commit();        session.close();    }    @Override    public User findUserById(int id) {        &#x2F;&#x2F; 获取session        SqlSession session = ssf.openSession();        &#x2F;&#x2F; 查询用户        User user = session.selectOne(&quot;findUserById&quot;, id);        session.commit();        session.close();        return user;    }}</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserDaoTest {&#x2F;&#x2F;    private SqlSession session = null;    private SqlSessionFactory sessionFactory;    @Before    public void before() throws IOException {        System.out.println(&quot;before:获取session&quot;);        &#x2F;&#x2F;1. 读取配置文件        InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;);        &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。        sessionFactory = new SqlSessionFactoryBuilder().build(is);    }    @Test    public void test1(){        &#x2F;&#x2F; 调用dao        &#x2F;&#x2F; 1. 创建dao        UserDaoImpl userDao = new UserDaoImpl(sessionFactory);        &#x2F;&#x2F; 2. 查询        User user = userDao.findUserById(1);        System.out.println(user);    }}</code></pre><h3 id="2-5-MyBatis的Dao编写-mapper代理方式实现"><a href="#2-5-MyBatis的Dao编写-mapper代理方式实现" class="headerlink" title="2.5 MyBatis的Dao编写(mapper代理方式实现)"></a>2.5 MyBatis的Dao编写(mapper代理方式实现)</h3><p>Mapper代理的开发方式，程序员只需编写mapper接口(相当于dao接口)即可。MyBatis会自动的为mapper接口生成动态代理实现类。</p><ul><li>开发规范<ul><li>mapper接口的全限定名要和mapper映射文件的namespace的值相同</li><li>mapper接口的方法名称要和映射文件中的statement的id相同</li><li>mapper的接口方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致。</li><li>mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致。</li></ul></li></ul><ul><li>编写示例文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; mapper类public interface UserMapper {    public void save(User user);    public User findUserById(int id);}</code></pre><p>映射文件:</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!--注意：使用mapper代理开发时，namespace值必须是接口全限定名 --&gt;&lt;mapper namespace=&quot;com.zero.mapper.UserMapper&quot;&gt;    &lt;insert id=&quot;save&quot; parameterType=&quot;com.zero.model.User&quot;&gt;        INSERT into user (username,sex,birthday,address)        values (#{username},#{sex},#{birthday},#{address})    &lt;&#x2F;insert&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.zero.model.User&quot;&gt;SELECT * FROM USER WHERE id = #{id}&lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre><p>开发规范：</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/21/mapper-1566398292193.jpg" alt="mapper"></p><ul><li>添加映射配置文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--加载映射文件--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;com&#x2F;zero&#x2F;mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserMapperTest {    private SqlSession session = null;    @Before    public void before() throws IOException {        System.out.println(&quot;before:获取session&quot;);        &#x2F;&#x2F;1. 读取配置文件        InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;);        &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);        session = sessionFactory.openSession();    }    @After    public void after(){        System.out.println(&quot;after:关闭会话&quot;);        &#x2F;&#x2F;5. 关闭会话。        session.close();    }    @Test    public void test1(){        &#x2F;&#x2F; 通过session获取接口代理类[默认代理：JDK实现的代理]        UserMapper mapper = session.getMapper(UserMapper.class);        &#x2F;&#x2F; 查询        User user = mapper.findUserById(1);        System.out.println(user);        mapper.save(new User(&quot;xxx&quot;, &quot;x&quot;, new Date(), &quot;xx&quot;));        session.commit();    }}</code></pre><h2 id="3-全局配置文件其他配置"><a href="#3-全局配置文件其他配置" class="headerlink" title="3. 全局配置文件其他配置"></a>3. 全局配置文件其他配置</h2><h3 id="3-1-properties数据库文件配置"><a href="#3-1-properties数据库文件配置" class="headerlink" title="3.1 properties数据库文件配置"></a>3.1 properties数据库文件配置</h3><ul><li>在src下配置<code>db.properties</code>文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-properties">driver=com.mysql.jdbc.Driverurl=jdbc:mysql:&#x2F;&#x2F;&#x2F;mybatis01?useUnicode=true&amp;amp;characterEncoding=utf8username=rootpassword=123456</code></pre><ul><li>在全局配置文件中加载并使用</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;configuration&gt;    &lt;!--1. 加载配置文件--&gt;    &lt;properties resource=&quot;db.properties&quot;&#x2F;&gt;    &lt;!-- 配置mybatis的环境信息 --&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;            &lt;!-- 配置数据源，采用dbcp连接池 --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!--2. 使用${}，可以引用一句加载的java配置文件中的信息--&gt;                &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;&#x2F;&gt;                &lt;property name=&quot;url&quot; value=&quot;${url}&quot;&#x2F;&gt;                &lt;property name=&quot;username&quot; value=&quot;${username}&quot;&#x2F;&gt;                &lt;property name=&quot;password&quot; value=&quot;${password}&quot;&#x2F;&gt;            &lt;&#x2F;dataSource&gt;        &lt;&#x2F;environment&gt;    &lt;&#x2F;environments&gt;&lt;&#x2F;configuration&gt;</code></pre><h3 id="3-2-typeAliases"><a href="#3-2-typeAliases" class="headerlink" title="3.2 typeAliases"></a>3.2 <code>typeAliases</code></h3><p>别名的使用是为了在映射文件中，更方便的去指定参数和结果集的类型，不再用写很长一段全限定名。</p><ul><li>mybatis支持的别名<ul><li>java的全部基本数据类型及其对应包装类，引用数据类型等等。</li></ul></li><li>自定义别名</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--在全局配置文件中进行别名配置--&gt;&lt;typeAliases&gt;    &lt;!--单个定义别名--&gt;    &lt;typeAlias type=&quot;com.zero.model.User&quot; alias=&quot;user&quot;&#x2F;&gt;    &lt;!-- 批量配置别名--&gt;    &lt;!-- [name]：指定批量定义别名的类包，别名为类名，第一个字母小写(User=user)--&gt;    &lt;package name=&quot;com.zero.model&quot;&#x2F;&gt;&lt;&#x2F;typeAliases&gt;</code></pre><h3 id="3-3-加载映射文件的几种方式"><a href="#3-3-加载映射文件的几种方式" class="headerlink" title="3.3 加载映射文件的几种方式"></a>3.3 加载映射文件的几种方式</h3><ul><li>使用相对于类路径的资源。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;mappers&gt;    &lt;mapper resource=&quot;com&#x2F;zero&#x2F;mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><ul><li>使用mapper接口的全限定名。注意：此方法要求mapper接口和mapper映射文件名称相同，且在同一目录下。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;mappers&gt;    &lt;mapper class=&quot;com.zero.mapper.UserMapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><p>​        如果没有映射文件，那么在接口中要声明注解。不推荐使用</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface UserMapper {    @Insert(&quot;INSERT into user (username,sex,birthday,address) values (#{username},#{sex},#{birthday},#{address})&quot;)    public void save(User user);    @Select(&quot;SELECT * FROM USER WHERE id = #{id}&quot;)    public User findUserById(int id);}</code></pre><ul><li>注册指定包下的所有映射文件。推荐</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;mappers&gt;&lt;!--3. 注册指定包下的所有映射文件--&gt;    &lt;package name=&quot;com.zero.mapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><h2 id="4-MyBatis的映射文件"><a href="#4-MyBatis的映射文件" class="headerlink" title="4. MyBatis的映射文件"></a>4. MyBatis的映射文件</h2><h3 id="4-1-输入映射ParameterType"><a href="#4-1-输入映射ParameterType" class="headerlink" title="4.1 输入映射ParameterType"></a>4.1 输入映射<code>ParameterType</code></h3><p>指定输入参数的java类型，可以使用别名或类的全限定名。它可以接收简单类型、POJO对象、HashMap</p><h4 id="4-1-1-传递简单类型"><a href="#4-1-1-传递简单类型" class="headerlink" title="4.1.1 传递简单类型"></a>4.1.1 传递简单类型</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.zero.model.User&quot;&gt;    SELECT * FROM USER WHERE id = #{id}&lt;&#x2F;select&gt;</code></pre><h4 id="4-1-2-传递POJO对象"><a href="#4-1-2-传递POJO对象" class="headerlink" title="4.1.2 传递POJO对象"></a>4.1.2 传递POJO对象</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--插入用户信息--&gt;&lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt;    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;        SELECT LAST_INSERT_ID()    &lt;&#x2F;selectKey&gt;    INSERT into user (username,sex,birthday,address) values (#{username},#{sex},#{birthday},#{address})&lt;&#x2F;insert&gt;</code></pre><h4 id="4-1-3-传递POJO包装对象"><a href="#4-1-3-传递POJO包装对象" class="headerlink" title="4.1.3 传递POJO包装对象"></a>4.1.3 传递POJO包装对象</h4><p>开发中通过pojo传递查询条件 ，查询条件是综合的查询条件。不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。</p><ul><li><p>需求：综合查询用户信息，需传入复杂查询条件，如（用户信息、订单信息、商品信息）。</p></li><li><p>定义POJO包装类</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserQueryVO {    private User user;    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}</code></pre><ul><li>修改映射接口</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface UserMapper {    public void save(User user);    public User findUserById(int id);    public List&lt;User&gt; findUserByUserQueryVo(UserQueryVO vo);}</code></pre><ul><li>修改映射文件，添加查询方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--查找用户id为n的用户--&gt;&lt;select id=&quot;findUserByUserQueryVo&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;user&quot;&gt;    select u.* from user u where u.id = #{user.id}&lt;&#x2F;select&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test1(){    UserMapper mapper = session.getMapper(UserMapper.class);    &#x2F;&#x2F; 构造查询对象    UserQueryVO query = new UserQueryVO();    &#x2F;&#x2F; 设置set    User user = new User();    user.setId(1);    query.setUser(user);    &#x2F;&#x2F; 查询用户列表    List&lt;User&gt; queryVo = mapper.findUserByUserQueryVo(query);    System.out.println(queryVo);}</code></pre><h4 id="4-1-4-传递Map对象"><a href="#4-1-4-传递Map对象" class="headerlink" title="4.1.4 传递Map对象"></a>4.1.4 传递Map对象</h4><ul><li>修改映射接口文件,添加方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface UserMapper {    public void save(User user);    public User findUserById(int id);    public List&lt;User&gt; findUserByUserQueryVo(UserQueryVO vo);    public List&lt;User&gt; findUserByMap(Map&lt;String,Object&gt; map);}</code></pre><ul><li>修改映射文件，添加查询语句</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;select id=&quot;findUserByMap&quot; parameterType=&quot;hashMap&quot; resultType=&quot;user&quot;&gt;    select u.* from user u    where username like &#39;%${username}%&#39; and sex=#{sex}&lt;&#x2F;select&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java"> @Testpublic void  test2(){    UserMapper mapper = session.getMapper(UserMapper.class);    &#x2F;&#x2F; 构建map    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;username&quot;,&quot;张&quot;);    map.put(&quot;sex&quot;,&quot;1&quot;);    &#x2F;&#x2F; 查询数据    List&lt;User&gt; users = mapper.findUserByMap(map);    System.out.println(users);}</code></pre><blockquote><p>如果查询不到数据，原因是全局配置文件加载外部数据库属性文件会影响到映射文件中的数据读取，需在全局配置文件中将加载外部数据库属性文件关闭。</p></blockquote><h3 id="4-2-输出映射resultType-resultMap"><a href="#4-2-输出映射resultType-resultMap" class="headerlink" title="4.2 输出映射resultType/resultMap"></a>4.2 输出映射<code>resultType/resultMap</code></h3><h4 id="4-2-1-resultType"><a href="#4-2-1-resultType" class="headerlink" title="4.2.1 resultType"></a>4.2.1 <code>resultType</code></h4><ul><li>使用<code>resultType</code>进行结果映射时，查询的列名和映射的POJO属性名完全一致，该列才能映射成功。</li><li>如果查询的列名和映射的POJO属性名全部不一致，则不会创建POJO对象。</li><li>如果查询的列名和映射的POJO属性名有一个一致，就会创建POJO对象。</li></ul><h5 id="4-2-1-1-输出简单类型"><a href="#4-2-1-1-输出简单类型" class="headerlink" title="4.2.1.1 输出简单类型"></a>4.2.1.1 输出简单类型</h5><p>当输出结果只有一列时，可以使用<code>resultType</code>指定简单类型作为输出结果类型。</p><ul><li><p>示例输出一个<code>count(*)</code></p></li><li><p>映射接口文件中添加方法</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public int findUserCount(UserQueryVO vo);</code></pre><ul><li>映射文件中添加查询方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;select id=&quot;findUserCount&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;int&quot;&gt;    select count(*) from user where sex=#{user.sex}&lt;&#x2F;select&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void  test3(){    UserMapper mapper = session.getMapper(UserMapper.class);    UserQueryVO query = new UserQueryVO();    User user = new User();    user.setSex(&quot;1&quot;);    query.setUser(user);    int userCount = mapper.findUserCount(query);    System.out.println(userCount);}</code></pre><h5 id="4-2-1-2-输出单个POJO对象"><a href="#4-2-1-2-输出单个POJO对象" class="headerlink" title="4.2.1.2 输出单个POJO对象"></a>4.2.1.2 输出单个POJO对象</h5><ul><li>接口文件添加方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public User findUserById(int id);</code></pre><ul><li>映射文件添加查询方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;    SELECT * FROM USER WHERE id = #{id}&lt;&#x2F;select&gt;</code></pre><h5 id="4-2-1-3-输出多个POJO对象"><a href="#4-2-1-3-输出多个POJO对象" class="headerlink" title="4.2.1.3 输出多个POJO对象"></a>4.2.1.3 输出多个POJO对象</h5><ul><li>接口</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public List&lt;User&gt; findUserByUserQueryVo(UserQueryVO vo);</code></pre><ul><li>映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;select id=&quot;findUserByUserQueryVo&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;user&quot;&gt;    select u.* from user u where u.id = #{user.id}&lt;&#x2F;select&gt;</code></pre><h5 id="4-2-1-小结"><a href="#4-2-1-小结" class="headerlink" title="4.2.1 小结"></a>4.2.1 小结</h5><p>输出单个POJO对象和POJO列表时，mapper映射文件中的resultType的类型是一样的，mapper接口的方法返回值不同。</p><p>同样的mapper映射文件，返回单个对象和对象列表时，mapper接口在生成动态代理时，会根据返回值的类型，决定调用selectOne方法还是selectList方法。</p><blockquote><ul><li>POJO对象属性跟数据库列名一致，使用resultType。</li><li>不一致，使用resultMap定义映射关系。</li></ul></blockquote><h4 id="4-2-2-resultMap"><a href="#4-2-2-resultMap" class="headerlink" title="4.2.2 resultMap"></a>4.2.2 <code>resultMap</code></h4><p>如果查询出来的列名和属性名不一致，通过定义一个resultMap将<strong>列名</strong>和POJO<strong>属性名</strong>之间作一个<strong>映射关系</strong>。</p><ul><li>mapper接口</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public User findUserByIdResultMap(int id);</code></pre><ul><li>映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--设置返回类型为resultMap--&gt;&lt;resultMap id=&quot;userResultMap&quot; type=&quot;user&quot;&gt;    &lt;!--自定义resultMap列名与属性之间的映射关系--&gt;    &lt;id property=&quot;id&quot; column=&quot;id_&quot; &#x2F;&gt;    &lt;result property=&quot;username&quot; column=&quot;username_&quot; &#x2F;&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex_&quot; &#x2F;&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday_&quot; &#x2F;&gt;    &lt;result property=&quot;address&quot; column=&quot;address_&quot; &#x2F;&gt;&lt;&#x2F;resultMap&gt;&lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;    select id id_, username username_, sex sex_,birthday birthday_, address address_    from user where id=#{id};&lt;&#x2F;select&gt;</code></pre><h2 id="5-动态SQL"><a href="#5-动态SQL" class="headerlink" title="5. 动态SQL"></a>5. 动态SQL</h2><h3 id="5-1-if和where"><a href="#5-1-if和where" class="headerlink" title="5.1 if和where"></a>5.1 if和where</h3><ul><li><p>if标签：作为判断入参来使用的，如果条件符合，则把if标签体内的SQL拼接上。</p></li><li><p>where标签：会去掉条件中的第一个and符号。</p></li><li><p>动态SQL示例：</p><ul><li>修改mapper接口</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  public List&lt;User&gt; findUserList(UserQueryVO vo);</code></pre></li></ul><ul><li><p>修改映射文件</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;!--    动态拼接SQL--&gt;  &lt;select id=&quot;findUserList&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;user&quot;&gt;      select * from user      -- 条件判断      &lt;where&gt;          &lt;if test=&quot;user != null&quot;&gt;              &lt;if test=&quot;user.sex != null and user.sex != &#39;&#39;&quot;&gt;                  sex=#{user.sex}              &lt;&#x2F;if&gt;              &lt;if test=&quot;user.username != null and user.username != &#39;&#39;&quot;&gt;                  and username like &#39;%${user.username}%&#39;              &lt;&#x2F;if&gt;          &lt;&#x2F;if&gt;      &lt;&#x2F;where&gt;  &lt;&#x2F;select&gt;</code></pre></li></ul><ul><li><p>测试</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;&#x2F; 动态拼接SQL  @Test  public void  test5(){      UserMapper mapper = session.getMapper(UserMapper.class);      UserQueryVO query = new UserQueryVO();      User user = new User();      user.setSex(&quot;1&quot;);      user.setUsername(&quot;张&quot;);      query.setUser(user);      List&lt;User&gt; list = mapper.findUserList(query);      System.out.println(list);  }</code></pre></li></ul><h3 id="5-2-SQL片段"><a href="#5-2-SQL片段" class="headerlink" title="5.2 SQL片段"></a>5.2 SQL片段</h3><p>MyBatis提供了SQL片段功能，可提高SQL的可重用性</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--声明一个SQL片段--&gt;&lt;sql id=&quot;select_user_where&quot;&gt;    &lt;if test=&quot;user != null&quot;&gt;        &lt;if test=&quot;user.sex != null and user.sex != &#39;&#39;&quot;&gt;            sex=#{user.sex}        &lt;&#x2F;if&gt;        &lt;if test=&quot;user.username != null and user.username != &#39;&#39;&quot;&gt;            and username like &#39;%${user.username}%&#39;        &lt;&#x2F;if&gt;        &lt;if test=&quot;user.address != null and user.address != &#39;&#39;&quot;&gt;            and address like &#39;%${user.address}%&#39;        &lt;&#x2F;if&gt;    &lt;&#x2F;if&gt;&lt;&#x2F;sql&gt;&lt;!--动态拼接SQL--&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;user&quot;&gt;    select * from user    -- 条件判断    &lt;where&gt;        -- 引用SQL片段        &lt;include refid=&quot;select_user_where&quot;&#x2F;&gt;    &lt;&#x2F;where&gt;&lt;&#x2F;select&gt;</code></pre><h3 id="5-3-forEach遍历"><a href="#5-3-forEach遍历" class="headerlink" title="5.3 forEach遍历"></a>5.3 forEach遍历</h3><ul><li>查询对象类中新增ids属性，存放id列表</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserQueryVO {    private User user;    private List&lt;Integer&gt; ids;    public List&lt;Integer&gt; getIds() {        return ids;    }    public void setIds(List&lt;Integer&gt; ids) {        this.ids = ids;    }    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}</code></pre><ul><li>mapper接口</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 查询多个id的用户数据     *&#x2F;public List&lt;User&gt; findUserByIds(UserQueryVO vo);</code></pre><ul><li>映射文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--foreach示例--&gt;&lt;select id=&quot;findUserByIds&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;user&quot;&gt;    select * from user    -- select * from user where id in (10,24,37);    &lt;where&gt;        &lt;if test=&quot;ids != null and ids.size &gt; 0&quot;&gt;            &lt;!--                    foreach标签：表示一个foreach循环                    collection：集合参数的名称，如果是直接传入集合参数，则该处参数名称只能填写[list]                    item：每次遍历出来的对象                    open：开始遍历时拼接的串                    close：结束遍历时拼接的串                    separator：遍历出的每个对象之间需要拼接的字符                --&gt;            &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;id in(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;                ${id}            &lt;&#x2F;foreach&gt;        &lt;&#x2F;if&gt;    &lt;&#x2F;where&gt;&lt;&#x2F;select&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void  test6() {    UserMapper mapper = session.getMapper(UserMapper.class);    UserQueryVO query = new UserQueryVO();    List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();    &#x2F;&#x2F;select * from user where id in (10,24,37);    ids.add(10);    ids.add(24);    ids.add(37);    query.setIds(ids);    List&lt;User&gt; users = mapper.findUserByIds(query);    System.out.println(users);}</code></pre><ul><li><p>关于参数直接传入id集合</p><ul><li>mapper接口</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  public List&lt;User&gt; findUserByLists(List&lt;Integer&gt; list);</code></pre></li></ul><ul><li><p>映射文件</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;!--如果参数是数组的话，parameterType可以写全限定名，也可以写别名--&gt;  &lt;select id=&quot;findUserByLists&quot; parameterType=&quot;java.util.List&quot; resultType=&quot;user&quot;&gt;      select * from user      &lt;where&gt;          &lt;if test=&quot;list != null and list.size &gt; 0&quot;&gt;              -- 如果是直接传入集合参数，则该处参数名称只能填写[list]              &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; open=&quot;id in(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;                  ${id}              &lt;&#x2F;foreach&gt;          &lt;&#x2F;if&gt;      &lt;&#x2F;where&gt;  &lt;&#x2F;select&gt;</code></pre></li></ul><ul><li>测试同上，查询方法改一下即可。</li></ul><h2 id="6-MyBatis与Hibernate的区别"><a href="#6-MyBatis与Hibernate的区别" class="headerlink" title="6. MyBatis与Hibernate的区别"></a>6. MyBatis与Hibernate的区别</h2><h3 id="6-1-MyBatis技术特点"><a href="#6-1-MyBatis技术特点" class="headerlink" title="6.1 MyBatis技术特点"></a>6.1 MyBatis技术特点</h3><ul><li>好处：<ul><li>通过直接编写SQL语句，可以直接对SQL进行性能优化</li><li>学习成本低，有SQL基础，就可以学习MyBatis，容易上手</li><li>由于直接编写SQL语句，所以灵活多变，代码维护性更好</li></ul></li><li>缺点<ul><li>不能支持数据库无关性，即数据库发生变更，要写多套代码进行支持，移植性不好。</li><li>需要编写结果映射。</li></ul></li></ul><h3 id="6-2-Hibernate技术特点"><a href="#6-2-Hibernate技术特点" class="headerlink" title="6.2 Hibernate技术特点"></a>6.2 Hibernate技术特点</h3><ul><li>好处<ul><li>标准的ORM框架，程序员无需编写SQL语句。</li><li>具有良好的数据库无关性，即数据库发生变化，代码无需再次编写。<ul><li>例：mysql数据迁移到oracle，只需更改方言配置即可</li></ul></li></ul></li><li>缺点<ul><li>学习门槛高，需要对数据关系模型有良好的基础，而且在设置OR映射时，需考虑好性能和对象模型的权衡</li><li>我们不能自主的去进行SQL性能优化。</li></ul></li></ul><h3 id="6-3-MyBatis应用场景"><a href="#6-3-MyBatis应用场景" class="headerlink" title="6.3 MyBatis应用场景"></a>6.3 MyBatis应用场景</h3><p>需求多变的互联网项目，例如电商项目</p><h3 id="6-4-Hibernate应用场景"><a href="#6-4-Hibernate应用场景" class="headerlink" title="6.4 Hibernate应用场景"></a>6.4 Hibernate应用场景</h3><p>需求明确，业务固定的项目，例如OA项目，ERP项目等。</p>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的事务管理</title>
      <link href="/FrameWork/Spring-Transaction.html"/>
      <url>/FrameWork/Spring-Transaction.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Java事务导引"><a href="#1-Java事务导引" class="headerlink" title="1. Java事务导引"></a>1. Java事务导引</h2><h3 id="1-1-事务简介"><a href="#1-1-事务简介" class="headerlink" title="1.1 事务简介"></a>1.1 事务简介</h3><ul><li>什么是事务<ul><li>事务是<strong>正确执行</strong>一系列的操作(或动作)，使得数据库从一种状态转换成另一种状态，且保证操作<strong>全部成功</strong>，或者<strong>全部失败</strong>。</li></ul></li></ul><a id="more"></a><ul><li>事务原则是什么<ul><li>事务必须服从ISO/IEC所制定的ACID原则</li></ul></li><li>ACID原则具体内容如下：<ul><li>原子性（Atomicity）：即不可分割性，事务要么全部被执行，要么就全部不被执行。</li><li>一致性（Consistency）：事务的执行使得数据库从一种正确状态转换成另一种正确状态。</li><li>隔离性（Isolation）：在事务正确提交之前，它可能的结果不应显示给任何其他事务。</li><li>持久性（Durability）：事务正确提交后，其结果将永久保存在数据库中。</li></ul></li></ul><h3 id="1-2-Java事务"><a href="#1-2-Java事务" class="headerlink" title="1.2 Java事务"></a>1.2 Java事务</h3><ul><li>Java事务的产生<ul><li>程序操作数据库的需要。以Java编写的程序或系统，实现ACID的操作。</li></ul></li><li>Java事务实现<ul><li>通过JDBC相应方法间接来实现对数据库的增删改查，把事务转移到Java程序代码中进行控制。</li><li>确保事务要么全部执行成功，要么撤销不执行。</li></ul></li><li>总结：Java事务机制和原理就是操作确保数据库操作的ACID特性。</li></ul><h3 id="1-3-Java事务实现模式"><a href="#1-3-Java事务实现模式" class="headerlink" title="1.3 Java事务实现模式"></a>1.3 Java事务实现模式</h3><ul><li>Java事务的实现<ul><li>通过Java代码来实现对数据库的事务性操作</li></ul></li><li>Java事务类型<ul><li>JDBC事务：用Connection对象控制的手动模式和自动模式</li><li>JTA(Java Transaction API)事务：与实现无关的，与协议无关的API</li><li>容器事务：应用服务器提供的，且大多是基于JTA完成(通常基于JNDI的，相当复杂的API实现)</li></ul></li></ul><h3 id="1-4-三种事务的差异"><a href="#1-4-三种事务的差异" class="headerlink" title="1.4 三种事务的差异"></a>1.4 三种事务的差异</h3><ul><li>JDBC事务：控制的局限性在一个数据库连接内，但是其使用简单。</li><li>JTA事务：功能强大，可跨越多个数据库或多DAO，使用比较复杂。</li><li>容器事务：主要指的是J2EE应用服务器提供的事务管理，局限于EJB应用使用。</li></ul><h2 id="2-Spring事务核心接口"><a href="#2-Spring事务核心接口" class="headerlink" title="2. Spring事务核心接口"></a>2. Spring事务核心接口</h2><h3 id="2-1-事务接口架构"><a href="#2-1-事务接口架构" class="headerlink" title="2.1 事务接口架构"></a>2.1 事务接口架构</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/18/framework-1566143165106.jpg" alt="framework"></p><h3 id="2-2-Spring事务管理器"><a href="#2-2-Spring事务管理器" class="headerlink" title="2.2 Spring事务管理器"></a>2.2 Spring事务管理器</h3><ul><li>JDBC事务管理器(<code>DataSourceTransactionManager</code>)<ul><li>本事务管理器是通过调用<code>java.sql.Connection</code>来管理事务。</li><li>Spring配置示例</li></ul></li><li>Hibernate事务管理器(<code>HibernateTransactionManager</code>)<ul><li>本管理器将事务管理的职责委托给<code>org.hibernate.Transaction</code>对象来管理事务，而后者是从Hibernate Session中获取到的。</li></ul></li><li>JPA事务管理器(<code>JpaTransactionManager</code>)<ul><li>通过一个JPA实体管理工厂(<code>javax.persistence.EntityManagerFactory</code>接口的任意实现)将与由工厂所产生的JPA <code>EntityManager</code>合作来构建事务。</li></ul></li><li>JTA事务管理器(<code>JtaTransactionManager</code>)<ul><li>本管理器将事务管理的责任委托给<code>javax.transaction.UserTransaction</code>和<code>javax.transaction.TransactionManager</code>对象进行事务处理。</li></ul></li></ul><h3 id="2-3-Spring事务属性定义"><a href="#2-3-Spring事务属性定义" class="headerlink" title="2.3 Spring事务属性定义"></a>2.3 Spring事务属性定义</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/18/Transaction_attribute-1566143193689.jpg" alt="Transaction_attribute"></p><h3 id="2-4-事务隔离级别"><a href="#2-4-事务隔离级别" class="headerlink" title="2.4 事务隔离级别"></a>2.4 事务隔离级别</h3><h4 id="2-4-1-数据读取类型说明"><a href="#2-4-1-数据读取类型说明" class="headerlink" title="2.4.1 数据读取类型说明"></a>2.4.1 数据读取类型说明</h4><ul><li>脏读<ul><li>脏读发生在一个事务A读取了被另一个事务B修改，但是还未提交的数据。假如B回滚，则事务A读取的就是无效数据。跟不可重复读类似，但是第二个事务无需执行提交。</li></ul></li><li>不可重复读<ul><li>在基于锁的并行控制方法中，如果在执行select时不添加读锁，就会发生不可重复读问题，导致两次读取的数据不一致。</li></ul></li><li>幻读<ul><li>幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一次查询的不相同。</li></ul></li></ul><p><a href="https://www.cnblogs.com/balfish/p/8298296.html" target="_blank" rel="noopener">参考文章</a></p><h4 id="2-4-2-事务隔离级别"><a href="#2-4-2-事务隔离级别" class="headerlink" title="2.4.2 事务隔离级别"></a>2.4.2 事务隔离级别</h4><ul><li>隔离级别定义了一个事务可能受其他并发事务影响的程度</li><li>隔离级别如下：</li></ul><table><thead><tr><th>隔离级别</th><th>含义</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT</td><td>使用后端数据库默认的隔离级别</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED</td><td>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</td></tr><tr><td>ISOLATION_READ_COMMITTED</td><td>允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</td></tr><tr><td>ISOLATION_REPEATABLE_READ</td><td>对同一字段的多次读取结果都是一致的，除非数据时被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</td></tr><tr><td>ISOLATION_SERIALIZABLE</td><td>最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读和幻读。也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</td></tr></tbody></table><h3 id="2-5-事务传播行为"><a href="#2-5-事务传播行为" class="headerlink" title="2.5 事务传播行为"></a>2.5 事务传播行为</h3><ul><li>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。即两个业务之间如何共享事务</li><li>Spring的7种传播行为：</li></ul><table><thead><tr><th>传播行为</th><th>含义</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>表示当前方法无需事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>表示该方法必须在事务中运行，如果当前事务不存在，则会抛异常</td></tr><tr><td>PROPAGATION_REQUIRED_NEW</td><td>表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用<code>JTATransactionManager</code>的话，则需要访问<code>TransactionManager</code></td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用<code>JTATransactionManager</code>的话，则需要访问<code>TransactionManager</code></td></tr><tr><td>PROPAGATION_NEVER</td><td>表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常</td></tr><tr><td>PROPAGATION_NESTED</td><td>表示如果当前存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与<code>PROPAGATION_REQUIRED</code>一样。注意各厂商对这种传播行为的支持是有所差异的。参考资源管理器的文档来确认它们是否支持嵌套事务。</td></tr></tbody></table><h3 id="2-6-事务中注意的问题"><a href="#2-6-事务中注意的问题" class="headerlink" title="2.6 事务中注意的问题"></a>2.6 事务中注意的问题</h3><ul><li>事务是否只读<ul><li>利用数据库事务的“只读”属性，进行特点优化处理</li></ul></li><li>注意：<ul><li>事务的是否“只读”属性，不同的数据库厂商支持不同</li><li>通常而言：只读属性的应用要参考厂商的具体支持说明，比如：<ul><li>Oracle的“readOnly”不起作用，不影响其增删改查</li><li>MySQL的“readOnly”为true，只能查，增删改则出异常</li></ul></li></ul></li><li>事务超时<ul><li>事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</li></ul></li><li>设计事务时注意点<ul><li>为了使应用程序更好的运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。</li></ul></li><li>事务回滚<ul><li>默认情况下，事务只有遇到运行期异常才会回滚，而在遇到检查型异常时不会回滚。</li></ul></li><li>自定义回滚策略<ul><li>声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚；</li><li>声明事务遇到特定的异常不回滚，即使这些异常时运行期异常。</li></ul></li></ul><h3 id="2-7-Spring事务状态"><a href="#2-7-Spring事务状态" class="headerlink" title="2.7 Spring事务状态"></a>2.7 Spring事务状态</h3><ul><li><p>事务接口</p><ul><li>通过事务管理器获取<code>TransactionStatus</code>实例；</li><li>控制事务在回滚或提交时需要应用对应的事务状态；</li><li>Spring事务接口：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;&#x2F; Spring事务状态接口：  &#x2F;&#x2F; 通过调用PlatformTransactionManager的getTransaction()  &#x2F;&#x2F; 获取事务状态实例  public interface TransactionStatus{      boolean isNewTransaction(); &#x2F;&#x2F; 是否是新的事务      boolean hasSavepoint(); &#x2F;&#x2F; 是否有恢复点      void setRollbackOnly(); &#x2F;&#x2F; 设置为只回滚      boolean isRollBackOnly(); &#x2F;&#x2F; 是否为只回滚      boolean isCompleted; &#x2F;&#x2F; 是否已完成  }</code></pre></li></ul><h3 id="2-8-转账案例"><a href="#2-8-转账案例" class="headerlink" title="2.8 转账案例"></a>2.8 转账案例</h3><p>通过代理工厂实现事务</p><h4 id="2-8-1-环境搭建"><a href="#2-8-1-环境搭建" class="headerlink" title="2.8.1 环境搭建"></a>2.8.1 环境搭建</h4><p>创建用户数据库表</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">create table account(id int primary key auto_increment,username varchar(50),money int);insert into account(username,money) values(&#39;jack&#39;,10000);insert into account(username,money) values(&#39;rose&#39;,10000);</code></pre><h4 id="2-8-2-导入jar包"><a href="#2-8-2-导入jar包" class="headerlink" title="2.8.2 导入jar包"></a>2.8.2 导入jar包</h4><ul><li>spring核心：4+1(core+context+beans+expression)+logging</li><li>aop：4（aop联盟、spring aop、aspectj规范、spring aspect）</li><li>数据库：jdbc、tx</li><li>驱动：mysql</li><li>连接池：dbcp</li></ul><h4 id="2-8-3-创建Dao层"><a href="#2-8-3-创建Dao层" class="headerlink" title="2.8.3 创建Dao层"></a>2.8.3 创建Dao层</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao {     &#x2F;&#x2F; JdbcDaoSupport，在xml中配置数据源即可使用    &#x2F;&#x2F; 转出    @Override    public void out(String outer, Integer money) {        String sql = &quot;update account set money = money - ? where username = ?&quot;;        getJdbcTemplate().update(sql,money,outer);    }    &#x2F;&#x2F; 进账    @Override    public void in(String inner, Integer money) {        String sql = &quot;update account set money = money + ? where username = ?&quot;;        getJdbcTemplate().update(sql,money,inner);    }}</code></pre><h4 id="2-8-4-创建Service层"><a href="#2-8-4-创建Service层" class="headerlink" title="2.8.4 创建Service层"></a>2.8.4 创建Service层</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class AccountServiceImpl implements AccountService {    private AccountDao accountDao;    &#x2F;&#x2F; 提供set方法，让spring注入属性    public void setAccountDao(AccountDao accountDao) {        this.accountDao = accountDao;    }    @Override    public void transfer(String outer, String inner, Integer money) {        this.accountDao.out(outer,money);        int i = 1&#x2F;0; &#x2F;&#x2F; 手动制造异常，测试事务是否其效果        this.accountDao.in(inner,money);    }}</code></pre><h4 id="2-8-5-配置文件"><a href="#2-8-5-配置文件" class="headerlink" title="2.8.5 配置文件"></a>2.8.5 配置文件</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;       xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;       xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;    &lt;!--配置DBCP数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!--配置Template--&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!--配置Dao--&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.zero.transaction.dao.Impl.AccountDaoImpl&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!--配置事务管理器--&gt;    &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!--配置service--&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.zero.transaction.service.Impl.AccountServiceImpl&quot;&gt;       &lt;!--添加属性accountDao--&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!--配置代理工厂--&gt;    &lt;bean id=&quot;proxyService&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;        &lt;!--接口，注意配置全类名--&gt;        &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.zero.transaction.service.AccountService&quot;&#x2F;&gt;         &lt;!--目标对象--&gt;        &lt;property name=&quot;target&quot; ref=&quot;accountService&quot;&#x2F;&gt;        &lt;!--切面对象，SPring做了，就不用写了--&gt;        &lt;!--事务管理器--&gt;        &lt;property name=&quot;transactionManager&quot; ref=&quot;txManager&quot;&#x2F;&gt;        &lt;!--            事务属性&#x2F;详情配置            prop.key ：确定哪些方法使用当前事务配置            prop.text:用于配置事务详情            格式：PROPAGATION,ISOLATION,readOnly,-Exception,+Exception            传播行为 隔离级别      是否只读异常回滚      异常提交        --&gt;        &lt;property name=&quot;transactionAttributes&quot;&gt;            &lt;props&gt;                &lt;!--可以配置隔离级别--&gt;                &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&lt;&#x2F;prop&gt;            &lt;&#x2F;props&gt;        &lt;&#x2F;property&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><h4 id="2-8-6-测试"><a href="#2-8-6-测试" class="headerlink" title="2.8.6 测试"></a>2.8.6 测试</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:transfer.xml&quot;)public class transferTest {&#x2F;&#x2F;    @Autowired    @Resource(name = &quot;proxyService&quot;)    private AccountService accountService;    &#x2F;&#x2F; 转账测试    @Test    public void test1(){        &#x2F;&#x2F; 获取service        accountService.transfer(&quot;jack&quot;,&quot;rose&quot;,100);    }}</code></pre><h2 id="3-编程式事务管理"><a href="#3-编程式事务管理" class="headerlink" title="3. 编程式事务管理"></a>3. 编程式事务管理</h2><h3 id="3-1-编程式事务实现方式"><a href="#3-1-编程式事务实现方式" class="headerlink" title="3.1 编程式事务实现方式"></a>3.1 编程式事务实现方式</h3><ul><li>模板事务(<code>TransactionTemplate</code>)的方式<ul><li>此为Spring官方团队推荐的编程式事务管理方式</li><li>主要工具为<code>JdbcTemplate</code>类。</li></ul></li><li>平台事务管理器(<code>PlatformTransactionManager</code>)方式<ul><li>类似应用<code>JTA UserTransaction API</code>方式，但异常处理更简洁；</li><li>辅助类为：<code>TransactionDefinition</code>和<code>TransactionStatus</code></li></ul></li></ul><h3 id="3-2-编程式事务实现案例"><a href="#3-2-编程式事务实现案例" class="headerlink" title="3.2 编程式事务实现案例"></a>3.2 编程式事务实现案例</h3><ul><li><p>模板事务(<code>TransactionTemplate</code>)案例</p><ul><li>步骤：获取模板对象；选择事务结果类型；业务数据操作处理。</li></ul></li><li><p>平台事务管理器(<code>PlatformTransactionManager</code>)案例</p><ul><li>步骤：获取事务管理器；获取事务属性对象；获取事务状态对象；创建JDBC模板对象；业务数据操作处理。</li></ul></li><li>数据库工具类DButil</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DBUtil {    static  final String dbDriver = &quot;com.mysql.jdbc.Driver&quot; ;    static final String dbUrl = &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;characterEncoding=utf-8&quot; ;&#x2F;&#x2F;    static final String userName = &quot;root&quot; ;    static final String password = &quot;123456&quot; ;    static {        try{&#x2F;&#x2F;加载MySql的驱动类            Class.forName(dbDriver) ;        }catch(ClassNotFoundException e){            System.out.println(&quot;找不到驱动程序类 ，加载驱动失败！&quot;);            e.printStackTrace() ;        }    }    public static Connection getConnection(){        try {            return DriverManager.getConnection(dbUrl , userName , password ) ;        } catch (SQLException e) {            e.printStackTrace();        }        return null ;    }}</code></pre><ul><li>数据库工具类<code>TemplateUtils</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * Spring数据库操作工具类 *&#x2F;public class TemplateUtils {private final static  String dbDriver = &quot;com.mysql.jdbc.Driver&quot; ;private final static  String dbUrl = &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;selection_course?useUnicode=true&amp;characterEncoding=utf-8&quot; ;&#x2F;&#x2F;private final static  String dbUser = &quot;root&quot;;private final static  String dbPwd = &quot;123456&quot;;private static BasicDataSource dataSource ;&#x2F;&#x2F;静态初识：创建连接数据源static {&#x2F;&#x2F;创建DBCP简单数据源并初始化相关数据源属性&#x2F;&#x2F;private void createSimpleDataSource(){dataSource = new   BasicDataSource() ;dataSource.setDriverClassName(dbDriver);dataSource.setUrl(dbUrl);dataSource.setUsername(dbUser);dataSource.setPassword(dbPwd);&#x2F;&#x2F;&#x2F;&#x2F;指定数据库连接池初始连接数&#x2F;&#x2F;dataSource.setInitialSize(10);&#x2F;&#x2F;&#x2F;&#x2F;设定同时向数据库申请的最大连接数&#x2F;&#x2F;dataSource.setMaxTotal(50);&#x2F;&#x2F;&#x2F;&#x2F;设置连接池中保持的最少连接数量&#x2F;&#x2F;dataSource.setMinIdle(5);&#x2F;&#x2F;}}public static TransactionTemplate getTransactionTemplate() {          PlatformTransactionManager txManager = new DataSourceTransactionManager(                  dataSource);          return new TransactionTemplate(txManager);      }        public static JdbcTemplate getJdbcTemplate() {          return new JdbcTemplate(dataSource);      }        public static NamedParameterJdbcTemplate getNamedParameterJdbcTemplate() {          return new NamedParameterJdbcTemplate(dataSource);      }        public static SimpleJdbcInsert getSimpleJdbcTemplate() {          return new SimpleJdbcInsert(dataSource);      }          &#x2F;**     * &#x2F;&#x2F;获取事务管理器：TransactionManager     * 根据需要，可以是如JDBC、Hibernate,这里定义JDBC事务管理其     * @return DataSourceTransactionManager     *&#x2F;    public static DataSourceTransactionManager getDataSourceTransactionManager(){     DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();     &#x2F;&#x2F; 设置数据源:此事务数据源须和正式事务管理器的数据源一致     dataSourceTransactionManager.setDataSource(dataSource);     return dataSourceTransactionManager;    }}</code></pre><ul><li>事务管理器示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** *  事务管理器方式案例 *&#x2F;public class ProTransExample {    &#x2F;&#x2F; 事务模板：第二种事务编程模式    &#x2F;&#x2F; private TransactionTemplate transactionTemplate ;    &#x2F;&#x2F; 数据持久化操作    public void addBook(final Book book) {        &#x2F;&#x2F; 获取事务模板对象        TransactionTemplate tt = TemplateUtils.getTransactionTemplate();        &#x2F;&#x2F; 可设置事务属性，如隔离级别、超时时间等,如：        &#x2F;&#x2F; tt.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);        &#x2F;&#x2F; 内部类        tt.execute(new TransactionCallbackWithoutResult() {            protected void doInTransactionWithoutResult(TransactionStatus s) {                try {                    &#x2F;&#x2F; 数据库操作1                    &#x2F;&#x2F; JdbcTemplate jdbcTemplate                    &#x2F;&#x2F; =TemplateUtils.getJdbcTemplate();                    &#x2F;&#x2F; jdbcTemplate.execute(sql);                    &#x2F;&#x2F; 简单模板化新增数据                    SimpleJdbcInsert simpleInsert = TemplateUtils.getSimpleJdbcTemplate();                    simpleInsert.withTableName(&quot;books&quot;).usingColumns(&quot;isbn&quot;, &quot;name&quot;, &quot;price&quot;, &quot;pubdate&quot;);                    Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;();                    parameters.put(&quot;isbn&quot;, book.getIsbn());                    parameters.put(&quot;name&quot;, book.getName());                    parameters.put(&quot;price&quot;, book.getPrice());                    parameters.put(&quot;pubdate&quot;, book.getPubdate());                    simpleInsert.execute(parameters);                    System.out.println(&quot;新增数据成功！&quot;);                    &#x2F;&#x2F; 或者DAO数据操作模式：                    &#x2F;&#x2F; BookDAO.save(book);                } catch (Exception e) {                    s.setRollbackOnly();                    e.printStackTrace();                }            }        });    }    public Book findBookByIsbn(final String isbn) {        TransactionTemplate tt = TemplateUtils.getTransactionTemplate();        Book book = null;        @SuppressWarnings(&quot;unchecked&quot;)        List&lt;Map&lt;String, Object&gt;&gt; books = (List&lt;Map&lt;String, Object&gt;&gt;) tt.execute(new TransactionCallback&lt;Object&gt;() {            public Object doInTransaction(TransactionStatus arg0) {                JdbcTemplate jdbcTemplate = TemplateUtils.getJdbcTemplate();                return jdbcTemplate.queryForList(&quot;select isbn,name,price,pubdate from books where isbn =&#39;&quot; + isbn + &quot;&#39;&quot;);            }        });        if (books.size() != 0) {&#x2F;&#x2F; 封装获取的数据            Map&lt;String, Object&gt; m = (Map) books.get(0);            book = new Book();            book.setIsbn(m.get(&quot;isbn&quot;).toString());            book.setName(m.get(&quot;name&quot;).toString());            book.setPrice((Float) m.get(&quot;price&quot;));            book.setPubdate((Date) m.get(&quot;pubdate&quot;));        }        return book;    }    &#x2F;&#x2F; 1、编程式事务管理：事务管理器PlatformTransactionManager方式实现    public void updateBookByIsbn(Book book) {        &#x2F;&#x2F;第一步：获取JDBC事务管理器        DataSourceTransactionManager dtm = TemplateUtils.getDataSourceTransactionManager();        &#x2F;&#x2F; 第二步：创建事务管理器属性对象        DefaultTransactionDefinition transDef = new DefaultTransactionDefinition(); &#x2F;&#x2F; 定义事务属性        &#x2F;&#x2F; 根据需要，设置事务管理器的相关属性        &#x2F;&#x2F; 设置传播行为属性        transDef.setPropagationBehavior(DefaultTransactionDefinition.PROPAGATION_REQUIRED);        &#x2F;&#x2F; 第三步：获得事务状态对象        TransactionStatus ts = dtm.getTransaction(transDef);        &#x2F;&#x2F; 第四步：基于当前事务管理器,获取数据源，创建操作数据库的JDBC模板对象        JdbcTemplate jt = new JdbcTemplate(dtm.getDataSource());        try {            &#x2F;&#x2F;第五步：业务操作            jt.update(&quot;update books set price=&quot;+book.getPrice()+&quot;,name=&#39;&quot;+book.getName()                    +&quot;&#39;  where isbn=&#39;&quot;+book.getIsbn()+&quot;&#39; &quot;);            &#x2F;&#x2F; 其它数据操作如增删            &#x2F;&#x2F;第六步：提交事务            dtm.commit(ts); &#x2F;&#x2F; 如果不commit，则更新无效果            System.out.println(&quot;修改成功&quot;);        } catch (Exception e) {            &#x2F;&#x2F; 报错直接回滚事务            dtm.rollback(ts);            e.printStackTrace();        }    }    public static void main(String[] args) {        ProTransExample pte = new ProTransExample();        Book book = pte.findBookByIsbn(&quot;128-166-890-China&quot;); &#x2F;&#x2F; 查询数据        if (book != null){ &#x2F;&#x2F; 如果查询到就更新数据            book.setName(&quot;华夏龙图腾&quot;);            book.setPrice(125.5f);            pte.updateBookByIsbn(book);        }else {            &#x2F;&#x2F; 如果没有则添加数据            Book addbook = new Book();            addbook.setIsbn(&quot;128-166-890-China&quot;);            addbook.setName(&quot;华夏龙图腾&quot;);            addbook.setPrice(128.5f);            pte.addBook(addbook);        }        &#x2F;*         *1-新增书籍         * Date pd = new Date(System.currentTimeMillis()); Book book = new         * Book(); book.setIsbn(&quot;120-166-990-China&quot;); book.setName(&quot;人性的弱点&quot;);         * book.setPrice(65.6f); book.setPubdate(pd);         *&#x2F;        &#x2F;&#x2F; pte.addBook(book);        &#x2F;&#x2F;2-查找书籍&#x2F;*Book bk = pte.findBookByIsbn(&quot;120-166-890-China&quot;);System.out.println(&quot;书籍名称：&quot; + bk.getName());*&#x2F;        &#x2F;&#x2F;3-更新书籍名称和价格    }}</code></pre><h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><ul><li>需要有效的数据源，具体数据源根据实际情况创建</li><li>创建编程事务管理对象<ul><li>事务模板(<code>TransactionTemplate</code>)</li><li>事务管理器(<code>PlateformTransactionManager</code>)</li></ul></li><li>业务逻辑处理<ul><li>基于<code>JdbcTemplate</code>完成业务处理。</li></ul></li></ul><h2 id="4-声明式事务管理-掌握"><a href="#4-声明式事务管理-掌握" class="headerlink" title="4. 声明式事务管理(掌握)"></a>4. 声明式事务管理(掌握)</h2><h3 id="4-1-声明式事务实现方式"><a href="#4-1-声明式事务实现方式" class="headerlink" title="4.1 声明式事务实现方式"></a>4.1 声明式事务实现方式</h3><ul><li><p>声明式事务管理的配置类型</p><ul><li>5种类型：独立代理；共享代理；拦截器；tx拦截器；全注释。</li></ul></li><li><p>声明式事务管理配置实现方式：</p><ul><li>5种类型的配置实现参考</li></ul></li><li><p>转账案例<strong>基于AOP的事务配置</strong>：</p><ul><li>基本代码不变，修改xml配置文件如下</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;         xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;         xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;         xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;         xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;        &lt;!--开启自动扫描--&gt;      &lt;context:component-scan base-package=&quot;com.zero.jdbc_Template&quot;&#x2F;&gt;        &lt;!--配置DBCP数据源--&gt;      &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt;          &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;          &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt;          &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt;          &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;        &lt;!--配置Template--&gt;      &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;        &lt;!--配置Dao--&gt;      &lt;bean id=&quot;accountDao&quot; class=&quot;com.zero.transaction.dao.Impl.AccountDaoImpl&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;        &lt;!--配置事务管理器--&gt;      &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;      &lt;!--配置service--&gt;      &lt;bean id=&quot;accountService&quot; class=&quot;com.zero.transaction.service.Impl.AccountServiceImpl&quot;&gt;          &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;        &lt;!--使用spring的aop来配置事务--&gt;        &lt;!--1. 配置通知事务管理器--&gt;      &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;          &lt;!--事务详情：传播行为，隔离级别--&gt;          &lt;tx:attributes&gt;              &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot;&#x2F;&gt;          &lt;&#x2F;tx:attributes&gt;      &lt;&#x2F;tx:advice&gt;      &lt;!--2. 事务通知与切入点关联--&gt;      &lt;aop:config&gt;  &lt;!--        &lt;aop:pointcut id=&quot;myPoinycut&quot; expression=&quot;execution(* com.zero.transaction.service..*.*(..))&quot;&#x2F;&gt;--&gt;  &lt;!--        &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;myPoinycut&quot;&#x2F;&gt;--&gt;          &lt;!--事务与连接点关联--&gt;          &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.zero.transaction.service..*.*(..))&quot;&#x2F;&gt;      &lt;&#x2F;aop:config&gt;    &lt;&#x2F;beans&gt;</code></pre></li></ul><ul><li><p>测试</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @RunWith(SpringJUnit4ClassRunner.class)  @ContextConfiguration(&quot;classpath:transfer_aop.xml&quot;)  public class transferTest {        @Autowired &#x2F;&#x2F; 使用自动注入  &#x2F;&#x2F;    @Resource(name = &quot;proxyService&quot;)      private AccountService accountService;        &#x2F;&#x2F; 转账测试      @Test      public void test1(){          &#x2F;&#x2F; 获取service          accountService.transfer(&quot;jack&quot;,&quot;rose&quot;,100);      }        &#x2F;&#x2F; 使用aop配置事务      @Test      public void test2(){          accountService.transfer(&quot;jack&quot;,&quot;rose&quot;,100);        }  }</code></pre></li></ul><ul><li><p>使用注解来实现事务</p><ul><li>基本代码不变，修改xml如下</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;         xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;         xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;         xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;         xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;        &lt;!--开启自动扫描--&gt;      &lt;context:component-scan base-package=&quot;com.zero.jdbc_Template&quot;&#x2F;&gt;        &lt;!--配置DBCP数据源--&gt;      &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt;          &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;          &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt;          &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt;          &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;        &lt;!--配置Template--&gt;      &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;        &lt;!--配置Dao--&gt;      &lt;bean id=&quot;accountDao&quot; class=&quot;com.zero.transaction.dao.Impl.AccountDaoImpl&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;        &lt;!--配置service--&gt;      &lt;bean id=&quot;accountService&quot; class=&quot;com.zero.transaction.service.Impl.AccountServiceImpl&quot;&gt;          &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;        &lt;!--使用spring的注解来实现事务--&gt;        &lt;!--1. 配置事务管理器--&gt;      &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;      &lt;!--2. 开启事务注解驱动--&gt;      &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;&#x2F;&gt;    &lt;&#x2F;beans&gt;</code></pre></li></ul><ul><li><p>在需要开启事务的实现类上添加注解信息</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.DEFAULT)  public class AccountServiceImpl implements AccountService {        private AccountDao accountDao;      &#x2F;&#x2F; 提供set方法，让spring注入属性      public void setAccountDao(AccountDao accountDao) {          this.accountDao = accountDao;      }        @Override      public void transfer(String outer, String inner, Integer money) {          this.accountDao.out(outer,money);  &#x2F;&#x2F;        int i = 1&#x2F;0;          this.accountDao.in(inner,money);      }  }</code></pre></li></ul><ul><li><p>测试</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @RunWith(SpringJUnit4ClassRunner.class)  @ContextConfiguration(&quot;classpath:transfer_anno.xml&quot;) &#x2F;&#x2F; 修改为注解配置的xml即可  public class transferTest {        @Autowired  &#x2F;&#x2F;    @Resource(name = &quot;proxyService&quot;)      private AccountService accountService;        &#x2F;&#x2F; 使用aop配置事务      @Test      public void test2(){          accountService.transfer(&quot;jack&quot;,&quot;rose&quot;,100);        }  }</code></pre></li></ul><h2 id="5-事务管理最佳实践"><a href="#5-事务管理最佳实践" class="headerlink" title="5. 事务管理最佳实践"></a>5. 事务管理最佳实践</h2><h3 id="5-1-编程事务管理和声明事务管理的区别"><a href="#5-1-编程事务管理和声明事务管理的区别" class="headerlink" title="5.1 编程事务管理和声明事务管理的区别"></a>5.1 编程事务管理和声明事务管理的区别</h3><ul><li>编程式事务允许用户在代码中精确定义事务的边界；</li><li>声明式事务有助于用户将操作与事务规则进行解耦<ul><li>基于AOP交由Spring容器实现</li><li>实现关注点聚焦在业务逻辑上</li></ul></li><li>简言<ul><li>编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以即能起到事务管理的作用，又不影响业务代码的具体实现。</li></ul></li></ul><h3 id="5-2-两种事务的选择"><a href="#5-2-两种事务的选择" class="headerlink" title="5.2 两种事务的选择"></a>5.2 两种事务的选择</h3><ul><li>小型应用、事务操作少<ul><li>建议编程式事务管理实现：<code>TransactionTemplate</code></li><li>简单、显式操作、直观明显、可以设置事务名称</li></ul></li><li>大型应用，事务操作量多<ul><li>业务复杂度高、关联性紧密，建议声明式事务管理实现</li><li>关注点聚焦到业务层面，实现业务和事务的解耦。</li></ul></li></ul><h2 id="6-Spring事务管理总结"><a href="#6-Spring事务管理总结" class="headerlink" title="6. Spring事务管理总结"></a>6. Spring事务管理总结</h2><ul><li>事务与Spring事务管理</li><li>Spring事务核心接口类</li><li>编程式事务实现</li><li>声明式事务实现</li><li>事务的综合案例</li></ul>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC_Template</title>
      <link href="/FrameWork/JDBC.html"/>
      <url>/FrameWork/JDBC.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-JDBC-Template"><a href="#1-JDBC-Template" class="headerlink" title="1. JDBC Template"></a>1. JDBC Template</h2><p>Spring对数据库的操作在jdbc上面做了深层次的封装，简化了持久层操作。使用spring的注入功能，可以把DataSource注册到JdbcTemplate中。</p><a id="more"></a><ul><li>为了简化持久化操作，Spring在JDBC API之上提供了JDBC Template组件</li></ul><h3 id="1-1-准备阶段"><a href="#1-1-准备阶段" class="headerlink" title="1.1 准备阶段"></a>1.1 准备阶段</h3><ul><li>先创建数据库</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">drop database if exists selection_course;create database selection_course;use selection_course;create table course(   id                   int not null auto_increment,   name                 char(20),   score                int,   primary key (id));create table selection(   student              int not null,   course               int not null,   selection_time       datetime,   score                int,   primary key (student, course));create table student(   id                   int not null auto_increment,   name                 varchar(20),   sex                  char(2),   born                 date,   primary key (id));alter table selection add constraint FK_Reference_1 foreign key (course)      references course (id) on delete restrict on update restrict;alter table selection add constraint FK_Reference_2 foreign key (student)      references student (id) on delete restrict on update restrict;-- 修改表字符集alter table course default character set utf8 collate utf8_general_ci;insert into course(id,name,score) values(1001,&#39;英语&#39;,5);insert into course(id,name,score) values(1002,&#39;操作系统&#39;,5);insert into course(id,name,score) values(1003,&#39;数据结构&#39;,3);commit;</code></pre><blockquote><p>如果出现1366问题，是表字符集编码问题，需修改表默认字符集为utf8。</p></blockquote><ul><li>创建Maven项目，导入相关jar包<ul><li>MySQL驱动</li><li>Spring组件（core、beans、context、aop）</li><li>JDBC Template（jdbc、tx）</li></ul></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--导入数据库驱动包--&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.1.32&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--导入Template相关包--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;    &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;    &lt;version&gt;${spring.version}&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ul><li><p>创建<code>spring.xml</code>文件，配置如下内容</p><ul><li>数据源</li><li>JDBC Template</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;         xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;         xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;         xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;         xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx      http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;      &lt;!--配置数据源--&gt;      &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;          &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;          &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_cource?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt;          &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt;          &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;      &lt;!--配置Template--&gt;      &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;  &lt;&#x2F;beans&gt;</code></pre></li></ul><h3 id="1-2-JDBC-Template基本使用"><a href="#1-2-JDBC-Template基本使用" class="headerlink" title="1.2 JDBC Template基本使用"></a>1.2 JDBC Template基本使用</h3><h4 id="1-2-1-execute方法"><a href="#1-2-1-execute方法" class="headerlink" title="1.2.1 execute方法"></a>1.2.1 execute方法</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public void testExecute(){    jdbcTemplate.execute(&quot;create table user1(id int,name varchar(20))&quot;);}</code></pre><h4 id="1-2-2-update与batchUpdate方法"><a href="#1-2-2-update与batchUpdate方法" class="headerlink" title="1.2.2 update与batchUpdate方法"></a>1.2.2 update与batchUpdate方法</h4><ul><li>update方法：对数据进行增删改操作</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">int update(String sql, Object[] agrs)int update(String slq, Object... args)    &#x2F;&#x2F; 方法示例&#x2F;&#x2F; int update(String sql, Object[] agrs)@Testpublic void testUpdate(){    String sql = &quot;insert into student(name,sex) values(?,?)&quot;;    jdbcTemplate.update(sql,new Object[]{&quot;小明&quot;,&quot;男&quot;});}&#x2F;&#x2F; int update(String slq, Object... args)@Testpublic void testUpdate2(){    String sql = &quot;update student set sex=? where name=?&quot;;    jdbcTemplate.update(sql,&quot;女&quot;,&quot;小明&quot;);}</code></pre><ul><li>batchUpdate方法：批量增删改操作</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">int[] batchUpdate(String[] sql)int[] barchUpdate(String sql, List&lt;Object[]&gt; args)&#x2F;&#x2F; 方法示例&#x2F;&#x2F; int[] batchUpdate(String[] sql)@Testpublic void testBatchUpdate(){    String[] sqls = {        &quot;insert into student(name,sex) values(&#39;小李&#39;,&#39;女&#39;)&quot;,        &quot;insert into student(name,sex) values(&#39;小花&#39;,&#39;女&#39;)&quot;,        &quot;update student set sex=&#39;男&#39; where name = &#39;小李&#39;&quot;    };    jdbcTemplate.batchUpdate(sqls);}&#x2F;&#x2F; int[] barchUpdate(String sql, List&lt;Object[]&gt; args),适用于同步sql语句执行,使用率较高。@Testpublic void testBatchUpdate2(){    String sql = &quot;insert into selection(student,course) values(?,?)&quot;;    List&lt;Object[]&gt; list = new ArrayList&lt;Object[]&gt;();    list.add(new Object[]{2,1002});    list.add(new Object[]{2,1003});    jdbcTemplate.batchUpdate(sql,list);}</code></pre><h4 id="1-2-3-query与queryXXX方法"><a href="#1-2-3-query与queryXXX方法" class="headerlink" title="1.2.3 query与queryXXX方法"></a>1.2.3 query与queryXXX方法</h4><ul><li><p>查询简单数据项</p><ul><li>获取一个</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  T queryForObject(String sql, Class&lt;T&gt; type)  T queryForObject(String sql, Object[] args, Class&lt;T&gt; type)  T queryForObject(String sql, Class&lt;T&gt; type,Object... arg)        &#x2F;&#x2F; 方法示例  &#x2F;&#x2F; T queryForObject(String sql, Class&lt;T&gt; type)  @Test  public void testQueryForObject(){      String sql = &quot;select count(*) from student&quot;;      int count = jdbcTemplate.queryForObject(sql, Integer.class); &#x2F;&#x2F; 第一个参数sql语句，第二个参数返回值类型      System.out.println(count);  }</code></pre></li></ul><ul><li><p>获取多个</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  T queryForList(String sql, Class&lt;T&gt; type)  T queryForList(String sql, Object[] args, Class&lt;T&gt; type)  T queryForList(String sql, Class&lt;T&gt; type,Object... arg)        &#x2F;&#x2F; 方法示例  &#x2F;&#x2F; T queryForList(String sql, Class&lt;T&gt; type)  @Test  public void testQueryForList(){      String sql = &quot;select name from student where sex=?&quot;;      List&lt;String&gt; names = jdbcTemplate.queryForList(sql, String.class, &quot;女&quot;);      System.out.println(names);  }</code></pre></li></ul><ul><li><p>查询复杂对象（封装为Map）</p><ul><li>获取一个</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  Map queryForMap(String sql)  Map queryForMap(String sql,Object[] args)  Map queryForMap(String sql,Object... arg)        &#x2F;&#x2F; 方法示例  &#x2F;&#x2F; Map queryForMap(String sql)  @Test  public void testQueryForMap(){      String sql = &quot;select * from student where id = ?&quot;;      Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 1);      System.out.println(map); &#x2F;&#x2F; {id=1, name=小明, sex=女, born=null}  }</code></pre></li></ul><ul><li><p>获取多个</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql)  List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql,Object[] args)  List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql,Object... arg)        &#x2F;&#x2F; 方法示例  &#x2F;&#x2F; List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql)  @Test  public void testQueryList(){      String sql = &quot;select * from student&quot;;      List&lt;Map&lt;String, Object&gt;&gt; stus = jdbcTemplate.queryForList(sql);      System.out.println(stus); &#x2F;&#x2F; [{id=1, name=小明, sex=女, born=null}, {id=2, name=小李, sex=男, born=null}, {id=3, name=小花, sex=女, born=null}]  }</code></pre></li></ul><ul><li><p>查询复杂对象（封装为实体对象）</p><ul><li><p>RowMapper接口</p></li><li><p>获取一个</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  T queryForObject(String sql,RowMapper&lt;T&gt; mapper)  T queryForObject(String sql,Object[] args,RowMapper&lt;T&gt; mapper)  T queryForObject(String sql,RowMapper&lt;T&gt; mapper,Object... arg)        &#x2F;&#x2F; 方法示例  @Test  public void testQueryEntity1(){      String sql = &quot;select * from student where id = ?&quot;;      Student student = jdbcTemplate.queryForObject(sql, new RowMapper&lt;Student&gt;() {          &#x2F;&#x2F; 设置映射关系          public Student mapRow(ResultSet rs, int rowNum) throws SQLException {              Student student = new Student();              student.setId(rs.getInt(&quot;id&quot;));              student.setName(rs.getString(&quot;name&quot;));              student.setSex(rs.getString(&quot;sex&quot;));              student.setBorn(rs.getDate(&quot;born&quot;));              return student;          }      },1);      System.out.println(student); &#x2F;&#x2F; Student{id=1, name=&#39;小明&#39;, sex=&#39;女&#39;, born=null}            &#x2F;&#x2F;        Student student = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;Student&gt;(Student.class), 1);      &#x2F;&#x2F;        System.out.println(student);  }</code></pre></li></ul><ul><li><p>获取多个</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  List&lt;T&gt; query(String sql,RowMapper&lt;T&gt; mapper)  List&lt;T&gt; query(String sql,Object[] args,RowMapper&lt;T&gt; mapper)  List&lt;T&gt; query(String sql,RowMapper&lt;T&gt; mapper,Object... arg)        &#x2F;&#x2F; 方法示例  &#x2F;&#x2F; List&lt;T&gt; query(String sql,RowMapper&lt;T&gt; mapper) 获取多条记录，封装成实体类  @Test  public void testQueryEntity2(){      String sql = &quot;select * from student&quot;;      List&lt;Student&gt; stus = jdbcTemplate.query(sql, new RowMapper&lt;Student&gt;() {          &#x2F;&#x2F; 设置映射关系          public Student mapRow(ResultSet rs, int rowNum) throws SQLException {              Student student = new Student();              student.setId(rs.getInt(&quot;id&quot;));              student.setName(rs.getString(&quot;name&quot;));              student.setSex(rs.getString(&quot;sex&quot;));              student.setBorn(rs.getDate(&quot;born&quot;));              return student;          }      });      System.out.println(stus);  }</code></pre></li></ul><h3 id="1-3-优缺点分析"><a href="#1-3-优缺点分析" class="headerlink" title="1.3 优缺点分析"></a>1.3 优缺点分析</h3><ul><li>优点：简单灵活</li><li>缺点：<ul><li>SQL与Java代码掺杂</li><li>功能不丰富</li></ul></li></ul><h2 id="2-连接池技术"><a href="#2-连接池技术" class="headerlink" title="2. 连接池技术"></a>2. 连接池技术</h2><ul><li>JDBC(Java DataBase Connecttivity)，java数据库连接。是一种用于执行SQL语句的Java API</li><li>ODBC(Open DataBase Connectivity)，开发数据库连接。是微软公司提供的一组对数据库访问的标准API(应用程序编程接口)</li><li>DBCP(DataBase Connection Pool)数据库连接池，是Java数据库连接池的一种，由Apache开发。</li><li>C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。</li><li>提问：c3p0和dbcp的区别？<ul><li>dbcp没有自动回收空闲连接的功能；c3p0有自动回收空闲连接的功能。</li><li>对数据连接的处理方式不同：C3P0提供最大空闲时间，DBCP提供最大连接数。C3P0当连接超过最大空闲连接时间时，当前连接就会被断掉。DBCP当前连接超过最大连接数时，所有连接都会被断开。</li></ul></li></ul><h3 id="2-1-配置DBCP"><a href="#2-1-配置DBCP" class="headerlink" title="2.1 配置DBCP"></a>2.1 配置DBCP</h3><p>导入<code>commons-dbcp2.jar</code>、<code>commons-pool.jar</code>到工程。在spring配置文件中配置如下。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--配置DBCP数据源--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--配置Template--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--依赖注入，注意一定要提供set方法--&gt;&lt;bean id=&quot;studentDao&quot; class=&quot;com.zero.jdbc_Template.dao.Impl.StudentDaoImpl&quot;&gt;    &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><h3 id="2-2-配置C3P0"><a href="#2-2-配置C3P0" class="headerlink" title="2.2 配置C3P0"></a>2.2 配置C3P0</h3><p>导入<code>c3p0-0.9.2.1.jar</code>到工程。在spring配置文件中配置如下。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;    &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt;    &lt;property name=&quot;user&quot; value=&quot;root&quot;&#x2F;&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><h3 id="2-3-关于JdbcDaoSupport"><a href="#2-3-关于JdbcDaoSupport" class="headerlink" title="2.3 关于JdbcDaoSupport"></a>2.3 关于<code>JdbcDaoSupport</code></h3><p>JdbcDaoSupport是spring框架为我们提供的一个类，该类中定义了一个JdbcTemplate对象，我们可以直接获取使用，但是要想创建该对象，需要为其提供一个数据源。</p><p><a href="https://blog.csdn.net/weixin_42112635/article/details/88020509" target="_blank" rel="noopener">参考文章</a></p><h3 id="2-4-关于引用外部属性文件"><a href="#2-4-关于引用外部属性文件" class="headerlink" title="2.4 关于引用外部属性文件"></a>2.4 关于引用外部属性文件</h3><ul><li>将数据库连接的信息配置到属性文件中：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-properties">username=rootpassword=123456driver=com.mysql.jdbc.Driverurl=jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8</code></pre><ul><li>在spring配置文件中引入外部的属性文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!-- 引入外部属性文件： --&gt;&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;    &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;!--方法2--&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&#x2F;&gt;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>持久化操作特点</li><li>ORM：对象关系映射</li><li>JDBC Template是Spring框架对JDBC操作的封装，简单、灵活但不够强大</li><li>实际应用中还需和其他ORM框架混合使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AspectJ的AOP开发</title>
      <link href="/FrameWork/Spring-AspectJ.html"/>
      <url>/FrameWork/Spring-AspectJ.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-AspectJ-简介"><a href="#1-AspectJ-简介" class="headerlink" title="1. AspectJ 简介"></a>1. AspectJ 简介</h2><p>AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。</p><a id="more"></a><ul><li>AspectJ是一个基于Java语言的AOP框架</li><li>Spring2.0以后新增了对AspectJ切点表达式的支持</li><li>@AspectJ是AspectJ1.5新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面</li><li>新版本Spring框架，建议使用AspectJ方式来开发AOP</li><li>使用AspectJ需要导入Spring AOP和AspectJ相关jar包<ul><li>spring-aop-4.2.4.RELEASE.jar</li><li>com.springsource.org.aopalliance-1.0.0.jar</li><li>spring.aspects-4.2.4.RELEASE.jar</li><li>com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</li></ul></li></ul><h2 id="2-注解方式实现AOP"><a href="#2-注解方式实现AOP" class="headerlink" title="2. 注解方式实现AOP"></a>2. 注解方式实现AOP</h2><h3 id="2-1-注解开发：环境准备"><a href="#2-1-注解开发：环境准备" class="headerlink" title="2.1 注解开发：环境准备"></a>2.1 注解开发：环境准备</h3><p>xml配置如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xsi:schemaLocation=&quot;       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;    &lt;!--开启AspectJ自动代理--&gt;    &lt;aop:aspectj-autoproxy&#x2F;&gt;&lt;&#x2F;beans&gt;</code></pre><h3 id="2-2-AspectJ提供不同的通知类型"><a href="#2-2-AspectJ提供不同的通知类型" class="headerlink" title="2.2 @AspectJ提供不同的通知类型"></a>2.2 <code>@AspectJ</code>提供不同的通知类型</h3><ul><li><code>@Before</code>：前置通知，相当于<code>BeforeAdvice</code></li><li><code>@AfterReturning</code>：后置通知，相当于<code>AfterReturningAdvice</code></li><li><code>@Around</code>：环绕通知，相当于<code>MethodInterceptor</code></li><li><code>@AfterThrowing</code>：异常抛出通知，相当于<code>ThrowAdvice</code></li><li><code>@After</code>：最终final通知，不管是否异常，该通知都会执行</li><li><code>@DeclareParents</code>：引介通知，相当于<code>IntroductionInterceptor</code>（了解即可）</li></ul><h3 id="2-3-在通知中通过value属性定义切点"><a href="#2-3-在通知中通过value属性定义切点" class="headerlink" title="2.3 在通知中通过value属性定义切点"></a>2.3 在通知中通过value属性定义切点</h3><ul><li>通过<code>execution</code>函数，可以定义切点的方法切入</li><li>语法：<code>execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)</code></li><li>示例：<ul><li>匹配所有类public方法：<code>execution(public * *(..))</code></li><li>匹配指定包下所有类方法：<code>execution(* com.zero.dao.*(..))</code>，不包含子包</li><li><code>execution(* com.zero.dao..*(..))</code>：<code>..*</code>表示包含子包</li><li>匹配指定类所有方法：<code>execution(* com.zero.service.UserService.*(..))</code></li><li>匹配实现特定接口所有类方法：<code>execution(* com.zero.dao.GenericDao+.*(..))</code></li><li>匹配所有save开头的方法：<code>execution(* save*(..))</code></li></ul></li></ul><h3 id="2-4-为目标类、定义切面类，实现AOP"><a href="#2-4-为目标类、定义切面类，实现AOP" class="headerlink" title="2.4 为目标类、定义切面类，实现AOP"></a>2.4 为目标类、定义切面类，实现AOP</h3><h4 id="2-4-1-使用前置通知-Before"><a href="#2-4-1-使用前置通知-Before" class="headerlink" title="2.4.1 使用前置通知@Before"></a>2.4.1 使用前置通知<code>@Before</code></h4><ul><li>首先定义目标类<code>ProductDao</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ProductDao {    public void save(){ System.out.println(&quot;保存商品。。。&quot;); }    public void delete(){        System.out.println(&quot;删除商品。。。&quot;);    }    public void update(){        System.out.println(&quot;更新商品。。。&quot;);    }    public void findOne(){        System.out.println(&quot;查询一个商品。。。&quot;);    }    public void findAll(){        System.out.println(&quot;查询所有商品。。。&quot;);    }}</code></pre><ul><li>定义切面类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 切面类，注解方式 *&#x2F;@Aspectpublic class MyAspectAnno {    @Before(value = &quot;execution( * com.zero.aspectj.demo1.ProductDao.*(..))&quot;)  &#x2F;&#x2F; 匹配任意返回值类型的，具体目标类(com.zero.aspectj.demo1.ProductDao)下的所有任意参数的方法    public void before(JoinPoint joinPoint){        System.out.println(&quot;前置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+joinPoint); &#x2F;&#x2F; 可以在方法中传入JoinPoint对象，用来获得切点信息，格式为：前置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;execution(void com.zero.aspectj.demo1.ProductDao.save())    }}</code></pre><ul><li>配置xml文件</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--开启AspectJ自动代理--&gt;&lt;aop:aspectj-autoproxy&#x2F;&gt;&lt;!--目标类--&gt;&lt;bean id=&quot;productDao&quot; class=&quot;com.zero.aspectj.demo1.ProductDao&quot;&#x2F;&gt;&lt;!--切面类--&gt;&lt;bean class=&quot;com.zero.aspectj.demo1.MyAspectAnno&quot;&#x2F;&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class Demo1Test {    @Resource(name = &quot;productDao&quot;) &#x2F;&#x2F; 注入目标类    private ProductDao productDao;    @Test    public void test1(){        productDao.save();        productDao.delete();        productDao.update();        productDao.findAll();        productDao.findOne();    }}</code></pre><blockquote><p>目标类定义方法时，注意要写上访问权限修饰符<code>public</code>，不然定义<code>execution( * com.zero.aspectj.demo1.ProductDao.*(..))</code>时会匹配不到方法</p></blockquote><h4 id="2-4-2-使用后置通知-AfterReturning"><a href="#2-4-2-使用后置通知-AfterReturning" class="headerlink" title="2.4.2 使用后置通知@AfterReturning"></a>2.4.2 使用后置通知<code>@AfterReturning</code></h4><ul><li>只需要在切面类中定义后置通知方法即可，如果目标方法有返回值，可以通过设置<code>returning</code>属性，来获取返回值。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 示例update有返回值，返回更新商品人员public String update(){    System.out.println(&quot;更新商品。。。&quot;);    return &quot;某某某更新了商品&quot;;}&#x2F;&#x2F; 使用后置通知，定义增强方法@AfterReturning(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.update(..))&quot;,returning = &quot;result&quot;)public void afterReturning(Object result){ &#x2F;&#x2F; 通过returning属性，可以定义方法返回值，作为参数    System.out.println(&quot;后置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+result);}</code></pre><h4 id="2-4-3-使用环绕通知-Around"><a href="#2-4-3-使用环绕通知-Around" class="headerlink" title="2.4.3 使用环绕通知@Around"></a>2.4.3 使用环绕通知<code>@Around</code></h4><ul><li><code>Around</code>方法的返回值就是目标代理方法执行的返回值</li><li><p>通过参数<code>ProceedingJoinPoing</code>，可以拦截目标方法执行</p></li><li><p>示例定义环绕通知方法</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 环绕通知@Around(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.delete(..))&quot;)public Object around(ProceedingJoinPoint joinPoint) throws Throwable {    System.out.println(&quot;环绕前通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); &#x2F;&#x2F; 环绕前代码区    Object obj = joinPoint.proceed(); &#x2F;&#x2F; 执行目标方法    System.out.println(&quot;环绕后通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);&#x2F;&#x2F; 环绕后代码区    return obj;}</code></pre><blockquote><p>如果不调用<code>ProceedingJoinPoing</code>的<code>proceed</code>方法，那么目标方法就不会被执行，即被拦截了。</p></blockquote><h4 id="2-4-4-异常抛出通知-AfterThrowing"><a href="#2-4-4-异常抛出通知-AfterThrowing" class="headerlink" title="2.4.4 异常抛出通知@AfterThrowing"></a>2.4.4 异常抛出通知<code>@AfterThrowing</code></h4><ul><li>通过设置<code>throwing</code>属性，可以设置发生异常时的处理</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 目标类public void findOne(){    System.out.println(&quot;查询一个商品。。。&quot;);    int i = 1&#x2F;0; &#x2F;&#x2F; 手动制造一个异常，测试异常通知}&#x2F;&#x2F; 切面类中定义异常通知操作&#x2F;&#x2F; 异常通知@AfterThrowing(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.findOne(..))&quot;,throwing = &quot;error&quot;) &#x2F;&#x2F; 设置throwing，获取异常信息public void afterThrowing(Throwable error){    System.out.println(&quot;某某某方法有异常抛出&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+error.getMessage()); }</code></pre><h4 id="2-4-5-最终通知-After"><a href="#2-4-5-最终通知-After" class="headerlink" title="2.4.5 最终通知@After"></a>2.4.5 最终通知<code>@After</code></h4><ul><li>无论是否出现异常，最终通知总是会被执行的</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 目标类public void findAll(){    System.out.println(&quot;查询所有商品。。。&quot;);    int i = 1&#x2F;0; &#x2F;&#x2F; 手动制造异常，测试最终通知}&#x2F;&#x2F; 最终通知,无论增强方法是否有异常都会执行@After(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.findAll(..))&quot;)public void after(){    System.out.println(&quot;最终通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);}</code></pre><h4 id="2-4-6-通过-Pointcut为切点命名"><a href="#2-4-6-通过-Pointcut为切点命名" class="headerlink" title="2.4.6 通过@Pointcut为切点命名"></a>2.4.6 通过<code>@Pointcut</code>为切点命名</h4><ul><li>在每个通知内定义切点，会造成工作量大，不易维护，对于重复的切点，可以使用<code>@Pointcut</code>进行定义</li><li>切点方法：<code>private void 无参方法，方法名为切点名</code></li><li>当通知多个切点时，可以使用||进行连接。</li><li>切面类代码示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Aspectpublic class MyAspectAnno {    &#x2F;&#x2F; 前置通知    @Before(value = &quot;savePointcut()&quot;)  &#x2F;&#x2F; 匹配任意返回值类型的，具体目标类(com.zero.aspectj.demo1.ProductDao)下的所有任意参数的方法    public void before(JoinPoint joinPoint){        System.out.println(&quot;前置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+joinPoint); &#x2F;&#x2F; 可以在方法中传入JoinPoint对象，用来获得切点信息，格式为：前置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;execution(void com.zero.aspectj.demo1.ProductDao.save())    }    &#x2F;&#x2F; 后置通知    @AfterReturning(value = &quot;updatePointcut()||findOnePointcut()&quot;,returning = &quot;result&quot;) &#x2F;&#x2F; 多个切点通知，用||连接    public void afterReturning(Object result){ &#x2F;&#x2F; 通过returning属性，可以定义方法返回值，作为参数        System.out.println(&quot;后置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+result);    }    &#x2F;&#x2F; 环绕通知    @Around(value = &quot;deletePointcut()&quot;)    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {        System.out.println(&quot;环绕前通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);        Object obj = joinPoint.proceed(); &#x2F;&#x2F; 执行目标方法        System.out.println(&quot;环绕后通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);        return obj;    }    &#x2F;&#x2F; 异常通知    @AfterThrowing(value = &quot;findOnePointcut()&quot;,throwing = &quot;error&quot;) &#x2F;&#x2F; 设置throwing，获取异常信息    public void afterThrowing(Throwable error){        System.out.println(&quot;某某某方法有异常抛出&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+error.getMessage());    }    &#x2F;&#x2F; 最终通知    @After(value = &quot;findAllPointcut()&quot;)    public void after(){        System.out.println(&quot;最终通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);    }    &#x2F;&#x2F; 使用Pointcut为所有切点命名    @Pointcut(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.save(..))&quot;)    private void savePointcut(){}    @Pointcut(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.delete(..))&quot;)    private void deletePointcut(){}    @Pointcut(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.update(..))&quot;)    private void updatePointcut(){}    @Pointcut(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.findOne(..))&quot;)    private void findOnePointcut(){}    @Pointcut(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.findAll(..))&quot;)    private void findAllPointcut(){}}</code></pre><h2 id="3-XML方式实现AOP"><a href="#3-XML方式实现AOP" class="headerlink" title="3. XML方式实现AOP"></a>3. XML方式实现AOP</h2><h3 id="3-1-使用XML配置切面"><a href="#3-1-使用XML配置切面" class="headerlink" title="3.1 使用XML配置切面"></a>3.1 使用XML配置切面</h3><ul><li>编写客户类及其实现类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class CustomerDaoImpl implements CustomerDao{    public void save() {        System.out.println(&quot;保存客户...&quot;);    }    public void update() {        System.out.println(&quot;修改客户...&quot;);    }    public void delete() {        System.out.println(&quot;删除客户...&quot;);    }    public void findOne() {        System.out.println(&quot;查询一个客户...&quot;);    }    public void findAll() {        System.out.println(&quot;查询全部客户...&quot;);    }}</code></pre><ul><li>编写切面类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 切面类，XML方式 *&#x2F;public class MyAspectXml {    &#x2F;&#x2F; 前置通知    public void before(){        System.out.println(&quot;XML方式的前置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);    }    public void afterReturning(Object obj){        System.out.println(&quot;后置增强&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+obj);    }    public Object around(ProceedingJoinPoint joinPoint) throws Throwable{        System.out.println(&quot;环绕前增强&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);        Object obj = joinPoint.proceed();        System.out.println(&quot;环绕后增强&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);        return obj;    }    public void afterThrowing(Throwable e){        System.out.println(&quot;异常抛出通知&gt;&gt;&gt;&gt;&gt;&gt;&quot;+e.getMessage());    }    public void after(){        System.out.println(&quot;最终通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);    }}</code></pre><ul><li>完成切面类的配置</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--使用XML配置方式完成AOP开发--&gt;&lt;!--配置目标类--&gt;&lt;bean id=&quot;customerDao&quot; class=&quot;com.zero.aspectj.demo2.CustomerDaoImpl&quot;&#x2F;&gt;&lt;!--配置切面类--&gt;&lt;bean id=&quot;myAspectXml&quot; class=&quot;com.zero.aspectj.demo2.MyAspectXml&quot;&#x2F;&gt;</code></pre><ul><li>配置AOP完成增强</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--进行AOP相关配置--&gt;&lt;aop:config&gt;    &lt;!--配置切入点：哪些类的哪些方法需要增强--&gt;    &lt;aop:pointcut id=&quot;savePointcut&quot; expression=&quot;execution(* com.zero.aspectj.demo2.CustomerDao.save(..))&quot;&#x2F;&gt;    &lt;aop:pointcut id=&quot;updatePointcut&quot; expression=&quot;execution(* com.zero.aspectj.demo2.CustomerDao.update(..))&quot;&#x2F;&gt;    &lt;aop:pointcut id=&quot;deletePointcut&quot; expression=&quot;execution(* com.zero.aspectj.demo2.CustomerDao.delete(..))&quot;&#x2F;&gt;    &lt;aop:pointcut id=&quot;findOnePointcut&quot; expression=&quot;execution(* com.zero.aspectj.demo2.CustomerDao.findOne(..))&quot;&#x2F;&gt;    &lt;aop:pointcut id=&quot;findAllPointcut&quot; expression=&quot;execution(* com.zero.aspectj.demo2.CustomerDao.findAll(..))&quot;&#x2F;&gt;    &lt;!--配置AOP的切面--&gt;    &lt;aop:aspect ref=&quot;myAspectXml&quot;&gt;        &lt;!--配置前置通知--&gt;        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;savePointcut&quot;&#x2F;&gt;        &lt;!--配置后置通知--&gt;        &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;updatePointcut&quot; returning=&quot;obj&quot;&#x2F;&gt;        &lt;!--配置环绕通知--&gt;        &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;deletePointcut&quot;&#x2F;&gt;        &lt;!--配置异常抛出通知--&gt;        &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;findOnePointcut&quot; throwing=&quot;e&quot;&#x2F;&gt;        &lt;!--配置最终通知--&gt;        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;findAllPointcut&quot; &#x2F;&gt;    &lt;&#x2F;aop:aspect&gt;&lt;&#x2F;aop:config&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext2.xml&quot;)public class Demo2Test {    @Resource(name = &quot;customerDao&quot;)    private CustomerDao customerDao;    @Test    public void test1(){        customerDao.save();        customerDao.update();        customerDao.delete();        customerDao.findOne();        customerDao.findAll();    }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用AspectJ完成AOP开发所需环境的配置，需要哪些jar包?</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--导入Spring基本开发包--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-beans&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-beans&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--导入AOP相关包--&gt;&lt;dependency&gt;    &lt;groupId&gt;aopalliance&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;aopalliance&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--导入AspectJ相关包--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;aspectjrt&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.8.9&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--导入测试相关包--&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.12&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--导入DI属性注入相关包,java注解类--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.annotation&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;javax.annotation-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ul><li>注解方式实现AOP</li><li>AspectJ的各种通知类型</li><li>切面类的定义，切入点的配置</li><li>XML方式实现AOP，AOP的XML配置</li></ul>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的AOP</title>
      <link href="/FrameWork/Spring-Aop.html"/>
      <url>/FrameWork/Spring-Aop.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-AOP的概念"><a href="#1-AOP的概念" class="headerlink" title="1. AOP的概念"></a>1. AOP的概念</h2><h3 id="1-1-什么是AOP？"><a href="#1-1-什么是AOP？" class="headerlink" title="1.1 什么是AOP？"></a>1.1 什么是AOP？</h3><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：<a href="https://baike.baidu.com/item/面向切面编程/6016335" target="_blank" rel="noopener">面向切面编程</a>，通过<a href="https://baike.baidu.com/item/预编译/3191547" target="_blank" rel="noopener">预编译</a>方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是<a href="https://baike.baidu.com/item/OOP" target="_blank" rel="noopener">OOP</a>的延续，是软件开发中的一个热点，也是<a href="https://baike.baidu.com/item/Spring" target="_blank" rel="noopener">Spring</a>框架中的一个重要内容，是<a href="https://baike.baidu.com/item/函数式编程/4035031" target="_blank" rel="noopener">函数式编程</a>的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<a href="https://baike.baidu.com/item/耦合度/2603938" target="_blank" rel="noopener">耦合度</a>降低，提高程序的可重用性，同时提高了开发的效率。</p><a id="more"></a><ul><li>AOP(Aspect Oriented Programing)，面向切面编程</li><li>AOP采取横向抽取的机制，取代了传统纵向继承体系重复性代码(性能监视、事务管理、安全检查、缓存)</li><li>Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过<strong>代理方式</strong>向目标类织入增强代码。</li></ul><h3 id="1-2-AOP相关术语"><a href="#1-2-AOP相关术语" class="headerlink" title="1.2 AOP相关术语"></a>1.2 AOP相关术语</h3><ul><li><strong><code>Joinpoint</code>(连接点)：所谓连接点是指那些被拦截到的点</strong>。在spring中，这些<strong>点指的是方法</strong>，因为spirng只支持方法类型的连接点。</li><li><code>Pointcut</code>(切入点)：所谓切入点是指我们要对哪些<code>Joinpoint</code>进行拦截的定义。</li><li><strong><code>Advice</code>(通知/增强)：所谓通知是指拦截到<code>Joinpoint</code>之后所要做的事情就是通知</strong>。通知分为前置通知，后置通知，异常通知，最终通知，环绕通知(切面要完成的功能)</li><li><code>Introduction</code>(引介)：引介是一种特殊的通知在不修改类代码的前提下，<code>Introduction</code>可以在运行期为类动态地添加一些方法或Filed。</li><li><strong><code>Target</code>(目标对象)：代理的目标对象。</strong></li><li><code>Weaving</code>(织入)：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译器织入和类装载期织入。</li><li><strong><code>Proxy</code>(代理)：一个类被AOP织入增强后，就产生一个结果代理类。</strong></li><li><code>Aspect</code>(切面)：是切入点和通知(引介)的结合。</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/09/aop-1565345189637.jpg" alt="aop"></p><h2 id="2-AOP的底层实现"><a href="#2-AOP的底层实现" class="headerlink" title="2. AOP的底层实现"></a>2. AOP的底层实现</h2><h3 id="2-1-JDK动态代理"><a href="#2-1-JDK动态代理" class="headerlink" title="2.1 JDK动态代理"></a>2.1 JDK动态代理</h3><p>使用JDK本身的一个类<code>Proxy</code>来实现动态代理，核心代码如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class MyJDKProxy implements InvocationHandler {    private final UserDao userDao;    public MyJDKProxy(UserDao userDao){        this.userDao = userDao;    }    public Object createProxy(){        Object proxy = Proxy.newProxyInstance(userDao.getClass().getClassLoader(),userDao.getClass().getInterfaces(),this);        return proxy;    }    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;所有代理对象的方法都会经过invoke调用&quot;);        if (&quot;save&quot;.equals(method.getName())){            &#x2F;&#x2F; 进行权限校验代码区            System.out.println(&quot;权限校验...&quot;);            return method.invoke(userDao,args);        }        return method.invoke(userDao,args);    }}</code></pre><h3 id="2-2-使用CGLIB生成代理"><a href="#2-2-使用CGLIB生成代理" class="headerlink" title="2.2 使用CGLIB生成代理"></a>2.2 使用CGLIB生成代理</h3><ul><li>对于不使用接口的业务类，无法使用JDK动态代理</li><li>CGlib采用非常底层字节码技术，可以为一个类创建子类，解决无接口代理问题。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 示意CGlib生成代理 *&#x2F;public class MyCGlibProxy implements MethodInterceptor {    private final UserDao userDao;    public MyCGlibProxy(UserDao userDao){        this.userDao = userDao;    }    public Object createProxy(){        &#x2F;&#x2F; 1. 创建核心类        Enhancer enhancer = new Enhancer();        &#x2F;&#x2F; 2. 设置父类        enhancer.setSuperclass(userDao.getClass());        &#x2F;&#x2F; 3. 设置回调        enhancer.setCallback(this);        &#x2F;&#x2F; 4. 生成代理        Object proxy = enhancer.create();        return proxy;    }    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        if (&quot;save&quot;.equals(method.getName())){            System.out.println(&quot;权限校验&quot;);            return methodProxy.invokeSuper(proxy,args);        }        return methodProxy.invokeSuper(proxy,args);    }}</code></pre><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><ul><li>Spring在运行期，生成动态代理对象，不需要特殊的编译器</li><li>Spring AOP的底层就是通过JDK动态代理或CGlib动态代理技术为目标Bean执行横向织入<ul><li>若目标对象实现了若干接口，spring使用JDK的<code>java.lang.reflect.Proxy</code>类代理</li><li>若目标对象没有实现任何接口，spring使用CGlib库生成目标对象的子类</li></ul></li><li>程序中应优先对接口创建代理，便于程序解耦维护</li><li>标记为final的方法，不能被代理，因为无法进行覆盖<ul><li>JDK动态代理，是针对接口生成子类，接口中方法不能使用final修饰</li><li>CGlib是针对目标类生成子类，因此类或方法不能使用final</li></ul></li><li>Spring只支持方法连接点，不提供属性连接</li></ul><h2 id="3-Spring的传统AOP"><a href="#3-Spring的传统AOP" class="headerlink" title="3. Spring的传统AOP"></a>3. Spring的传统AOP</h2><h3 id="3-1-Spring-AOP增强类型"><a href="#3-1-Spring-AOP增强类型" class="headerlink" title="3.1 Spring AOP增强类型"></a>3.1 Spring AOP增强类型</h3><ul><li>AOP联盟为通知Advice定义了<code>org.aopalliance.aop.Interface.Advice</code></li><li>Spring按照通知Advice在目标类方法的连接点位置，可以分为5类<ul><li>前置通知<code>org.springframework.aop.MethodBeforeAdvice</code>：在目标方法执行前实施增强</li><li>后置通知<code>org.springframework.aop.AfterReturningAdvice</code>：在目标方法执行后实施增强</li><li>环绕通知<code>org.aopalliance.intercept.MethodInterceptor</code>：在目标方法执行前后实施增强</li><li>异常抛出通知<code>org.springframework.aop.ThrowsAdvice</code>：在方法抛出异常后实施增强</li><li>引介通知<code>org.springframework.aop.IntroductionInterceptor</code>：在目标类中添加一些新的方法和属性</li></ul></li></ul><h3 id="3-2-Spring-AOP切面类型"><a href="#3-2-Spring-AOP切面类型" class="headerlink" title="3.2 Spring AOP切面类型"></a>3.2 Spring AOP切面类型</h3><ul><li><code>Advisor</code>：代表一般切面，Advice本身就是一个切面，对目标类所有方法进行拦截</li><li><code>PointcutAdvisor</code>：代表具有切点的切面，可以指定拦截目标类哪些方法</li><li><code>IntroductionAdvisor</code>：代表引介切面，针对引介通知而使用切面(了解即可)</li></ul><h3 id="3-3-Advisor切面案例"><a href="#3-3-Advisor切面案例" class="headerlink" title="3.3 Advisor切面案例"></a>3.3 <code>Advisor</code>切面案例</h3><p><code>ProxyFactoryBean</code>常用可配置属性：</p><ul><li><code>target</code>：代理的目标对象</li><li><code>proxyInterfaces</code>：代理要实现的接口</li><li><code>proxyTargetClass</code>：是否对类代理而不是接口，设置为true时，使用CGlib代理</li><li><code>interceptorNames</code>：需要织入目标的Advice</li><li><code>singleton</code>：返回代理是否为单实例，默认为单例</li><li><code>optimize</code>：当设置为true时，强制使用CGlib</li></ul><p>代码示例：</p><ul><li>创建学生接口及其实现类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface StudentDao {    void save();    void update();    void delete();    void find();}public class StudentDaoImpl implements StudentDao {    public void save() {        System.out.println(&quot;学生保存&quot;);    }    public void update() {        System.out.println(&quot;学生修改&quot;);    }    public void delete() {        System.out.println(&quot;学生删除&quot;);    }    public void find() {        System.out.println(&quot;学生查询&quot;);    }}</code></pre><ul><li>创建前置通知增强类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 使用前置通知实现增强类public class MyBeforeAdvice implements MethodBeforeAdvice {    public void before(Method method, Object[] args, Object target) throws Throwable {        System.out.println(&quot;前置增强&gt;&gt;&gt;&gt;&gt;&gt;&quot;);    }}</code></pre><ul><li>配置xml</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;!--    配置目标类--&gt;    &lt;bean id=&quot;studentDao&quot; class=&quot;com.zero.aop.demo2.StudentDaoImpl&quot;&#x2F;&gt;&lt;!--    前置通知类型--&gt;    &lt;bean id=&quot;myBeforeAdvice&quot; class=&quot;com.zero.aop.demo2.MyBeforeAdvice&quot;&#x2F;&gt;&lt;!--    Sprint AOP 产生代理对象--&gt;    &lt;bean id=&quot;studentDaoProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;&lt;!--        配置目标类--&gt;        &lt;property name=&quot;target&quot; ref=&quot;studentDao&quot;&#x2F;&gt;&lt;!--        实现的接口--&gt;        &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.zero.aop.demo2.StudentDao&quot;&#x2F;&gt;&lt;!--        采用拦截的名称--&gt;        &lt;property name=&quot;interceptorNames&quot; value=&quot;myBeforeAdvice&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class demo2Test {&#x2F;&#x2F;    @Resource(name = &quot;studentDao&quot;)     @Resource(name = &quot;studentDaoProxy&quot;) &#x2F;&#x2F; 使用代理对象    private StudentDao studentDao;    @Test    public void test1(){        studentDao.find();        studentDao.delete();        studentDao.save();        studentDao.update();    }}</code></pre><h3 id="3-4-PoingcutAdvisor切点切面"><a href="#3-4-PoingcutAdvisor切点切面" class="headerlink" title="3.4 PoingcutAdvisor切点切面"></a>3.4 <code>PoingcutAdvisor</code>切点切面</h3><ul><li>使用普通Advice作为切面，将对目标类所有方法进行拦截，不够灵活，在实际开发中常采用带有切点的切面</li><li><p>常用<code>PointcutAdvisor</code>实现类</p><ul><li><code>DefaultPointcutAdvisor</code>：最常用的切面类型，它可以通过任意<code>Pointcut</code>和Advice组合定义切面</li><li><code>JdkRegexpMethodPointcut</code>：构造正则表达式切点</li></ul></li><li><p>示例，创建客户类</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class CustomerDao {    public void save() {        System.out.println(&quot;客户保存&quot;);    }    public void update() {        System.out.println(&quot;客户修改&quot;);    }    public void delete() {        System.out.println(&quot;客户删除&quot;);    }    public void find() {        System.out.println(&quot;客户查询&quot;);    }}</code></pre><ul><li>创建环绕通知型增强类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class MyAroundAdvice implements MethodInterceptor {    public Object invoke(MethodInvocation invocation) throws Throwable {        System.out.println(&quot;环绕前增强&gt;&gt;&gt;&gt;&gt;&gt;&quot;);        &#x2F;&#x2F; 执行目标方法        Object obj = invocation.proceed();        System.out.println(&quot;环绕后增强&gt;&gt;&gt;&gt;&gt;&gt;&quot;);        return obj;    }}</code></pre><ul><li>配置xml</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;!--配置目标类--&gt;    &lt;bean id=&quot;customerDao&quot; class=&quot;com.zero.aop.demo3.CustomerDao&quot;&#x2F;&gt;&lt;!--配置通知--&gt;    &lt;bean id=&quot;myAroundAdvice&quot; class=&quot;com.zero.aop.demo3.MyAroundAdvice&quot;&#x2F;&gt;&lt;!--一般的切面是使用通知作为切面的，因为要对目标类的指定方法进行增强就需要配置一个带有切入点的切面--&gt;    &lt;bean id=&quot;MyAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt;&lt;!--pattern中配置正则表达式，以达到对指定方法进行增强的效果--&gt;        &lt;!--            对单个方法进行增强使用pattern即可            如果对多个方法，需使用patterns，多个值用逗号隔开        --&gt;&lt;!--&lt;property name=&quot;pattern&quot; value=&quot;.*save.*&quot;&#x2F;&gt;--&gt;        &lt;property name=&quot;patterns&quot; value=&quot;.*save.*,.*delete.*&quot;&#x2F;&gt;        &lt;property name=&quot;advice&quot; ref=&quot;myAroundAdvice&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;!--配置产生代理--&gt;    &lt;bean id=&quot;customerDaoProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;        &lt;property name=&quot;target&quot; ref=&quot;customerDao&quot;&#x2F;&gt;        &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot;&#x2F;&gt;        &lt;property name=&quot;interceptorNames&quot; value=&quot;MyAdvisor&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext2.xml&quot;)public class demo3Test {&#x2F;&#x2F;    @Resource(name=&quot;customerDao&quot;) &#x2F;&#x2F; 不使用代理    @Resource(name = &quot;customerDaoProxy&quot;) &#x2F;&#x2F; 使用代理对象    private CustomerDao customerDao;    @Test    public void test1(){        customerDao.find();        customerDao.delete();        customerDao.save();        customerDao.update();    }}</code></pre><h2 id="4-Spring传统AOP的自动代理"><a href="#4-Spring传统AOP的自动代理" class="headerlink" title="4. Spring传统AOP的自动代理"></a>4. Spring传统AOP的自动代理</h2><ul><li>前面的案例中，每个代理都是通过<code>ProxyFactoryBean</code>织入切面代理，在实际开发中，非常多的Bean每个都配置<code>ProxyFactoryBean</code>的话，开发维护量巨大</li><li>解决方案：自动创建代理<ul><li><code>BeanNameAutoProxyCreator</code>：根据Bean名称创建代理</li><li><code>DefaultAdvisorAutoProxyCreator</code>：根据Advisor本身包含信息创建代理</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>：基于Bean中的AspectJ注解进行自动代理</li></ul></li></ul><h3 id="4-1-基于Bean名称的自动代理"><a href="#4-1-基于Bean名称的自动代理" class="headerlink" title="4.1 基于Bean名称的自动代理"></a>4.1 基于Bean名称的自动代理</h3><ul><li><p>代码示例对所有以DAO结尾Bean所有方法进行代理</p><ul><li>将前面案例的<code>CustomerDao,StudentDao,StudentDaoImpl,MyBeforeAdvice,MyAroundAdvice</code>复制到一个文件夹，然后配置xml。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;         xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;    &lt;!--    配置目标类--&gt;      &lt;bean id=&quot;studentDao&quot; class=&quot;com.zero.aop.demo4.StudentDaoImpl&quot;&#x2F;&gt;      &lt;bean id=&quot;customerDao&quot; class=&quot;com.zero.aop.demo4.CustomerDao&quot;&#x2F;&gt;      &lt;!--配置通知：前置通知--&gt;      &lt;bean id=&quot;myBeforeAdvice&quot; class=&quot;com.zero.aop.demo4.MyBeforeAdvice&quot;&#x2F;&gt;      &lt;!--配置通知：环绕通知--&gt;      &lt;bean id=&quot;myAroundAdvice&quot; class=&quot;com.zero.aop.demo4.MyAroundAdvice&quot;&#x2F;&gt;        &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;          &lt;property name=&quot;beanNames&quot; value=&quot;*Dao&quot;&#x2F;&gt;          &lt;property name=&quot;interceptorNames&quot; value=&quot;myBeforeAdvice&quot;&#x2F;&gt;      &lt;&#x2F;bean&gt;  &lt;&#x2F;beans&gt;</code></pre></li></ul><ul><li><p>测试</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @RunWith(SpringJUnit4ClassRunner.class)  @ContextConfiguration(&quot;classpath:applicationContext3.xml&quot;)  public class demo4Test {        @Resource(name = &quot;studentDao&quot;)      private StudentDao studentDao;      @Resource(name = &quot;customerDao&quot;)      private CustomerDao customerDao;        @Test      public void test1(){          studentDao.find();          studentDao.delete();          studentDao.save();          studentDao.update();            customerDao.find();          customerDao.delete();          customerDao.save();          customerDao.update();          }  }</code></pre></li></ul><h3 id="4-2-基于切面信息的自动代理"><a href="#4-2-基于切面信息的自动代理" class="headerlink" title="4.2 基于切面信息的自动代理"></a>4.2 基于切面信息的自动代理</h3><ul><li>配置环绕代理，将上述案例xml修改如下即可对指定方法进行增强</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--根据切面信息创建代理--&gt;&lt;!--配置目标类--&gt;&lt;bean id=&quot;studentDao&quot; class=&quot;com.zero.aop.demo4.StudentDaoImpl&quot;&#x2F;&gt;&lt;bean id=&quot;customerDao&quot; class=&quot;com.zero.aop.demo4.CustomerDao&quot;&#x2F;&gt;&lt;!--配置通知：前置通知--&gt;&lt;bean id=&quot;myBeforeAdvice&quot; class=&quot;com.zero.aop.demo4.MyBeforeAdvice&quot;&#x2F;&gt;&lt;!--配置通知：环绕通知--&gt;&lt;bean id=&quot;myAroundAdvice&quot; class=&quot;com.zero.aop.demo4.MyAroundAdvice&quot;&#x2F;&gt;&lt;!--配置切面--&gt;&lt;bean id=&quot;myAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt;    &lt;!--对指定包下指定方法进行增强,注意转义--&gt;    &lt;property name=&quot;pattern&quot; value=&quot;com\.zero\.aop\.demo4\.CustomerDao\.save&quot;&#x2F;&gt;    &lt;property name=&quot;advice&quot; ref=&quot;myAroundAdvice&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;&gt;&lt;&#x2F;bean&gt;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>什么是AOP</li><li>了解AOP相关术语：连接点，切入点，织入，目标对象，代理对象等。</li><li>传统AOP实现原理：JDK动态代理，CGlib代理</li><li>Spring的传统AOP：增强类型，切面类型。没有切入点的切面和有切入点的切面。</li><li>自动代理：基于Bean名称的，基于切面信息的</li></ul>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBean管理</title>
      <link href="/FrameWork/Spring-Bean.html"/>
      <url>/FrameWork/Spring-Bean.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Spring的工厂类"><a href="#1-Spring的工厂类" class="headerlink" title="1. Spring的工厂类"></a>1. Spring的工厂类</h2><p><code>ApplicationContext</code>是继承自<code>BeanFactory</code>的。<code>BeanFactory</code>是一个老版本的工厂类，只有在调用<code>getBean</code>方法时，才会生成类的实例。</p><a id="more"></a><p><code>ApplicationContext</code>工厂在加载配置文件时，就会将Spring管理的类都实例化。</p><p>加载配置文件一般使用以下两个实现类：</p><ul><li><code>ClassPathXmlApplicationContext</code>：加载类路径下的配置文件（src下）</li><li><code>FileSystemXmlApplicationContext</code>：加载文件系统下的配置文件（磁盘下的文件）</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/07/SpringFactory-1565180791566.jpg" alt="SpringFactory"></p><h2 id="2-Spring的Bean管理-XML方式"><a href="#2-Spring的Bean管理-XML方式" class="headerlink" title="2. Spring的Bean管理(XML方式)"></a>2. Spring的Bean管理(XML方式)</h2><h3 id="2-1-使用类构造器实例化-默认无参数"><a href="#2-1-使用类构造器实例化-默认无参数" class="headerlink" title="2.1 使用类构造器实例化(默认无参数)"></a>2.1 使用类构造器实例化(默认无参数)</h3><ul><li>编写Bean1类：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * Bean的实例化的三种方式：采用无参数的构造方法的方式 *&#x2F;public class Bean1 {    public Bean1(){        System.out.println(&quot;Bean1被实例化了...&quot;);    }}</code></pre><ul><li>在xml中配置如下内容：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--    Bean的实例化的三种方式--&gt;&lt;!--    第一种：无参构造器的方式--&gt;&lt;bean id=&quot;bean1&quot; class=&quot;com.zero.ioc.demo1.Bean1&quot;&gt;&lt;&#x2F;bean&gt;</code></pre><ul><li>在测试方法中加载对象，并完成实例化</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test1(){    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    Bean1 bean1 = (Bean1) context.getBean(&quot;bean1&quot;);}</code></pre><h3 id="2-2-使用静态工厂方法实例化-简单工厂模式"><a href="#2-2-使用静态工厂方法实例化-简单工厂模式" class="headerlink" title="2.2 使用静态工厂方法实例化(简单工厂模式)"></a>2.2 使用静态工厂方法实例化(简单工厂模式)</h3><ul><li>编写Bean2类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * Bean的实例化的三种方式：使用静态工厂方法实例化 *&#x2F;public class Bean2 {}</code></pre><ul><li>编写静态工厂类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; Bean2的静态工厂public class Bean2Factory {    public static Bean2 createBean2(){        System.out.println(&quot;Bean2Factory已执行...&quot;);        return new Bean2();    }}</code></pre><ul><li>配置xml</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--    第二种：静态工厂的方式--&gt;&lt;bean id=&quot;bean2&quot; class=&quot;com.zero.ioc.demo1.Bean2Factory&quot; factory-method=&quot;createBean2&quot;&#x2F;&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test2(){    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    Bean2 bean2 = (Bean2) context.getBean(&quot;bean2&quot;);}</code></pre><blockquote><p>JDK12和Spring3.2不兼容！！！在使用静态工厂方法实例化对象时，会导致<code>java.lang.IllegalArgumentException</code>异常，更换Spring版本至4.2即可。</p></blockquote><h3 id="2-3-使用实例工厂方法实例化-工厂方法模式"><a href="#2-3-使用实例工厂方法实例化-工厂方法模式" class="headerlink" title="2.3 使用实例工厂方法实例化(工厂方法模式)"></a>2.3 使用实例工厂方法实例化(工厂方法模式)</h3><ul><li>编写Bean3类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * Bean的实例化三种方式：实例工厂实例化 *&#x2F;public class Bean3 {}</code></pre><ul><li>编写实例工厂类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Bean3Factory {    public Bean3 createBean3(){        System.out.println(&quot;Bean3Factory执行了...&quot;);        return new Bean3();    }}</code></pre><ul><li>配置xml</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--    第三种：实例工厂的方式--&gt;&lt;bean id=&quot;bean3Factory&quot; class=&quot;com.zero.ioc.demo1.Bean3Factory&quot;&#x2F;&gt;&lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;createBean3&quot;&#x2F;&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test3(){    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    Bean3 bean3 = (Bean3) context.getBean(&quot;bean3&quot;);}</code></pre><h3 id="2-4-Bean的配置"><a href="#2-4-Bean的配置" class="headerlink" title="2.4 Bean的配置"></a>2.4 Bean的配置</h3><ul><li><strong>id和name</strong><ul><li>一般情况下，装配一个Bean时，通过指定一个id属性作为Bean的名称</li><li>id属性在IOC容器中必须是唯一的</li><li>如果Bean的名称中含有特殊字符，就需要使用name属性</li></ul></li><li><strong>class</strong><ul><li>class用于设置一个类的<strong>完全路径名称</strong>，主要作用是IOC容器生成类的实例</li></ul></li></ul><h3 id="2-5-Bean的作用域"><a href="#2-5-Bean的作用域" class="headerlink" title="2.5 Bean的作用域"></a>2.5 Bean的作用域</h3><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td><code>singleton</code></td><td>在<code>SpringIOC</code>容器中仅存在一个Bean实例，Bean以单实例的方式存在</td></tr><tr><td><code>prototype</code></td><td>每次调用<code>getBean()</code>时都会返回一个新的实例</td></tr><tr><td><code>request</code></td><td>每次HTTP请求都会创建一新的Bean，该作用域仅适用于<code>WebApplicationContext</code>环境</td></tr><tr><td><code>session</code></td><td>同一个<code>HTTP Session</code>共享一个Bean，不同的<code>HTTP Session</code>使用不同的Bean。该作用域仅适用于<code>WebApplicationContext</code>环境</td></tr></tbody></table><ul><li>在xml中配置</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--    Bean的作用范围--&gt;&lt;!--仅存在一个Bean实例，单实例--&gt;&lt;bean id=&quot;person&quot; class=&quot;com.zero.ioc.demo2.Person&quot; scope=&quot;singleton&quot;&#x2F;&gt;&lt;!--每次调用getBean()都会返回一个新实例--&gt;&lt;bean id=&quot;person&quot; class=&quot;com.zero.ioc.demo2.Person&quot; scope=&quot;prototype&quot;&#x2F;&gt;</code></pre><h3 id="2-6-Spring容器中Bean的生命周期"><a href="#2-6-Spring容器中Bean的生命周期" class="headerlink" title="2.6 Spring容器中Bean的生命周期"></a>2.6 Spring容器中Bean的生命周期</h3><p>Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean时调用bean的两个生命周期方法。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot;      init-method=&quot;init&quot;      destroy-method=&quot;destroy&quot;&#x2F;&gt;&lt;!--当bean被载入到容器时调用init当bean从容器中删除时调用destroy(必须是单例bean才会自动调用，即scope=&quot;singleton&quot;才有效)--&gt;</code></pre><blockquote><p>web容器中会自动调用，但是main函数或测试用例需手动调用。</p></blockquote><ul><li>示例，创建一个man类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Man {    public Man(){        System.out.println(&quot;Man被实例化了&quot;);    }    public void setup(){        System.out.println(&quot;Man被初始化了&quot;);    }    public void myDestroy(){        System.out.println(&quot;Man被销毁了&quot;);    }}</code></pre><ul><li>配置xml</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;bean id=&quot;man&quot; class=&quot;com.zero.ioc.demo2.Man&quot; init-method=&quot;setup&quot; destroy-method=&quot;myDestroy&quot;&#x2F;&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java"> @Testpublic void test2(){    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    Man man = (Man) context.getBean(&quot;man&quot;);    context.close();}</code></pre><h4 id="2-6-1-Bean完整生命周期过程"><a href="#2-6-1-Bean完整生命周期过程" class="headerlink" title="2.6.1 Bean完整生命周期过程"></a>2.6.1 Bean完整生命周期过程</h4><p>完整生命周期总共有11个步骤。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/07/bean_lifeCycle-1565180819738.jpg" alt="bean_lifeCycle"></p><ol><li><code>instantiate bean</code>，对象实例化</li><li><code>populate properties</code>，封装属性</li><li>如果Bean实现<code>BeanNameAware</code>执行<code>setBeanName</code></li><li>如果Bean实现<code>BeanFactoryAware</code>或者<code>ApplicationContextAware</code>设置工厂<code>setBeanFactory</code>或者上下文对象<code>setApplicationContext</code></li><li>如果存在类实现<code>BeanPostProcessor</code>(后处理Bean)，执行<code>postProcessBeforeInitialization</code></li><li>如果Bean实现<code>InitializingBean</code>执行<code>afterPropertiesSet</code></li><li>调用<code>&lt;bean init-method=&quot;init&quot;&gt;</code>指定初始化方法init</li><li>如果存在类实现<code>BeanPostProcessor</code>(处理Bean)，执行<code>postProcessAfterInitialization</code></li><li>执行业务处理</li><li>如果Bean实现<code>DisposableBean</code>执行<code>destroy</code></li><li>调用<code>&lt;bean destroy-method=&quot;customerDestroy&quot;&gt;</code>指定销毁方法<code>customerDestroy</code></li></ol><p><strong>代码演示</strong>：</p><ul><li>编写man类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Man implements BeanNameAware, ApplicationContextAware, InitializingBean, DisposableBean {    private String name;    public String getName() {        return name;    }    public void setName(String name) {        System.out.println(&quot;第二步：设置属性&quot;);        this.name = name;    }    public Man(){        System.out.println(&quot;第一步：实例化。。。&quot;);    }    public void setup(){        System.out.println(&quot;第七步：Man被初始化了&quot;);    }    public void myDestroy(){        System.out.println(&quot;第十一步：执行自己定义的销毁方法&quot;);    }    @Override    public void setBeanName(String s) {        System.out.println(&quot;第三步：设置Bean的名称&quot;+s); &#x2F;&#x2F; 就是xml中配置的id的值    }    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        System.out.println(&quot;第四步：了解工厂信息&quot;);    }    @Override    public void afterPropertiesSet() throws Exception {        System.out.println(&quot;第六步：属性设置后执行 &quot;);    }    public void run(){        System.out.println(&quot;第九步：执行业务方法 &quot;);    }    public void destroy() throws Exception{        System.out.println(&quot;第十步：执行Spring的销毁方法&quot;);    }}</code></pre><ul><li>编写<code>MyBeanPostProcessor</code>类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class MyBeanPostProcessor implements BeanPostProcessor {    @Override    public Object postProcessBeforeInitialization(Object o, String s) throws BeansException {        System.out.println(&quot;第五步：初始化前方法。。。&quot;);        return o;    }    @Override    public Object postProcessAfterInitialization(Object o, String s) throws BeansException {        System.out.println(&quot;第八步：初始化后方法。。。&quot;);        return o;    }}</code></pre><ul><li>配置xml</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;bean id=&quot;man&quot; class=&quot;com.zero.ioc.demo2.Man&quot; init-method=&quot;setup&quot; destroy-method=&quot;myDestroy&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;bean class=&quot;com.zero.ioc.demo2.MyBeanPostProcessor&quot;&#x2F;&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test2(){    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    Man man = (Man) context.getBean(&quot;man&quot;);    man.run();    context.close();}&#x2F;** 输出结果:    第一步：实例化。。。    第二步：设置属性    第三步：设置Bean的名称man    第四步：了解工厂信息    第五步：初始化前方法。。。    第六步：属性设置后执行     第七步：Man被初始化了    第八步：初始化后方法。。。    第九步：执行业务方法     8月 06, 2019 7:48:41 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose    信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@7823a2f9: startup date [Tue Aug 06 19:48:41 CST 2019]; root of context hierarchy    第十步：执行Spring的销毁方法    第十一步：执行自己定义的销毁方法*&#x2F;</code></pre><h2 id="3-Spring的属性注入-XML方式"><a href="#3-Spring的属性注入-XML方式" class="headerlink" title="3. Spring的属性注入(XML方式)"></a>3. Spring的属性注入(XML方式)</h2><p>对于类成员变量，注入方式有三种：构造函数注入、属性setter方法注入、接口注入</p><blockquote><p>Spring支持前两种</p></blockquote><h3 id="3-1-属性注入-构造方法注入"><a href="#3-1-属性注入-构造方法注入" class="headerlink" title="3.1 属性注入-构造方法注入"></a>3.1 属性注入-构造方法注入</h3><ul><li><p>通过构造方法注入Bean的属性值或依赖的对象，它保证了Bean实例在实例化后就可以使用。</p></li><li><p>构造器注入通过<code>&lt;constructor-arg&gt;</code>元素来声明属性</p></li><li><p>代码示例</p><ul><li>创建user类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  public class User {      private String name;      private Integer age;        public User(String name, Integer age){          this.name = name;          this.age = age;      }        @Override      public String toString() {          return &quot;User{&quot; +                  &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                  &quot;, age=&quot; + age +                  &#39;}&#39;;      }  }</code></pre></li></ul><ul><li><p>配置xml</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;!--    Spring属性注入-通过构造方法注入--&gt;  &lt;bean id=&quot;user&quot; class=&quot;com.zero.ioc.demo3.User&quot;&gt;      &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&#x2F;&gt;      &lt;constructor-arg name=&quot;age&quot; value=&quot;22&quot;&#x2F;&gt;  &lt;&#x2F;bean&gt;</code></pre></li></ul><ul><li><p>测试</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  public class demo3Test {      @Test      public void test1(){          ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);          User user = (User) context.getBean(&quot;user&quot;);          System.out.println(user);      }  }</code></pre></li></ul><h3 id="3-2-属性注入-set方法注入"><a href="#3-2-属性注入-set方法注入" class="headerlink" title="3.2 属性注入-set方法注入"></a>3.2 属性注入-set方法注入</h3><ul><li><p>使用set方法注入，在Spring配置文件中，通过<code>&lt;property&gt;</code>设置注入的属性</p></li><li><p>代码示例</p><ul><li>创建person类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  public class Person {      private String name;      private Integer age;        private Cat cat;        &#x2F;&#x2F; 省略get&#x2F;set方法      @Override      public String toString() {          return &quot;Person{&quot; +                  &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                  &quot;, age=&quot; + age +                  &quot;, cat=&quot; + cat +                  &#39;}&#39;;      }  }</code></pre></li></ul><ul><li><p>创建cat类</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  public class Cat {      private String name;        @Override      public String toString() {          return &quot;Cat{&quot; +                  &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                  &#39;}&#39;;      }  &#x2F;&#x2F; 省略get&#x2F;set方法  }</code></pre></li></ul><ul><li><p>配置xml</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;!--    Spring属性注入-通过set方法注入--&gt;  &lt;bean id=&quot;person&quot; class=&quot;com.zero.ioc.demo3.Person&quot;&gt;      &lt;property name=&quot;name&quot; value=&quot;李四&quot;&#x2F;&gt;    &lt;property name=&quot;age&quot; value=&quot;25&quot;&#x2F;&gt;      &lt;!--        ref可以引入其他bean的id或name--&gt;    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;&#x2F;&gt;  &lt;&#x2F;bean&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.zero.ioc.demo3.Cat&quot;&gt;      &lt;property name=&quot;name&quot; value=&quot;ketty&quot;&#x2F;&gt;  &lt;&#x2F;bean&gt;</code></pre></li></ul><ul><li><p>测试</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @Test  public void test2(){      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    Person person = (Person) context.getBean(&quot;person&quot;);      System.out.println(person); &#x2F;&#x2F; Person{name=&#39;李四&#39;, age=25, cat=Cat{name=&#39;ketty&#39;}}}</code></pre></li></ul><blockquote><p>普通类型的值使用value设置值，对象类型的值使用ref。</p></blockquote><h3 id="3-3-属性注入-p名称空间"><a href="#3-3-属性注入-p名称空间" class="headerlink" title="3.3 属性注入-p名称空间"></a>3.3 属性注入-p名称空间</h3><p>使用p命名空间：为了简化xml文件配置，Spring从2.5开始引入一个新的p名称空间。</p><p>语法：<code>p:&lt;属性名&gt;=&quot;xxx&quot; 引入常量值</code>，<code>p:&lt;属性名&gt;-ref=&quot;xxx&quot;</code>引用其他Bean对象</p><ul><li>示例，配置xml，</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--先在beans中添加:xmlns:p=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;，引入p命名空间--&gt;&lt;!--    Spring属性注入-通过p名称空间注入--&gt;&lt;!--修改原有的person配置如下，即可实现通过p名称空间注入--&gt;&lt;bean id=&quot;person&quot; class=&quot;com.zero.ioc.demo3.Person&quot; p:name=&quot;赵钱&quot; p:age=&quot;26&quot; p:cat-ref=&quot;cat&quot;&#x2F;&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.zero.ioc.demo3.Cat&quot; p:name=&quot;小黑&quot;&#x2F;&gt;</code></pre><h3 id="3-4-属性注入-SpEL注入"><a href="#3-4-属性注入-SpEL注入" class="headerlink" title="3.4 属性注入-SpEL注入"></a>3.4 属性注入-SpEL注入</h3><ul><li><code>SpEL</code>：<code>spring expression language</code>，Spring表达式语言，对依赖注入进行简化</li><li>语法：<code>#{表达式}</code>，<code>&lt;bean id=&quot;&quot; value=&quot;#{表达式}&quot;/&gt;</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-shell">Spel表达式语法：基本语法：#{}#{&#39;hello&#39;}:使用字符串#{beanId}:使用另一个bean#{beanId.method()}:指定bean和对应方法，并执行方法#{T(java.lang.Math).PI}:使用静态字段或方法</code></pre><ul><li>示例如下，创建Product和Category类用于测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Product {    private String name;    private Double price;    private Category category;    @Override    public String toString() {        return &quot;Product{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, price=&quot; + price +                &quot;, category=&quot; + category +                &#39;}&#39;;    }    &#x2F;&#x2F; 省略get&#x2F;set方法}public class Category {    private String name;    @Override    public String toString() {        return &quot;Category{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;}&#39;;    }   &#x2F;&#x2F; 省略get&#x2F;set方法}</code></pre><ul><li>创建简单的计算类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ProductInfo {    public Double addPrice(){        return Math.random() * 20;    }}</code></pre><ul><li>配置xml</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--    Spring属性注入-通过SpEL注入--&gt;&lt;bean id=&quot;category&quot; class=&quot;com.zero.ioc.demo3.Category&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;#{&#39;水果&#39;}&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&lt;bean id=&quot;productInfo&quot; class=&quot;com.zero.ioc.demo3.ProductInfo&quot;&#x2F;&gt;&lt;bean id=&quot;product&quot; class=&quot;com.zero.ioc.demo3.Product&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;#{&#39;西瓜&#39;}&quot;&#x2F;&gt;    &lt;property name=&quot;price&quot; value=&quot;#{productInfo.addPrice()}&quot;&#x2F;&gt;    &lt;property name=&quot;category&quot; value=&quot;#{category}&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><ul><li>测试 </li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java"> @Test    public void test3(){        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Product product = (Product) context.getBean(&quot;product&quot;);        System.out.println(product);    }</code></pre><h3 id="3-5-复杂类型的属性注入"><a href="#3-5-复杂类型的属性注入" class="headerlink" title="3.5 复杂类型的属性注入"></a>3.5 复杂类型的属性注入</h3><ul><li>数组类型的属性注入</li><li>List集合类型的属性注入</li><li>Set集合类型的属性注入</li><li>Map集合类型的属性注入</li><li><p>Properties类型的属性注入</p></li><li><p>代码示例如下：</p><ul><li>创建集合类CollectionBean</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  public class CollectionBean {      private String[] arrs; &#x2F;&#x2F; 数组类型      private List&lt;String&gt; list; &#x2F;&#x2F; List集合类型      private Set&lt;String&gt; set; &#x2F;&#x2F; Set集合类型      private Map&lt;String,Integer&gt; map; &#x2F;&#x2F; Map集合类型      private Properties properties; &#x2F;&#x2F; 属性类型          @Override      public String toString() {          return &quot;CollectionBean{&quot; +                  &quot;arrs=&quot; + Arrays.toString(arrs) +                  &quot;, list=&quot; + list +                  &quot;, set=&quot; + set +                  &quot;, map=&quot; + map +                  &quot;, properties=&quot; + properties +                  &#39;}&#39;;      }   &#x2F;&#x2F; 省略get&#x2F;set方法     }</code></pre></li></ul><ul><li><p>配置xml，添加如下内容</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;!--    复杂类型的属性注入--&gt;  &lt;bean id=&quot;collectionBean&quot; class=&quot;com.zero.ioc.demo4.CollectionBean&quot;&gt;      &lt;!--        数组类型的属性注入--&gt;      &lt;property name=&quot;arrs&quot;&gt;          &lt;list&gt;              &lt;value&gt;aaa&lt;&#x2F;value&gt;              &lt;value&gt;bbb&lt;&#x2F;value&gt;              &lt;value&gt;ccc&lt;&#x2F;value&gt;          &lt;&#x2F;list&gt;      &lt;&#x2F;property&gt;      &lt;!--        List集合类型的属性注入--&gt;      &lt;property name=&quot;list&quot;&gt;          &lt;list&gt;              &lt;value&gt;111&lt;&#x2F;value&gt;              &lt;value&gt;222&lt;&#x2F;value&gt;              &lt;value&gt;333&lt;&#x2F;value&gt;          &lt;&#x2F;list&gt;      &lt;&#x2F;property&gt;      &lt;!--        set集合类型的属性注入--&gt;      &lt;property name=&quot;set&quot;&gt;          &lt;set&gt;              &lt;value&gt;ddd&lt;&#x2F;value&gt;              &lt;value&gt;eee&lt;&#x2F;value&gt;              &lt;value&gt;fff&lt;&#x2F;value&gt;          &lt;&#x2F;set&gt;      &lt;&#x2F;property&gt;      &lt;!--        map集合类型的属性注入--&gt;      &lt;property name=&quot;map&quot;&gt;          &lt;map&gt;              &lt;entry key=&quot;aaa&quot; value=&quot;111&quot;&#x2F;&gt;              &lt;entry key=&quot;bbb&quot; value=&quot;222&quot;&#x2F;&gt;              &lt;entry key=&quot;ccc&quot; value=&quot;333&quot;&#x2F;&gt;          &lt;&#x2F;map&gt;      &lt;&#x2F;property&gt;      &lt;!--        Properties类型的属性注入--&gt;      &lt;property name=&quot;properties&quot;&gt;          &lt;props&gt;              &lt;prop key=&quot;username&quot;&gt;root&lt;&#x2F;prop&gt;              &lt;prop key=&quot;password&quot;&gt;123456&lt;&#x2F;prop&gt;          &lt;&#x2F;props&gt;      &lt;&#x2F;property&gt;  &lt;&#x2F;bean&gt;</code></pre></li></ul><ul><li><p>测试</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @Test  public void test1(){      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);      CollectionBean collectionBean = (CollectionBean) context.getBean(&quot;collectionBean&quot;);      System.out.println(collectionBean);  }</code></pre></li></ul><h2 id="4-Spring的Bean管理-注解方式"><a href="#4-Spring的Bean管理-注解方式" class="headerlink" title="4. Spring的Bean管理(注解方式)"></a>4. Spring的Bean管理(注解方式)</h2><h3 id="4-1-使用注解定义Bean"><a href="#4-1-使用注解定义Bean" class="headerlink" title="4.1 使用注解定义Bean"></a>4.1 使用注解定义Bean</h3><ul><li>Spring2.5 引入使用注解去定义Bean<ul><li><code>@Component</code>，描述Spring框架中的Bean</li></ul></li><li>除了<code>@Component</code>外，Spring还提供了3个功能基本等效的注解<ul><li><code>@Repository</code>：用于对DAO实现类进行标注</li><li><code>@Service</code>：用于对Service实现类进行标注</li><li><code>@Controller</code>：用于对Controller实现类进行标注</li></ul></li><li><p>这三个注解是为了让标注类本身的用途更加清晰，Spring在后续版本会对其增强。</p></li><li><p>代码示例</p><ul><li>创建<code>UserService</code>类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;**   * Spring的Bean管理的注解方式：   *      传统方式：需要去XML中配置&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;&#x2F;bean&gt;   *   *&#x2F;    @Service(&quot;userService&quot;)  public class UserService {      public String hello(String name){          return &quot;Hello&quot; + name;      }  }</code></pre></li></ul><ul><li><p>配置xml，开启扫描</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;         xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;         xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;        &lt;!-- 开启注解扫描 --&gt;      &lt;context:component-scan base-package=&quot;com.zero.demo1&quot;&#x2F;&gt;      &lt;&#x2F;beans&gt;</code></pre></li></ul><ul><li><p>测试</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @Test  public void demo1(){      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);      UserService userService = (UserService) context.getBean(&quot;userService&quot;);        String hello = userService.hello(&quot;小明&quot;);      System.out.println(hello);  }</code></pre></li></ul><h2 id="5-Spring的属性注入-注解方式"><a href="#5-Spring的属性注入-注解方式" class="headerlink" title="5. Spring的属性注入(注解方式)"></a>5. Spring的属性注入(注解方式)</h2><ul><li>使用<code>@Autowired</code>进行自动注入</li><li><code>@Autowired</code>默认按照类型进行注入<ul><li>如果存在两个相同Bean类型相同，则按照名称注入</li></ul></li><li><code>@Autowired</code>注入时可以针对成员变量或者set方法</li><li>通过<code>@Autowired</code>的<code>required</code>属性，设置一定要找到匹配的Bean</li><li>使用<code>@Qualifier</code>指定注入Bean的名称</li><li><p>使用<code>Qualifier</code>指定Bean名称后，注解Bean必须指定相同名称</p></li><li><p>代码示例：</p><ul><li>创建一个dao</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @Repository(&quot;userDao&quot;)  public class UserDao {      public void save(){          System.out.println(&quot;Dao中保存用户。。。&quot;);      }  }</code></pre></li></ul><ul><li><p>修改UserService</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @Service(&quot;userService&quot;)  public class UserService {      &#x2F;&#x2F;使用value直接对属性值进行注入      @Value(&quot;苹果&quot;)      private String something;        &#x2F;&#x2F; 自动注入      @Autowired      @Qualifier(&quot;userDao&quot;) &#x2F;&#x2F; 指定注解的Bean名称必须相同‘      @Resource(name=&quot;userDao&quot;) &#x2F;&#x2F; 可以使用@Resource，指定Bean名称      private UserDao dao;        public String hello(String name){          return &quot;Hello&quot; + name;      }        public void eat(){          System.out.println(&quot;eat:&quot;+something);      }        public void save(){          System.out.println(&quot;Service中保存用户。。。&quot;);          dao.save();      }  }</code></pre></li></ul><ul><li><p>测试</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @Test  public void demo2(){      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);      UserService userService = (UserService) context.getBean(&quot;userService&quot;);      userService.save();  }</code></pre></li></ul><blockquote><ul><li>Spring提供对JSR-250中定义<code>@Resource</code>标准注解的支持</li><li><code>@Resource</code>和<code>@Autowired</code>注解功能相似</li><li>如无法使用<code>@Resource</code>，需在<code>pom.xml</code>中引入<code>javax.annotation-api</code>依赖</li></ul></blockquote><h3 id="5-1-Spring的其他注解"><a href="#5-1-Spring的其他注解" class="headerlink" title="5.1 Spring的其他注解"></a>5.1 Spring的其他注解</h3><p>Spring初始化Bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean时调用bean的两个生命周期方法。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot;      init-method=&quot;setup&quot;      destroy-method=&quot;teardown&quot;&#x2F;&gt;&lt;!--当bean被载入到容器时调用setup,注解方式：@PostConstruct,初始化当bean从容器中删除时调用teardown(必须是单例bean才会自动调用，即scope=&quot;singleton&quot;才有效)注解方式：@PreDestroy，销毁--&gt;</code></pre><ul><li>代码示例，创建bean1类</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Component(&quot;bean1&quot;)public class Bean1 {        &#x2F;&#x2F; 生命周期注解，初始化    @PostConstruct    public void init(){        System.out.println(&quot;initBean...&quot;);    }    public void say(){        System.out.println(&quot;say...&quot;);    }&#x2F;&#x2F; 生命周期注解，销毁    @PreDestroy    public void destroy(){        System.out.println(&quot;destroyBean...&quot;);    }}</code></pre><ul><li>配置xml</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!-- 开启注解扫描 --&gt;&lt;context:component-scan base-package=&quot;com.zero&quot;&#x2F;&gt;</code></pre><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test1(){    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);    Bean1 bean1 = (Bean1) context.getBean(&quot;bean1&quot;);    bean1.say();    context.close();}</code></pre><h3 id="5-2-Bean的作用范围"><a href="#5-2-Bean的作用范围" class="headerlink" title="5.2 Bean的作用范围"></a>5.2 Bean的作用范围</h3><ul><li>使用注解配置的Bean和<code>&lt;bean&gt;</code>配置的一样，默认作用范围都是<code>singleton</code></li><li><p><code>@Scope</code>注解用于指定Bean的作用范围</p></li><li><p>代码示例：</p><ul><li>创建bean2类，设置其作用范围</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @Component(&quot;bean2&quot;)  @Scope(&quot;prototype&quot;) &#x2F;&#x2F; 设置作用范围，使用多例创建对象  public class Bean2 {  }</code></pre></li></ul><ul><li><p>测试</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   @Test  public void test2(){      ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);      Bean2 bean1 = (Bean2) context.getBean(&quot;bean2&quot;);      Bean2 bean2 = (Bean2) context.getBean(&quot;bean2&quot;);        System.out.println(bean1 == bean2);    }</code></pre></li></ul><h3 id="5-3-传统XML配置和注解配置混合使用"><a href="#5-3-传统XML配置和注解配置混合使用" class="headerlink" title="5.3 传统XML配置和注解配置混合使用"></a>5.3 传统XML配置和注解配置混合使用</h3><ul><li>XML方式的优势<ul><li>结构清晰，易于阅读</li></ul></li><li>注解方式的优势<ul><li>开发便捷，属性注入方便</li></ul></li><li><p>XML与注解的整合开发</p><ul><li>引入context命名空间</li><li>在配置文件中添加<code>&lt;context:annotation-config/&gt;</code></li></ul></li><li><p>代码示例</p><ul><li>创建<code>ProductService，ProductDao，CategoryDao</code>，均创建简单的save方法。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  public class ProductService {      &#x2F;&#x2F; 使用注解      @Resource(name = &quot;categoryDao&quot;)      private CategoryDao categoryDao;        @Resource(name = &quot;productDao&quot;)      private ProductDao productDao;    &#x2F;&#x2F;    public void setCategoryDao(CategoryDao categoryDao) {  &#x2F;&#x2F;        this.categoryDao = categoryDao;  &#x2F;&#x2F;    }  &#x2F;&#x2F;  &#x2F;&#x2F;    public void setProductDao(ProductDao productDao) {  &#x2F;&#x2F;        this.productDao = productDao;  &#x2F;&#x2F;    }        public void save(){          System.out.println(&quot;ProductService中的save方法执行了...&quot;);          categoryDao.save();          productDao.save();      }  }    public class ProductDao {      public void save(){          System.out.println(&quot;ProductDao中的save方法执行了...&quot;);      }  }      public class CategoryDao {      public void save(){          System.out.println(&quot;CategoryDao中的save方法执行了...&quot;);      }  }</code></pre></li></ul><ul><li><p>配置xml</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;!--单独开启注解功能--&gt;  &lt;context:annotation-config&#x2F;&gt;    &lt;bean id=&quot;productService&quot; class=&quot;com.zero.demo3.ProductService&quot;&gt;      &lt;!--        &lt;property name=&quot;productDao&quot; ref=&quot;productDao&quot;&#x2F;&gt;--&gt;      &lt;!--        &lt;property name=&quot;categoryDao&quot; ref=&quot;categoryDao&quot;&#x2F;&gt;--&gt;  &lt;&#x2F;bean&gt;  &lt;bean id=&quot;productDao&quot; class=&quot;com.zero.demo3.ProductDao&quot;&#x2F;&gt;  &lt;bean id=&quot;categoryDao&quot; class=&quot;com.zero.demo3.CategoryDao&quot;&#x2F;&gt;</code></pre></li></ul><ul><li>测试</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test1() {    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);    ProductService productService = (ProductService) context.getBean(&quot;productService&quot;);    productService.save();}</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring简单入门</title>
      <link href="/FrameWork/Spring-Basic.html"/>
      <url>/FrameWork/Spring-Basic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Spring介绍"><a href="#1-Spring介绍" class="headerlink" title="1. Spring介绍"></a>1. Spring介绍</h2><p>Spring是一个开源框架，于2003年兴起的轻量级Java开发框架。Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。</p><blockquote><p>简单来说：Spring是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架。</p></blockquote><a id="more"></a><h3 id="1-1-Spring的好处"><a href="#1-1-Spring的好处" class="headerlink" title="1.1 Spring的好处"></a>1.1 Spring的好处</h3><ul><li>方便解耦，简化开发<ul><li>Spring就是一个大工厂，专门负责生产Bean，可以将所有对象创建和依赖关系维护，交给Spring管理。</li></ul></li><li>AOP编程的支持<ul><li>Spring提供面向切面编程，可以方便的实现对程序进行<strong>权限拦截</strong>、运行监控等功能。</li></ul></li><li>声明式事务的支持<ul><li>只需要通过配置就可以完成对事务的管理，而无需手动编程。</li></ul></li><li>方便程序的测试<ul><li>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</li></ul></li><li>方便集成各种优秀框架<ul><li>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架(如：Struts、Hibernate、MyBatis等)的直接支持。</li></ul></li><li>降低JavaEE API的使用难度<ul><li>Spring对JavaEE开发中非常难用的一些API(JDBC、JavaMail、远程调用等)，都提供了封装，使这些API应用难度大大降低。</li></ul></li></ul><h3 id="1-2-Spring体系结构"><a href="#1-2-Spring体系结构" class="headerlink" title="1.2 Spring体系结构"></a>1.2 Spring体系结构</h3><p>Spring框架是一个分层架构，它包含一系列的功能要素并被分为大约<strong>20个模块</strong>。这些模块分为Core Container、Data Access/Integration、Web、AOP（Aspect Oriented Programming）、Instrumentation和测试部分。如下图所示：</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/05/Spring-1565010640149.jpg" alt="Spring"></p><h2 id="2-Spring简单入门"><a href="#2-Spring简单入门" class="headerlink" title="2. Spring简单入门"></a>2. Spring简单入门</h2><p>基本流程：</p><ol><li>下载Spring开发包</li><li>导入Spring核心jar包</li><li>编写Spring核心配置文件</li><li>在程序中读取Spring配置文件，通过Spring框架获取Bean，完成相应操作。</li></ol><h3 id="2-1-下载Spring开发包"><a href="#2-1-下载Spring开发包" class="headerlink" title="2.1 下载Spring开发包"></a>2.1 下载Spring开发包</h3><p>Spring<a href="https://repo.spring.io/libs-release-local/org/springframework/spring/" target="_blank" rel="noopener">官方下载地址</a></p><p>下载后解压，目录结构如下：</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/05/SpringDir-1565010658795.jpg" alt="SpringDir"></p><h3 id="2-2-导入Spring核心jar包到项目中"><a href="#2-2-导入Spring核心jar包到项目中" class="headerlink" title="2.2 导入Spring核心jar包到项目中"></a>2.2 导入Spring核心jar包到项目中</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/05/spring_jar-1565010729837.jpg" alt="spring_jar"></p><ul><li><code>spring-core-3.2.0.RELEASE.jar</code><ul><li>包含Spring框架基本的核心工具类，Spring其他组件都要使用到这个包里的类，是其他组件的基本核心。</li></ul></li><li><code>spring-beans-3.2.0.RELEASE.jar</code><ul><li>所有应用都要用到的，它包含访问配置文件、创建和管理bean，以及进行IOC/DI操作相关的所有类</li></ul></li><li><code>spring-context-3.2.0.RELEASE.jar</code><ul><li>Spring提供在基础IOC功能上的扩展功能，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI定位、EJB集成、远程访问、缓存以及各种视图层框架的封装等。</li></ul></li><li><code>spring-expression-3.2.0.RELEASE.jar</code><ul><li>Spring表达式语言</li></ul></li><li><code>commons-logging-1.2.jar</code><ul><li>第三方的主要用于处理日志</li></ul></li></ul><blockquote><p>注意导入时，不要导入带source的源文件。</p></blockquote><h3 id="2-3-编写Spring核心配置文件"><a href="#2-3-编写Spring核心配置文件" class="headerlink" title="2.3 编写Spring核心配置文件"></a>2.3 编写Spring核心配置文件</h3><h4 id="2-3-1-创建测试方法"><a href="#2-3-1-创建测试方法" class="headerlink" title="2.3.1 创建测试方法"></a>2.3.1 创建测试方法</h4><ul><li>在src下创建一个service文件夹，里面创建UserService及其对应实现类，实现add方法，直接打印一句话。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserServiceImpl implements UserService{    @Override    public void add() {        System.out.println(&quot;创建用户...&quot;);    }}</code></pre><ul><li>创建测试方法，调用add方法。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserServiceTest {    @Test    public void test1(){        UserService us = new UserServiceImpl();        us.add();    }}</code></pre><h4 id="2-3-2-使用Spring-IOC控制反转创建实例"><a href="#2-3-2-使用Spring-IOC控制反转创建实例" class="headerlink" title="2.3.2 使用Spring IOC控制反转创建实例"></a>2.3.2 使用<code>Spring IOC</code>控制反转创建实例</h4><ul><li>编写配置文件<code>beans.xml</code>，xsd约束文件可以在<code>/spring-framework-3.2.0.RC2-docs/reference/html/xsd-config.html</code>中查看</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;    &lt;!-- 配置一个bean --&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.zero.service.UserServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><h3 id="2-4-在程序中读取Spring配置文件，通过Spring框架获取Bean，完成相应操作。"><a href="#2-4-在程序中读取Spring配置文件，通过Spring框架获取Bean，完成相应操作。" class="headerlink" title="2.4 在程序中读取Spring配置文件，通过Spring框架获取Bean，完成相应操作。"></a>2.4 在程序中读取Spring配置文件，通过Spring框架获取Bean，完成相应操作。</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserServiceTest {    @Test    public void test1(){        &#x2F;&#x2F; 不使用spring的方式，自己创建对象        &#x2F;&#x2F;        UserService us = new UserServiceImpl();        &#x2F;&#x2F;        us.add();        &#x2F;&#x2F; 使用spring容器方式获取UserService        &#x2F;&#x2F; 1. 加载beans.xml 这个spring的配置文件，内部就会创建对象        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);&#x2F;&#x2F; 2. 获取对象        UserService userService1 = (UserService) context.getBean(&quot;userService&quot;);        userService1.add();        System.out.println(userService1); &#x2F;&#x2F; com.zero.service.UserServiceImpl@5f058f00        UserService userService2 = (UserService) context.getBean(&quot;userService&quot;);        System.out.println(userService2); &#x2F;&#x2F; com.zero.service.UserServiceImpl@5f058f00    }}</code></pre><h3 id="2-5-IOC"><a href="#2-5-IOC" class="headerlink" title="2.5 IOC"></a>2.5 IOC</h3><p>IOC(Inverse of Control) 反转控制的概念，就是将原本在程序中手动创建对象的控制权，交由Spring框架管理。简单的说，就是创建对象控制权被反转到了Spring框架。</p><h3 id="2-6-DI解释"><a href="#2-6-DI解释" class="headerlink" title="2.6 DI解释"></a>2.6 DI解释</h3><ul><li>Dependency Injection 依赖输入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件。</li></ul><p>例：在UserServiceImpl中提供一个get/set的name方法，在beans.xml中提供property去注入。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class UserServiceImpl implements UserService{    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    @Override    public void add() {        System.out.println(&quot;创建用户...&quot;+name);    }}</code></pre><p>配置文件中使用依赖注入：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;    &lt;!-- 配置一个bean --&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.zero.service.UserServiceImpl&quot;&gt;        &lt;!-- 使用DI依赖注入数据, 调用属性的set方法--&gt;        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;&#x2F;property&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络相关知识汇总(随缘更新中~)</title>
      <link href="/Interview/network.html"/>
      <url>/Interview/network.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-OSI开放式互联参考模型"><a href="#1-OSI开放式互联参考模型" class="headerlink" title="1. OSI开放式互联参考模型"></a>1. OSI开放式互联参考模型</h2><p>OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能就是帮助<strong>不同类型的主机实现数据传输 </strong>。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/OSI-1564755170924.png" alt="OSI"></p><p>一个设备在哪一层，关键看它工作时利用哪一层的数据头部信息。举例来说：</p><ul><li>物理层：网卡、网线、集线器、中继器、调制解调器</li><li>数据链路层：网桥、交换机</li><li>网络层：路由器</li></ul><p><strong>网关</strong>工作在第四层传输层及其以上。<strong>集线器</strong>是物理层设备，采用广播的形式来传输信息。<strong>交换机</strong>就是用来进行报文交换的及其，多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文。<strong>路由器</strong>的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。</p><h3 id="1-1-物理层"><a href="#1-1-物理层" class="headerlink" title="1.1 物理层"></a>1.1 物理层</h3><p>在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。</p><ul><li>主要功能：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li></ul><p>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><h3 id="1-2-数据链路层"><a href="#1-2-数据链路层" class="headerlink" title="1.2 数据链路层"></a>1.2 数据链路层</h3><p>数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。</p><ul><li>主要功能：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</li></ul><p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p><p>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p><ul><li>MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制</li><li>LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。</li></ul><p>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p><h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><p>网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。</p><p>其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。<br>一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 </p><p>在实现网络层功能时，需要解决的主要问题如下：</p><ul><li>寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。</li><li>交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。</li><li>路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。</li><li>连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。</li></ul><h3 id="1-4-传输层"><a href="#1-4-传输层" class="headerlink" title="1.4 传输层"></a>1.4 传输层</h3><p>OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。</p><ul><li>主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。</li><li>该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。</li></ul><p>传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。</p><p>因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：</p><ul><li>传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。</li><li>处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。</li><li>监控服务质量。</li></ul><h3 id="1-5-会话层"><a href="#1-5-会话层" class="headerlink" title="1.5 会话层"></a>1.5 会话层</h3><p>会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：<strong>向两个实体的表示层提供建立和使用连接的方法</strong>。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。<br>用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名（DN）就是一种网络上使用的远程地址例如：<code>www.baidu.com</code> 就是一个域名。</p><p>会话层的具体功能如下：</p><ul><li>会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。</li><li>会话流量控制：提供会话流量控制和交叉会话功能。</li><li>寻址：使用远程地址建立会话连接。</li><li>出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。</li></ul><h3 id="1-6-表示层"><a href="#1-6-表示层" class="headerlink" title="1.6 表示层"></a>1.6 表示层</h3><p>表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“<strong>处理用户信息的表示问题，如编码、数据格式转换和加密解密</strong>”等。</p><p>表示层的具体功能如下：</p><ul><li>数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。</li><li>数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。</li><li>压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。</li><li>数据的加密和解密：可以提高网络的安全性。</li></ul><h3 id="1-7-应用层"><a href="#1-7-应用层" class="headerlink" title="1.7 应用层"></a>1.7 应用层</h3><p>应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，<strong>负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议</strong>。</p><p>此外，该层还负责协调各个应用程序间的工作。<br>应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。</p><p>应用层的主要功能如下：</p><ul><li>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。</li><li>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</li></ul><h3 id="1-8-OSI7层模型小结"><a href="#1-8-OSI7层模型小结" class="headerlink" title="1.8 OSI7层模型小结"></a>1.8 OSI7层模型小结</h3><p>由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。</p><p>在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层、应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。</p><blockquote><p>简言之：下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。</p></blockquote><h3 id="1-9-TCP-IP分层模型"><a href="#1-9-TCP-IP分层模型" class="headerlink" title="1.9 TCP/IP分层模型"></a>1.9 TCP/IP分层模型</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP_IP-1564755221704.jpg" alt="TCP_IP"></p><p>TCP/IP分层模型的四个协议层分别完成以下的功能：</p><ul><li><p>第一层，链路层：包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。</p></li><li><p>第二层，网络层：对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。</p></li><li>第三层，传输层：对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。</li><li>第四层，应用层：对应于OSI七层参考模型的应用层和表达层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等。</li></ul><h2 id="2-三次握手和四次挥手"><a href="#2-三次握手和四次挥手" class="headerlink" title="2. 三次握手和四次挥手"></a>2. 三次握手和四次挥手</h2><ul><li>TCP概述：</li></ul><p>TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字(socket)，它的定义为端口号拼接到IP地址即构成了套接字。例如，假设IP地址为<code>192.3.4.15</code>，端口号为80，那么得到的套接字为<code>192.3.4.15:80</code>。</p><h3 id="2-1-TCP的三次握手"><a href="#2-1-TCP的三次握手" class="headerlink" title="2.1 TCP的三次握手"></a>2.1 TCP的三次握手</h3><p>所谓三次握手，即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。</p><h4 id="2-1-1-传输控制协议TCP简介"><a href="#2-1-1-传输控制协议TCP简介" class="headerlink" title="2.1.1 传输控制协议TCP简介"></a>2.1.1 传输控制协议TCP简介</h4><ul><li>面向连接的、可靠的、基于字节流的传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用<strong>校验和</strong>来校验数据在传输过程中是否有误</li></ul><h4 id="2-1-2-TCP报文结构详解"><a href="#2-1-2-TCP报文结构详解" class="headerlink" title="2.1.2 TCP报文结构详解"></a>2.1.2 TCP报文结构详解</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP-1564755257344.jpg" alt="TCP"></p><p>TCP报文由首部和数据两部分组成。首部一般由20-60字节(Byte)构成，长度可变。其中前20B格式固定，后40B为可选。</p><p>因为，TCP报文还得传给下层网络层，封装成IP包，而一个IP包最大长度为65535，同时IP包首部也包含最少20B，所以一个IP包或TCP包可以包含的数据部分最多为65535-20-20=65495B。</p><p>TCP报文中数据部分是可选的，即TCP报文可以不包含数据（同理IP包也可以不包含数据）。不含数据的TCP报文通常是一些确认和控制信息类的报文，如TCP建立连接时的三次握手和TCP终止时的四次挥手等。</p><p>参数详解：</p><ol><li>源端口号（Source Port）：长度为16位占2个字节，指明发送数据的进程。</li><li>目的端口号（Destination Port）：长度为16位占2个字节，指明目的主机接收数据的进程。</li><li>序号（Sequence Number）：也称为序列号，长度为32位占4个字节。<strong>TCP连接中传送的字节流中的每个字节都按顺序编号</strong>。例如，一段报文的序号字段是301，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始。</li><li>确认号（Acknowledgement Number）：长度为32位占4个字节，<strong>是期望收到对方下一个报文的第一个数据字节的序号</strong>。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，<strong>这表明B正确的收到了A发送的到序号700为止的数据</strong>。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。确认号只有在ACK标志为1时才有效。</li><li>数据偏移：占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远。</li><li>首部长度：长度为4位，用于表示TCP报文首部的长度。用4位(bit)表示，十进制值就是[0,15]，一个TCP报文前20个字节是必有的，后40个字节根据情况可有可无。如果TCP报文首部是20个字节，则该位应是20/4=5。</li><li>保留位（Reserved）：长度为6位，必须是0，它是为将来定义新用途保留的。</li><li>标志（Code Bits）：长度为6位，在TCP报文中不管是挥手还是传数据等，这6位标志都很重要。6位从左到右依次为：<ul><li>URG：紧急标志位，当URG=1时，表明紧急指针有效。告诉系统此报文段中有紧急数据。</li><li>ACK：确认标志位，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置为1。</li><li>PSH：推标志位，当两个应用程序进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时就可以将PSH=1。</li><li>RST：复位标志，用于重建一个已经混乱的连接。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。</li><li>SYN：同步标志，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1,ACK=1。</li><li>FIN：结束标志，带该标志位的数据包用于结束一个TCP会话。当FIN=1,时，表明此报文的发送方数据已经发送完毕，并且要求释放。</li></ul></li><li>窗口大小（Window Size）：长度为16位占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接收。</li><li>校验和（Checksum）：长度为16位占2字节，该字段覆盖整个TCP报文端，是个强制性的字段，是由发送端计算和存储，到接收端后，由接收端进行验证。主要检验首部和数据这两部分。</li><li>紧急指针（Urgent Pointer）：长度为16位占2字节，指出本报文段中的紧急数据的字节数，该字段在URG标志置位时有效。</li><li>选型（Options）：长度可变，定义一些其他的可选参数。通常包含：最长报文大小（Maximum Segment Size，MSS）、窗口扩大选项、时间戳选项、选择性确认（Selective ACKnowlegement，SACK）等。</li><li>数据：TCP 报文段中的数据部分是可选的。</li></ol><blockquote><ul><li>单工数据传输只支持数据在一个方向上传输；</li><li>半双工数据传输允许数据在两个方向上传输，但在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；</li><li>全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都具有独立的接收和发送能力。</li></ul></blockquote><h4 id="2-1-3-TCP三次握手流程图"><a href="#2-1-3-TCP三次握手流程图" class="headerlink" title="2.1.3 TCP三次握手流程图"></a>2.1.3 TCP三次握手流程图</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-1564755271685.gif" alt="三次握手"></p><p><strong>整个流程为</strong>：</p><ol><li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态。</li><li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同步位SYN=1，同时选择一个初始序列号Seq=x，此时TCP客户端进程进入了SYN-SENT(同步已发送)状态。TCP规定，SYN报文段(SYN=1的报文段)不能携带数据，但需要消耗掉一个序号。</li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该ACK=1,SYN=1,确认号是ack=x+1，同时也要为自己初始化一个序列号Seq=y。此时，TCP服务器进程进入了SYN-RCVD(同步收到)状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号Seq=x+1。此时，TCP连接建立，客户端进入ESTABLISHED(已建立连接)状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li><li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li></ol><blockquote><p>TCB：传输控制块，它是协议栈的核心数据结构，一个套接字在TCP、IP层的代表就是一个传输控制块，它包含了一个套接字所需要的所有信息。</p></blockquote><p><a href="https://www.cnblogs.com/lipengfei159263/p/9745986.html" target="_blank" rel="noopener">内容详见文章</a></p><p><strong>流程小结</strong>：</p><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><p>第一次握手：建立连接时，客户端发送SYN包{syn=x}到服务器，并进入SYN_SEND(同步已发送)状态，等待服务器确认。</p><p>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包(syn=y)，即SYN+ACK包，此时服务器进入SYN_RECV(同步收到)状态。</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK{ack=y+1}，此包发送完毕，客户端和服务器进入ESTABLISHED（已建立连接）状态，完成三次握手。</p><h4 id="2-1-4-SYN攻击"><a href="#2-1-4-SYN攻击" class="headerlink" title="2.1.4 SYN攻击"></a>2.1.4 SYN攻击</h4><p>在三次握手过程中，服务端发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接，此时服务端处于SYN-RCVD(同步收到)状态。当收到ACK后，服务端才会进入ESTABLISHED（已建立连接）状态。SYN攻击就是客户端在短时间内伪造大量不存在的IP地址，并向服务端不断发送SYN包，服务端回复确认包，并等待客户端的确认，由于源地址IP是不存在的，因此，服务端需要不断重发直至SYN超时。这些伪造的SYN包将占用未连接队列，导致正常的SYN请求因队列满而被丢弃，从而引起网络阻塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当服务端上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。使用如下命令可以让其现行：<code>netstat -nap | grep SYN_RECV</code></p><h3 id="2-2-TCP的四次挥手"><a href="#2-2-TCP的四次挥手" class="headerlink" title="2.2  TCP的四次挥手"></a>2.2  TCP的四次挥手</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/TCP_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-1564755288068.gif" alt="四次挥手"></p><blockquote><p>数据传输完毕后，双方都可释放连接。最开始时，客户端和服务端都是处于ESTABLISHED状态，然后客户端主动关闭，服务端被动关闭。</p></blockquote><p><strong>具体流程</strong>：</p><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）。此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务端收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。<strong>TCP服务器通知高层应用进程，客户端要释放向服务器的通信连接了，这时处于半关闭状态，即客户端已经无数据要发送了，但服务器若发送数据，客户端依然要接受。</strong>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1。由于处在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，那么此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1。此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销响应的TCB后，才会进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，会立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ol><p><strong>挥手小结</strong>：</p><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态；</p><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态，Client进入FIN-WAIT-2状态；</p><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态；</p><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，Client在经过2MSL后也会进入CLOSED状态，完成四次挥手；</p><h2 id="3-计算机网络相关面试题"><a href="#3-计算机网络相关面试题" class="headerlink" title="3. 计算机网络相关面试题"></a>3. 计算机网络相关面试题</h2><h3 id="3-1-为什么TCP客户端最后还要发送一次确认呢？为什么需要三次握手才能建立起连接？"><a href="#3-1-为什么TCP客户端最后还要发送一次确认呢？为什么需要三次握手才能建立起连接？" class="headerlink" title="3.1 为什么TCP客户端最后还要发送一次确认呢？为什么需要三次握手才能建立起连接？"></a>3.1 为什么TCP客户端最后还要发送一次确认呢？为什么需要三次握手才能建立起连接？</h3><p>主要为了防止已经失效的连接请求报文突然又传送到了服务端，因而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h3 id="3-2-为什么在四次挥手时客户端最后还要等待2MSL？"><a href="#3-2-为什么在四次挥手时客户端最后还要等待2MSL？" class="headerlink" title="3.2 为什么在四次挥手时客户端最后还要等待2MSL？"></a>3.2 为什么在四次挥手时客户端最后还要等待2MSL？</h3><blockquote><p>MSL（Maximum Segment Lifetime）最长报文段寿命，TCP允许不同的实现可以设置不同的MSL值。</p></blockquote><p>第一：<strong>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失</strong>。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二：<strong>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中</strong>。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h3 id="3-3-为什么建立连接是三次握手，关闭连接却是四次挥手呢？"><a href="#3-3-为什么建立连接是三次握手，关闭连接却是四次挥手呢？" class="headerlink" title="3.3 为什么建立连接是三次握手，关闭连接却是四次挥手呢？"></a>3.3 为什么建立连接是三次握手，关闭连接却是四次挥手呢？</h3><p>建立连接时，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，己方ACK和FIN一般都会分开发送，从而导致多一次数据包传递。</p><h3 id="3-4-如果已经建立了连接，但客户端突然出现故障了怎么办？"><a href="#3-4-如果已经建立了连接，但客户端突然出现故障了怎么办？" class="headerlink" title="3.4 如果已经建立了连接，但客户端突然出现故障了怎么办？"></a>3.4 如果已经建立了连接，但客户端突然出现故障了怎么办？</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h3 id="3-5-TCP和UDP的区别"><a href="#3-5-TCP和UDP的区别" class="headerlink" title="3.5 TCP和UDP的区别"></a>3.5 TCP和UDP的区别</h3><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接</td><td>无连接</td></tr><tr><td>可靠性高，利用握手确认和重传机制保证数据不丢失</td><td>可靠性不高，可能会丢失数据</td></tr><tr><td>有序性：利用序列号保证消息包的顺序交互</td><td>无有序性</td></tr><tr><td>需要创建连接，保证消息的可靠性和有序性，导致速度较慢</td><td>无需考虑连接和可靠，速度较快</td></tr><tr><td>消息头20字节，重量级</td><td>消息头只需8字节，轻量级</td></tr></tbody></table><h3 id="3-6-在浏览器地址栏键入URL，按下回车之后经历的流程"><a href="#3-6-在浏览器地址栏键入URL，按下回车之后经历的流程" class="headerlink" title="3.6 在浏览器地址栏键入URL，按下回车之后经历的流程"></a>3.6 在浏览器地址栏键入URL，按下回车之后经历的流程</h3><ol><li><strong>DNS解析</strong>：首先浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名所对应的IP地址。DNS缓存从近到远依次是：浏览器缓存→系统缓存→路由器缓存→IPS服务器缓存→根域名服务器缓存→顶级域名服务器缓存。找到IP则直接返回，不查询后续缓存。</li><li><strong>TCP连接</strong>：根据IP地址和默认端口(80)来和服务器建立TCP连接(三次握手)。</li><li><strong>发送HTTP请求</strong>：浏览器发出读取文件的HTTP请求，该请求将发送给服务器。</li><li><strong>服务器处理请求并返回HTTP报文</strong>：服务器对浏览器请求作出响应，并把对应的带有HTML文本的HTTP响应报文发送给浏览器。</li><li><strong>浏览器解析渲染页面</strong>：浏览器接收到HTML，并在显示窗口内渲染它。</li><li><strong>连接结束</strong>：浏览器释放TCP连接(四次挥手)。</li></ol><h3 id="3-7-说说常见的HTTP状态码"><a href="#3-7-说说常见的HTTP状态码" class="headerlink" title="3.7 说说常见的HTTP状态码"></a>3.7 说说常见的HTTP状态码</h3><ul><li><p><strong>200 OK：</strong>正常返回信息</p></li><li><p><strong>400 Bad Request：</strong>客户端请求有语法错误，不能被服务器所理解</p></li><li><p><strong>401 Unauthorized：</strong>请求未经授权，这个状态码必须和<code>WWW-Authenticate</code>报头域一起使用</p></li><li><p><strong>403 Forbidden：</strong>服务器收到请求，但是拒绝提供服务</p></li><li><p><strong>404 Not Found：</strong>请求资源不存在，eg：输入了错误的URL</p></li><li><p><strong>500 Internal Server Error：</strong>服务器发生不可预期的错误</p></li><li><p><strong>501 Server Unavailable：</strong>服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p></li></ul><h3 id="3-8-GET请求和POST请求的区别"><a href="#3-8-GET请求和POST请求的区别" class="headerlink" title="3.8 GET请求和POST请求的区别"></a>3.8 GET请求和POST请求的区别</h3><p>从以下几个层面来解答</p><ul><li>Http报文层面：GET将请求信息放在URL后面，请求信息与URL以？隔开，请求信息的格式为键值对；POST将请求信息放在报文体中，获取请求信息必须解析报文，因此安全性较GET要高一些。 </li><li>长度方面：GET请求信息放在URL后面，浏览器会限制URL长度，故GET请求长度有限；POST请求消息放在报文体中，所以长度没有限制。</li><li>数据库层面：GET符合幂等性(对数据库的一次操作和多次操作的结果是一致的)和安全性(对数据库的操作没有改变数据库中的数据)，POST不符合。</li><li>其他层面：GET可以被缓存、被存储，可以保存在浏览器的浏览记录中，而POST不行。</li></ul><h3 id="3-9-Cookie和Session的区别"><a href="#3-9-Cookie和Session的区别" class="headerlink" title="3.9 Cookie和Session的区别"></a>3.9 Cookie和Session的区别</h3><h4 id="3-9-1-Cookie简介"><a href="#3-9-1-Cookie简介" class="headerlink" title="3.9.1 Cookie简介"></a>3.9.1 Cookie简介</h4><ul><li>是由服务器发送给客户端的特殊信息，以文本的形式存放在客户端</li><li>客户端再次请求时，会把Cookie放在请求头中回发，每一次请求都会带上所有Cookie，过多会造成网络压力</li><li>服务器接收到后，会解析Cookie生成与客户端相对应的内容(记住密码功能)</li><li>Cookie的设置及发送过程如下图：</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/08/02/cookie-1564755310096.jpg" alt="cookie"></p><h4 id="3-9-2-Session简介"><a href="#3-9-2-Session简介" class="headerlink" title="3.9.2 Session简介"></a>3.9.2 Session简介</h4><ul><li>服务器端的机制，在服务器上保存的信息</li><li>解析客户端请求并操作<code>session id</code>，按需保存状态信息。当服务器需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否包含的session标识(<code>即session id</code>)，如果已包含<code>session id</code>，则说明以前已经为此客户端创建过session了，服务器就根据这个<code>session id</code>把session检索出来使用。如果检索不到，会新建一个。如果客户端不包含<code>session id</code>，则会为此客户端创建一个session，并创建一个与此session相关的<code>session id</code>，这个id会在本次请求中回发给客户端进行保存。</li></ul><h4 id="3-9-3-三点主要区别"><a href="#3-9-3-三点主要区别" class="headerlink" title="3.9.3 三点主要区别"></a>3.9.3 三点主要区别</h4><ul><li>Cookie数据存放在客户的浏览器上，Session数据放在服务器上</li><li>Session相对于Cookie更安全</li><li>因Session存放在服务器端，大量存放会造成服务器负担，如考虑到减轻服务器负担，应当使用Cookie。</li><li>Cookie的大量使用会造成网络压力，因为每一次请求都会携带所有的Cookie数据。</li></ul><h3 id="3-10-HTTP和HTTPS的区别"><a href="#3-10-HTTP和HTTPS的区别" class="headerlink" title="3.10 HTTP和HTTPS的区别"></a>3.10 HTTP和HTTPS的区别</h3><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP传输协议。</p><ul><li>SSL（Security Sockets Layer，安全套接层）<ul><li>为网络通信提供安全及数据完整性的一种安全协议</li><li>是操作系统对外的API，SSL3.0后更名为TLS</li><li>采用身份验证和数据加密保证网络通信的安全和数据的完整性</li></ul></li></ul><h4 id="3-10-1-主要区别如下"><a href="#3-10-1-主要区别如下" class="headerlink" title="3.10.1 主要区别如下"></a>3.10.1 主要区别如下</h4><ul><li>HTTPS需到CA申请证书，HTTP不需要</li><li>HTTPS密文传输，HTTP明文传输</li><li>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口</li><li>HTTPS=HTTP+SSL加密+身份认证+完整性保护，较HTTP安全</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>travel项目开发日志</title>
      <link href="/JavaWeb/travelLog.html"/>
      <url>/JavaWeb/travelLog.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h3><p>黑马旅游网是一个前后端分离的Web项目，后端采用了MVC设计模式。前端通过<code>Ajax</code>来请求后端服务器，获取<code>json</code>数据，然后填充到前端页面，部分不经常变动数据(如导航栏数据)，使用到了<code>redis</code>来做数据缓存以减少对数据库的访问。</p><a id="more"></a><h3 id="2-项目进度"><a href="#2-项目进度" class="headerlink" title="2. 项目进度"></a>2. 项目进度</h3><p>截止7月28日，目前已完成的模块为：</p><ol><li>登录注册</li><li>国内游功能及其内附加功能，如查看详情，收藏等。</li><li>线路搜索功能</li></ol><p>待完成功能：</p><ol><li>首页数据展示功能，包括人气旅游，最新旅游等。</li><li>导航栏功能的添加</li><li>我的收藏功能</li><li>热门推荐</li><li>前端部分样式修改</li><li>记住密码功能</li><li>收藏排行榜</li><li>整体细节方面，如登录后登录按钮消失等。</li></ol><h3 id="3-项目展示"><a href="#3-项目展示" class="headerlink" title="3. 项目展示"></a>3. 项目展示</h3><p><a href="http://www.luoxiansen.cn/travel/index.html" target="_blank" rel="noopener">旅游网项目</a></p><blockquote><p>无法访问多刷新几次试试</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅游网项目03</title>
      <link href="/JavaWeb/travel-project03.html"/>
      <url>/JavaWeb/travel-project03.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今日内容为旅游网项目的旅游线路名称查询，详情页展示，线路收藏功能。</p><a id="more"></a><h2 id="1-旅游线路名称查询功能"><a href="#1-旅游线路名称查询功能" class="headerlink" title="1. 旅游线路名称查询功能"></a>1. 旅游线路名称查询功能</h2><h3 id="1-1-查询参数的传递"><a href="#1-1-查询参数的传递" class="headerlink" title="1.1 查询参数的传递"></a>1.1 查询参数的传递</h3><p>在<code>header.html</code>中添加如下js</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&#x2F;&#x2F; 给搜索按钮绑定单击事件，获取搜索输入框的内容$(&quot;#search_btn&quot;).click(function () {    &#x2F;&#x2F; 用户输入的线路名称    var rname = $(&quot;#search_input&quot;).val();    var cid = getParameter(&quot;cid&quot;);    &#x2F;&#x2F; 跳转路径  http:&#x2F;&#x2F;localhost&#x2F;travel&#x2F;route_list.html?cid=5, 拼接上rname=xxx    location.href = &quot;http:&#x2F;&#x2F;localhost&#x2F;travel&#x2F;route_list.html?cid=&quot;+cid+&quot;&amp;rname=&quot;+rname;});</code></pre><p>在<code>route_list.html</code>中添加代码</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">$(function () {    &#x2F;&#x2F; 获取cid的参数值    var cid = getParameter(&quot;cid&quot;);    &#x2F;&#x2F; 获取rname的参数值    var rname = getParameter(&quot;rname&quot;);    &#x2F;&#x2F; 判断rname不为null    if (rname){        &#x2F;&#x2F; url 解码        rname = window.decodeURIComponent(rname);    }});</code></pre><h3 id="1-2-后台代码修改"><a href="#1-2-后台代码修改" class="headerlink" title="1.2 后台代码修改"></a>1.2 后台代码修改</h3><p>主要就是重构查询总记录数方法和查询当前页数据集合方法，添加一个模糊查询的参数<code>rname</code></p><p>设计到重构的模块及方法：</p><ol><li><code>RouteServlet</code>部分代修改及添加</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 添加以下代码&#x2F;&#x2F; 接受rname 参数String rname = request.getParameter(&quot;rname&quot;); rname = new String(rname.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); &#x2F;&#x2F; 重新编码rnmae，解决get请求乱码问题&#x2F;&#x2F; 修改查询方法，添加rname参数&#x2F;&#x2F; 3. 调用service查询PageBean对象PageBean&lt;Route&gt; pb = routeService.pageQuery(cid, currentPage, pageSize,rname);</code></pre><ol start="2"><li><code>RouteServiceImpl</code>代码修改</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 添加rname参数public PageBean&lt;Route&gt; pageQuery(int cid, int currentPage, int pageSize, String rname) {}&#x2F;&#x2F; 以下方法均添加rname参数int totalCount = routeDao.findTotalCount(cid,rname);List&lt;Route&gt; list = routeDao.findByPage(cid, start, pageSize,rname);</code></pre><ol start="3"><li><code>RouteDaoImpl</code>代码修改</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Overridepublic int findTotalCount(int cid, String rname) {    &#x2F;&#x2F; String sql = &quot;select count(*) from tab_route where cid = ?&quot;;    &#x2F;&#x2F; 1. 定义sql模板,拼接sql时注意空格    String sql = &quot;select count(*) from tab_route where 1 = 1 &quot;;    StringBuilder sb = new StringBuilder(sql);    List params = new ArrayList(); &#x2F;&#x2F; 条件参数    &#x2F;&#x2F; 2. 判断参数是否有值    if (cid != 0){        sb.append(&quot; and cid = ? &quot;);        params.add(cid); &#x2F;&#x2F; 添加？对应值    }    if (rname != null &amp;&amp; rname.length() &gt; 0){        sb.append(&quot; and rname like ? &quot;);        params.add(&quot;%&quot;+rname+&quot;%&quot;);    }    sql = sb.toString(); &#x2F;&#x2F; 转换为字符串    return template.queryForObject(sql,Integer.class,params.toArray()); &#x2F;&#x2F; params.toArray() 集合转换为数组}@Overridepublic List&lt;Route&gt; findByPage(int cid, int start, int pageSize, String rname) {    &#x2F;&#x2F; String sql = &quot;select * from tab_route where cid = ? limit ? , ?&quot;;    &#x2F;&#x2F; 1. 定义sql模板    String sql = &quot;select * from tab_route where 1 = 1 &quot;;    StringBuilder sb = new StringBuilder(sql);    List params = new ArrayList(); &#x2F;&#x2F; 条件参数集合    &#x2F;&#x2F; 2. 判断参数是否有值    if (cid != 0){        sb.append(&quot; and cid = ? &quot;);        params.add(cid); &#x2F;&#x2F; 添加？对应值    }    if (rname != null &amp;&amp; rname.length() &gt; 0){        sb.append(&quot; and rname like ? &quot;);        params.add(&quot;%&quot;+rname+&quot;%&quot;);    }    sb.append(&quot; limit ? , ? &quot;); &#x2F;&#x2F; 分页条件限制    sql = sb.toString();    &#x2F;&#x2F; 加入分页条件参数    params.add(start);    params.add(pageSize);    return template.query(sql,new BeanPropertyRowMapper&lt;Route&gt;(Route.class),params.toArray());}</code></pre><h3 id="1-3-前台代码修改"><a href="#1-3-前台代码修改" class="headerlink" title="1.3 前台代码修改"></a>1.3 前台代码修改</h3><p>主要将<code>rname</code>参数添加入<code>load</code>方法中，并且修改所有的跳转页面标签，加上<code>rname</code>参数。</p><blockquote><p>注意在标签处添加<code>rname</code>参数时，该参数是一个字符串，故需使用“\”进行转义。</p></blockquote><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;        $(function () {            &#x2F;&#x2F; var search = location.search;            &#x2F;&#x2F; &#x2F;&#x2F; alert(search);            &#x2F;&#x2F; &#x2F;&#x2F; 切割字符串，拿到第二个值            &#x2F;&#x2F; var cid = search.split(&quot;=&quot;)[1];            &#x2F;&#x2F; 获取cid的参数值            var cid = getParameter(&quot;cid&quot;);            &#x2F;&#x2F; 获取rname的参数值            var rname = getParameter(&quot;rname&quot;);            &#x2F;&#x2F; 判断rname不为null            if (rname){                &#x2F;&#x2F; url 解码                rname = window.decodeURIComponent(rname);            }            &#x2F;&#x2F; 当页码加载完毕后，调用load方法，            load(cid,null,rname);        })    function load(cid, currentPage,rname) {    &#x2F;&#x2F; 发送ajax请求，请求route&#x2F;pageQuery，传递cid    $.get(&quot;route&#x2F;pageQuery&quot;,{cid:cid,currentPage:currentPage,rname:rname},function (pb) {        &#x2F;&#x2F; 解析PageBean数据，展示到页面上        &#x2F;&#x2F; 1. 分页工具条数据展示        &#x2F;&#x2F; 1.1 展示总页码和总记录数        $(&quot;#totalPage&quot;).html(pb.totalPage);        $(&quot;#totalCount&quot;).html(pb.totalCount);        var lis = &quot;&quot;;        var fristPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,1,\&#39;&#39;+rname+&#39;\&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        &#x2F;&#x2F; 计算上一页的页码        var beforeNum = pb.currentPage - 1;        if (beforeNum &lt;= 0){            beforeNum = 1;        }        var beforePage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+beforeNum+&#39;,\&#39;&#39;+rname+&#39;\&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;上一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        lis += fristPage;        lis += beforePage;        &#x2F;&#x2F; 1.2 展示分页页码        &#x2F;*                    仿百度分页样式：前五后四                    1. 一共展示10个页码，能够达到前5后4的效果                    2. 如果前边不足5个，后边补齐10个                    3. 如果后边不足4个，前边补齐10个                 *&#x2F;        &#x2F;&#x2F; 定义开始位置begin和结束位置end        var begin; &#x2F;&#x2F; 开始位置        var end; &#x2F;&#x2F; 结束位置        &#x2F;&#x2F; 1. 显示10个页码        if(pb.totalPage &lt; 10){            &#x2F;&#x2F; 总页码不足10页            begin = 1;            end = pb.totalPage;        }else{            &#x2F;&#x2F; 总页码超过10页            &#x2F;&#x2F; 实现前5后4效果            begin = pb.currentPage - 5;            end = pb.currentPage + 4;            &#x2F;&#x2F; 进行数据修正            &#x2F;&#x2F; 2. 如果前边不够5个，后边补齐10个            if (begin &lt; 1){                begin = 1;                end = begin + 9;            }            &#x2F;&#x2F; 3. 如果后边不足4个，前边补齐10个            if (end &gt; pb.totalPage){                end = pb.totalPage;                begin = end - 9;            }        }        for (var i = begin; i &lt;= end; i++) {            var li;            &#x2F;&#x2F; 判断当前页码是否等于i            if (pb.currentPage == i){                li = &#39;&lt;li class=&quot;curPage&quot; onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;,\&#39;&#39;+rname+&#39;\&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;            }else{                &#x2F;&#x2F; 创建页码的li                li = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;,\&#39;&#39;+rname+&#39;\&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;            }            &#x2F;&#x2F; 拼接进字符串            lis += li;        }                &#x2F;&#x2F; 计算下一页页码        var nextNum = pb.currentPage + 1;        if(nextNum &gt;= pb.totalPage){            nextNum = pb.totalPage;        }        var nextPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+nextNum+&#39;,\&#39;&#39;+rname+&#39;\&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;下一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        var lastPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+pb.totalPage+&#39;,\&#39;&#39;+rname+&#39;\&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;末页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        lis += nextPage;        lis += lastPage;        &#x2F;&#x2F; 将lis内容设置到ul中        $(&quot;#pageNum&quot;).html(lis);        &#x2F;&#x2F; 2. 列表数据展示        var route_lis = &quot;&quot;;        for (var i = 0; i &lt; pb.list.length; i++) {            &#x2F;&#x2F; 获取数据 {rid&quot;: 1,&quot;rname&quot;: &quot;xxx&quot;,&quot;price&quot;: 999.0,xxxx}            var route = pb.list[i];            var li = &#39;&lt;li&gt;\n&#39; +                &#39;                &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;&#39;+route.rimage+&#39;&quot; style=&quot;width: 299px&quot;&gt;&lt;&#x2F;div&gt;\n&#39; +                &#39;                    &lt;div class=&quot;text1&quot;&gt;\n&#39; +                &#39;                    &lt;p&gt;&#39;+route.rname+&#39;&lt;&#x2F;p&gt;\n&#39; +                &#39;                    &lt;br&#x2F;&gt;\n&#39; +                &#39;                    &lt;p&gt;&#39;+route.routeIntroduce+&#39;&lt;&#x2F;p&gt;\n&#39; +                &#39;                &lt;&#x2F;div&gt;\n&#39; +                &#39;                &lt;div class=&quot;price&quot;&gt;\n&#39; +                &#39;                    &lt;p class=&quot;price_num&quot;&gt;\n&#39; +                &#39;                    &lt;span&gt;&amp;yen;&lt;&#x2F;span&gt;\n&#39; +                &#39;                &lt;span&gt;&#39;+route.price+&#39;&lt;&#x2F;span&gt;\n&#39; +                &#39;                &lt;span&gt;起&lt;&#x2F;span&gt;\n&#39; +                &#39;                &lt;&#x2F;p&gt;\n&#39; +                &#39;                &lt;p&gt;&lt;a href=&quot;route_detail.html&quot;&gt;查看详情&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;\n&#39; +                &#39;                &lt;&#x2F;div&gt;\n&#39; +                &#39;             &lt;&#x2F;li&gt;&#39;;            route_lis += li;        }        $(&quot;#route&quot;).html(route_lis);        &#x2F;&#x2F; 每次点击翻页后，定位到页面顶部        window.scrollTo(0,0);    });}&lt;&#x2F;script&gt;</code></pre><p>​    </p><h2 id="2-旅游线路的详情展示"><a href="#2-旅游线路的详情展示" class="headerlink" title="2. 旅游线路的详情展示"></a>2. 旅游线路的详情展示</h2><h3 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h3><p><img src="D:\资料\Java\img\route_info.jpg" alt="route_info"></p><p><img src="D:\资料\Java\img\route_info2.jpg" alt="route_info2"></p><h3 id="2-2-后台代码实现"><a href="#2-2-后台代码实现" class="headerlink" title="2.2 后台代码实现"></a>2.2 后台代码实现</h3><ul><li>在<code>RouteServlet</code>中创建一个<code>findOne</code>方法，查询<code>route</code>对象并返回给客户端</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * @Description: 根据id查询一个旅游线路的详细信息 * @Author: zero * @param request * @param response * @return void * @Date 2019&#x2F;7&#x2F;26 20:56 *&#x2F;public void findOne(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    &#x2F;&#x2F; 1. 接收id    String rid = request.getParameter(&quot;rid&quot;);    &#x2F;&#x2F; 2. 调用service查询route对象    Route route = routeService.findOne(Integer.parseInt(rid));    &#x2F;&#x2F; 3. 转为json返回客户端    writeValue(route,response);}</code></pre><ul><li>在<code>RouteServiceImpl</code>中新建<code>findOne</code>方法，根据<code>rid</code>查询三表数据，封装进<code>route</code>对象</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * @Description: 根据rid查询三个表数据，封装进route对象 * @Author: zero * @param rid * @return 封装好的route对象 * @Date 2019&#x2F;7&#x2F;26 21:16 *&#x2F;@Overridepublic Route findOne(int rid) {    &#x2F;&#x2F; 1. 根据id查询route对象 routeDao    Route route = routeDao.findOne(rid);    &#x2F;&#x2F; 2. 根据rid线路id查询tab_route_img，将集合设置到route对象中    List&lt;RouteImg&gt; img = routeImgDao.findImg(rid);    &#x2F;&#x2F; 2.1 将img集合设置到route对象中    route.setRouteImgList(img);    &#x2F;&#x2F; 3. 根据sid卖家id查询tab_seller查询卖家信息，设置到route对象中    Seller seller = sellerDao.findSeller(route.getSid());    &#x2F;&#x2F; 3.1 设置到route对象中    route.setSeller(seller);    return route;}</code></pre><ul><li>修改<code>RouteDao</code>层，添加<code>findOne</code>方法，新建两个Dao及其对应实现类，分别是<code>RouteImgDao</code>和<code>SellerDao</code>，查询图片信息和卖家信息。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; RouteDaoImpl&#x2F;** * 根据id查询 * @param rid * @return *&#x2F;@Overridepublic Route findOne(int rid) {    return template.queryForObject(&quot;select * from tab_route where rid = ?&quot;,                                   new BeanPropertyRowMapper&lt;Route&gt;(Route.class),rid);}&#x2F;&#x2F; RouteImgDaoImpl&#x2F;** * 根据rid查询图片信息 * @param rid * @return *&#x2F;@Overridepublic List&lt;RouteImg&gt; findImg(int rid) {    return template.query(&quot;select * from tab_route_img where rid = ?&quot;,                          new BeanPropertyRowMapper&lt;RouteImg&gt;(RouteImg.class),rid);}&#x2F;&#x2F; SellerDaoImpl&#x2F;** * 根据sid查询卖家信息 * @param sid * @return *&#x2F;@Overridepublic Seller findSeller(int sid) {    return template.queryForObject(&quot;select * from tab_seller where sid = ?&quot;,                                   new BeanPropertyRowMapper&lt;Seller&gt;(Seller.class),sid);}</code></pre><h3 id="2-3-前台代码实现"><a href="#2-3-前台代码实现" class="headerlink" title="2.3 前台代码实现"></a>2.3 前台代码实现</h3><p>在<code>Route_detail.html</code>中加载后获取rid，然后发送ajax请求，获取route对象，解析对象数据，填充入html中</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;$(document).ready(function() {    goImg();});function goImg() {    &#x2F;&#x2F;焦点图效果    &#x2F;&#x2F;点击图片切换图片    $(&#39;.little_img&#39;).on(&#39;mousemove&#39;, function() {        $(&#39;.little_img&#39;).removeClass(&#39;cur_img&#39;);        var big_pic = $(this).data(&#39;bigpic&#39;);        $(&#39;.big_img&#39;).attr(&#39;src&#39;, big_pic);        $(this).addClass(&#39;cur_img&#39;);    });    &#x2F;&#x2F;上下切换    var picindex = 0;    var nextindex = 4;    $(&#39;.down_img&#39;).on(&#39;click&#39;,function(){        var num = $(&#39;.little_img&#39;).length;        if((nextindex + 1) &lt;= num){            $(&#39;.little_img:eq(&#39;+picindex+&#39;)&#39;).hide();            $(&#39;.little_img:eq(&#39;+nextindex+&#39;)&#39;).show();            picindex = picindex + 1;            nextindex = nextindex + 1;        }    });    $(&#39;.up_img&#39;).on(&#39;click&#39;,function(){        var num = $(&#39;.little_img&#39;).length;        if(picindex &gt; 0){            $(&#39;.little_img:eq(&#39;+(nextindex-1)+&#39;)&#39;).hide();            $(&#39;.little_img:eq(&#39;+(picindex-1)+&#39;)&#39;).show();            picindex = picindex - 1;            nextindex = nextindex - 1;        }    });    &#x2F;&#x2F;自动播放    &#x2F;&#x2F; var timer = setInterval(&quot;auto_play()&quot;, 5000);}&#x2F;&#x2F;自动轮播方法function auto_play() {    var cur_index = $(&#39;.prosum_left dd&#39;).find(&#39;a.cur_img&#39;).index();    cur_index = cur_index - 1;    var num = $(&#39;.little_img&#39;).length;    var max_index = 3;    if ((num - 1) &lt; 3) {        max_index = num - 1;    }    if (cur_index &lt; max_index) {        var next_index = cur_index + 1;        var big_pic = $(&#39;.little_img:eq(&#39; + next_index + &#39;)&#39;).data(&#39;bigpic&#39;);        $(&#39;.little_img&#39;).removeClass(&#39;cur_img&#39;);        $(&#39;.little_img:eq(&#39; + next_index + &#39;)&#39;).addClass(&#39;cur_img&#39;);        $(&#39;.big_img&#39;).attr(&#39;src&#39;, big_pic);    } else {        var big_pic = $(&#39;.little_img:eq(0)&#39;).data(&#39;bigpic&#39;);        $(&#39;.little_img&#39;).removeClass(&#39;cur_img&#39;);        $(&#39;.little_img:eq(0)&#39;).addClass(&#39;cur_img&#39;);        $(&#39;.big_img&#39;).attr(&#39;src&#39;, big_pic);    }}$(function () {    &#x2F;&#x2F; 1. 获取id    var rid = getParameter(&quot;rid&quot;);    &#x2F;&#x2F; 2. 发送请求， route&#x2F;findOne    $.get(&quot;route&#x2F;findOne&quot;,{rid:rid},function (route) {        &#x2F;&#x2F; 3. 解析数据填充html        $(&quot;#rname&quot;).html(route.rname);        $(&quot;#routeIntroduce&quot;).html(route.routeIntroduce);        $(&quot;#price&quot;).html(route.price);        $(&quot;#sname&quot;).html(route.seller.sname);        $(&quot;#consphone&quot;).html(route.seller.consphone);        $(&quot;#address&quot;).html(route.seller.address);        &#x2F;&#x2F; 图片展示        var dd_str = &#39;&lt;a class=&quot;up_img up_img_disable&quot;&gt;&lt;&#x2F;a&gt;&#39;;        &#x2F;&#x2F; 遍历routeImgList        for (var i = 0; i &lt; route.routeImgList.length; i++) {            var a_str;            &#x2F;&#x2F; 判断图片是否大于4，将大于4的图片设置为display:none            if (i &gt;= 4) {                a_str = &#39;&lt;a title=&quot;&quot; class=&quot;little_img&quot; data-bigpic=&quot;&#39;+route.routeImgList[i].bigPic+&#39;&quot; style=&quot;display:none;&quot;&gt;\n&#39; +                    &#39;                        &lt;img src=&quot;&#39;+route.routeImgList[i].smallPic+&#39;&quot;&gt;\n&#39; +                    &#39;                    &lt;&#x2F;a&gt;&#39;;            } else {                a_str = &#39;&lt;a title=&quot;&quot; class=&quot;little_img&quot; data-bigpic=&quot;&#39;+route.routeImgList[i].bigPic+&#39;&quot;&gt;\n&#39; +                    &#39;                        &lt;img src=&quot;&#39;+route.routeImgList[i].smallPic+&#39;&quot;&gt;\n&#39; +                    &#39;                    &lt;&#x2F;a&gt;&#39;;            }            dd_str += a_str;        }        dd_str += &#39;&lt;a class=&quot;down_img down_img_disable&quot; style=&quot;margin-bottom: 0;&quot;&gt;&lt;&#x2F;a&gt;&#39;;        $(&quot;#dd&quot;).html(dd_str);        &#x2F;&#x2F; 图片展示和切换代码的调用        goImg();    });});&lt;&#x2F;script&gt;</code></pre><blockquote><p>需注意：在<code>route_list.html</code>中的查看详情URL处修改代码，传递rid值：<code>&lt;p&gt;&lt;a href=&quot;route_detail.html?rid=&#39;+route.rid+&#39;&quot;&gt;查看详情&lt;/a&gt;&lt;/p&gt;\n&#39;</code></p></blockquote><h2 id="3-旅游线路收藏功能"><a href="#3-旅游线路收藏功能" class="headerlink" title="3. 旅游线路收藏功能"></a>3. 旅游线路收藏功能</h2><h3 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h3><ul><li>表结构信息：</li></ul><p><img src="D:\资料\Java\img\table.jpg" alt="table"></p><h4 id="3-1-1-判断当前登录用户是否收藏过该线路"><a href="#3-1-1-判断当前登录用户是否收藏过该线路" class="headerlink" title="3.1.1 判断当前登录用户是否收藏过该线路"></a>3.1.1 判断当前登录用户是否收藏过该线路</h4><p>当页面加载完成后，发送ajax请求，获取用户是否收藏的标记，根据此标记展示不同的按钮样式。</p><p><img src="D:\资料\Java\img\favorite.jpg" alt="favorite"></p><h3 id="3-2-后台代码编写"><a href="#3-2-后台代码编写" class="headerlink" title="3.2 后台代码编写"></a>3.2 后台代码编写</h3><ul><li>修改<code>RouteServlet</code>，添加<code>isFavorite</code>方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * @Description: 根据线路id和用户id，判断用户是否收藏了该线路     * @Author: zero     * @param request     * @param response     * @return void     * @Date 2019&#x2F;7&#x2F;27 23:11     *&#x2F;public void isFavorite(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    &#x2F;&#x2F; 1. 获取rid，线路id    String rid = request.getParameter(&quot;rid&quot;);    &#x2F;&#x2F; 2. 获取udi，通过当前登录用户对象，session    User user = (User) request.getSession().getAttribute(&quot;user&quot;);    &#x2F;&#x2F; 2.1 如果user对象为null，则表示未登录，设置uid=0    int uid; &#x2F;&#x2F; 用户id    if (user == null){        &#x2F;&#x2F; 用户未登录        uid = 0;    }else{        &#x2F;&#x2F; 用户已登录        uid = user.getUid();    }    &#x2F;&#x2F; 3. 调用FavoriteService查询，传递rid，uid    boolean flag = favoriteService.isFavorite(Integer.parseInt(rid), uid);    &#x2F;&#x2F; 4. 写回客户端flag标记    writeValue(flag,response);}</code></pre><ul><li><code>FavoriteServiceImpl</code>添加<code>isFavorite</code>方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Overridepublic boolean isFavorite(int rid, int uid) {    Favorite favorite = favoriteDao.findFavorite(rid, uid);    return favorite != null ? true : false; &#x2F;&#x2F; 如果对象有值，则表示收藏过了，返回true，反之表示未收藏过返回false。}</code></pre><ul><li><code>FavoriteDaoImpl</code>添加<code>findFavorite</code>方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * @Description: 根据线路id和用户id查询数据     * @Author: zero     * @param rid     * @param uid     * @return 查询到的Favorite对象     * @Date 2019&#x2F;7&#x2F;27 22:34     *&#x2F;@Overridepublic Favorite findFavorite(int rid, int uid) {    Favorite favorite = null;    try{        favorite = template.queryForObject(&quot;select * from tab_favorite where rid = ? and uid = ? &quot;,                                           new BeanPropertyRowMapper&lt;Favorite&gt;(Favorite.class), rid, uid);    }catch (DataAccessException e){        e.printStackTrace();    }    return favorite;}</code></pre><h3 id="3-3-前台代码编写"><a href="#3-3-前台代码编写" class="headerlink" title="3.3 前台代码编写"></a>3.3 前台代码编写</h3><p>在<code>route.detail.html</code>中添加<code>isFavorite</code>的js方法，在页面加载完毕后请求。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">function isFavorite() {    &#x2F;&#x2F; 发送请求，判断用户是否收藏过该线路    var rid = getParameter(&quot;rid&quot;);    $.get(&quot;route&#x2F;isFavorite&quot;,{rid:rid},function (flag) {        if (flag){            &#x2F;&#x2F; 用户已经收藏过了            &#x2F;&#x2F; &lt;a  class=&quot;btn already&quot; disabled=&quot;disabled&quot;&gt;            &#x2F;&#x2F; 设置收藏按钮的样式            $(&quot;#favorite&quot;).addClass(&quot;already&quot;);            $(&quot;#favorite&quot;).attr(&quot;disabled&quot;,&quot;disabled&quot;);            &#x2F;&#x2F; 删除按钮的点击事件            $(&quot;#favorite&quot;).removeAttr(&quot;onclick&quot;);        } else {            &#x2F;&#x2F; 用户没有收藏过        }    });};</code></pre><h3 id="3-4-收藏次数的动态展示"><a href="#3-4-收藏次数的动态展示" class="headerlink" title="3.4 收藏次数的动态展示"></a>3.4 收藏次数的动态展示</h3><p>前台代码：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&#x2F;&#x2F; 设置收藏次数$(&quot;#favoriteNumber&quot;).html(&quot;已收藏&quot;+route.count+&quot;次&quot;);</code></pre><p>后台添加一个查询次数方法即可</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; RouteService, 在加载页面时调用findOne方法，同时将收藏次数也封装进Route对象中&#x2F;&#x2F; 4. 查询收藏次数int count = favoriteDao.findFavoriteCount(route.getRid());route.setCount(count);&#x2F;&#x2F; FavoriteDao&#x2F;** * @Description: 根据rid查询收藏次数 * @Author: zero * @param rid * @return 收藏次数 * @Date 2019&#x2F;7&#x2F;27 23:20 *&#x2F;@Overridepublic int findFavoriteCount(int rid) {    return template.queryForObject(&quot;select count(*) from tab_favorite where rid = ?&quot;, Integer.class,rid);}</code></pre><h3 id="3-5-点击按钮收藏线路"><a href="#3-5-点击按钮收藏线路" class="headerlink" title="3.5 点击按钮收藏线路"></a>3.5 点击按钮收藏线路</h3><h4 id="3-5-1-分析"><a href="#3-5-1-分析" class="headerlink" title="3.5.1 分析"></a>3.5.1 分析</h4><p><img src="D:\资料\Java\img\clickFavorite.jpg" alt="clickFavorite"></p><h4 id="3-5-2-代码实现"><a href="#3-5-2-代码实现" class="headerlink" title="3.5.2 代码实现"></a>3.5.2 代码实现</h4><ul><li>前台代码</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&#x2F;&#x2F; 点击收藏按钮触发的方法function addFavorite() {    var rid = getParameter(&quot;rid&quot;);    &#x2F;&#x2F; 1. 判断用户是否登录    $.get(&quot;user&#x2F;findOne&quot;,{},function (user) {        if (user){            &#x2F;&#x2F; 用户登录了            &#x2F;&#x2F; 调用添加功能            $.get(&quot;route&#x2F;addFavorite&quot;,{rid:rid},function () {});            &#x2F;&#x2F; 刷新页面            location.reload();        } else{            &#x2F;&#x2F; 用户未登录            alert(&quot;您未登录，请登录&quot;);            location.href = &quot;http:&#x2F;&#x2F;localhost&#x2F;travel&#x2F;login.html&quot;;        }    });};</code></pre><ul><li>后台代码，在<code>RouteServlet</code>中添加<code>addFavorite</code>方法</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * @Description: 添加收藏功能     * @Author: zero     * @param request     * @param response     * @return void     * @Date 2019&#x2F;7&#x2F;27 23:46     *&#x2F;public void addFavorite(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    &#x2F;&#x2F; 1. 获取线路id rid    String rid = request.getParameter(&quot;rid&quot;);    &#x2F;&#x2F; 2. 获取用户对象 uid    User user = (User) request.getSession().getAttribute(&quot;user&quot;);    int uid; &#x2F;&#x2F; 用户id    if (user == null){        &#x2F;&#x2F; 用户未登录        return;    }else{        &#x2F;&#x2F; 用户已登录        uid = user.getUid();    }    &#x2F;&#x2F; 3. 调用service添加    favoriteService.add(Integer.parseInt(rid), uid);}</code></pre><ul><li><p>在<code>FavoriteServiceImpl</code>中添加<code>add</code>方法</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  @Override  public void add(int rid, int uid) {      favoriteDao.add(rid,uid);  }</code></pre></li></ul><ul><li><p>在<code>FavoriteDaoImpl</code>中添加<code>add</code>方法</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;**       * @Description: 添加收藏功能       * @Author: zero       * @param rid       * @param uid       * @return void       * @Date 2019&#x2F;7&#x2F;27 23:54       *&#x2F;  @Override  public void add(int rid, int uid) {      template.update(&quot;insert into tab_favorite values(?,?,?)&quot;,rid,new Date(),uid);  }</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅游网项目02</title>
      <link href="/JavaWeb/travel-project02.html"/>
      <url>/JavaWeb/travel-project02.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>旅游网项目，今日内容主要为优化Servlet、分类数据查询和分页查询。</p><a id="more"></a><h2 id="2-优化Servlet"><a href="#2-优化Servlet" class="headerlink" title="2. 优化Servlet"></a>2. 优化<code>Servlet</code></h2><h3 id="2-1-目的"><a href="#2-1-目的" class="headerlink" title="2.1 目的"></a>2.1 目的</h3><p>为了减少Servlet的数量，现在是一个功能一个Servlet，将其优化为相同功能的Servlet为一个模块。相当于在数据库中一张表对应一个Servlet，在Servlet中提供不同的方法，完成用户的请求。</p><h3 id="2-2-BaseServlet编写"><a href="#2-2-BaseServlet编写" class="headerlink" title="2.2 BaseServlet编写"></a>2.2 <code>BaseServlet</code>编写</h3><p>主要进行方法的分发，利用反射机制，获取请求路径和方法名称，再获取方法对象然后执行。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;&#x2F;** * 使用反射机制，完成方法的分发 *&#x2F;public class BaseServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println(&quot;baseServlet的service方法被执行&quot;);        &#x2F;&#x2F; 完成方法分发        &#x2F;&#x2F; 1. 获取请求路径        String uri = req.getRequestURI(); &#x2F;&#x2F; uri = &#x2F;travel&#x2F;user&#x2F;add        System.out.println(&quot;请求uri：&quot;+uri);        &#x2F;&#x2F; 2. 获取方法名称        String methodName = uri.substring(uri.lastIndexOf(&#39;&#x2F;&#39;) + 1);&#x2F;&#x2F; 为何+1？        System.out.println(&quot;方法名称&quot;+methodName);        &#x2F;&#x2F; 3. 获取方法对象Method        System.out.println(this); &#x2F;&#x2F; this表示当前调用service的对象，谁调用我我表示谁        try {            &#x2F;&#x2F; 获取方法            Method method = this.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);            &#x2F;&#x2F; 4.执行方法            method.invoke(this,req,resp);        } catch (NoSuchMethodException e) {            e.printStackTrace();        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="2-3-UserServlet改写"><a href="#2-3-UserServlet改写" class="headerlink" title="2.3 UserServlet改写"></a>2.3 <code>UserServlet</code>改写</h3><p>继承自<code>BaseServlet</code>，所有用户相关的方法都抽取在内。只需访问<code>user/对应方法</code>即可完成相应功能。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.web.servlet;import cn.itcast.travel.domain.ResultInfo;import cn.itcast.travel.domain.User;import cn.itcast.travel.service.UserService;import cn.itcast.travel.service.impl.UserServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(&quot;&#x2F;user&#x2F;*&quot;)public class UserServlet extends BaseServlet {    &#x2F;&#x2F; 声明UserService业务对象    private UserService service = new UserServiceImpl();    &#x2F;**     * @Description: 用户注册功能     * @Author: zero     * @param request     * @param response     * @return void     * @Date 2019&#x2F;7&#x2F;23 21:35     *&#x2F;    public void regist(HttpServletRequest request, HttpServletResponse response) throws IOException {        &#x2F;&#x2F; 获取用户输入的验证码        String check = request.getParameter(&quot;check&quot;);        &#x2F;&#x2F; 从session中获取生成的验证码        HttpSession session = request.getSession();        String checkcode_server = (String)session.getAttribute(&quot;CHECKCODE_SERVER&quot;);        session.removeAttribute(&quot;CHECKCODE_SERVER&quot;); &#x2F;&#x2F; 确保验证码只能使用一次        &#x2F;&#x2F; 如果验证码错误，直接注册失败        if (checkcode_server == null || !checkcode_server.equalsIgnoreCase(check)){            &#x2F;&#x2F; 验证码错误            ResultInfo info = new ResultInfo();            &#x2F;&#x2F; 注册失败            info.setFlag(false);            info.setErrorMsg(&quot;验证码错误&quot;);            &#x2F;&#x2F; 将info对象序列化为json            ObjectMapper mapper = new ObjectMapper();            String json = mapper.writeValueAsString(info);            response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);            response.getWriter().write(json);            return; &#x2F;&#x2F; todo:为何return?        }        &#x2F;&#x2F; 验证通过        &#x2F;&#x2F; 1. 获取前台表单数据        Map&lt;String, String[]&gt; map = request.getParameterMap();        &#x2F;&#x2F; 2. 封装为user对象        User user = new User();        try {            BeanUtils.populate(user,map);        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        }        &#x2F;&#x2F; 3. 调用service完成注册        service = new UserServiceImpl();        boolean flag = service.regist(user);        ResultInfo info = new ResultInfo();        &#x2F;&#x2F; 4. 响应结果        if (flag){            &#x2F;&#x2F; 注册成功            info.setFlag(true);        }else{            &#x2F;&#x2F; 注册失败            info.setFlag(false);            info.setErrorMsg(&quot;注册失败！&quot;);        }        &#x2F;&#x2F; 将info对象序列化为json        ObjectMapper mapper = new ObjectMapper();        String json = mapper.writeValueAsString(info);        &#x2F;&#x2F; 将json数据回写客户端        &#x2F;&#x2F; 设置content-type        response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);        response.getWriter().write(json);    }    &#x2F;**     * @Description: 邮箱激活功能     * @Author: zero     * @param request     * @param response     * @return void     * @Date 2019&#x2F;7&#x2F;23 21:36     *&#x2F;    public void active(HttpServletRequest request, HttpServletResponse response) throws IOException {        &#x2F;&#x2F; 1. 获取激活码        String code = request.getParameter(&quot;code&quot;);        if (code != null){            &#x2F;&#x2F; 2. 调用service完成激活            service = new UserServiceImpl();            boolean flag = service.active(code);            &#x2F;&#x2F; 3. 判断标记            String msg = null;            if (flag){                &#x2F;&#x2F; 激活成功                msg = &quot;激活成功，请&lt;a href=&#39;login.html&#39;&gt;登录&lt;&#x2F;a&gt;&quot;;            }else{                &#x2F;&#x2F; 激活失败                msg = &quot;激活失败，请联系管理员！&quot;;            }            &#x2F;&#x2F; 回写数据            response.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;);            response.getWriter().write(msg);        }    }    &#x2F;**     * @Description: 用户登录功能     * @Author: zero     * @param request     * @param response     * @return void     * @Date 2019&#x2F;7&#x2F;23 21:37     *&#x2F;    public void login(HttpServletRequest request, HttpServletResponse response) throws IOException {        &#x2F;&#x2F; 1. 获取用户名和密码        Map&lt;String, String[]&gt; map = request.getParameterMap();        &#x2F;&#x2F; 2. 封装User对象        User user = new User();        try {            BeanUtils.populate(user,map);        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        }        &#x2F;&#x2F; 3. 调用service查询        service = new UserServiceImpl();        User u = service.login(user);        ResultInfo info = new ResultInfo();        &#x2F;&#x2F; 4. 判断用户对象是否为null        if (u == null){            &#x2F;&#x2F; 用户名或密码错误            info.setFlag(false);            info.setErrorMsg(&quot;用户名或密码错误&quot;);        }        &#x2F;&#x2F; 5. 判断用户账户是否激活        if (u != null &amp;&amp; !&quot;Y&quot;.equals(u.getStatus())){            &#x2F;&#x2F; 用户未激活            info.setFlag(false);            info.setErrorMsg(&quot;您的账户尚未激活，请激活&quot;);        }        &#x2F;&#x2F; 6. 判断登录成功        if (u != null &amp;&amp; &quot;Y&quot;.equals(u.getStatus())){            &#x2F;&#x2F; 登录成功            info.setFlag(true);            &#x2F;&#x2F; 将登陆用户信息存入session中            request.getSession().setAttribute(&quot;user&quot;,u);        }        &#x2F;&#x2F; 响应数据        ObjectMapper mapper = new ObjectMapper();        response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);        mapper.writeValue(response.getOutputStream(),info);    }    &#x2F;**     * @Description: 查询单个用户，前台显示登录用户功能     * @Author: zero     * @param request     * @param response     * @return void     * @Date 2019&#x2F;7&#x2F;23 21:38     *&#x2F;    public void findOne(HttpServletRequest request, HttpServletResponse response) throws IOException {        &#x2F;&#x2F; 从session中获取登录用户        Object user = request.getSession().getAttribute(&quot;user&quot;);        &#x2F;&#x2F; 将user回写客户端        ObjectMapper mapper = new ObjectMapper();        response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);        mapper.writeValue(response.getOutputStream(),user);    }    &#x2F;**     * @Description: 用户退出功能     * @Author: zero     * @param request     * @param response     * @return void     * @Date 2019&#x2F;7&#x2F;23 21:38     *&#x2F;    public void exit(HttpServletRequest request, HttpServletResponse response) throws IOException {        &#x2F;&#x2F; 1. 销毁session        request.getSession().invalidate();        &#x2F;&#x2F; 2. 跳转到登录页面        response.sendRedirect(request.getContextPath()+&quot;&#x2F;login.html&quot;);    }}</code></pre><h3 id="2-4-页面路径改写"><a href="#2-4-页面路径改写" class="headerlink" title="2.4 页面路径改写"></a>2.4 页面路径改写</h3><p>将所有用户相关的请求路径改为<code>user/对应方法</code>。例登录路径：<code>user/login</code></p><p>激活功能URL：<code>String content = &quot;&lt;a href=&#39;http://localhost/travel/user/active?code=&quot;+user.getCode()+&quot;&#39;&gt;点击激活账户&lt;/a&gt;&quot;;</code></p><h2 id="3-分类数据展示"><a href="#3-分类数据展示" class="headerlink" title="3. 分类数据展示"></a>3. 分类数据展示</h2><h3 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/25/1.%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2-1564023806439.bmp" alt="title"></p><h3 id="3-2-后台代码实现"><a href="#3-2-后台代码实现" class="headerlink" title="3.2 后台代码实现"></a>3.2 后台代码实现</h3><h4 id="3-2-1-CategoryServlet代码"><a href="#3-2-1-CategoryServlet代码" class="headerlink" title="3.2.1 CategoryServlet代码"></a>3.2.1 <code>CategoryServlet</code>代码</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.web.servlet;import cn.itcast.travel.domain.Category;import cn.itcast.travel.service.CategoryService;import cn.itcast.travel.service.impl.CategoryServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;&#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;23 22:51 * Modified By: *&#x2F;@WebServlet(&quot;&#x2F;category&#x2F;*&quot;)public class CategoryServlet extends BaseServlet {    private CategoryService service = new CategoryServiceImpl();    &#x2F;**     * @Description:查询所有     * @Author: zero     * @param request     * @param response     * @return void     * @Date 2019&#x2F;7&#x2F;23 22:52     *&#x2F;    public void findAll(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 1. 调用servvice查询所有        List&lt;Category&gt; categories = service.findAll();        &#x2F;&#x2F; 2. 序列化为json返回        writeValue(categories,response);    }}</code></pre><h4 id="3-2-2-CategoryService代码"><a href="#3-2-2-CategoryService代码" class="headerlink" title="3.2.2 CategoryService代码"></a>3.2.2 <code>CategoryService</code>代码</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.service.impl;import cn.itcast.travel.dao.CategoryDao;import cn.itcast.travel.dao.impl.CategoryDaoImpl;import cn.itcast.travel.domain.Category;import cn.itcast.travel.service.CategoryService;import java.util.List;&#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;23 22:49 * Modified By: *&#x2F;public class CategoryServiceImpl implements CategoryService {    private CategoryDao categoryDao = new CategoryDaoImpl();    @Override    public List&lt;Category&gt; findAll() {        return categoryDao.findAll();    }}</code></pre><h4 id="3-2-3-CategoryDao代码"><a href="#3-2-3-CategoryDao代码" class="headerlink" title="3.2.3 CategoryDao代码"></a>3.2.3 <code>CategoryDao</code>代码</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.dao;import cn.itcast.travel.domain.Category;import java.util.List;&#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;23 22:42 * Modified By: *&#x2F;public interface CategoryDao {    &#x2F;**     * @Description: 查询所有     * @Author: zero     * @param     * @return List集合     * @Date 2019&#x2F;7&#x2F;23 22:44     *&#x2F;    List&lt;Category&gt; findAll();}</code></pre><h4 id="3-2-4-优化部分代码"><a href="#3-2-4-优化部分代码" class="headerlink" title="3.2.4 优化部分代码"></a>3.2.4 优化部分代码</h4><p>将序列化<code>json</code>方法封装在<code>BaseServlet</code>，减少代码冗余</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * @Description: 直接将传入的对象序列化为json，并且写回客户端     * @Author: zero     * @param obj     * @param response     * @return void     * @Date 2019&#x2F;7&#x2F;23 23:16     *&#x2F;public void writeValue(Object obj,HttpServletResponse response) throws IOException{    ObjectMapper mapper = new ObjectMapper();    response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);    mapper.writeValue(response.getOutputStream(),obj);}&#x2F;**     * @Description: 将传入的对象序列化为json后返回     * @Author: zero     * @param obj     * @return String     * @Date 2019&#x2F;7&#x2F;23 23:18     *&#x2F;public String writeValueAsString(Object obj) throws JsonProcessingException {    return new ObjectMapper().writeValueAsString(obj);}</code></pre><h3 id="3-3-前台代码实现"><a href="#3-3-前台代码实现" class="headerlink" title="3.3 前台代码实现"></a>3.3 前台代码实现</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&#x2F;&#x2F; 查询分类数据$.get(&quot;category&#x2F;findAll&quot;,{},function (data) {    &#x2F;&#x2F; [{cid:1,cname:xxx},{cid:2,cname:xxx},]    var lis = &#39;&lt;li class=&quot;nav-active&quot;&gt;&lt;a href=&quot;index.html&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;    &#x2F;&#x2F; 遍历数组，拼接字符串（&lt;li&gt;）    for (var i = 0; i &lt; data.length; i++) {        var li = &#39;&lt;li&gt;&lt;a href=&quot;route_list.html&quot;&gt;&#39;+data[i].cname+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        lis += li;    }    &#x2F;&#x2F; 拼接收藏排行榜的li，&lt;li&gt;&lt;a href=&quot;favoriterank.html&quot;&gt; 收藏排行榜&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;    lis+=&#39;&lt;li&gt;&lt;a href=&quot;favoriterank.html&quot;&gt;收藏排行榜&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;    &#x2F;&#x2F; 将lis字符串，设置到ul的html内容中    $(&quot;#category&quot;).html(lis);})</code></pre><h3 id="3-4-对分类数据进行缓存优化"><a href="#3-4-对分类数据进行缓存优化" class="headerlink" title="3.4 对分类数据进行缓存优化"></a>3.4 对分类数据进行缓存优化</h3><p>分类的数据在每一次页面加载后都会重新请求数据库来加载，对数据库的压力比较大，且分类的数据不会经常产生变化，故在此可以使用redis来缓存这个数据。</p><h3 id="3-5-优化代码实现"><a href="#3-5-优化代码实现" class="headerlink" title="3.5 优化代码实现"></a>3.5 优化代码实现</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * @Description: 使用redis缓存，优化代码，减少对数据库的访问     * @Author: zero     * @param     * @return List     * @Date 2019&#x2F;7&#x2F;24 20:52     *&#x2F;@Overridepublic List&lt;Category&gt; findAll() {    &#x2F;&#x2F; 初始化集合对象    List&lt;Category&gt; cs = null;    &#x2F;&#x2F; 1. 从redis中查询数据    &#x2F;&#x2F; 1.1 获取redis客户端连接对象    Jedis jedis = JedisUtil.getJedis();    &#x2F;&#x2F; 1.2 使用sortedset排序查询    Set&lt;String&gt; categorys = jedis.zrange(&quot;category&quot;, 0, -1);    &#x2F;&#x2F; 2. 判断集合是否为null    if (categorys == null || categorys.size() == 0){        &#x2F;&#x2F; 2.1 为空，则表示第一次访问        System.out.println(&quot;redis中无数据，查询数据库...&quot;);        &#x2F;&#x2F; 2.2 查询数据库，获取数据        cs = categoryDao.findAll();        &#x2F;&#x2F; 2.3 将集合数据存储到redis中的category的key        for (int i = 0; i &lt; cs.size(); i++) {            jedis.zadd(&quot;category&quot;,cs.get(i).getCid(),cs.get(i).getCname());        }    }else{        &#x2F;&#x2F; 3. 不为空，将查询到的set集合数据存入list再返回        &#x2F;&#x2F; 因返回的是list集合，故将查询到的set集合数据转换为list数据        System.out.println(&quot;redis中有数据，查询缓存...&quot;);        cs = new ArrayList&lt;Category&gt;();        for (String name : categorys) {            Category category = new Category();            category.setCname(name);            cs.add(category);        }    }    return cs;}</code></pre><h2 id="4-旅游线路的分页展示"><a href="#4-旅游线路的分页展示" class="headerlink" title="4. 旅游线路的分页展示"></a>4. 旅游线路的分页展示</h2><h3 id="4-1-类别id的传递"><a href="#4-1-类别id的传递" class="headerlink" title="4.1  类别id的传递"></a>4.1  类别id的传递</h3><ul><li>从<code>redis</code>中查询数据是，需要将分数也查询出来；并且在返回list集合里，将<code>cid</code>的值设置为对应分数</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/25/cid-1564023861129.jpg" alt="title"></p><ul><li>前台页面传递对应<code>cid</code>，修改<code>header.html</code>，加上<code>data[i].cid</code>即可。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">var li = &#39;&lt;li&gt;&lt;a href=&quot;route_list.html?cid=&#39;+data[i].cid+&#39;&quot;&gt;&#39;+data[i].cname+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;</code></pre><ul><li>获取<code>cid</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">$(function(){    var search = location.search;    &#x2F;&#x2F; alert(search);    &#x2F;&#x2F; 切割字符串，拿到第二个值    var cid = search.split(&quot;=&quot;)[1];});</code></pre><h3 id="4-2-根据id查询不同类别的旅游线路"><a href="#4-2-根据id查询不同类别的旅游线路" class="headerlink" title="4.2  根据id查询不同类别的旅游线路"></a>4.2  根据id查询不同类别的旅游线路</h3><h4 id="4-2-1-分析"><a href="#4-2-1-分析" class="headerlink" title="4.2.1  分析"></a>4.2.1  分析</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/25/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-1564023971902.png" alt="title"></p><h4 id="4-2-2-后台代码实现"><a href="#4-2-2-后台代码实现" class="headerlink" title="4.2.2  后台代码实现"></a>4.2.2  后台代码实现</h4><h5 id="4-2-2-1-PageBean对象"><a href="#4-2-2-1-PageBean对象" class="headerlink" title="4.2.2.1 PageBean对象"></a>4.2.2.1 <code>PageBean</code>对象</h5><p>后台返回给前台的对象</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class PageBean&lt;T&gt; {    private int totalCount; &#x2F;&#x2F; 总记录数    private int totalPage; &#x2F;&#x2F; 总页数    private int currentPage; &#x2F;&#x2F; 当前页码    private int pageSize; &#x2F;&#x2F; 每页显示的条数    private List&lt;T&gt; list; &#x2F;&#x2F; 每页显示的数据集合&#x2F;&#x2F; 省略getset方法}</code></pre><h5 id="4-2-2-2-RouteServlet控制器代码"><a href="#4-2-2-2-RouteServlet控制器代码" class="headerlink" title="4.2.2.2 RouteServlet控制器代码"></a>4.2.2.2 <code>RouteServlet</code>控制器代码</h5><p>负责接收前台传递的参数并处理，调用<code>service</code>查询到<code>PageBean</code>对象后序列化为<code>json</code>再返回给前端。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.web.servlet;import cn.itcast.travel.domain.PageBean;import cn.itcast.travel.domain.Route;import cn.itcast.travel.service.RouteService;import cn.itcast.travel.service.impl.RouteServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;&#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;24 21:52 * Modified By: *&#x2F;@WebServlet(&quot;&#x2F;route&#x2F;*&quot;)public class RouteServlet extends BaseServlet {    private RouteService routeService = new RouteServiceImpl();    public void pageQuery(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 1. 接受参数        String currentPageStr = request.getParameter(&quot;currentPage&quot;);        String pageSizeStr = request.getParameter(&quot;pageSize&quot;);        String cidStr = request.getParameter(&quot;cid&quot;);        &#x2F;&#x2F; 2. 处理参数        int cid = 0; &#x2F;&#x2F; 类别id        if (cidStr != null &amp;&amp; cidStr.length() &gt; 0){            cid = Integer.parseInt(cidStr);        }        int currentPage = 0; &#x2F;&#x2F; 当前页码，如果不传递，则默认为第一页        if (currentPageStr != null &amp;&amp; currentPageStr.length() &gt; 0){            currentPage = Integer.parseInt(currentPageStr);        }else {            currentPage = 1;        }        int pageSize = 0; &#x2F;&#x2F; 每页显示条数，默认为5        if (pageSizeStr != null &amp;&amp; pageSizeStr.length() &gt; 0){            pageSize = Integer.parseInt(pageSizeStr);        }else {            pageSize = 5;        }        &#x2F;&#x2F; 3. 调用service查询PageBean对象        PageBean&lt;Route&gt; pb = routeService.pageQuery(cid, currentPage, pageSize);        &#x2F;&#x2F; 4. 将pageBean对象序列化为json，返回        writeValue(pb,response);    }}</code></pre><h5 id="4-2-2-3-RouteServiceImpl代码"><a href="#4-2-2-3-RouteServiceImpl代码" class="headerlink" title="4.2.2.3 RouteServiceImpl代码"></a>4.2.2.3 <code>RouteServiceImpl</code>代码</h5><p>根据当前页码，类别信息等，从数据库中查询出当前类别对应数据集合，封装<code>PageBean</code>对象后返回</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.service.impl;import cn.itcast.travel.dao.RouteDao;import cn.itcast.travel.dao.impl.RouteDaoImpl;import cn.itcast.travel.domain.PageBean;import cn.itcast.travel.domain.Route;import cn.itcast.travel.service.RouteService;import java.util.List;&#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;24 22:04 * Modified By: *&#x2F;public class RouteServiceImpl implements RouteService {    private RouteDao routeDao = new RouteDaoImpl();    &#x2F;**     * @Description: 查询当前页数据集合并封装为PageBean对象后返回     * @Author: zero     * @param cid     * @param currentPage     * @param pageSize     * @return 封装好的PageBean对象     * @Date 2019&#x2F;7&#x2F;24 22:50     *&#x2F;    @Override    public PageBean&lt;Route&gt; pageQuery(int cid, int currentPage, int pageSize) {        &#x2F;&#x2F; 封装PageBean        PageBean&lt;Route&gt; pb = new PageBean&lt;&gt;();        &#x2F;&#x2F; 设置当前页码        pb.setCurrentPage(currentPage);        &#x2F;&#x2F; 设置每页显示的条数        pb.setPageSize(pageSize);        &#x2F;&#x2F; 设置总记录数        int totalCount = routeDao.findTotalCount(cid);        pb.setTotalCount(totalCount);        &#x2F;&#x2F; 设置当前页显示的数据集合        int start = (currentPage - 1) * pageSize; &#x2F;&#x2F; 开始的记录数        List&lt;Route&gt; list = routeDao.findByPage(cid, start, pageSize);        pb.setList(list);        &#x2F;&#x2F; 设置总页数 = 总记录数 &#x2F; 每页显示条数        int totalPage = totalCount % pageSize == 0 ? totalCount &#x2F; pageSize : (totalCount &#x2F; pageSize) + 1;        pb.setTotalPage(totalPage);        return pb;    }}</code></pre><h5 id="4-2-2-4-RouteDaoImpl，DAO实现类"><a href="#4-2-2-4-RouteDaoImpl，DAO实现类" class="headerlink" title="4.2.2.4 RouteDaoImpl，DAO实现类"></a>4.2.2.4 <code>RouteDaoImpl</code>，DAO实现类</h5><p>查询当前类别总记录数和类别当前页的数据集合</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.dao.impl;import cn.itcast.travel.dao.RouteDao;import cn.itcast.travel.domain.Route;import cn.itcast.travel.util.JDBCUtils;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import java.util.List;&#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;24 22:09 * Modified By: *&#x2F;public class RouteDaoImpl implements RouteDao {    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());    &#x2F;**     * @Description: 根据cid查询总记录数     * @Author: zero     * @param cid     * @return 总记录数     * @Date 2019&#x2F;7&#x2F;24 22:08     *&#x2F;    @Override    public int findTotalCount(int cid) {        return template.queryForObject(&quot;select count(*) from tab_route where cid = ?&quot;,Integer.class,cid);    }        &#x2F;**     * @Description: 根据cid，start，pageSize查询当前页的数据集合     * @Author: zero     * @param cid     * @param start     * @param pageSize     * @return 查询到的当前页数据集合     * @Date 2019&#x2F;7&#x2F;24 22:08     *&#x2F;    @Override    public List&lt;Route&gt; findByPage(int cid, int start, int pageSize) {        String sql = &quot;select * from tab_route where cid = ? limit ? , ?&quot;;        return template.query(sql,new BeanPropertyRowMapper&lt;Route&gt;(Route.class),cid,start,pageSize);    }}</code></pre><h4 id="4-2-3-前台代码实现"><a href="#4-2-3-前台代码实现" class="headerlink" title="4.2.3 前台代码实现"></a>4.2.3 前台代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;    $(function () {    var search = location.search;    &#x2F;&#x2F; alert(search);    &#x2F;&#x2F; 切割字符串，拿到第二个值    var cid = search.split(&quot;=&quot;)[1];    &#x2F;&#x2F; 当页码加载完毕后，调用load方法，    load(cid);})function load(cid, currentPage) {    &#x2F;&#x2F; 发送ajax请求，请求route&#x2F;pageQuery，传递cid    $.get(&quot;route&#x2F;pageQuery&quot;,{cid:cid,currentPage:currentPage},function (pb) {        &#x2F;&#x2F; 解析PageBean数据，展示到页面上        &#x2F;&#x2F; 1. 分页工具条数据展示        &#x2F;&#x2F; 1.1 展示总页码和总记录数        $(&quot;#totalPage&quot;).html(pb.totalPage);        $(&quot;#totalCount&quot;).html(pb.totalCount);        var lis = &quot;&quot;;        var fristPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        &#x2F;&#x2F; 计算上一页的页码        var beforeNum = pb.currentPage - 1;        if (beforeNum &lt;= 0){            beforeNum = 1;        }        var beforePage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+beforeNum+&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;上一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        lis += fristPage;        lis += beforePage;        &#x2F;&#x2F; 1.2 展示分页页码        &#x2F;*                    仿百度分页样式：前五后四                    1. 一共展示10个页码，能够达到前5后4的效果                    2. 如果前边不足5个，后边补齐10个                    3. 如果后边不足4个，前边补齐10个                 *&#x2F;        &#x2F;&#x2F; 定义开始位置begin和结束位置end        var begin; &#x2F;&#x2F; 开始位置        var end; &#x2F;&#x2F; 结束位置        &#x2F;&#x2F; 1. 显示10个页码        if(pb.totalPage &lt; 10){            &#x2F;&#x2F; 总页码不足10页            begin = 1;            end = pb.totalPage;        }else{            &#x2F;&#x2F; 总页码超过10页            &#x2F;&#x2F; 实现前5后4效果            begin = pb.currentPage - 5;            end = pb.currentPage + 4;            &#x2F;&#x2F; 进行数据修正            &#x2F;&#x2F; 2. 如果前边不够5个，后边补齐10个            if (begin &lt; 1){                begin = 1;                end = begin + 9;            }            &#x2F;&#x2F; 3. 如果后边不足4个，前边补齐10个            if (end &gt; pb.totalPage){                end = pb.totalPage;                begin = end - 9;            }        }        for (var i = begin; i &lt;= end; i++) {            var li;            &#x2F;&#x2F; 判断当前页码是否等于i            if (pb.currentPage == i){                li = &#39;&lt;li class=&quot;curPage&quot; onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;            }else{                &#x2F;&#x2F; 创建页码的li                li = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;            }            &#x2F;&#x2F; 拼接进字符串            lis += li;        }        &#x2F;&#x2F; for (var i = 1; i &lt;= pb.totalPage ; i++) {        &#x2F;&#x2F;     var li;        &#x2F;&#x2F;     &#x2F;&#x2F; 判断当前页码是否等于i        &#x2F;&#x2F;     if (pb.currentPage == i){        &#x2F;&#x2F;         li = &#39;&lt;li class=&quot;curPage&quot; onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        &#x2F;&#x2F;     }else{        &#x2F;&#x2F;         &#x2F;&#x2F; 创建页码的li        &#x2F;&#x2F;         li = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        &#x2F;&#x2F;     }        &#x2F;&#x2F;     &#x2F;&#x2F; 拼接进字符串        &#x2F;&#x2F;     lis += li;        &#x2F;&#x2F; }        &#x2F;&#x2F; 计算下一页页码        var nextNum = pb.currentPage + 1;        if(nextNum &gt;= pb.totalPage){            nextNum = pb.totalPage;        }        var nextPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+nextNum+&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;下一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        var lastPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+pb.totalPage+&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;末页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;        lis += nextPage;        lis += lastPage;        &#x2F;&#x2F; 将lis内容设置到ul中        $(&quot;#pageNum&quot;).html(lis);        &#x2F;&#x2F; 2. 列表数据展示        var route_lis = &quot;&quot;;        for (var i = 0; i &lt; pb.list.length; i++) {            &#x2F;&#x2F; 获取数据 {rid&quot;: 1,&quot;rname&quot;: &quot;xxx&quot;,&quot;price&quot;: 999.0,xxxx}            var route = pb.list[i];            var li = &#39;&lt;li&gt;\n&#39; +                &#39;                &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;&#39;+route.rimage+&#39;&quot; style=&quot;width: 299px&quot;&gt;&lt;&#x2F;div&gt;\n&#39; +                &#39;                    &lt;div class=&quot;text1&quot;&gt;\n&#39; +                &#39;                    &lt;p&gt;&#39;+route.rname+&#39;&lt;&#x2F;p&gt;\n&#39; +                &#39;                    &lt;br&#x2F;&gt;\n&#39; +                &#39;                    &lt;p&gt;&#39;+route.routeIntroduce+&#39;&lt;&#x2F;p&gt;\n&#39; +                &#39;                &lt;&#x2F;div&gt;\n&#39; +                &#39;                &lt;div class=&quot;price&quot;&gt;\n&#39; +                &#39;                    &lt;p class=&quot;price_num&quot;&gt;\n&#39; +                &#39;                    &lt;span&gt;&amp;yen;&lt;&#x2F;span&gt;\n&#39; +                &#39;                &lt;span&gt;&#39;+route.price+&#39;&lt;&#x2F;span&gt;\n&#39; +                &#39;                &lt;span&gt;起&lt;&#x2F;span&gt;\n&#39; +                &#39;                &lt;&#x2F;p&gt;\n&#39; +                &#39;                &lt;p&gt;&lt;a href=&quot;route_detail.html&quot;&gt;查看详情&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;\n&#39; +                &#39;                &lt;&#x2F;div&gt;\n&#39; +                &#39;             &lt;&#x2F;li&gt;&#39;;            route_lis += li;        }        $(&quot;#route&quot;).html(route_lis);        &#x2F;&#x2F; 每次点击翻页后，定位到页面顶部        window.scrollTo(0,0);    });}&lt;&#x2F;script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅游网项目01</title>
      <link href="/JavaWeb/travel-project01.html"/>
      <url>/JavaWeb/travel-project01.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>为了巩固web基础知识，提升综合运用能力，故编写此项目，以做练习。</p><p>今日内容为登录注册内容。</p><a id="more"></a><h2 id="2-技术选型"><a href="#2-技术选型" class="headerlink" title="2. 技术选型"></a>2. 技术选型</h2><h3 id="2-1-Web层"><a href="#2-1-Web层" class="headerlink" title="2.1 Web层"></a>2.1 <code>Web</code>层</h3><ol><li><code>Servlet</code>：前端控制器</li><li><code>html</code>：视图</li><li><code>Filter</code>：过滤器</li><li><code>BeanUtils</code>：数据封装</li><li><code>Jackson</code>：json序列化工具</li></ol><h3 id="2-2-Service层"><a href="#2-2-Service层" class="headerlink" title="2.2 Service层"></a>2.2 <code>Service</code>层</h3><ol><li><code>Javamail</code>：java发送邮件工具</li><li><code>Redis</code>：nosql内存数据库</li><li><code>Jedis</code>：java的Redis客户端</li></ol><h3 id="2-3-Dao层"><a href="#2-3-Dao层" class="headerlink" title="2.3  Dao层"></a>2.3  <code>Dao</code>层</h3><ol><li><code>MySQL</code>：后台数据库</li><li><code>Druid</code>：数据库连接池</li><li><code>JdbcTemplate</code>：jdbc的工具</li></ol><h2 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3. 创建数据库"></a>3. 创建数据库</h2><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 创建数据库create database travel;-- 使用数据库use travel;-- 创建表&#x2F;*==============================================================*&#x2F;&#x2F;* DBMS name:      MySQL 5.0                                    *&#x2F;&#x2F;* Created on:     2019&#x2F;7&#x2F;21 20:13:29                           *&#x2F;&#x2F;*==============================================================*&#x2F;set names utf8;drop table if exists tab_favorite;drop table if exists tab_route_img;drop table if exists tab_route;drop table if exists tab_category;drop table if exists tab_seller;drop table if exists tab_user;&#x2F;*==============================================================*&#x2F;&#x2F;* Table: tab_category                                          *&#x2F;&#x2F;*==============================================================*&#x2F;create table tab_category(   cid                  int not null auto_increment,   cname                varchar(100) not null,   primary key (cid),   unique key AK_nq_categoryname (cname));&#x2F;*==============================================================*&#x2F;&#x2F;* Table: tab_favorite                                          *&#x2F;&#x2F;*==============================================================*&#x2F;create table tab_favorite(   rid                  int not null,   date                 date not null,   uid                  int not null,   primary key (rid, uid));&#x2F;*==============================================================*&#x2F;&#x2F;* Table: tab_route                                             *&#x2F;&#x2F;*==============================================================*&#x2F;create table tab_route(   rid                  int not null auto_increment,   rname                varchar(500) not null,   price                double not null,   routeIntroduce       varchar(1000),   rflag                char(1) not null,   rdate                varchar(19),   isThemeTour          char(1) not null,   count                int default 0,   cid                  int not null,   rimage               varchar(200),   sid                  int,   sourceId             varchar(50),   primary key (rid),   unique key AK_nq_sourceId (sourceId));&#x2F;*==============================================================*&#x2F;&#x2F;* Table: tab_route_img                                         *&#x2F;&#x2F;*==============================================================*&#x2F;create table tab_route_img(   rgid                 int not null auto_increment,   rid                  int not null,   bigPic               varchar(200) not null,   smallPic             varchar(200),   primary key (rgid));&#x2F;*==============================================================*&#x2F;&#x2F;* Table: tab_seller                                            *&#x2F;&#x2F;*==============================================================*&#x2F;create table tab_seller(   sid                  int not null auto_increment,   sname                varchar(200) not null,   consphone            varchar(20) not null,   address              varchar(200),   primary key (sid),   unique key AK_Key_2 (sname));&#x2F;*==============================================================*&#x2F;&#x2F;* Table: tab_user                                              *&#x2F;&#x2F;*==============================================================*&#x2F;create table tab_user(   uid                  int not null auto_increment,   username             varchar(100) not null,   password             varchar(32) not null,   name                 varchar(100),   birthday             date,   sex                  char(1),   telephone            varchar(11),   email                varchar(100),   status               char(1) ,   codevarchar(50),      primary key (uid),   unique key AK_nq_username (username),   unique key AK_nq_code (code));-- 建立表连接alter table tab_favorite add constraint FK_route_favorite foreign key (rid)      references tab_route (rid) on delete restrict on update restrict;alter table tab_favorite add constraint FK_user_favorite foreign key (uid)      references tab_user (uid) on delete restrict on update restrict;alter table tab_route add constraint FK_category_route foreign key (cid)      references tab_category (cid) on delete restrict on update restrict;alter table tab_route add constraint FK_seller_route foreign key (sid)      references tab_seller (sid) on delete restrict on update restrict;alter table tab_route_img add constraint FK_route_routeimg foreign key (rid)      references tab_route (rid) on delete restrict on update restrict;-- 修改表默认字符集,解决1366问题alter table tab_category convert to character set utf8 collate utf8_general_ci;alter table tab_favorite convert to character set utf8 collate utf8_general_ci;alter table tab_route convert to character set utf8 collate utf8_general_ci;alter table tab_route_img convert to character set utf8 collate utf8_general_ci;alter table tab_seller convert to character set utf8 collate utf8_general_ci;alter table tab_user convert to character set utf8 collate utf8_general_ci;</code></pre><p>关于报错1366问题：<a href="https://blog.csdn.net/weixin_40539892/article/details/80227981" target="_blank" rel="noopener">详见文章</a></p><h2 id="4-注册功能"><a href="#4-注册功能" class="headerlink" title="4. 注册功能"></a>4. 注册功能</h2><h3 id="4-1-功能分析"><a href="#4-1-功能分析" class="headerlink" title="4.1 功能分析"></a>4.1 功能分析</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/22/register-1563759463469.bmp" alt="title"></p><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h3><h4 id="4-2-1-表单校验"><a href="#4-2-1-表单校验" class="headerlink" title="4.2.1 表单校验"></a>4.2.1 表单校验</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&#x2F;&#x2F; 使用Jquery完成表单校验&#x2F;&#x2F; 定义校验方法&#x2F;&#x2F; 用户名校验function checkUsername() {    &#x2F;&#x2F; 1. 获取用户名值    var username = $(&quot;#username&quot;).val();    &#x2F;&#x2F; 2. 定义正则    var reg_username = &#x2F;^[\u4e00-\u9fa5]|[0-9a-zA-Z]{2,20}$&#x2F;;    &#x2F;&#x2F; 3. 判断，给出提示信息    var flag = reg_username.test(username);    if (flag){        &#x2F;&#x2F; 用户名合法        $(&quot;#username&quot;).css(&quot;border&quot;,&quot;&quot;);    }else {        &#x2F;&#x2F; 用户名非法，加红色边框        $(&quot;#username&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;);    }    return flag;}&#x2F;&#x2F; 密码校验function checkPwd() {    &#x2F;&#x2F; 1. 获取值    var password = $(&quot;#password&quot;).val();    &#x2F;&#x2F; 2. 定义正则    var reg_password = &#x2F;^[\w_-]{6,20}$&#x2F;;    &#x2F;&#x2F; 3. 判断，返回信息    var flag = reg_password.test(password);    if (flag){        &#x2F;&#x2F; 密码合法        $(&quot;#password&quot;).css(&quot;border&quot;,&quot;&quot;);    } else {        &#x2F;&#x2F; 非法，加红色边框        $(&quot;#password&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;);    }    return flag;}&#x2F;&#x2F; 邮箱校验function checkEmail() {    var email = $(&quot;#email&quot;).val();    var reg_email = &#x2F;^\w+@\w+\.\w+$&#x2F;;    var flag = reg_email.test(email);    if(flag){        $(&quot;#email&quot;).css(&quot;border&quot;,&quot;&quot;);    }else {        $(&quot;#email&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;);    }    return flag;}$(function () {    &#x2F;&#x2F; 当表单提交时，调用所有校验方法    $(&quot;#registerForm&quot;).submit(function () {        return checkUsername() &amp;&amp; checkPwd() &amp;&amp; checkEmail();    });    &#x2F;&#x2F; 当某一组件失去焦点时，调用对应的校验方法    $(&quot;#username&quot;).blur(checkUsername);    $(&quot;#password&quot;).blur(checkPwd);    $(&quot;#email&quot;).blur(checkEmail);});</code></pre><h4 id="4-2-2-异步提交表单"><a href="#4-2-2-异步提交表单" class="headerlink" title="4.2.2 异步提交表单"></a>4.2.2 异步提交表单</h4><p>使用异步提交表单是为了获取服务器响应的数据。因为前台使用的是html作为视图层，不能够直接从servlet相关的域对象获取值，只能通过ajax获取响应数据。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">$(function () {    &#x2F;&#x2F; 当表单提交时，调用所有校验方法    $(&quot;#registerForm&quot;).submit(function () {        &#x2F;&#x2F; 1. 发送数据到服务器        if ( checkUsername() &amp;&amp; checkPwd() &amp;&amp; checkEmail()){            &#x2F;&#x2F; 校验通过，发送ajax请求，提交表单数据            $.post(&quot;registUserServlet&quot;,$(this).serialize(),function (data) {                &#x2F;&#x2F; 处理服务器响应的数据 data  {flag:true,errorMsg:&quot;注册失败&quot;}                if (data.flag){                    &#x2F;&#x2F; 注册成功，跳转到成功页面                    location.href = &quot;register_ok.html&quot;;                }else{                    &#x2F;&#x2F; 注册失败，给errorMsg添加提示信息                    $(&quot;#errorMsg&quot;).html(data.errorMsg);                }            })        }        &#x2F;&#x2F; 2. 不让页面跳转，不提交        return false;    });    &#x2F;&#x2F; 当某一组件失去焦点时，调用对应的校验方法    $(&quot;#username&quot;).blur(checkUsername);    $(&quot;#password&quot;).blur(checkPwd);    $(&quot;#email&quot;).blur(checkEmail);});</code></pre><h3 id="4-3-后台代码实现"><a href="#4-3-后台代码实现" class="headerlink" title="4.3 后台代码实现"></a>4.3 后台代码实现</h3><h4 id="4-3-1-注册用户控制器：RegistUserServlet"><a href="#4-3-1-注册用户控制器：RegistUserServlet" class="headerlink" title="4.3.1 注册用户控制器：RegistUserServlet"></a>4.3.1 注册用户控制器：<code>RegistUserServlet</code></h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.web.servlet;import cn.itcast.travel.domain.ResultInfo;import cn.itcast.travel.domain.User;import cn.itcast.travel.service.UserService;import cn.itcast.travel.service.impl.UserServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(&quot;&#x2F;registUserServlet&quot;)public class RegistUserServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 获取用户输入的验证码        String check = request.getParameter(&quot;check&quot;);        &#x2F;&#x2F; 从session中获取生成的验证码        HttpSession session = request.getSession();        String checkcode_server = (String)session.getAttribute(&quot;CHECKCODE_SERVER&quot;);        session.removeAttribute(&quot;CHECKCODE_SERVER&quot;); &#x2F;&#x2F; 确保验证码只能使用一次        &#x2F;&#x2F; 如果验证码错误，直接注册失败        if (checkcode_server == null || !checkcode_server.equalsIgnoreCase(check)){            &#x2F;&#x2F; 验证码错误            ResultInfo info = new ResultInfo();            &#x2F;&#x2F; 注册失败            info.setFlag(false);            info.setErrorMsg(&quot;验证码错误&quot;);            &#x2F;&#x2F; 将info对象序列化为json            ObjectMapper mapper = new ObjectMapper();            String json = mapper.writeValueAsString(info);            response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);            response.getWriter().write(json);            return; &#x2F;&#x2F; todo:为何return?        }        &#x2F;&#x2F; 验证通过        &#x2F;&#x2F; 1. 获取前台表单数据        Map&lt;String, String[]&gt; map = request.getParameterMap();        &#x2F;&#x2F; 2. 封装为user对象        User user = new User();        try {            BeanUtils.populate(user,map);        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        }        &#x2F;&#x2F; 3. 调用service完成注册        UserService service = new UserServiceImpl();        boolean flag = service.regist(user);        ResultInfo info = new ResultInfo();        &#x2F;&#x2F; 4. 响应结果        if (flag){            &#x2F;&#x2F; 注册成功            info.setFlag(true);        }else{            &#x2F;&#x2F; 注册失败            info.setFlag(false);            info.setErrorMsg(&quot;注册失败！&quot;);        }        &#x2F;&#x2F; 将info对象序列化为json        ObjectMapper mapper = new ObjectMapper();        System.out.println(info);        String json = mapper.writeValueAsString(info);        &#x2F;&#x2F; 将json数据回写客户端        &#x2F;&#x2F; 设置content-type        response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);        response.getWriter().write(json);    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}</code></pre><h4 id="4-3-2-用户服务业务层以及对应实现类"><a href="#4-3-2-用户服务业务层以及对应实现类" class="headerlink" title="4.3.2 用户服务业务层以及对应实现类"></a>4.3.2 用户服务业务层以及对应实现类</h4><p>服务层接口</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.service;import cn.itcast.travel.domain.User;public interface UserService {    boolean regist(User user);}</code></pre><p>实现类</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.service.impl;import cn.itcast.travel.dao.UserDao;import cn.itcast.travel.dao.impl.UserDaoImpl;import cn.itcast.travel.domain.User;import cn.itcast.travel.service.UserService;public class UserServiceImpl implements UserService {    private UserDao userDao = new UserDaoImpl();    &#x2F;**     * 注册用户服务     * @param user     * @return 是否注册成功     *&#x2F;    @Override    public boolean regist(User user) {        &#x2F;&#x2F; 1. 根据用户名查询用户对象        User u = userDao.findByUsername(user.getUsername());        &#x2F;&#x2F; 判断是否为null        if (u != null){            &#x2F;&#x2F; 不为空，说明用户名存在，注册失败            return false;        }        &#x2F;&#x2F; 2. 保存用户信息        userDao.save(user);        return true;    }}</code></pre><h4 id="4-3-3-数据操作层及对应实现类"><a href="#4-3-3-数据操作层及对应实现类" class="headerlink" title="4.3.3 数据操作层及对应实现类"></a>4.3.3 数据操作层及对应实现类</h4><p>Dao</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.dao;import cn.itcast.travel.domain.User;public interface UserDao {    User findByUsername(String username);    void save(User user);}</code></pre><p>实现类</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.dao.impl;import cn.itcast.travel.dao.UserDao;import cn.itcast.travel.domain.User;import cn.itcast.travel.util.JDBCUtils;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;public class UserDaoImpl implements UserDao {    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());    &#x2F;**     * 查询用户是否存在     * @param username     * @return 返回查询到的用户     *&#x2F;    @Override    public User findByUsername(String username) {        &#x2F;*            queryForObject()方法            如果查询结果条数为0或者大于1)都会返回异常，我们希望没查到直接返回null         *&#x2F;        User user = null;        try{            user = template.queryForObject(&quot;select * from tab_user where username = ? &quot;,                    new BeanPropertyRowMapper&lt;User&gt;(User.class),username);        }catch (Exception e){            System.out.println(&quot;用户未查询到&quot;);        }        return user;    }    @Override    public void save(User user) {        &#x2F;&#x2F; 1. 定义sql        String sql = &quot;insert into tab_user(username,password,name,birthday,sex,telephone,email) values(?,?,?,?,?,?,?)&quot;;        &#x2F;&#x2F; 2. 执行sql        template.update(sql,user.getUsername(),user.getPassword(),user.getName(),                            user.getBirthday(),user.getSex(),user.getTelephone(),user.getEmail());    }}</code></pre><h4 id="4-3-4-邮件激活"><a href="#4-3-4-邮件激活" class="headerlink" title="4.3.4 邮件激活"></a>4.3.4 邮件激活</h4><p>为什么要进行邮件激活？为了保证用户填写的邮箱是正确的。将来可以推广一些宣传信息，到用户邮箱中。</p><h4 id="4-3-5-发送邮件"><a href="#4-3-5-发送邮件" class="headerlink" title="4.3.5 发送邮件"></a>4.3.5 发送邮件</h4><ol><li>打开邮箱</li><li>开启授权码，并生成一个</li><li>在<code>MailUtils</code>中设置自己的邮箱账号和密码(授权码)</li></ol><blockquote><p><code>MailUtils</code>是邮箱工具类，调用其中的<code>sendMail</code>方法可以完成邮件发送</p></blockquote><h4 id="4-3-6-用户点击邮件激活"><a href="#4-3-6-用户点击邮件激活" class="headerlink" title="4.3.6 用户点击邮件激活"></a>4.3.6 用户点击邮件激活</h4><h5 id="4-3-6-1-功能分析"><a href="#4-3-6-1-功能分析" class="headerlink" title="4.3.6.1 功能分析"></a>4.3.6.1 功能分析</h5><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/22/sendEmail-1563759504470.png" alt="title"></p><h5 id="4-3-6-2-发送邮件代码实现"><a href="#4-3-6-2-发送邮件代码实现" class="headerlink" title="4.3.6.2 发送邮件代码实现"></a>4.3.6.2 发送邮件代码实现</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Overridepublic boolean regist(User user) {    &#x2F;&#x2F; 1. 根据用户名查询用户对象    User u = userDao.findByUsername(user.getUsername());    &#x2F;&#x2F; 判断是否为null    if (u != null){        &#x2F;&#x2F; 不为空，说明用户名存在，注册失败        return false;    }    &#x2F;&#x2F; 2. 保存用户信息    &#x2F;&#x2F; 2.1 设置激活码，唯一字符串    String uuid = UuidUtil.getUuid();    System.out.println(uuid);    user.setCode(uuid);    &#x2F;&#x2F; 2.2 设置激活状态    user.setStatus(&quot;N&quot;); &#x2F;&#x2F; 默认未激活    userDao.save(user);    &#x2F;&#x2F; 3. 激活邮件发送，邮件正文    &#x2F;&#x2F; 邮件正文 todo:后期项目部署需要将href改为服务器域名    String content = &quot;&lt;a href=&#39;http:&#x2F;&#x2F;localhost&#x2F;travel&#x2F;activeUserServlet?code=&quot;+user.getCode()+&quot;&#39;&gt;点击激活账户&lt;&#x2F;a&gt;&quot;;    &#x2F;&#x2F; 发送邮件    MailUtils.sendMail(user.getEmail(),content,&quot;激活邮件&quot;);    return true;}</code></pre><h5 id="4-3-6-3-修改保存Dao代码，以及存储status和code代码逻辑"><a href="#4-3-6-3-修改保存Dao代码，以及存储status和code代码逻辑" class="headerlink" title="4.3.6.3 修改保存Dao代码，以及存储status和code代码逻辑"></a>4.3.6.3 修改保存Dao代码，以及存储<code>status</code>和<code>code</code>代码逻辑</h5><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/22/update-1563759516887.png" alt="title"></p><h5 id="4-3-6-4-激活Servlet实现"><a href="#4-3-6-4-激活Servlet实现" class="headerlink" title="4.3.6.4 激活Servlet实现"></a>4.3.6.4 激活<code>Servlet</code>实现</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.web.servlet;import cn.itcast.travel.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;&#x2F;activeUserServlet&quot;)public class ActiveUserServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 1. 获取激活码        String code = request.getParameter(&quot;code&quot;);        if (code != null){            &#x2F;&#x2F; 2. 调用service完成激活            UserServiceImpl service = new UserServiceImpl();            boolean flag = service.active(code);            &#x2F;&#x2F; 3. 判断标记            String msg = null;            if (flag){                &#x2F;&#x2F; 激活成功                msg = &quot;激活成功，请&lt;a href=&#39;login.html&#39;&gt;登录&lt;&#x2F;a&gt;&quot;;            }else{                &#x2F;&#x2F; 激活失败                msg = &quot;激活失败，请联系管理员！&quot;;            }            &#x2F;&#x2F; 回写数据            response.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;);            response.getWriter().write(msg);        }    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}</code></pre><h5 id="4-3-6-5-激活Service代码"><a href="#4-3-6-5-激活Service代码" class="headerlink" title="4.3.6.5 激活Service代码"></a>4.3.6.5 激活<code>Service</code>代码</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Overridepublic boolean active(String code) {    &#x2F;&#x2F; 1. 根据激活码查询用户对象    User user = userDao.findByCode(code);    if (user != null){        &#x2F;&#x2F; 2. 调用dao的修改激活状态的方法        userDao.updateStatus(user);        return true;    }else{        return false;    }}</code></pre><h5 id="4-3-6-6-激活Dao代码：findByCode-amp-updateStatus"><a href="#4-3-6-6-激活Dao代码：findByCode-amp-updateStatus" class="headerlink" title="4.3.6.6 激活Dao代码：findByCode&amp;updateStatus"></a>4.3.6.6 激活Dao代码：<code>findByCode&amp;updateStatus</code></h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 根据激活码查询用户对象* @param code* @return 查询到的对象*&#x2F;@Overridepublic User findByCode(String code) {    User user = null;    try{        String sql = &quot;select * from tab_user where code = ?&quot;;        user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), code);    }catch (DataAccessException e){        e.printStackTrace();    }    return user;}&#x2F;*** 修改指定用户激活状态* @param user*&#x2F;@Overridepublic void updateStatus(User user) {    template.update(&quot;update tab_user set status = &#39;Y&#39; where uid = ?&quot;,user.getUid());}</code></pre><h2 id="5-登录"><a href="#5-登录" class="headerlink" title="5. 登录"></a>5. 登录</h2><h3 id="5-1-分析"><a href="#5-1-分析" class="headerlink" title="5.1 分析"></a>5.1 分析</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/22/login-1563759530918.bmp" alt="title"></p><h3 id="5-2-前台代码实现"><a href="#5-2-前台代码实现" class="headerlink" title="5.2 前台代码实现"></a>5.2 前台代码实现</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;    $(function () {    &#x2F;&#x2F; 1. 给登录按钮绑定单击事件    $(&quot;#btn_sub&quot;).click(function () {        &#x2F;&#x2F; 2. 发送ajax请求，提交表单数据        $.post(&quot;loginServlet&quot;,$(&quot;#loginForm&quot;).serialize(),function (data) {            &#x2F;&#x2F; data: {flag:false,errorMsg:&quot;&quot;}            if (data.flag){                &#x2F;&#x2F; 登录成功                location.href = &quot;index.html&quot;;            } else{                &#x2F;&#x2F; 登录失败                $(&quot;#errorMsg&quot;).html(data.errorMsg);            }        });    });});&lt;&#x2F;script&gt;</code></pre><h3 id="5-3-后台代码实现"><a href="#5-3-后台代码实现" class="headerlink" title="5.3 后台代码实现"></a>5.3 后台代码实现</h3><h4 id="5-3-1-登录控制器：LoginServlet"><a href="#5-3-1-登录控制器：LoginServlet" class="headerlink" title="5.3.1 登录控制器：LoginServlet"></a>5.3.1 登录控制器：<code>LoginServlet</code></h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.web.servlet;import cn.itcast.travel.domain.ResultInfo;import cn.itcast.travel.domain.User;import cn.itcast.travel.service.impl.UserServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(&quot;&#x2F;loginServlet&quot;)public class LoginServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 1. 获取用户名和密码        Map&lt;String, String[]&gt; map = request.getParameterMap();        &#x2F;&#x2F; 2. 封装User对象        User user = new User();        try {            BeanUtils.populate(user,map);        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        }        &#x2F;&#x2F; 3. 调用service查询        UserServiceImpl service = new UserServiceImpl();        User u = service.login(user);        ResultInfo info = new ResultInfo();        &#x2F;&#x2F; 4. 判断用户对象是否为null        if (u == null){            &#x2F;&#x2F; 用户名或密码错误            info.setFlag(false);            info.setErrorMsg(&quot;用户名或密码错误&quot;);        }        &#x2F;&#x2F; 5. 判断用户账户是否激活        if (u != null &amp;&amp; !&quot;Y&quot;.equals(u.getStatus())){            &#x2F;&#x2F; 用户未激活            info.setFlag(false);            info.setErrorMsg(&quot;您的账户尚未激活，请激活&quot;);        }        &#x2F;&#x2F; 6. 判断登录成功        if (u != null &amp;&amp; &quot;Y&quot;.equals(u.getStatus())){            &#x2F;&#x2F; 登录成功            info.setFlag(true);            &#x2F;&#x2F; 将登陆用户信息存入session中            request.getSession().setAttribute(&quot;user&quot;,u);        }        &#x2F;&#x2F; 响应数据        ObjectMapper mapper = new ObjectMapper();        response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);        mapper.writeValue(response.getOutputStream(),info);    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}</code></pre><h4 id="5-3-2-服务层代码"><a href="#5-3-2-服务层代码" class="headerlink" title="5.3.2 服务层代码"></a>5.3.2 服务层代码</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;*** 进行登录操作* @param user* @return User对象*&#x2F;@Overridepublic User login(User user) {    return userDao.findByUsernameAndPassword(user.getUsername(),user.getPassword());}</code></pre><h4 id="5-3-3-Dao层代码"><a href="#5-3-3-Dao层代码" class="headerlink" title="5.3.3 Dao层代码"></a>5.3.3 Dao层代码</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;*** 根据用户名和密码，查询是否有此用户* @param username* @param password* @return user对象*&#x2F;@Overridepublic User findByUsernameAndPassword(String username, String password) {    User user = null;    try{        String sql = &quot;select * from tab_user where username = ? and password = ?&quot;;        user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), username,password);    }catch (DataAccessException e){        e.printStackTrace();    }    return user;}</code></pre><h4 id="5-3-4-用户登录后，主页显示登录用户名功能"><a href="#5-3-4-用户登录后，主页显示登录用户名功能" class="headerlink" title="5.3.4 用户登录后，主页显示登录用户名功能"></a>5.3.4 用户登录后，主页显示登录用户名功能</h4><p><code>header.html</code>代码</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;    $(function () {       $.get(&quot;findUserServlet&quot;,{},function (data) {           var msg = &quot;欢迎回来，&quot;+data.name;           $(&quot;#span_username&quot;).html(msg);       })    });&lt;&#x2F;script&gt;</code></pre><p>控制器代码</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.web.servlet;import com.fasterxml.jackson.databind.ObjectMapper;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;&#x2F;findUserServlet&quot;)public class FindUserServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 从session中获取登录用户        Object user = request.getSession().getAttribute(&quot;user&quot;);        &#x2F;&#x2F; 将user回写客户端        ObjectMapper mapper = new ObjectMapper();        response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);        mapper.writeValue(response.getOutputStream(),user);    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}</code></pre><h2 id="6-退出"><a href="#6-退出" class="headerlink" title="6. 退出"></a>6. 退出</h2><p>什么情况下算登录了？答：session中有user对象。</p><ul><li>实现步骤：<ul><li>访问servlet，将session销毁</li><li>跳转到登录页面</li></ul></li><li>前台代码实现：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;a href=&quot;javascript:location.href=&#39;exitServlet&#39;;&quot;&gt;退出&lt;&#x2F;a&gt;</code></pre><ul><li>后台代码实现：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.itcast.travel.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;&#x2F;exitServlet&quot;)public class ExitServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 1. 销毁session        request.getSession().invalidate();        &#x2F;&#x2F; 2. 跳转到登录页面        response.sendRedirect(request.getContextPath()+&quot;&#x2F;login.html&quot;);    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/JavaWeb/maven.html"/>
      <url>/JavaWeb/maven.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Maven基础概念和配置"><a href="#1-Maven基础概念和配置" class="headerlink" title="1. Maven基础概念和配置"></a>1. <code>Maven</code>基础概念和配置</h2><p>Maven是一个项目管理工具，它包含了一个项目对象模型(<code>POM:Project Object Model</code>)，一组标准集合，一个项目生命周期(<code>Project Lifecycle</code>)，一个依赖管理系统(<code>Dependency Management System</code>)，和用来运行定义在生命周期阶段(<code>phase</code>)中插件(<code>plugin</code>)目标(<code>goal</code>)的逻辑。</p><a id="more"></a><h3 id="1-1-Maven能解决的问题"><a href="#1-1-Maven能解决的问题" class="headerlink" title="1.1 Maven能解决的问题"></a>1.1 <code>Maven</code>能解决的问题</h3><ol><li>依赖管理</li><li>编译代码</li><li>单元测试</li><li>打包项目</li></ol><h3 id="1-2-安装与配置"><a href="#1-2-安装与配置" class="headerlink" title="1.2 安装与配置"></a>1.2 安装与配置</h3><h4 id="1-2-1-官网下载Maven"><a href="#1-2-1-官网下载Maven" class="headerlink" title="1.2.1 官网下载Maven"></a>1.2.1 官网下载<code>Maven</code></h4><p>官网下载<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">链接</a></p><p>点击<code>apache-maven-3.6.1-bin.zip</code>下载</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/downloadMaven-1563321026172.png" alt="title"></p><h4 id="1-2-2-解压"><a href="#1-2-2-解压" class="headerlink" title="1.2.2 解压"></a>1.2.2 解压</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/jieya-1563321057082.png" alt="title"></p><h4 id="1-2-3-配置环境变量"><a href="#1-2-3-配置环境变量" class="headerlink" title="1.2.3 配置环境变量"></a>1.2.3 配置环境变量</h4><blockquote><p>注意：安装maven之前，确保电脑中已安装JDK，如安装Maven3则必须是JDK1.7以上。</p></blockquote><p>新建一个系统变量，变量名：<code>MAVEN_HOME</code>，变量值为你解压的文件路径，例我的路径是：<code>D:\Maven\apache-maven-3.6.1</code></p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/add_variable-1563321074839.png" alt="title"></p><p>添加到系统路径中：</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/addToPath-1563321084507.png" alt="title"></p><p>完成后打开<code>cmd</code>输入<code>mvn -v</code>，显示版本信息则配置正确。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/mvn-1563321095966.png" alt="title"></p><h3 id="1-3-本地仓库配置"><a href="#1-3-本地仓库配置" class="headerlink" title="1.3 本地仓库配置"></a>1.3 本地仓库配置</h3><p>仓库分三类：本地仓库，远程仓库[私服]，中央仓库。</p><ul><li>本地仓库：用于存储从远程仓库或中央仓库下载的插件和jar包，项目使用的一些插件或jar包。优先从本地仓库查找，默认本地仓库位置在<code>${user.home}/.m2/repository</code>，<code>${user.home}</code>表示windows用户目录。</li></ul><p>在<code>maven</code>的<code>conf</code>文件夹下的<code>settings.xml</code>文件中配置本地仓库。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/settings-1563321177548.png" alt="title"></p><ul><li>远程仓库：又叫私服仓库，如果私服仓库存在，且在本地仓库所需的插件或jar包没有的情况下，会从当前仓库下载。</li><li>中央仓库：在maven软件中内置一个远程仓库地址<code>http://repo1.maven.org/maven2</code>。它是中央仓库(<code>Central Repository</code>)，服务于整个互联网，由Maven官方团队维护，里面存储了非常全面的jar包，包含了世界上大部分主流的开源项目构件。</li></ul><h2 id="2-Maven工程的认识"><a href="#2-Maven工程的认识" class="headerlink" title="2. Maven工程的认识"></a>2. <code>Maven</code>工程的认识</h2><h3 id="2-1-Maven工程的目录结构"><a href="#2-1-Maven工程的目录结构" class="headerlink" title="2.1 Maven工程的目录结构"></a>2.1 <code>Maven</code>工程的目录结构</h3><ul><li>工程目录结构：</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/mavenProject-1563321204302.png" alt="title"><br>作为一个<code>Maven</code>工程，它的<code>src</code>目录和<code>pom.xml</code>是必备的。</p><ul><li><code>target</code>：项目输出位置，编译后的<code>class</code>文件会输出到此目录。</li><li><p><code>pom.xml</code>：<code>maven</code>项目核心配置文件。</p></li><li><p><code>src</code>目录结构：</p></li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/src-1563321214987.png" alt="title"></p><ul><li><p>标准<code>src</code>目录结构：</p><ul><li><code>src/main/java</code>：存放项目的<code>.java</code>文件。</li><li><code>src/main/resources</code>：存放项目资源文件，如<code>spring,hibernate</code>配置文件。</li><li><code>src/test/java</code>：存放所有单元测试<code>.java</code>文件，如<code>Junit</code>测试类。</li><li><code>src/test/resources</code>：测试资源文件。</li></ul></li></ul><ul><li>运行项目：进入maven工程目录(当前目录有<code>pom.xml</code>)，打开<code>cmd</code>，运行<code>mvn tomcat:run</code>命令即可。</li></ul><h2 id="3-Maven常用命令"><a href="#3-Maven常用命令" class="headerlink" title="3. Maven常用命令"></a>3. <code>Maven</code>常用命令</h2><p>我们可以在<code>cmd</code>中通过一系列的<code>maven</code>命令来对我们的<code>maven</code>工程进行编译、测试、运行、打包、安装、部署。</p><h3 id="3-1-compile"><a href="#3-1-compile" class="headerlink" title="3.1 compile"></a>3.1 <code>compile</code></h3><p><code>compile</code>是<code>maven</code>工程的编译命令，作用是将<code>src/main/java</code>下的文件编译为<code>class</code>文件输出到<code>target</code>目录下。</p><h3 id="3-2-test"><a href="#3-2-test" class="headerlink" title="3.2 test"></a>3.2 <code>test</code></h3><p><code>test</code>是<code>maven</code>工程的测试命令，执行<code>mvn test</code>命令，会执行<code>src/test/java</code>下的单元测试类。</p><h3 id="3-3-clean"><a href="#3-3-clean" class="headerlink" title="3.3 clean"></a>3.3 <code>clean</code></h3><p><code>clean</code>是<code>maven</code>工程的清理命令，执行<code>mvn clean</code>命令会删除<code>target</code>目录及内容。</p><h3 id="3-4-package"><a href="#3-4-package" class="headerlink" title="3.4 package"></a>3.4 <code>package</code></h3><p><code>package</code>是<code>maven</code>工程的打包命令，对于<code>java</code>工程执行该命令会打包成<code>jar</code>包，<code>web</code>工程则会打包成<code>war</code>包。</p><h3 id="3-5-install"><a href="#3-5-install" class="headerlink" title="3.5 install"></a>3.5 <code>install</code></h3><p><code>install</code>是<code>maven</code>工程的安装命令，执行该命令会将<code>maven</code>打包成<code>jar</code>包或<code>war</code>包发布到本地仓库。</p><h3 id="3-6-Maven指令的生命周期"><a href="#3-6-Maven指令的生命周期" class="headerlink" title="3.6 Maven指令的生命周期"></a>3.6 <code>Maven</code>指令的生命周期</h3><p><code>maven</code>对项目构建过程分为三套相互独立的生命周期，请注意是<strong><em>三套</em></strong>且<strong><em>相互独立</em></strong>的。</p><p>这三套生命周期分别是：</p><ol><li><code>Clean Lifecycle</code>：在进行真正的构建之前进行一些清理工作。</li><li><code>Default Lifecycle</code>：构建的核心部分，进行编译、测试、打包、部署等等。</li><li><code>Site Lifecycle</code>：生成项目报告、站点，发布站点。</li></ol><h3 id="3-7-maven的概念模型"><a href="#3-7-maven的概念模型" class="headerlink" title="3.7 maven的概念模型"></a>3.7 <code>maven</code>的概念模型</h3><p><code>Maven</code>包含了一个项目对象模型(<code>POM:Project Object Model</code>)，一组标准集合，一个项目生命周期(<code>Project Lifecycle</code>)，一个依赖管理系统(<code>Dependency Management System</code>)，和用来运行定义在生命周期阶段(<code>phase</code>)中插件(<code>plugin</code>)目标(<code>goal</code>)的逻辑。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/maven_model-1563321257756.png" alt="title"></p><ul><li><p>项目对象模型：一个<code>maven</code>工程都有一个<code>pom.xml</code>文件，通过该文件定义项目的坐标、项目依赖、项目信息、插件目标等。</p></li><li><p>依赖管理系统：通过maven的依赖管理对项目所依赖的jar包进行统一管理。</p><ul><li>如：项目依赖<code>junit4.9</code>，通过在<code>pom.xml</code>中定义<code>junit4.9</code>的依赖即使用<code>junit4.9</code>，如下所示<code>junit4.9</code>的依赖定义：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">  &lt;dependencies&gt;      &lt;!-- 此项目运行使用junit，所以此项目依赖junit --&gt;      &lt;dependency&gt;          &lt;!-- junit的项目名称 --&gt;          &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;          &lt;!-- junit的模块名称 --&gt;          &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;          &lt;!-- junit版本 --&gt;          &lt;version&gt;4.9&lt;&#x2F;version&gt;          &lt;!-- 依赖范围：单元测试时使用junit --&gt;          &lt;scope&gt;test&lt;&#x2F;scope&gt;      &lt;&#x2F;dependency&gt;  &lt;&#x2F;dependencies&gt;</code></pre></li></ul><ul><li>一个项目生命周期：使用maven完成项目的构建，项目构建包括：清理、编译、测试、部署等过程。maven将这些过程规范为一个生命周期，如下所示：</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/lifecycle-1563321277883.png" alt="title"></p><ul><li>一组标准集合：maven将整个项目管理过程定义一组标准，比如：通过maven构建工程有标准的目录结构，标准的生命周期阶段、依赖管理和标准的坐标定义等。</li><li>插件(<code>plugin</code>)目标(<code>goal</code>)：maven管理项目生命周期过程都是基于插件完成的。</li></ul><h2 id="4-IDEA开发maven项目"><a href="#4-IDEA开发maven项目" class="headerlink" title="4. IDEA开发maven项目"></a>4. IDEA开发<code>maven</code>项目</h2><h3 id="4-1-IDEA的maven配置"><a href="#4-1-IDEA的maven配置" class="headerlink" title="4.1 IDEA的maven配置"></a>4.1 IDEA的<code>maven</code>配置</h3><p>打开<code>--&gt;File--&gt;Settings</code>，搜索maven，配置如下内容：</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/IDEASettingMaven-1563321323464.png" alt="title"></p><h3 id="4-2-在IDEA中创建一个maven的web工程"><a href="#4-2-在IDEA中创建一个maven的web工程" class="headerlink" title="4.2 在IDEA中创建一个maven的web工程"></a>4.2 在IDEA中创建一个<code>maven</code>的<code>web</code>工程</h3><p>新建工程，选择IDEA提供好的maven的web工程模板</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/create_project-1563321341204.png" alt="title"></p><p>点击<code>Next</code>填写项目信息</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/create_project02-1563321355572.png" alt="title"></p><p>点击<code>Next</code>，配置相关属性，此处不做改动。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/create_project03-1563321363619.png" alt="title"></p><p>再点击<code>Next</code>选择项目所在目录，最后点击<code>Finish</code>，等待项目构建。显示如下信息则构建成功。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/create_project04-1563321374779.png" alt="title"></p><p>最终目录结构并不完整，需手动补齐。手动添加<code>src/main/java</code>目录，将<code>java</code>目录设置为<code>Sources Root</code>。</p><h4 id="4-2-1-创建一个Servlet"><a href="#4-2-1-创建一个Servlet" class="headerlink" title="4.2.1 创建一个Servlet"></a>4.2.1 创建一个Servlet</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package com.zero.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;&#x2F;testServlet&quot;)public class TestServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        request.getRequestDispatcher(&quot;&#x2F;hello.jsp&quot;).forward(request,response);    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}</code></pre><h4 id="4-2-2-配置pom-xml"><a href="#4-2-2-配置pom-xml" class="headerlink" title="4.2.2  配置pom.xml"></a>4.2.2  配置<code>pom.xml</code></h4><p>此时编译器会提示servlet相关包不存在，需要在<code>pom.xml</code>中添加坐标。添加jar包坐标时，还可指定该jar包的作用范围。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;dependencies&gt;&lt;!--    放置项目运行所依赖的jar包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;        &lt;version&gt;4.11&lt;&#x2F;version&gt;        &lt;scope&gt;test&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.5&lt;&#x2F;version&gt;        &lt;scope&gt;provided&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.0&lt;&#x2F;version&gt;        &lt;scope&gt;provided&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.1.0&lt;&#x2F;version&gt;        &lt;scope&gt;provided&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre><p>依赖范围表：</p><table><thead><tr><th>依赖范围</th><th>编译时有效</th><th>测试时有效</th><th>运行时有效</th><th>例</th></tr></thead><tbody><tr><td><code>compile</code></td><td>Y</td><td>Y</td><td>Y</td><td><code>spring-core</code></td></tr><tr><td><code>test</code></td><td>-</td><td>Y</td><td>-</td><td><code>Junit</code></td></tr><tr><td><code>provided</code></td><td>Y</td><td>Y</td><td>-</td><td><code>servlet-api</code></td></tr><tr><td><code>runtime</code></td><td>-</td><td>Y</td><td>Y</td><td>JDBC驱动</td></tr><tr><td><code>system</code></td><td>Y</td><td>Y</td><td>-</td><td>本地的，Maven仓库之外的类库</td></tr></tbody></table><p><code>scope</code>范围依赖小结：</p><ul><li>默认引入的jar包使用<code>compile</code>[默认范围，可不写,编译、测试、运行都有效]</li><li><code>servlet-api、jsp-api</code>使用<code>provided</code>[编译、测试有效，运行时无效，防止和tomcat下jar包冲突]</li><li>JDBC驱动包使用<code>runtime</code>[测试、运行有效]</li><li><code>Junit</code>使用<code>test</code>[仅测试有效]</li></ul><p>依赖范围由强到弱的顺序是：<code>compile&gt;provided&gt;runtime&gt;test</code></p><h4 id="4-2-3-运行"><a href="#4-2-3-运行" class="headerlink" title="4.2.3 运行"></a>4.2.3 运行</h4><p>点击<code>M</code>图标，输入<code>tomcat7:run</code>运行maven项目。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/pom-1563321412176.png" alt="title"></p><h4 id="4-2-4-配置断点调试"><a href="#4-2-4-配置断点调试" class="headerlink" title="4.2.4 配置断点调试"></a>4.2.4 配置断点调试</h4><p>在项目配置中添加maven项目，设置操作命令。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/debug-1563321428242.png" alt="title"><br>点击小虫子，即可启动<code>debug</code>模式。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/17/debug2-1563321435566.png" alt="title"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><h3 id="5-1-maven仓库"><a href="#5-1-maven仓库" class="headerlink" title="5.1 maven仓库"></a>5.1 <code>maven</code>仓库</h3><ol><li><code>maven</code>仓库的类型有哪些？</li><li><code>maven</code>工程查找仓库的流程是什么？</li><li>本地仓库如何配置？</li></ol><h3 id="5-2-常用的maven命令"><a href="#5-2-常用的maven命令" class="headerlink" title="5.2 常用的maven命令"></a>5.2 常用的<code>maven</code>命令</h3><ul><li><code>compile</code>：编译</li><li><code>clean</code>：清理</li><li><code>test</code>：测试</li><li><code>package</code>：打包</li><li><code>install</code>：安装</li></ul><h3 id="5-3-坐标定义"><a href="#5-3-坐标定义" class="headerlink" title="5.3 坐标定义"></a>5.3 坐标定义</h3><p>在<code>pom.xml</code>中定义坐标，内容包括：<code>groupId、artifactld、version</code>，示例如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;&lt;groupId&gt;com.zero.maven&lt;&#x2F;groupId&gt;&lt;!--模块名称--&gt;&lt;artifactId&gt;maven-first&lt;&#x2F;artifactId&gt;&lt;!--当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本--&gt;&lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;!--打包类型--&gt;&lt;packaging&gt;war&lt;&#x2F;packaging&gt;&lt;!--jar:执行package会打包成jar包 war：执行package会打包成war包pom：用于maven工程的继承，通常父工程设置为pom--&gt;</code></pre><h3 id="5-4-pom基本配置"><a href="#5-4-pom基本配置" class="headerlink" title="5.4 pom基本配置"></a>5.4 <code>pom</code>基本配置</h3><p><code>pom.xml</code>是<code>Maven</code>项目的核心配置文件，位于每个工程的根目录，基本配置如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;project&gt;文件的根节点&lt;&#x2F;project&gt;&lt;modelversion&gt;pom.xml使用的对象模型版本&lt;&#x2F;modelversion&gt;&lt;groupId&gt;项目名称，一般写项目的域名&lt;&#x2F;groupId&gt;&lt;artifactld&gt;模块名称或子项目名&lt;&#x2F;artifactld&gt;&lt;version&gt;产品的版本号&lt;&#x2F;version&gt;&lt;packaging&gt;打包类型，有jar、war、pom等&lt;&#x2F;packaging&gt;&lt;name&gt;项目的显示名，常用于Maven生成的文档&lt;&#x2F;name&gt;&lt;description&gt;项目描述，常用于Maven生成的文档&lt;&#x2F;description&gt;&lt;dependencies&gt;项目依赖构件配置，配置项目依赖构件的坐标&lt;&#x2F;dependencies&gt;&lt;build&gt;项目构建配置，配置编译、运行插件等&lt;&#x2F;build&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据库</title>
      <link href="/DataBase/Redis-Basic.html"/>
      <url>/DataBase/Redis-Basic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><code>Redis</code>是一款高性能的NOSQL系列的非关系型数据库，完全开源免费的数据库，key-value型数据库，遵守BSD协议。</p><a id="more"></a><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-什么是NOSQL"><a href="#1-1-什么是NOSQL" class="headerlink" title="1.1 什么是NOSQL"></a>1.1 什么是NOSQL</h3><p><code>NoSQL(NoSQL = Not Only SQL)</code>，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p><p>随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p><h4 id="1-1-1-NoSQL和关系型数据库比较"><a href="#1-1-1-NoSQL和关系型数据库比较" class="headerlink" title="1.1.1 NoSQL和关系型数据库比较"></a>1.1.1 NoSQL和关系型数据库比较</h4><ul><li>优点：<ul><li>成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</li><li>查询速度：nosql数据库将数据存储在缓存中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</li><li>存储数据的格式： nosql存储格式是key-value形式、文档形式，图片形式等等，所以可以存储基础类型以及对象或是集合等各种格式，而数据库则只支持基础类型。</li><li>扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很难。</li></ul></li><li>缺点：<ul><li>维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库十几年的技术同日而语。</li><li>不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定的用户学习成本和使用成本。</li><li>不提供关系型数据库对事务的处理。</li></ul></li></ul><h4 id="1-1-2-关系型数据库的优势"><a href="#1-1-2-关系型数据库的优势" class="headerlink" title="1.1.2 关系型数据库的优势"></a>1.1.2 关系型数据库的优势</h4><ol><li>复杂查询可以用SQL语句方便的在单表或多表之间做非常<strong>复杂的数据查询</strong>。</li><li><strong>事务支持</strong>使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</li></ol><h4 id="1-1-3-非关系型数据库的优势"><a href="#1-1-3-非关系型数据库的优势" class="headerlink" title="1.1.3 非关系型数据库的优势"></a>1.1.3 非关系型数据库的优势</h4><ol><li>NoSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所有<strong>性能非常高</strong>。</li><li>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平<strong>扩展</strong>。</li></ol><h4 id="1-1-4-总结"><a href="#1-1-4-总结" class="headerlink" title="1.1.4 总结"></a>1.1.4 总结</h4><ol><li>关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL时使用NoSQL数据库。</li><li>使用NoSQL数据库对关系型数据库的不足进行弥补。</li><li>一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据。</li></ol><h3 id="1-2-主流的NoSQL产品"><a href="#1-2-主流的NoSQL产品" class="headerlink" title="1.2 主流的NoSQL产品"></a>1.2 主流的NoSQL产品</h3><ul><li>键值存储数据库<ul><li>相关产品：Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</li><li>典型应用：内容缓存，主要用于处理大量数据的高访问负载。</li><li>数据模型：一系列键值对</li><li>优势：快速查询</li><li>劣势：存储的数据缺少结构化</li></ul></li><li>列存储数据库<ul><li>相关产品：Cassandra, HBase, Riak</li><li>典型应用：分布式的文件系统</li><li>数据模型：以列簇式存储，将同一列数据存在一起</li><li>优势：查找速度快，可扩展性强，更容易进行分布式扩展</li><li>劣势：功能相对局限</li></ul></li><li>文档性数据库<ul><li>相关产品：CouchDB、MongoDB</li><li>典型应用：Web应用（与Key-Value类似，Value是结构化的）</li><li>数据模型：一系列键值对</li><li>优势：数据结构要求不严格</li><li>劣势：查询性能不高，且缺乏统一的查询语法</li></ul></li><li>图形(Graph)数据库<ul><li>相关数据库：Neo4J、InfoGrid、Infinite Graph</li><li>典型应用：社交网络</li><li>数据模型：图结构</li><li>优势：利用图结构相关算法</li><li>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</li></ul></li></ul><h3 id="1-3-什么是Redis"><a href="#1-3-什么是Redis" class="headerlink" title="1.3 什么是Redis"></a>1.3 什么是Redis</h3><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p><ol><li>字符串类型：string</li><li>哈希类型：hash</li><li>列表类型：list</li><li>集合类型：set</li><li>有序集合类型：sortedset</li></ol><h4 id="1-3-1-redis的应用场景"><a href="#1-3-1-redis的应用场景" class="headerlink" title="1.3.1 redis的应用场景"></a>1.3.1 redis的应用场景</h4><p>缓存（数据查询、短连接、新闻内容、商品内容等等）</p><ul><li>聊天室的在线好友列表</li><li>任务队列。（秒杀、抢购、12306等等）</li><li>应用排行榜</li><li>网站访问统计</li><li>数据过期处理（可以精确到毫秒</li><li>分布式集群架构中的session分离</li></ul><h2 id="2-下载与安装"><a href="#2-下载与安装" class="headerlink" title="2. 下载与安装"></a>2. 下载与安装</h2><ol><li>官网：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></li><li>中文网：<a href="https://www.redis.net.cn/" target="_blank" rel="noopener">https://www.redis.net.cn/</a></li><li>windows下载地址：<a href="https://github.com/dmajkic/redis/downloads" target="_blank" rel="noopener">https://github.com/dmajkic/redis/downloads</a></li><li>安装与使用：解压即可直接使用<ul><li><code>redis.windows.conf</code>：配置文件</li><li><code>redis-cli.exe</code>：redis的客户端</li><li><code>redis-server.exe</code>：redis服务器端</li></ul></li><li>Redis桌面管理工具：<a href="https://redisdesktop.com/download" target="_blank" rel="noopener">下载地址</a></li><li>安装为windows服务：<code>redis-server.exe --service-install redis.windows.conf</code><ul><li>启动服务：<code>redis-server --service-start</code></li><li>停止服务：<code>redis-server --service-stop</code></li><li>卸载服务：<code>redis-server --service-uninstall</code></li><li>连接客户端：<code>redis-cli</code>&amp;<code>redis-cli -h [服务器地址] -p [指定端口号] -a [连接数据库的密码,在conf中配置，默认无]</code></li></ul></li></ol><p>安装与部署服务参考<a href="https://www.cnblogs.com/dingguofeng/p/8709476.html" target="_blank" rel="noopener">文章</a></p><h2 id="3-命令操作"><a href="#3-命令操作" class="headerlink" title="3. 命令操作"></a>3. 命令操作</h2><h3 id="3-1-redis的数据结构"><a href="#3-1-redis的数据结构" class="headerlink" title="3.1 redis的数据结构"></a>3.1 redis的数据结构</h3><ul><li>redis存储的是：<code>key-value</code>格式的数据，其中key都是字符串，value有5种不同的数据结构。</li></ul><h4 id="value的五种数据结构"><a href="#value的五种数据结构" class="headerlink" title="value的五种数据结构"></a>value的五种数据结构</h4><ol><li>字符串类型：<code>string</code></li><li>哈希类型<code>hash</code>：<code>ma</code>p格式</li><li>列表类型 <code>list</code>：<code>linkedlis</code>t格式。支持重复元素</li><li>集合类型 <code>set</code>：不允许重复元素</li><li>有序集合类型<code>sortedset</code>：不允许重复元素，且元素有顺序</li></ol><h3 id="3-2-字符串类型-String"><a href="#3-2-字符串类型-String" class="headerlink" title="3.2 字符串类型:String"></a>3.2 字符串类型:<code>String</code></h3><ul><li>存储：<code>set key value</code></li><li>获取：<code>get key</code></li><li>删除：<code>del key</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-powershell">127.0.0.1:6379&gt; set ts teststringOK127.0.0.1:6379&gt; get ts&quot;teststring&quot;127.0.0.1:6379&gt; del ts(integer) 1</code></pre><h3 id="3-3-哈希类型-Hash"><a href="#3-3-哈希类型-Hash" class="headerlink" title="3.3 哈希类型:Hash"></a>3.3 哈希类型:<code>Hash</code></h3><ul><li>存储：<code>hset key field value</code></li><li>获取：<ul><li><code>hget key field</code>：获取指定的<code>field</code>对应的值</li><li><code>hgetall key</code>：获取所有的<code>field</code>和<code>value</code></li></ul></li><li>删除：<code>hdel key field</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-powershell">127.0.0.1:6379&gt; hset myhash username shangsan(integer) 1127.0.0.1:6379&gt; hset myhash password 123(integer) 1127.0.0.1:6379&gt; hget myhash username&quot;shangsan&quot;127.0.0.1:6379&gt; hgetall myhash1) &quot;username&quot;2) &quot;shangsan&quot;3) &quot;password&quot;4) &quot;123&quot;127.0.0.1:6379&gt; hdel myhash username(integer) 1127.0.0.1:6379&gt; hdel myhash password(integer) 1</code></pre><h3 id="3-4-列表类型-List"><a href="#3-4-列表类型-List" class="headerlink" title="3.4 列表类型:List"></a>3.4 列表类型:<code>List</code></h3><p>可以添加一个元素到列表的头部(左边)或尾部(右边)</p><ul><li>添加：<ul><li><code>lpush key value</code>：将元素加入列表左边。</li><li><code>rpush key value</code>：将元素加入列表右边</li></ul></li><li>获取：<code>lrange key start end</code>，获取指定范围的元素数据</li><li>删除：<ul><li><code>lpop key</code>：删除列表最左边的元素，并将元素返回。从左出栈</li><li><code>rpop key</code>：删除列表最右边的元素，并返回。从右出栈</li></ul></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-powershell">127.0.0.1:6379&gt; lpush mylist c(integer) 9998127.0.0.1:6379&gt; lpush mylist b(integer) 9999127.0.0.1:6379&gt; lpush mylist a(integer) 10000127.0.0.1:6379&gt; lrange mylist 0 21) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;127.0.0.1:6379&gt; lpop mylist&quot;a&quot;127.0.0.1:6379&gt; lpop mylist&quot;b&quot;127.0.0.1:6379&gt; lpop mylist&quot;c&quot;</code></pre><h3 id="3-5-集合类型-set"><a href="#3-5-集合类型-set" class="headerlink" title="3.5 集合类型:set"></a>3.5 集合类型:<code>set</code></h3><p>不允许重复元素</p><ul><li>存储：<code>add key value</code></li><li>获取：<code>smembers key</code>，获取集合中所有元素</li><li>删除：<code>srem key value</code>，删除集合中的某个元素</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-powershell">127.0.0.1:6379&gt; sadd myset a(integer) 1127.0.0.1:6379&gt; sadd myset a(integer) 0127.0.0.1:6379&gt; smembers myset1) &quot;a&quot;127.0.0.1:6379&gt; srem myset a(integer) 1</code></pre><h3 id="3-6-有序集合类型-sortedset"><a href="#3-6-有序集合类型-sortedset" class="headerlink" title="3.6 有序集合类型:sortedset"></a>3.6 有序集合类型:<code>sortedset</code></h3><p>不允许重复元素，且元素有顺序。每个元素都会关联一个<code>double</code>类型的分数。<code>redis</code>正是通过分数来为集合中的成员进行从小到大的排序。</p><ul><li>存储：<code>zadd key score vlaue</code></li><li>获取：<code>zrange key start end [withscores]</code>，withscores可以在获取时同时获取分数。</li><li>删除：<code>zrem key value</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-powershell">127.0.0.1:6379&gt; zadd mysort 50 zhangsan(integer) 1127.0.0.1:6379&gt; zadd mysort 36 lisi(integer) 1127.0.0.1:6379&gt; zadd mysort 88 wangwu(integer) 1127.0.0.1:6379&gt; zrange mysort 0 -11) &quot;lisi&quot;2) &quot;zhangsan&quot;3) &quot;wangwu&quot;127.0.0.1:6379&gt; zrem mysort lisi(integer) 1127.0.0.1:6379&gt; zrange mysort 0 -11) &quot;zhangsan&quot;2) &quot;wangwu&quot;</code></pre><h3 id="3-7-通用命令"><a href="#3-7-通用命令" class="headerlink" title="3.7 通用命令"></a>3.7 通用命令</h3><ol><li><code>keys *</code>：查询所有的键</li><li><code>type key</code>：获取键对应的<code>value</code>类型</li><li><code>del key</code>：删除指定的<code>key valu</code></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-powershell">127.0.0.1:6379&gt; keys *1) &quot;counter:__rand_int__&quot;2) &quot;mylist&quot;3) &quot;key:__rand_int__&quot;4) &quot;mysort&quot;127.0.0.1:6379&gt; type mylistlist127.0.0.1:6379&gt; type mysortzset127.0.0.1:6379&gt; del mylist(integer) 1</code></pre><h2 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4. 持久化"></a>4. 持久化</h2><p><code>redis</code>是一个内存数据库，当<code>redis</code>服务器重启或电脑重启时，数据会丢失。我们可以将<code>redis</code>内存中的数据持久化保存到硬盘的文件中。</p><h4 id="4-1-redis持久化机制"><a href="#4-1-redis持久化机制" class="headerlink" title="4.1 redis持久化机制"></a>4.1 redis持久化机制</h4><ul><li><p>RDB：默认方式，不需要进行配置。在一定的间隔时间中，检测key的变化情况，然后持久化数据。</p><ul><li><p>编辑<code>redis.windows.conf</code>文件</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-properties">    #   after 900 sec (15 min) if at least 1 key changed    save 900 1    #   after 300 sec (5 min) if at least 10 keys changed    save 300 10    #   after 60 sec if at least 10000 keys changed    save 60 10000</code></pre></li></ul></li></ul><ul><li>重启redis服务器，并指定配置文件名称：<code>redis-server.exe redis.windows.conf</code></li></ul><ul><li><p>AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据。</p><ul><li><p>编辑<code>redis.windows.conf</code>文件</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-properties">    # 开启AOF    appendonly yes    # 三种同步方式:    # 1. 每一次操作都进行持久化    # appendfsync always     # 2. 每隔一秒进行一次持久化，缺省值    appendfsync everysec    # 3. 不进行持久化    # appendfsync no</code></pre></li></ul></li></ul><ul><li>重启服务器，指定配置文件。</li></ul><h2 id="5-Java客户端：Jedis"><a href="#5-Java客户端：Jedis" class="headerlink" title="5. Java客户端：Jedis"></a>5. Java客户端：<code>Jedis</code></h2><p><code>Jedis</code>是一款java操作redis数据库的工具。</p><h3 id="5-1Jedis操作各种Redis中的数据结构"><a href="#5-1Jedis操作各种Redis中的数据结构" class="headerlink" title="5.1Jedis操作各种Redis中的数据结构"></a>5.1<code>Jedis</code>操作各种<code>Redis</code>中的数据结构</h3><h4 id="5-1-1-字符串类型："><a href="#5-1-1-字符串类型：" class="headerlink" title="5.1.1 字符串类型："></a>5.1.1 字符串类型：</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test2(){    &#x2F;&#x2F; 1. 获取连接    Jedis jedis = new Jedis(); &#x2F;&#x2F; 如果使用空参构造，默认值&#39;localhost&#39;,6379    &#x2F;&#x2F; 2. 操作    &#x2F;&#x2F; 存储    jedis.set(&quot;username&quot;,&quot;wangwu&quot;);    &#x2F;&#x2F; 获取    String username = jedis.get(&quot;username&quot;);    System.out.println(username);    &#x2F;&#x2F; 可以使用setex()方法存储指定过期时间的 key value    jedis.setex(&quot;activecode&quot;,20,&quot;gj8a&quot;); &#x2F;&#x2F;将activecode：gj8a键值对存入redis，并且20秒后自动删除该键值对    &#x2F;&#x2F; 3. 关闭连接    jedis.close();}</code></pre><h4 id="5-1-2-哈希类型："><a href="#5-1-2-哈希类型：" class="headerlink" title="5.1.2 哈希类型："></a>5.1.2 哈希类型：</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test3(){    &#x2F;&#x2F; 1. 获取连接    Jedis jedis = new Jedis();    &#x2F;&#x2F; 2. 操作    &#x2F;&#x2F; 存储hash    jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);    jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);    jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);    &#x2F;&#x2F; 获取hash    String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);    System.out.println(name);    &#x2F;&#x2F; 获取hash的所有map中的数据    Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;);    Set&lt;String&gt; keySet = user.keySet();    for (String key:keySet) {        String value = user.get(key);        System.out.println(key+&quot;:&quot;+value);    }    &#x2F;&#x2F; 3. 关闭连接    jedis.close();}</code></pre><h4 id="5-1-3-列表类型："><a href="#5-1-3-列表类型：" class="headerlink" title="5.1.3 列表类型："></a>5.1.3 列表类型：</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test4() {    &#x2F;&#x2F; 1. 获取连接    Jedis jedis = new Jedis();    &#x2F;&#x2F; 2. 操作    jedis.del(&quot;mylist&quot;);    &#x2F;&#x2F; list存储    jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); &#x2F;&#x2F; 从左边存    jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); &#x2F;&#x2F; 从右边存    &#x2F;&#x2F; 获取    List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);    System.out.println(mylist); &#x2F;&#x2F; [c, b, a, a, b, c]    &#x2F;&#x2F; 弹出    String element1 = jedis.lpop(&quot;mylist&quot;);    System.out.println(element1);    String element2 = jedis.rpop(&quot;mylist&quot;);    System.out.println(element2);    List&lt;String&gt; mylist２ = jedis.lrange(&quot;mylist&quot;, 0, -1);    System.out.println(mylist２);    &#x2F;&#x2F; 3.关闭连接    jedis.close();}</code></pre><h4 id="5-1-4-集合类型："><a href="#5-1-4-集合类型：" class="headerlink" title="5.1.4 集合类型："></a>5.1.4 集合类型：</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test5() {    &#x2F;&#x2F; 1. 获取连接    Jedis jedis = new Jedis();    &#x2F;&#x2F; 2. 操作    &#x2F;&#x2F; 存储    jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c&quot;);    &#x2F;&#x2F; 获取    Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);    System.out.println(myset);    jedis.close();}</code></pre><h4 id="5-1-5-有序集合类型："><a href="#5-1-5-有序集合类型：" class="headerlink" title="5.1.5 有序集合类型："></a>5.1.5 有序集合类型：</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Testpublic void test6() {    &#x2F;&#x2F; 1. 获取连接    Jedis jedis = new Jedis();    &#x2F;&#x2F; 2. 操作    &#x2F;&#x2F; 存储    jedis.zadd(&quot;mysortedset&quot;,8,&quot;亚索&quot;);    jedis.zadd(&quot;mysortedset&quot;,6,&quot;剑圣&quot;);    jedis.zadd(&quot;mysortedset&quot;,3,&quot;vn&quot;);    &#x2F;&#x2F; 获取    Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1);    System.out.println(mysortedset); &#x2F;&#x2F; [vn, 剑圣, 亚索]    jedis.close();}</code></pre><h3 id="5-2-Jedis连接池：JedisPool"><a href="#5-2-Jedis连接池：JedisPool" class="headerlink" title="5.2 Jedis连接池：JedisPool"></a>5.2 <code>Jedis</code>连接池：<code>JedisPool</code></h3><ul><li>使用方法：<ul><li>创建<code>JedisPool</code>连接池对象</li><li>调用方法<code>getResource()</code>方法获取<code>Jedis</code>连接</li></ul></li></ul><h4 id="5-2-1-jedis详细配置"><a href="#5-2-1-jedis详细配置" class="headerlink" title="5.2.1 jedis详细配置"></a>5.2.1 <code>jedis</code>详细配置</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-properties">#最大活动对象数     redis.pool.maxTotal=1000    #最大能够保持idel状态的对象数      redis.pool.maxIdle=100  #最小能够保持idel状态的对象数   redis.pool.minIdle=50    #当池内没有返回对象时，最大等待时间    redis.pool.maxWaitMillis=10000    #当调用borrow Object方法时，是否进行有效性检查    redis.pool.testOnBorrow=true    #当调用return Object方法时，是否进行有效性检查    redis.pool.testOnReturn=true  #“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1.  redis.pool.timeBetweenEvictionRunsMillis=30000  #向调用者输出“链接”对象时，是否检测它的空闲超时；redis.pool.testWhileIdle=true  # 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3.  redis.pool.numTestsPerEvictionRun=50  #redis服务器的IP    redis.ip=xxxxxx  #redis服务器的Port    redis1.port=6379   </code></pre><h4 id="5-2-2-自定义jedis工具类"><a href="#5-2-2-自定义jedis工具类" class="headerlink" title="5.2.2 自定义jedis工具类"></a>5.2.2 自定义<code>jedis</code>工具类</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.zero.jedis.util;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.io.IOException;import java.io.InputStream;import java.util.Properties;&#x2F;** * JedisPool工具类 *  加载配置文件，配置连接池参数 *  提供获取连接的方法 *&#x2F;public class JedisPoolUtils {    private static JedisPool jedisPool;    static {        &#x2F;&#x2F; 读取配置文件        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);        &#x2F;&#x2F; 创建Properties对象        Properties pro = new Properties();        &#x2F;&#x2F; 关联文件        try {            pro.load(is);        } catch (IOException e) {            e.printStackTrace();        }        &#x2F;&#x2F; 获取数据，设置到JedisPoolConfig中        JedisPoolConfig config = new JedisPoolConfig();        config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));        config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));        &#x2F;&#x2F; 初始化JedisPool        jedisPool = new JedisPool(config, pro.getProperty(&quot;host&quot;), Integer.parseInt(pro.getProperty(&quot;port&quot;)));    }        &#x2F;**     * 获取连接方法     * @return     *&#x2F;    public static Jedis getJedis(){        return jedisPool.getResource();    }}</code></pre><h2 id="6-练习"><a href="#6-练习" class="headerlink" title="6. 练习"></a>6. 练习</h2><h3 id="6-1-需求"><a href="#6-1-需求" class="headerlink" title="6.1 需求"></a>6.1 需求</h3><ol><li>提供index.html页面，页面中有一个省份下拉列表</li><li>当 页面加载完毕后 发送ajax请求，加载所有省份。</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/07/14/4.%E6%A1%88%E4%BE%8B-1563119468012.bmp" alt="title"></p><ul><li>注意：使用redis缓存一些不经常发生变化的数据。<ul><li>数据库的数据一旦发生改变，则需要更新缓存。<ul><li>数据库的表执行 <strong>增删改</strong>的相关操作，需要将redis缓存数据清空，再次存入。</li><li>在service对应的增删改方法中，将redis数据删除。</li></ul></li></ul></li></ul><h3 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h3><p>后端service实现类核心代码：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;**     * 使用redis缓存     * @return     *&#x2F;    @Override    public String findAllJson() {        &#x2F;&#x2F; 1. 先从redis中查询数据        &#x2F;&#x2F; 1.1 获取redis客户端连接对象        Jedis jedis = JedisPoolUtils.getJedis();        &#x2F;&#x2F; 1.2 查询数据        String province_json = jedis.get(&quot;province&quot;);        &#x2F;&#x2F; 2. 判断province_json 是否为null        if (province_json == null || province_json.length() == 0){            &#x2F;&#x2F; redis中无数据            System.out.println(&quot;redis中无数据，查询数据库...&quot;);            &#x2F;&#x2F; 2.1 从数据库中查询            List&lt;Province&gt; ps = dao.findAll();            &#x2F;&#x2F; 2.2 将list序列化为json            ObjectMapper mapper = new ObjectMapper();            try {                province_json = mapper.writeValueAsString(ps);            } catch (JsonProcessingException e) {                e.printStackTrace();            }            &#x2F;&#x2F; 2.3 将json数据存入redis中            jedis.set(&quot;province&quot;,province_json);            &#x2F;&#x2F; 归还连接            jedis.close();        }else {            System.out.println(&quot;redis中有数据，查询缓存...&quot;);            System.out.println(province_json);        }        return province_json;    }</code></pre><p>后端servlet代码：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.zero.web.servlet;import cn.zero.domain.Province;import cn.zero.service.impl.ProvinceServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import javax.servlet.annotation.WebServlet;import java.io.IOException;import java.util.List;@WebServlet(&quot;&#x2F;provinceServlet&quot;)public class ProvinceServlet extends javax.servlet.http.HttpServlet {    protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {&#x2F;&#x2F;        &#x2F;&#x2F; 1. 调用service查询&#x2F;&#x2F;        ProvinceServiceImpl service = new ProvinceServiceImpl();&#x2F;&#x2F;        List&lt;Province&gt; list = service.findAll();&#x2F;&#x2F;        &#x2F;&#x2F; 2. 序列化list为json&#x2F;&#x2F;        ObjectMapper mapper = new ObjectMapper();&#x2F;&#x2F;        String json = mapper.writeValueAsString(list);        ProvinceServiceImpl service = new ProvinceServiceImpl();        String json = service.findAllJson();        System.out.println(json);        &#x2F;&#x2F; 3. 响应结果        response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;);        response.getWriter().write(json);    }    protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {        this.doPost(request, response);    }}</code></pre><p>前端代码：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Province&lt;&#x2F;title&gt;    &lt;script src=&quot;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        $(function () {            &#x2F;&#x2F; 发送ajax请求，加载所有省份数据            $.get(&quot;provinceServlet&quot;,{},function (data) {                &#x2F;&#x2F; data = [{&quot;id&quot;:1,&quot;name&quot;:&quot;北京&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;上海&quot;},{&quot;id&quot;:3,&quot;name&quot;:&quot;广州&quot;},{&quot;id&quot;:4,&quot;name&quot;:&quot;深圳&quot;}]                &#x2F;&#x2F; 1. 获取select                var province = $(&quot;#province&quot;);                &#x2F;&#x2F; 2. 遍历json数组                $(data).each(function () {                    &#x2F;&#x2F; 3. 创建&lt;option&gt;                    var option = &quot;&lt;option name=&#39;&quot;+this.id+&quot;&#39;&gt;&quot;+this.name+&quot;&lt;&#x2F;option&gt;&quot;                    &#x2F;&#x2F; 4. 调用select的append追加option                    province.append(option);                });            });        });    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;select name=&quot;&quot; id=&quot;province&quot;&gt;        &lt;option value=&quot;&quot;&gt;--请选择省份--&lt;&#x2F;option&gt;    &lt;&#x2F;select&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX和Json</title>
      <link href="/JavaWeb/ajax-json.html"/>
      <url>/JavaWeb/ajax-json.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>Ajax 即“<strong>A</strong>synchronous <strong>J</strong>avascript <strong>A</strong>nd <strong>X</strong>ML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。</p><a id="more"></a><p> <strong>同步和异步</strong>：在客户端和服务器端相互通信的基础上。</p><ul><li>同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</li><li>异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他操作。</li></ul><p>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p><p>Ajax可以<strong>提升用户的体验</strong>。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="1-原生的JS实现方式"><a href="#1-原生的JS实现方式" class="headerlink" title="1. 原生的JS实现方式"></a>1. 原生的JS实现方式</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;    &#x2F;&#x2F; 定义方法    function fun() {        &#x2F;&#x2F; 发送异步请求        &#x2F;&#x2F; 1. 创建核心对象(固定写法)        var xmlhttp;        if (window.XMLHttpRequest)        {&#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari            xmlhttp=new XMLHttpRequest();        }        else        {&#x2F;&#x2F; code for IE6, IE5            xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);        }        &#x2F;&#x2F; 2. 建立连接        &#x2F;*                参数：                1. 请求方式：GET,POST                   - get方式：请求参数在URL后边拼接。send方法为空参                   - post方式：请求参数在send方法中定义                2. 请求的URL：                3. 同步还是异步请求：true异步，false同步        *&#x2F;        xmlhttp.open(&quot;GET&quot;,&quot;&#x2F;Demo7_10&#x2F;ajaxServlet?username=xiaoming&quot;,true);        &#x2F;&#x2F; 3. 发送请求        xmlhttp.send();        &#x2F;&#x2F; 4. 接受和处理来自服务器的响应结果        &#x2F;&#x2F; 获取方式：xmlhttp.responseText; 什么时候获取? 当服务器响应成功后再获取        &#x2F;&#x2F; 当xmlhttp对象的就绪状态改变时，触发事件：onreadystatechange。        xmlhttp.onreadystatechange=function()        {            &#x2F;&#x2F; 判断readyState就绪状态是否为4，并且status状态码为200            if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)            {                &#x2F;&#x2F; 获取服务器的响应结果                var responseText = xmlhttp.responseText;                alert(responseText);            }        }}&lt;&#x2F;script&gt;</code></pre><h4 id="2-JQuery实现方式"><a href="#2-JQuery实现方式" class="headerlink" title="2. JQuery实现方式"></a>2. JQuery实现方式</h4><ol><li><p><code>$.ajax()</code>，语法：<code>$.ajax({键值对})</code>；</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">   &lt;script&gt;       &#x2F;&#x2F; 定义方法       function fun() {           &#x2F;&#x2F; 使用 $.ajax()发送异步请求           $.ajax({               url:&quot;ajaxServlet&quot;,&#x2F;&#x2F; 请求路径               type:&quot;POST&quot;, &#x2F;&#x2F; 请求方式               &#x2F;&#x2F; data:&quot;username=jack$age=23&quot;, &#x2F;&#x2F; 请求参数               data:{&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23},               success:function (data) {                   alert(data);               }, &#x2F;&#x2F; 响应成功后执行的函数               error:function () {                   alert(&quot;出错啦...&quot;)               }, &#x2F;&#x2F; 表示如果请求响应出现错误，会执行的回调函数               dataType:&quot;text&quot; &#x2F;&#x2F; 设置接受到的响应数据的格式           });   }   &lt;&#x2F;script&gt;</code></pre></li></ol><ol start="2"><li><p><code>$.get()</code>，发送get请求，语法：<code>$.get(url,[data],[callback],[type])</code>，参数如下。</p><ul><li><code>url</code>：请求路径</li><li><code>data</code>：请求参数</li><li><code>callback</code>：回调函数</li><li><code>type</code>：响应结果的类型</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">   &lt;script&gt;       &#x2F;&#x2F; 定义方法       function fun() {           &#x2F;&#x2F; 使用 $.get()发送异步请求           $.get(&quot;ajaxServlet&quot;,{username:&quot;rose&quot;},function (data) {               alert(data);           },&quot;text&quot;);   }   &lt;&#x2F;script&gt;</code></pre></li></ol><ol start="3"><li><code>$.post()</code>，发送post请求，语法：<code>$.post(url,[data],[callback],[type])</code>，参数同上。</li></ol><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li><p>JSON 指的是 JavaScript 对象表示法（<em>J</em>ava<em>S</em>cript <em>O</em>bject <em>N</em>otation），是一种轻量级的数据交换格式。</p></li><li><p><strong>JSON 是存储和交换文本信息的语法。</strong></p></li><li>进行数据的传输。</li><li><strong>JSON 比 XML 更小、更快，更易解析。</strong></li></ul><h3 id="2-JSON-语法规则"><a href="#2-JSON-语法规则" class="headerlink" title="2.  JSON 语法规则"></a>2.  JSON 语法规则</h3><h4 id="2-1-基本规则"><a href="#2-1-基本规则" class="headerlink" title="2.1 基本规则"></a>2.1 基本规则</h4><p>JSON 语法是 JavaScript 对象表示法语法的子集。</p><ul><li>数据在名称/值对中：json数据是由键值对构成的<ul><li>键用引号(单双都可)引起来，也可以不使用引号。</li><li>值的取值类型：<ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true或false）</li><li>数组（在方括号中），例：<code>{&quot;persons&quot;:[{},{}]}</code></li><li>对象（在花括号中），例：<code>{&quot;address&quot;:{&quot;province&quot;:&quot;杭州&quot;...}}</code></li><li>null</li></ul></li></ul></li><li>数据由逗号分隔：多个键值对由逗号分隔</li><li>花括号保存对象：使用<code>{}</code>定义json格式</li><li>方括号保存数组：<code>[]</code></li></ul><h4 id="2-2-获取数据"><a href="#2-2-获取数据" class="headerlink" title="2.2 获取数据"></a>2.2 获取数据</h4><ol><li>json对象.键名</li><li>json对象[“键名”]</li><li>数组对象[索引]</li><li>遍历</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript"> &lt;script&gt;    &#x2F;&#x2F; 1. 定义基本格式    var person = {name:&quot;xiaozhang&quot;,age:23,&#39;gender&#39;:true};    var ps = [        {name:&quot;xiaozhang&quot;,age:23,&#39;gender&#39;:true},        {name:&quot;xiaoli&quot;,age:25,&#39;gender&#39;:true},        {name:&quot;xiaohua&quot;,age:19,&#39;gender&#39;:false}];    &#x2F;&#x2F; 获取person对象中的所有键和值    &#x2F;&#x2F; for in 循环    for(var key in person){        alert(key+&quot;：&quot;+person[key]);    }    &#x2F;&#x2F; 获取ps数组中所有对象的键值    for (var i = 0; i &lt; ps.length; i++){        var p = ps[i];        for (var key in p){            alert(key+&quot;：&quot;+p[key]);        }    }&lt;&#x2F;script&gt;</code></pre><h4 id="2-3-JSON数据和Java对象的相互转换"><a href="#2-3-JSON数据和Java对象的相互转换" class="headerlink" title="2.3 JSON数据和Java对象的相互转换"></a>2.3 JSON数据和Java对象的相互转换</h4><ul><li>JSON解析器，常见的解析器有：<code>Jsonlib,Gson,fastjson,jackson</code></li></ul><h5 id="2-3-1-JSON转为Java对象"><a href="#2-3-1-JSON转为Java对象" class="headerlink" title="2.3.1 JSON转为Java对象"></a>2.3.1 JSON转为Java对象</h5><ul><li>导入<code>jackson</code>的相关jar包</li><li>创建<code>jackson</code>核心对象：<code>ObjectMapper</code></li><li>调用<code>ObjectMapper</code>的相关方法进行转换：<code>readValue(json字符串数据，Class)</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 演示JSON字符串转换为Java对象@Testpublic void test5() throws Exception {    &#x2F;&#x2F; 1. 初始化JSON字符串    String json = &quot;{\&quot;gender\&quot;:\&quot;男\&quot;,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:23}&quot;;    &#x2F;&#x2F; 2. 创建ObjectMapper对象    ObjectMapper mapper = new ObjectMapper();    &#x2F;&#x2F; 3. 转为Java对象 Person    Person person = mapper.readValue(json, Person.class);    System.out.println(person); &#x2F;&#x2F; Person{name=&#39;张三&#39;, age=23, gender=&#39;男&#39;, birthday=null}}</code></pre><h5 id="2-3-2-Java对象转为JSON"><a href="#2-3-2-Java对象转为JSON" class="headerlink" title="2.3.2 Java对象转为JSON"></a>2.3.2 Java对象转为JSON</h5><ol><li>导入<code>jackson</code>的相关jar包</li><li>创建<code>jackson</code>核心对象：<code>ObjectMapper</code></li><li>调用<code>ObjectMapper</code>的相关方法进行转换</li></ol><p><strong>转换方法</strong>：</p><ul><li><code>writeValue(参数，obj)</code></li><li>常用参数：<ul><li><code>File</code>：将obj对象转换为json字符串，并保存到指定的文件中。</li><li><code>Writer</code>：将obj对象转换为json字符串，并将json数据填充到字符输出流中。</li><li><code>OutputStream</code>：将obj对象转换为json字符串，并将json数据填充到字节输出流中。</li></ul></li><li><code>writeValueAsString(obj)</code>：将对象转换为json字符串</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public void test1() throws Exception {        &#x2F;&#x2F; 1. 创建Person对象    Person person = new Person();    person.setName(&quot;张三&quot;);    person.setAge(23);    person.setGender(&quot;男&quot;);    &#x2F;&#x2F; 2. 创建Jackson核心对象 ObjectMapper    ObjectMapper mapper = new ObjectMapper();    &#x2F;&#x2F; 3. 调用方法转换    String json = mapper.writeValueAsString(person);    System.out.println(json); &#x2F;&#x2F; {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;}    &#x2F;&#x2F; writeValue,将数据写到d:&#x2F;&#x2F;json.txt中    mapper.writeValue(new File(&quot;d:&#x2F;&#x2F;json.txt&quot;),person);    &#x2F;&#x2F; writeValue,将数据关联到Writer中    mapper.writeValue(new FileWriter(&quot;d:&#x2F;&#x2F;json2.txt&quot;),person);}</code></pre><p><strong>注解</strong>：</p><ul><li><p><code>@JsonIgnore</code>：排除属性</p></li><li><p><code>@JsonFormat</code>：属性值格式化</p><ul><li><code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</code></li></ul></li></ul><p><strong>复杂Java对象转换</strong>：</p><ul><li><code>List</code>：数组</li><li><code>Map</code>：对象格式一致</li></ul><h3 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h3><p>用户注册页面，输入用户名，异步请求数据库验证用户名是否存在。</p><ul><li>服务器响应的数据，在客户端使用时，要想当做json数据格式使用，方法有如下：<ul><li><code>$.get(type);</code>将最后一个参数type指定为“json”；</li><li>在服务器端设置MIME类型：<code>response.setContentType(&quot;application/json;charset=utf-8&quot;);</code></li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>前端部分：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;用户注册&lt;&#x2F;title&gt;    &lt;script src=&quot;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        &#x2F;&#x2F; 在页面加载完成后        $(function () {            &#x2F;&#x2F; 给username绑定blur(离焦)事件            $(&quot;#username&quot;).blur(function () {                &#x2F;&#x2F; 获取username文本框输入的值                var username = $(this).val();                &#x2F;&#x2F; 发送ajax请求                &#x2F;&#x2F; 期望服务器响应会的数据格式：{&quot;userExsit&quot;:true,&quot;msg&quot;:&quot;用户名已存在！&quot;}                &#x2F;&#x2F;                        {&quot;userExsit&quot;:false,&quot;msg&quot;:&quot;用户名可用！&quot;}                $.get(&quot;regUserServlet&quot;,{username:username},function (data) {                    var span = $(&quot;#s_username&quot;);                    if (data[&quot;userExsit&quot;] == true){                        &#x2F;&#x2F; 用户名已存在                        span.css(&quot;color&quot;,&quot;red&quot;);                        span.html(data.msg);                    }else{                        &#x2F;&#x2F; 用户名不存在                        span.css(&quot;color&quot;,&quot;green&quot;);                        span.html(data.msg);                    }                })            });        })    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;form action=&quot;&quot;&gt;        &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;        &lt;span id=&quot;s_username&quot;&gt;&lt;&#x2F;span&gt;        &lt;br&gt;        &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;br&gt;        &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>后端部分：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package cn.zero.web.servlet;import com.fasterxml.jackson.databind.ObjectMapper;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;@WebServlet(&quot;&#x2F;regUserServlet&quot;)public class RegUserServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 1. 获取用户名        String username = request.getParameter(&quot;username&quot;);        String json = &quot;{\&quot;userExsit\&quot;:true,\&quot;msg\&quot;:\&quot;用户名已存在！\&quot;}&quot;;        &#x2F;&#x2F; 2. 调用service层判断用户名是否存在        &#x2F;&#x2F; 期望服务器响应会的数据格式：{&quot;userExsit&quot;:true,&quot;msg&quot;:&quot;用户名已存在！&quot;}        &#x2F;&#x2F;                        {&quot;userExsit&quot;:false,&quot;msg&quot;:&quot;用户名可用！&quot;}        &#x2F;&#x2F; 设置响应的数据格式为json        response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); &#x2F;&#x2F; 解决乱码问题        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        if (&quot;张三&quot;.equals(username)) {            map.put(&quot;userExsit&quot;,true);            map.put(&quot;msg&quot;,&quot;用户名已存在，请更换！&quot;);        }else{            map.put(&quot;userExsit&quot;,false);            map.put(&quot;msg&quot;,&quot;用户名可用&quot;);        }        &#x2F;&#x2F; 将map转为json，并传递给客户端        ObjectMapper mapper = new ObjectMapper();        mapper.writeValue(response.getWriter(),map);    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery高级</title>
      <link href="/JavaWeb/JQueryHigh.html"/>
      <url>/JavaWeb/JQueryHigh.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="JQuery高级"><a href="#JQuery高级" class="headerlink" title="JQuery高级"></a>JQuery高级</h2><p>JQuery进阶内容，包括图片显示和隐藏方式、遍历方式、事件绑定方法以及自定义插件。</p><a id="more"></a><h2 id="1-动画"><a href="#1-动画" class="headerlink" title="1. 动画"></a>1. 动画</h2><p>主要有三种方式显示和隐藏元素</p><h3 id="1-1-默认显示和隐藏方式"><a href="#1-1-默认显示和隐藏方式" class="headerlink" title="1.1 默认显示和隐藏方式"></a>1.1 默认显示和隐藏方式</h3><ol><li><code>show([speed,[easing],[fn]])</code></li><li><code>hide([speed,[easing],[fn]])</code></li><li><code>toggle([speed,[easing],[fn]])</code></li></ol><p><strong>通用参数概述</strong>：</p><ol><li><code>speed</code>：动画的速度。三个预定义的值<code>(&quot;slow&quot;,&quot;normal&quot;,&quot;fast&quot;)</code>或表示动画时长的毫秒数值(如：1000)</li><li><code>easing</code>：用来指定切换效果，默认是<code>&quot;swing&quot;</code>(动画执行时效果是：先慢，中间快，最后再慢)，可用参数<code>&quot;linear&quot;</code>(动画执行时速度是匀速的)</li><li><code>fn</code>：在动画完成时执行的函数，每个元素执行一次。</li></ol><h3 id="1-2-滑动显示和隐藏方式"><a href="#1-2-滑动显示和隐藏方式" class="headerlink" title="1.2 滑动显示和隐藏方式"></a>1.2 滑动显示和隐藏方式</h3><ol><li><code>slideDown([speed,[easing],[fn]])</code></li><li><code>slideUp([speed,[easing],[fn]])</code></li><li><code>slideToggle([speed,[easing],[fn]])</code></li></ol><h3 id="1-3-淡入淡出显示和隐藏方式"><a href="#1-3-淡入淡出显示和隐藏方式" class="headerlink" title="1.3 淡入淡出显示和隐藏方式"></a>1.3 淡入淡出显示和隐藏方式</h3><ol><li><code>fadeIn([speed,[easing],[fn]])</code></li><li><code>fadeOut([speed,[easing],[fn]])</code></li><li><code>fadeToggle([speed,[easing],[fn]])</code></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;    &#x2F;&#x2F; 隐藏div    function hideFn() {    &#x2F;&#x2F; 默认方式    &#x2F;&#x2F; $(&quot;#showDiv&quot;).hide(5000,&quot;swing&quot;);    &#x2F;&#x2F; 滑动方式    &#x2F;&#x2F; $(&quot;#showDiv&quot;).slideUp(&quot;slow&quot;);    &#x2F;&#x2F; 淡入淡出方式    $(&quot;#showDiv&quot;).fadeOut(&quot;slow&quot;);}&#x2F;&#x2F; 显示divfunction showFn() {    &#x2F;&#x2F; 默认方式    &#x2F;&#x2F; $(&quot;#showDiv&quot;).show(&quot;slow&quot;,&quot;swing&quot;);    &#x2F;&#x2F; 滑动方式    &#x2F;&#x2F; $(&quot;#showDiv&quot;).slideDown(&quot;slow&quot;);    &#x2F;&#x2F; 淡入淡出方式    $(&quot;#showDiv&quot;).fadeIn(&quot;slow&quot;);}&#x2F;&#x2F; 切换显示和隐藏divfunction toggleFn() {    &#x2F;&#x2F; 默认方式    &#x2F;&#x2F; $(&quot;#showDiv&quot;).toggle(&quot;slow&quot;);    &#x2F;&#x2F; 滑动方式    &#x2F;&#x2F; $(&quot;#showDiv&quot;).slideToggle(&quot;slow&quot;);    &#x2F;&#x2F; 淡入淡出方式    $(&quot;#showDiv&quot;).fadeToggle(&quot;slow&quot;);}&lt;&#x2F;script&gt;</code></pre><h2 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2. 遍历"></a>2. 遍历</h2><h3 id="2-1-JS的遍历方式"><a href="#2-1-JS的遍历方式" class="headerlink" title="2.1 JS的遍历方式"></a>2.1 JS的遍历方式</h3><ul><li><code>for(初始值;循环结束条件;步长)</code></li></ul><h3 id="2-2-JQuery的遍历方式"><a href="#2-2-JQuery的遍历方式" class="headerlink" title="2.2 JQuery的遍历方式"></a>2.2 JQuery的遍历方式</h3><h4 id="1-JQ对象-each-callback"><a href="#1-JQ对象-each-callback" class="headerlink" title="1. JQ对象.each(callback)"></a>1. <code>JQ对象.each(callback)</code></h4><ul><li>语法：<code>jquery对象.each(function(index,element){});</code><ul><li><code>index</code>：就是元素在集合中的索引</li><li><code>element</code>：就是集合中的每一个元素对象</li><li><code>this</code>：集合中的每一个元素对象（当前元素对象）</li></ul></li><li>回调函数返回值<ul><li><code>true</code>：如果当前<code>function</code>返回<code>false</code>，则结束循环<code>(相当于break)</code>。</li><li><code>false</code>：如果当前<code>function</code>返回<code>true</code>，则结束本次循环，继续下次循环<code>(相当于continue)</code>。</li></ul></li></ul><h4 id="2-each-object-callback"><a href="#2-each-object-callback" class="headerlink" title="2. $.each(object,[callback])"></a>2. <code>$.each(object,[callback])</code></h4><h4 id="3-for-of"><a href="#3-for-of" class="headerlink" title="3. for..of"></a>3. <code>for..of</code></h4><p>3.0版本之后提供的方式，使用方法：<code>for(元素对象 of 容器对象)</code></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {    &#x2F;&#x2F; 1. js方法遍历    &#x2F;&#x2F; 获取所有ul下的li    var citys = $(&quot;#city li&quot;);    &#x2F;&#x2F; 遍历li    for (var i = 0; i &lt; citys.length; i++){        if (&quot;上海&quot; == citys[i].innerHTML ){            break;            continue;        }        alert(i+&quot;:&quot;+citys[i].innerHTML);    }        &#x2F;&#x2F; 2. jq方法遍历，JQ对象.each(callback)    citys.each(function (index,element) {        &#x2F;&#x2F; 获取li对象,使用this        &#x2F;&#x2F; alert(this.innerHTML);        &#x2F;&#x2F; 获取li对象，在回调函数中定义参数，index,element        &#x2F;&#x2F; 判断如果是上海，则结束循环        if (&quot;上海&quot; == $(element).html()){            &#x2F;&#x2F; 如果当前function返回为false，则结束循环(break);            &#x2F;&#x2F; 如果返回为true，则结束本次循环，继续下次循环(continue);            return true;        }        alert(index+&quot;:&quot;+$(element).html());    })    &#x2F;&#x2F; 3. $.each(object,[callback]);    $.each(citys,function () {        alert($(this).html());    })        &#x2F;&#x2F; 4. for..of(jquery3.0之后提供的方式)    for (li of citys){        alert(li.innerHTML);    }})&lt;&#x2F;script&gt;</code></pre><h2 id="3-事件绑定"><a href="#3-事件绑定" class="headerlink" title="3. 事件绑定"></a>3. 事件绑定</h2><h3 id="3-1-JQuery标准的绑定方式"><a href="#3-1-JQuery标准的绑定方式" class="headerlink" title="3.1 JQuery标准的绑定方式"></a>3.1 <code>JQuery标准的绑定方式</code></h3><ul><li><code>JQuery对象.事件方法(回调函数)</code></li></ul><blockquote><p>如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。</p></blockquote><ul><li><code>表单对象.submit();</code>  ： 让表单提交</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {    &#x2F;&#x2F; 1. 获取name对象，表单click事件    $(&quot;#name&quot;).click(function () {        alert(&quot;我被点击了&quot;)    });    &#x2F;&#x2F; 给name绑定聚焦离焦事件    $(&quot;#name&quot;).mouseover(function () {        alert(&quot;鼠标来了...&quot;)    })    $(&quot;#name&quot;).mouseout(function () {        alert(&quot;鼠标走了...&quot;)    })    &#x2F;&#x2F; 简化操作，链式编程    $(&quot;#name&quot;).mouseover(function () {        alert(&quot;鼠标来了...&quot;);    }).mouseout(function () {        alert(&quot;鼠标走了&quot;)    });    $(&quot;#name&quot;).focus(); &#x2F;&#x2F; 浏览器默认行为：让文本输入框获得焦点})&lt;&#x2F;script&gt;</code></pre><h3 id="3-2-on绑定事件-off解除绑定"><a href="#3-2-on绑定事件-off解除绑定" class="headerlink" title="3.2 on绑定事件/off解除绑定"></a>3.2 <code>on绑定事件/off解除绑定</code></h3><ul><li><code>JQuery对象.on(&quot;事件名称&quot;,回调函数)</code></li><li><code>JQuery对象.off(&quot;事件名称&quot;)</code><ul><li>如果<code>off</code>方法不传递任何参数，则会将组件上的所有事件全部解绑。</li></ul></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;     $(function () {     &#x2F;&#x2F; 1. 使用on绑定点击事件     $(&quot;#btn&quot;).on(&quot;click&quot;,function () {         alert(&quot;我被点击了...&quot;)     })     $(&quot;#btn2&quot;).click(function () {         alert(&quot;解除了单击事件...&quot;)         &#x2F;&#x2F; 解绑btn单击事件         &#x2F;&#x2F; $(&quot;#btn&quot;).off(&quot;click&quot;);         $(&quot;#btn&quot;).off();&#x2F;&#x2F; 将组件上的所有事件全部解绑     }) })&lt;&#x2F;script&gt;</code></pre><h3 id="3-3-事件切换：toggle"><a href="#3-3-事件切换：toggle" class="headerlink" title="3.3 事件切换：toggle"></a>3.3 事件切换：<code>toggle</code></h3><ul><li><code>JQuery对象.toggle(fn1,fu2...)</code>：当单击JQ对象对应的组件后，会执行<code>fn1</code>，第二次点击会执行<code>fn2...</code></li></ul><blockquote><p>Notice：1.9版本之后<code>.toggle()</code>方法删除，使用<code>JQuery Migrate</code>(迁移)插件可恢复此功能。</p></blockquote><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&lt;script src=&quot;..&#x2F;js&#x2F;jquery-migrate-1.0.0.js&quot; type=&quot;text&#x2F;javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {    &#x2F;&#x2F; 获取按钮，调用toggle方法    $(&quot;#btn&quot;).toggle(function () {        $(&quot;#myDiv&quot;).css(&quot;backgroundColor&quot;,&quot;green&quot;);    },function () {        $(&quot;#myDiv&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);    })})&lt;&#x2F;script&gt;</code></pre><h2 id="4-综合案例"><a href="#4-综合案例" class="headerlink" title="4. 综合案例"></a>4. 综合案例</h2><h4 id="4-1-广告图片自动显示与隐藏"><a href="#4-1-广告图片自动显示与隐藏" class="headerlink" title="4.1 广告图片自动显示与隐藏"></a>4.1 广告图片自动显示与隐藏</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;广告的自动显示与隐藏&lt;&#x2F;title&gt;    &lt;style&gt;        #content{width:100%;height:500px;background:#999}    &lt;&#x2F;style&gt;    &lt;!--引入jquery--&gt;    &lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        &#x2F;*            需求：                1. 当页面加载完，3秒后，自动显示广告。                2. 广告显示5秒后，自动消失。         *&#x2F;        &#x2F;&#x2F; 1. 使用定时器来完成。setTimeout(执行一次定时器)        &#x2F;&#x2F; 2. 通过控制display属性来实现显示和隐藏        $(function () {            &#x2F;&#x2F; 定义定时器，调用adShow方法 3秒后执行一次            setTimeout(adShow,3000);            &#x2F;&#x2F; 定义定时器，调用adHide方法，8秒后执行一次            setTimeout(adHide,8000);        })        &#x2F;&#x2F; 显示广告        function adShow() {            &#x2F;&#x2F; 获取div，调用显示方法            $(&quot;#ad&quot;).show(&quot;slow&quot;);        }        &#x2F;&#x2F; 隐藏广告        function adHide() {            $(&quot;#ad&quot;).hide(&quot;slow&quot;);        }    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!-- 整体的DIV --&gt;&lt;div&gt;    &lt;!-- 广告DIV --&gt;    &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt;        &lt;img style=&quot;width:100%&quot; src=&quot;..&#x2F;img&#x2F;adv.jpg&quot; &#x2F;&gt;    &lt;&#x2F;div&gt;    &lt;!-- 下方正文部分 --&gt;    &lt;div id=&quot;content&quot;&gt;        正文部分    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4 id="4-2-抽奖"><a href="#4-2-抽奖" class="headerlink" title="4.2 抽奖"></a>4.2 抽奖</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;jquery案例之抽奖&lt;&#x2F;title&gt;    &lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        &#x2F;*            分析：                1. 给开始按钮绑定单击事件                    1.1 定义循环定时器                    1.2 切换小相框的src属性                        - 定义数组，存放图片资源路径                        - 生成随机数，数组索引                2. 给结束按钮绑定单击事件                    1.1 停止定时器                    1.2 给大相框设置src属性                        - 等于小相框当前src属性         *&#x2F;        &#x2F;&#x2F; 定义图片路径数组        var imgs = [&quot;..&#x2F;img&#x2F;man00.jpg&quot;,                    &quot;..&#x2F;img&#x2F;man01.jpg&quot;,                    &quot;..&#x2F;img&#x2F;man02.jpg&quot;,                    &quot;..&#x2F;img&#x2F;man03.jpg&quot;,                    &quot;..&#x2F;img&#x2F;man04.jpg&quot;,                    &quot;..&#x2F;img&#x2F;man05.jpg&quot;,                    &quot;..&#x2F;img&#x2F;man06.jpg&quot;]        var startId;        var index; &#x2F;&#x2F; 随机角标        $(function () {            &#x2F;&#x2F; 处理按钮是否可以使用效果            $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);            $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);            &#x2F;&#x2F; 1. 给开始按钮绑定单击事件            $(&quot;#startID&quot;).click(function () {                &#x2F;&#x2F; 1.1 定义循环定时器， 20毫秒执行一次                startId = setInterval(function () {                    &#x2F;&#x2F; 处理按钮是否可以使用效果                    $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true);                    $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false);                    &#x2F;&#x2F; 1.2 生成随机角标 0-6                    index = Math.floor(Math.random() * 7);  &#x2F;&#x2F; 0.000~0.999 --&gt; *7 =&gt; 0.0~6.9999                    &#x2F;&#x2F; 1.3 小相框src属性                    $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]);                },20);            })            &#x2F;&#x2F; 2. 给结束按钮绑定单击事件            $(&quot;#stopID&quot;).click(function () {                &#x2F;&#x2F; 处理按钮是否可以使用效果                $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);                &#x2F;&#x2F; 2.1 停止定时器                clearInterval(startId);                &#x2F;&#x2F; 2.2 给大相框设置src属性                $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide();                &#x2F;&#x2F; 1秒之后显示                $(&quot;#img2ID&quot;).show(1000);            })        })    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!-- 小像框 --&gt;&lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt;    &lt;img id=&quot;img1ID&quot; src=&quot;..&#x2F;img&#x2F;man00.jpg&quot; style=&quot;width:160px;height:100px&quot;&#x2F;&gt;&lt;&#x2F;div&gt;&lt;!-- 大像框 --&gt;&lt;div        style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt;    &lt;img id=&quot;img2ID&quot; src=&quot;..&#x2F;img&#x2F;man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;&#x2F;&gt;&lt;&#x2F;div&gt;&lt;!-- 开始按钮 --&gt;&lt;input        id=&quot;startID&quot;        type=&quot;button&quot;        value=&quot;点击开始&quot;        style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;&lt;!-- 停止按钮 --&gt;&lt;input        id=&quot;stopID&quot;        type=&quot;button&quot;        value=&quot;点击停止&quot;        style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="5-插件"><a href="#5-插件" class="headerlink" title="5. 插件"></a>5. 插件</h2><p>主要用于增强JQuery的功能，实现方式：</p><ul><li><code>$.fn.extend(object)</code>：增强通过JQuery获取的对象的功能，<code>$(&quot;#id&quot;)</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;01-jQuery对象进行方法扩展&lt;&#x2F;title&gt;    &lt;script src=&quot;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot; type=&quot;text&#x2F;javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;    &lt;script type=&quot;text&#x2F;javascript&quot;&gt;        &#x2F;&#x2F; 1. 定义JQuery的对象插件        $.fn.extend({            &#x2F;&#x2F; 定义了一个check()方法。所有的jq对象都可以调用该方法            check:function () {                &#x2F;&#x2F; 让复选框选中                &#x2F;&#x2F; this:调用该方法的jq对象                this.prop(&quot;checked&quot;,true);            },            uncheck:function () {              &#x2F;&#x2F; 不选中                this.prop(&quot;checked&quot;,false);            }        });        $(function () {            $(&quot;#btn-check&quot;).click(function () {                $(&quot;input[type=&#39;checkbox&#39;]&quot;).check();            });            $(&quot;#btn-uncheck&quot;).click(function () {                $(&quot;input[type=&#39;checkbox&#39;]&quot;).uncheck();            });        })    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;input id=&quot;btn-check&quot; type=&quot;button&quot; value=&quot;点击选中复选框&quot; &gt;&lt;input id=&quot;btn-uncheck&quot; type=&quot;button&quot; value=&quot;点击取消复选框选中&quot; &gt;&lt;br&#x2F;&gt;&lt;input type=&quot;checkbox&quot; value=&quot;football&quot;&gt;足球&lt;input type=&quot;checkbox&quot; value=&quot;basketball&quot;&gt;篮球&lt;input type=&quot;checkbox&quot; value=&quot;volleyball&quot;&gt;排球&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li><code>$.extend(object)</code>：增强JQuery对象自身的功能，<code>$/jQuery</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;01-jQuery对象进行方法扩展&lt;&#x2F;title&gt;    &lt;script src=&quot;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot; type=&quot;text&#x2F;javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;    &lt;script type=&quot;text&#x2F;javascript&quot;&gt;        &#x2F;&#x2F;对全局方法扩展2个方法，扩展min方法：求2个值的最小值；扩展max方法：求2个值最大值        $.extend({            max:function (a,b) {                &#x2F;&#x2F; 返回大值                return a &gt;= b ? a:b;            },            min:function (a,b) {                &#x2F;&#x2F; 返回小值                return a &lt;= b ? a:b;            }        });        &#x2F;&#x2F; 调用全局方法        alert($.max(4,3));        alert($.min(4,3));    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery基础</title>
      <link href="/JavaWeb/JQueryBasic.html"/>
      <url>/JavaWeb/JQueryBasic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-JQuery基础"><a href="#1-JQuery基础" class="headerlink" title="1. JQuery基础"></a>1. JQuery基础</h2><p>jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（<em>或JavaScript框架</em>）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，<strong>优化HTML文档操作</strong>、事件处理、动画设计和Ajax交互。</p><a id="more"></a><ul><li>JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已。</li></ul><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h2><h3 id="2-1-下载JQuery"><a href="#2-1-下载JQuery" class="headerlink" title="2.1. 下载JQuery"></a>2.1. 下载<code>JQuery</code></h3><p>目前JQuery有三个大版本：</p><p>1.x：兼容ie678，使用最为广泛的，官方只做BUG维护，功能不再新增。对于一般项目来说，使用1.x版本即可。</p><p>2.x：不兼容ie768，很少有人使用，官方只做BUG维护，功能不新增。如果不考虑兼容低版本浏览器可以使用2.x。</p><p>3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本，很多老的JQuery插件不支持该版本。</p><blockquote><p><code>jquery-xxx.js</code>与<code>jquery-xxx.min.js</code>的区别：</p><ol><li><code>jquery-xxx.js</code>：开发版本。供开发人员查看的，有良好的缩进和注释。体积大一些。</li><li><code>jquery-xxx.min.js</code>：生成版本。程序中使用，没有缩进。体积小巧，程序加载更快。</li></ol></blockquote><h3 id="2-2-导入JQuery的js文件：导入min-js文件"><a href="#2-2-导入JQuery的js文件：导入min-js文件" class="headerlink" title="2.2. 导入JQuery的js文件：导入min.js文件"></a>2.2. 导入<code>JQuery</code>的js文件：导入<code>min.js</code>文件</h3><h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3. 使用"></a>2.3. 使用</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script src=&quot;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    var div1 = $(&quot;#div1&quot;);alert(div1.html());&lt;&#x2F;script&gt;</code></pre><h2 id="3-JQuery对象和JS对象区别和转换"><a href="#3-JQuery对象和JS对象区别和转换" class="headerlink" title="3. JQuery对象和JS对象区别和转换"></a>3. <code>JQuery</code>对象和JS对象区别和转换</h2><ol><li><code>JQuery</code>对象在操作时，更加方便。</li><li><code>JQuery</code>对象和JS对象方法不通用。</li><li>两者可以相互转换<ul><li><code>jq --- &gt; js：jq对象[索引] 或者 jq对象.get(索引)</code></li><li><code>js --- &gt; jq：$(js对象)</code></li></ul></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;    &#x2F;&#x2F; 1. 通过js方式来获取元素对象    var divs = document.getElementsByTagName(&quot;div&quot;);    alert(divs.length); &#x2F;&#x2F; 可以将其当做数组来使用    &#x2F;&#x2F; 将divs中的所有div标签体内容修改为&quot;aaa&quot;    for(var i = 0;i &lt; divs.length; i++){        &#x2F;&#x2F; divs[i].innerHTML = &quot;aaa&quot;;        $(divs[i]).html(&quot;ccc&quot;); &#x2F;&#x2F; 将js对象转换为JQuery对象    }    &#x2F;&#x2F; 2. 通过Jquery方式来获取元素对象    var $divs = $(&quot;div&quot;);    alert($divs);    &#x2F;&#x2F; 将$divs中的所有div标签体内容修改为&quot;bbb&quot;    &#x2F;&#x2F; $divs.html(&quot;bbb&quot;);    &#x2F;&#x2F; 将JQuery对象转换为js对象    $divs[0].innerHTML = &quot;ddd&quot;;    $divs[1].innerHTML = &quot;ddd&quot;;&lt;&#x2F;script&gt;</code></pre><h2 id="4-选择器：筛选具有相似特征的元素-标签"><a href="#4-选择器：筛选具有相似特征的元素-标签" class="headerlink" title="4. 选择器：筛选具有相似特征的元素(标签)"></a>4. 选择器：筛选具有相似特征的元素(标签)</h2><h3 id="4-1-基本操作学习"><a href="#4-1-基本操作学习" class="headerlink" title="4.1 基本操作学习"></a>4.1 基本操作学习</h3><h4 id="1-事件绑定"><a href="#1-事件绑定" class="headerlink" title="1. 事件绑定"></a>1. 事件绑定</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">$(&quot;#b1&quot;).click(function () {    alert(&quot;abc&quot;);})</code></pre><h4 id="2-入口函数"><a href="#2-入口函数" class="headerlink" title="2. 入口函数"></a>2. 入口函数</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">$(function () {});&#x2F;*   window.onload 和 $(function)的区别       1. window.onload只能定义一次，如定义多次，后边的会将前边的覆盖掉       2. $(function)可以定义多次*&#x2F;</code></pre><h4 id="3-样式控制：CSS方法"><a href="#3-样式控制：CSS方法" class="headerlink" title="3. 样式控制：CSS方法"></a>3. 样式控制：CSS方法</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">$(function () {    $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);})</code></pre><h3 id="4-2-分类"><a href="#4-2-分类" class="headerlink" title="4.2 分类"></a>4.2 分类</h3><h4 id="1-基本选择器"><a href="#1-基本选择器" class="headerlink" title="1. 基本选择器"></a>1. 基本选择器</h4><table><thead><tr><th>选择器名称</th><th>语法</th></tr></thead><tbody><tr><td>标签选择器(元素选择器)</td><td><code>$(&quot;html标签名&quot;)</code> ：获取所有匹配标签名称的元素</td></tr><tr><td>ID选择器</td><td><code>$(&quot;#id的属性值&quot;)</code>：获取与指定id属性值匹配的元素</td></tr><tr><td>类选择器</td><td><code>$(.class的属性值)</code>：获取与指定class属性值匹配的元素</td></tr></tbody></table><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;改变 id 为 one 的元素的背景色为 红色&quot;  id=&quot;b1&quot;&#x2F;&gt;        $(&quot;#b1&quot;).click(function () {            $(&quot;#one&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变元素名为 &lt;div&gt; 的所有元素的背景色为 红色&quot;  id=&quot;b2&quot;&#x2F;&gt;        $(&quot;#b2&quot;).click(function () {            $(&quot;div&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变 class 为 mini 的所有元素的背景色为 红色&quot;  id=&quot;b3&quot;&#x2F;&gt;        $(&quot;#b3&quot;).click(function () {            $(&quot;.mini&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变所有的&lt;span&gt;元素和 id 为 two 的元素的背景色为红色&quot;  id=&quot;b4&quot;&#x2F;&gt;        $(&quot;#b4&quot;).click(function () {            $(&quot;span&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);            $(&quot;#two&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });});&lt;&#x2F;script&gt;</code></pre><h4 id="2-层级选择器"><a href="#2-层级选择器" class="headerlink" title="2. 层级选择器"></a>2. 层级选择器</h4><table><thead><tr><th>选择器名称</th><th>语法</th></tr></thead><tbody><tr><td>后代选择器</td><td><code>$(&quot;A B &quot;)</code>：选择A元素内部的所有B元素</td></tr><tr><td>子选择器</td><td><code>$(&quot;A &gt; B&quot;)</code>：选择A元素内部的所有B子元素</td></tr></tbody></table><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变 &lt;body&gt; 内所有 &lt;div&gt; 的背景色为红色&quot;  id=&quot;b1&quot;&#x2F;&gt;        $(&quot;#b1&quot;).click(function () {            $(&quot;body div&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变 &lt;body&gt; 内子 &lt;div&gt; 的背景色为 红色&quot;  id=&quot;b2&quot;&#x2F;&gt;        $(&quot;#b2&quot;).click(function () {            $(&quot;body &gt; div&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });})&lt;&#x2F;script&gt;</code></pre><h4 id="3-属性选择器"><a href="#3-属性选择器" class="headerlink" title="3. 属性选择器"></a>3. 属性选择器</h4><table><thead><tr><th>选择器名称</th><th>语法</th></tr></thead><tbody><tr><td>属性名称选择器</td><td><code>$(&quot;A[属性名]&quot;)</code>：选择包含指定属性名称的元素</td></tr><tr><td>属性选择器</td><td><code>$(&quot;A[属性名 = &#39;值&#39;]&quot;)</code>：选择指定属性等于指定值的元素</td></tr><tr><td>复合属性选择器</td><td><code>$(&quot;A[属性名=&#39;值&#39;][]...&quot;)</code>：包含多个属性条件的选择器</td></tr></tbody></table><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 含有属性title 的div元素背景色为红色&quot;  id=&quot;b1&quot;&#x2F;&gt;        $(&quot;#b1&quot;).click(function () {            $(&quot;div[title]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 属性title值等于test的div元素背景色为红色&quot;  id=&quot;b2&quot;&#x2F;&gt;        $(&quot;#b2&quot;).click(function () {            $(&quot;div[title=&#39;test&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 属性title值不等于test的div元素(没有属性title的也将被选中)背景色为红色&quot;  id=&quot;b3&quot;&#x2F;&gt;        $(&quot;#b3&quot;).click(function () {            $(&quot;div[title != &#39;test&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 属性title值 以te开始 的div元素背景色为红色&quot;  id=&quot;b4&quot;&#x2F;&gt;        $(&quot;#b4&quot;).click(function () {            $(&quot;div[title ^= &#39;te&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 属性title值 以est结束 的div元素背景色为红色&quot;  id=&quot;b5&quot;&#x2F;&gt;        $(&quot;#b5&quot;).click(function () {            $(&quot;div[title $= &#39;est&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;属性title值 含有es的div元素背景色为红色&quot;  id=&quot;b6&quot;&#x2F;&gt;        $(&quot;#b6&quot;).click(function () {            $(&quot;div[title*=&#39;es&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;选取有属性id的div元素，然后在结果中选取属性title值含有“es”的 div 元素背景色为红色&quot;  id=&quot;b7&quot;&#x2F;&gt;        $(&quot;#b7&quot;).click(function () {            $(&quot;div[id][title*=&#39;es&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });})&lt;&#x2F;script&gt;</code></pre><h4 id="4-过滤选择器"><a href="#4-过滤选择器" class="headerlink" title="4. 过滤选择器"></a>4. 过滤选择器</h4><table><thead><tr><th>选择器名称</th><th>语法</th></tr></thead><tbody><tr><td>首元素选择器</td><td><code>:first</code>：获得选择的元素中的第一个元素</td></tr><tr><td>尾元素选择器</td><td><code>:last</code>：获得选择的元素中的最后一个元素</td></tr><tr><td>非元素选择器</td><td><code>:not(selector)</code>：不包含指定内容的元素</td></tr><tr><td>偶数选择器</td><td><code>:even</code>：偶数，从0开始计数</td></tr><tr><td>计数选择器</td><td><code>:odd</code>：奇数，从0开始计数</td></tr><tr><td>等于索引选择器</td><td><code>:eq(index)</code>：指定索引元素</td></tr><tr><td>大于索引选择器</td><td><code>:gt(index)</code>：大于指定索引元素</td></tr><tr><td>小于索引选择器</td><td><code>:lt(index)</code>：小于指定索引元素</td></tr><tr><td>标题选择器</td><td><code>:header</code>：获取标题<code>(h1~h6)</code>元素，固定写法</td></tr></tbody></table><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变第一个 div 元素的背景色为 红色&quot;  id=&quot;b1&quot;&#x2F;&gt;        $(&quot;#b1&quot;).click(function () {            $(&quot;div:first&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变最后一个 div 元素的背景色为 红色&quot;  id=&quot;b2&quot;&#x2F;&gt;        $(&quot;#b2&quot;).click(function () {            $(&quot;div:last&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变class不为 one 的所有 div 元素的背景色为 红色&quot;  id=&quot;b3&quot;&#x2F;&gt;        $(&quot;#b3&quot;).click(function () {            $(&quot;div:not(.one)&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变索引值为偶数的 div 元素的背景色为 红色&quot;  id=&quot;b4&quot;&#x2F;&gt;        $(&quot;#b4&quot;).click(function () {            $(&quot;div:even&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变索引值为奇数的 div 元素的背景色为 红色&quot;  id=&quot;b5&quot;&#x2F;&gt;        $(&quot;#b5&quot;).click(function () {            $(&quot;div:odd&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变索引值为大于 3 的 div 元素的背景色为 红色&quot;  id=&quot;b6&quot;&#x2F;&gt;        $(&quot;#b6&quot;).click(function () {            $(&quot;div:gt(3)&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变索引值为等于 3 的 div 元素的背景色为 红色&quot;  id=&quot;b7&quot;&#x2F;&gt;        $(&quot;#b7&quot;).click(function () {            $(&quot;div:eq(3)&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变索引值为小于 3 的 div 元素的背景色为 红色&quot;  id=&quot;b8&quot;&#x2F;&gt;        $(&quot;#b8&quot;).click(function () {            $(&quot;div:lt(3)&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变所有的标题元素的背景色为 红色&quot;  id=&quot;b9&quot;&#x2F;&gt;        $(&quot;#b9&quot;).click(function () {            $(&quot;:header&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);        });})&lt;&#x2F;script&gt;</code></pre><h4 id="5-表单过滤选择器"><a href="#5-表单过滤选择器" class="headerlink" title="5. 表单过滤选择器"></a>5. 表单过滤选择器</h4><table><thead><tr><th>选择器名称</th><th>语法</th></tr></thead><tbody><tr><td>可用元素选择器</td><td><code>:enabled</code>：获取可用元素</td></tr><tr><td>不可用元素选择器</td><td><code>:disabled</code>：获取不可用元素</td></tr><tr><td>选中选择器</td><td><code>:checked</code>：获取单选/复选框选中的元素</td></tr><tr><td>选中选择器</td><td><code>:selected</code>：获取下拉框选中的元素</td></tr></tbody></table><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 利用 jQuery 对象的 val() 方法改变表单内可用 &lt;input&gt; 元素的值&quot;  id=&quot;b1&quot;&#x2F;&gt;        $(&quot;#b1&quot;).click(function () {            $(&quot;input[type=&#39;text&#39;]:enabled&quot;).val(&quot;可用元素&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 利用 jQuery 对象的 val() 方法改变表单内不可用 &lt;input&gt; 元素的值&quot;  id=&quot;b2&quot;&#x2F;&gt;        $(&quot;#b2&quot;).click(function () {            $(&quot;input[type=&#39;text&#39;]:disabled&quot;).val(&quot;不可用元素&quot;);        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 利用 jQuery 对象的 length 属性获取复选框选中的个数&quot;  id=&quot;b3&quot;&#x2F;&gt;        $(&quot;#b3&quot;).click(function () {            var result = $(&quot;input[type=&#39;checkbox&#39;]:checked&quot;).length;            alert(result)        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 利用 jQuery 对象的 length 属性获取下拉框选中的个数&quot;  id=&quot;b4&quot;&#x2F;&gt;        $(&quot;#b4&quot;).click(function () {            alert($(&quot;#job &gt; option:selected&quot;).length);        });})&lt;&#x2F;script&gt;</code></pre><h2 id="5-DOM操作"><a href="#5-DOM操作" class="headerlink" title="5. DOM操作"></a>5. DOM操作</h2><h3 id="5-1-内容操作"><a href="#5-1-内容操作" class="headerlink" title="5.1 内容操作"></a>5.1 内容操作</h3><ol><li><code>html()</code>：获取/设置元素的标签体内容</li><li><code>text()</code>：获取/设置元素的标签体纯文本内容</li><li><code>val()</code>：获取/设置元素的value属性值</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;    $(function () {        &#x2F;&#x2F; 获取myinput 的value值        alert($(&quot;#myinput&quot;).val());        &#x2F;&#x2F; 设置值        alert($(&quot;#myinput&quot;).val(&quot;李四&quot;));        &#x2F;&#x2F; 获取mydiv的标签体内容        alert($(&quot;#mydiv&quot;).html());        &#x2F;&#x2F; 设置值        alert($(&quot;#mydiv&quot;).html(&quot;&lt;h4&gt;hello&lt;&#x2F;h4&gt;&quot;));        &#x2F;&#x2F; 获取mydiv纯文本内容        alert($(&quot;#mydiv&quot;).text());        &#x2F;&#x2F; 设置值        alert($(&quot;#mydiv&quot;).text(&quot;aaa&quot;));})&lt;&#x2F;script&gt;</code></pre><h3 id="5-2-属性操作"><a href="#5-2-属性操作" class="headerlink" title="5.2 属性操作"></a>5.2 属性操作</h3><h4 id="1-通用属性操作"><a href="#1-通用属性操作" class="headerlink" title="1. 通用属性操作"></a>1. 通用属性操作</h4><ol><li><code>attr()</code>：获取/设置元素的属性</li><li><code>removeAttr()</code>：删除属性</li><li><code>prop()</code>：获取/设置元素的属性</li><li><code>removeProp()</code>：删除属性</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {        &#x2F;&#x2F;获取北京节点的name属性值        alert($(&quot;#bj&quot;).attr(&quot;name&quot;));        &#x2F;&#x2F;设置北京节点的name属性的值为dabeijing        $(&quot;#bj&quot;).attr(&quot;name&quot;,&quot;dabeijing&quot;);        &#x2F;&#x2F;新增北京节点的discription属性 属性值是didu        $(&quot;#bj&quot;).attr(&quot;discription&quot;,&quot;didu&quot;);        &#x2F;&#x2F;删除北京节点的name属性并检验name属性是否存在        $(&quot;#bj&quot;).removeAttr(&quot;name&quot;);        &#x2F;&#x2F;获得hobby的的选中状态        alert($(&quot;#hobby&quot;).prop(&quot;checked&quot;));})&lt;&#x2F;script&gt;</code></pre><blockquote><p><code>attr</code>和<code>prop</code>区别？</p><ol><li>如果操作的是元素的固有属性，则建议使用<code>prop</code></li><li>如果操作的是元素自定义的属性，则建议使用<code>attr</code></li></ol></blockquote><h4 id="2-对class属性操作"><a href="#2-对class属性操作" class="headerlink" title="2. 对class属性操作"></a>2. 对class属性操作</h4><ol><li><code>addClass()</code>：添加class属性值</li><li><code>removeClass()</code>：删除class属性值</li><li><code>toggleClass()</code>：切换class属性值</li><li><code>css()</code>：操作元素css样式</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {        &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot;采用属性增加样式(改变id=one的样式)&quot;  id=&quot;b1&quot;&#x2F;&gt;        $(&quot;#b1&quot;).click(function () {            $(&quot;#one&quot;).prop(&quot;class&quot;,&quot;second&quot;);        });        &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot; addClass&quot;  id=&quot;b2&quot;&#x2F;&gt;        $(&quot;#b2&quot;).click(function () {            $(&quot;#one&quot;).addClass(&quot;second&quot;);        });        &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot;removeClass&quot;  id=&quot;b3&quot;&#x2F;&gt;        $(&quot;#b3&quot;).click(function () {            $(&quot;#one&quot;).removeClass(&quot;second&quot;);        });        &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot; 切换样式&quot;  id=&quot;b4&quot;&#x2F;&gt;        $(&quot;#b4&quot;).click(function () {            $(&quot;#one&quot;).toggleClass(&quot;second&quot;);        });        &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot; 通过css()获得id为one背景颜色&quot;  id=&quot;b5&quot;&#x2F;&gt;        $(&quot;#b5&quot;).click(function () {            alert($(&quot;#one&quot;).css(&quot;backgroundColor&quot;));        });        &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot; 通过css()设置id为one背景颜色为绿色&quot;  id=&quot;b6&quot;&#x2F;&gt;        $(&quot;#b6&quot;).click(function () {            $(&quot;#one&quot;).css(&quot;backgroundColor&quot;,&quot;blue&quot;);        });})&lt;&#x2F;script&gt;</code></pre><h3 id="5-3-CRUD操作"><a href="#5-3-CRUD操作" class="headerlink" title="5.3 CRUD操作"></a>5.3 CRUD操作</h3><table><thead><tr><th>方法名称</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td><code>append()</code></td><td>父元素将子元素追加到末尾</td><td><code>对象1.append(对象2)</code>：将对象2添加到对象1元素内部末尾处。</td></tr><tr><td><code>prepend()</code></td><td>父元素将子元素追加到开头</td><td><code>对象1.prepend(对象2)</code>：将对象2添加到对象1元素内部开头处。</td></tr><tr><td><code>appendTo()</code></td><td></td><td><code>对象1.appendTo(对象2)</code>：将对象1添加到对象2内部末尾处。</td></tr><tr><td><code>prependTo()</code></td><td></td><td><code>对象1.prependTo(对象2)</code>：将对象1添加到对象2内部开头处。</td></tr><tr><td><code>after()</code></td><td>添加元素到元素后边</td><td><code>对象1.after(对象2)</code>：将对象2添加到对象1后边。对象1和2是兄弟关系。</td></tr><tr><td><code>before()</code></td><td>添加元素到元素前边</td><td><code>对象1.before(对象2)</code>：将对象2添加到对象1前边。对象1和2是兄弟关系。</td></tr><tr><td><code>insertAfter()</code></td><td></td><td><code>对象1.insertAfter(对象2)</code>：将对象1添加到对象2后边。对象1和2是兄弟关系。</td></tr><tr><td><code>insertBefore()</code></td><td></td><td><code>对象1.insertBefore(对象2)</code>：将对象1添加到对象2前边。对象1和对象2是兄弟关系。</td></tr><tr><td><code>remov()</code></td><td>移除元素</td><td><code>对象.remove()</code>：将对象删除</td></tr><tr><td><code>empty()</code></td><td>清空元素的所有后代元素</td><td><code>对象.empty()</code>：将对象的后代元素全部清空，但保留当前对象及其属性节点。</td></tr></tbody></table><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script type=&quot;text&#x2F;javascript&quot;&gt;    $(function () {        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;将反恐放置到city的后面&quot;  id=&quot;b1&quot;&#x2F;&gt;        $(&quot;#b1&quot;).click(function () {            &#x2F;&#x2F; append            &#x2F;&#x2F; $(&quot;#city&quot;).append($(&quot;#fk&quot;));            &#x2F;&#x2F; appendTo            $(&quot;#fk&quot;).appendTo($(&quot;#city&quot;));        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;将反恐放置到city的最前面&quot;  id=&quot;b2&quot;&#x2F;&gt;        $(&quot;#b2&quot;).click(function () {            &#x2F;&#x2F; prepend            $(&quot;#fk&quot;).prependTo($(&quot;#city&quot;));        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;将反恐插入到天津后面&quot;  id=&quot;b3&quot;&#x2F;&gt;        $(&quot;#b3&quot;).click(function () {            &#x2F;&#x2F; after            &#x2F;&#x2F; $(&quot;#tj&quot;).after($(&quot;#fk&quot;));            &#x2F;&#x2F; insertAfter            $(&quot;#fk&quot;).insertAfter($(&quot;#tj&quot;));        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;将反恐插入到天津前面&quot;  id=&quot;b4&quot;&#x2F;&gt;        $(&quot;#b4&quot;).click(function () {            $(&quot;#fk&quot;).insertBefore($(&quot;#tj&quot;));        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;删除&lt;li id=&#39;bj&#39; name=&#39;beijing&#39;&gt;北京&lt;&#x2F;li&gt;&quot;  id=&quot;b1&quot;&#x2F;&gt;        $(&quot;#b1&quot;).click(function () {            $(&quot;#bj&quot;).remove();        });        &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;删除city所有的li节点   清空元素中的所有后代节点(不包含属性节点)&quot;  id=&quot;b2&quot;&#x2F;&gt;        $(&quot;#b2&quot;).click(function () {            $(&quot;#city&quot;).empty();        });})&lt;&#x2F;script&gt;</code></pre><h2 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h2><h3 id="1-隔行换色"><a href="#1-隔行换色" class="headerlink" title="1. 隔行换色"></a>1. 隔行换色</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;script  src=&quot;..&#x2F;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;&#x2F;&#x2F;需求：将数据行的奇数行背景色设置为 pink，偶数行背景色设置为 yellow$(function () {&#x2F;&#x2F; 1. 获取数据行的奇数行的tr，设置背景色为pink$(&quot;tr:gt(1):odd&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;)&#x2F;&#x2F; 2. 获取数据行的偶数行的tr，设置背景色为yellow$(&quot;tr:gt(1):even&quot;).css(&quot;backgroundColor&quot;,&quot;yellow&quot;)});&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;table id=&quot;tab1&quot; border=&quot;1&quot; width=&quot;800&quot; align=&quot;center&quot; &gt;&lt;tr&gt;&lt;td colspan=&quot;5&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;删除&quot;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr style=&quot;background-color: #999999;&quot;&gt;&lt;th&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;&#x2F;th&gt;&lt;th&gt;分类ID&lt;&#x2F;th&gt;&lt;th&gt;分类名称&lt;&#x2F;th&gt;&lt;th&gt;分类描述&lt;&#x2F;th&gt;&lt;th&gt;操作&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;手机数码&lt;&#x2F;td&gt;&lt;td&gt;手机数码类商品&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;电脑办公&lt;&#x2F;td&gt;&lt;td&gt;电脑办公类商品&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;鞋靴箱包&lt;&#x2F;td&gt;&lt;td&gt;鞋靴箱包类商品&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;家居饰品&lt;&#x2F;td&gt;&lt;td&gt;家居饰品类商品&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3 id="2-全选-全不选"><a href="#2-全选-全不选" class="headerlink" title="2. 全选/全不选"></a>2. 全选/全不选</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;script  src=&quot;..&#x2F;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;&#x2F;&#x2F; 需要保证下边的选中状态和第一个复选框的状态一致即可。function selectAll(obj) {&#x2F;&#x2F; 获取下边的所有复选框$(&quot;.itemSelect&quot;).prop(&quot;checked&quot;,obj.checked);}&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;table id=&quot;tab1&quot; border=&quot;1&quot; width=&quot;800&quot; align=&quot;center&quot; &gt;&lt;tr&gt;&lt;td colspan=&quot;5&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;删除&quot;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;th&gt;&lt;input type=&quot;checkbox&quot; onclick=&quot;selectAll(this)&quot; &gt;&lt;&#x2F;th&gt;&lt;th&gt;分类ID&lt;&#x2F;th&gt;&lt;th&gt;分类名称&lt;&#x2F;th&gt;&lt;th&gt;分类描述&lt;&#x2F;th&gt;&lt;th&gt;操作&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;itemSelect&quot;&gt;&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;手机数码&lt;&#x2F;td&gt;&lt;td&gt;手机数码类商品&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;itemSelect&quot;&gt;&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;电脑办公&lt;&#x2F;td&gt;&lt;td&gt;电脑办公类商品&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;itemSelect&quot;&gt;&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;鞋靴箱包&lt;&#x2F;td&gt;&lt;td&gt;鞋靴箱包类商品&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;itemSelect&quot;&gt;&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;家居饰品&lt;&#x2F;td&gt;&lt;td&gt;家居饰品类商品&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3 id="3-qq表情选择"><a href="#3-qq表情选择" class="headerlink" title="3. qq表情选择"></a>3. qq表情选择</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; &#x2F;&gt;    &lt;title&gt;QQ表情选择&lt;&#x2F;title&gt; &lt;script  src=&quot;..&#x2F;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;style type=&quot;text&#x2F;css&quot;&gt;    *{margin: 0;padding: 0;list-style: none;}    .emoji{margin:50px;}    ul{overflow: hidden;}    li{float: left;width: 48px;height: 48px;cursor: pointer;}    .emoji img{ cursor: pointer; }    &lt;&#x2F;style&gt;&lt;script&gt;        &#x2F;&#x2F;需求：点击qq表情，将其追加到发言框中        $(function () {            &#x2F;&#x2F; 1. 给img图片添加onclick事件            $(&quot;ul img&quot;).click(function () {                &#x2F;&#x2F; 2. 追加到p标签中即可,$(this)：将js对象转换为JQuery对象                $(&quot;.word&quot;).append($(this).clone());            });        });    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div class=&quot;emoji&quot;&gt;        &lt;ul&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;01.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;02.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;03.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;04.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;05.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;06.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;07.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;08.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;09.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;10.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;11.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;            &lt;li&gt;&lt;img src=&quot;img&#x2F;12.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;        &lt;&#x2F;ul&gt;        &lt;p class=&quot;word&quot;&gt;            &lt;strong&gt;请发言：&lt;&#x2F;strong&gt;            &lt;img src=&quot;img&#x2F;12.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;        &lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3 id="4-多选下拉列表左右移动"><a href="#4-多选下拉列表左右移动" class="headerlink" title="4. 多选下拉列表左右移动"></a>4. 多选下拉列表左右移动</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;script  src=&quot;..&#x2F;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;style&gt;#leftName , #btn,#rightName{float: left;width: 100px;height: 300px;}#toRight,#toLeft{margin-top:100px ;margin-left:30px;width: 50px;}.border{height: 500px;padding: 100px;}&lt;&#x2F;style&gt;&lt;script&gt;&#x2F;&#x2F;需求：实现下拉列表选择条目左右选择功能$(function () {$(&quot;#toRight&quot;).click(function () {&#x2F;&#x2F; 获取右边的下拉列表对象，append(左边下拉列表选中的option)$(&quot;#rightName&quot;).append($(&quot;#leftName &gt; option:selected&quot;));});$(&quot;#toLeft&quot;).click(function () {$(&quot;#leftName&quot;).append($(&quot;#rightName &gt; option:selected&quot;));});});&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class=&quot;border&quot;&gt;&lt;select id=&quot;leftName&quot; multiple=&quot;multiple&quot;&gt;&lt;option&gt;张三&lt;&#x2F;option&gt;&lt;option&gt;李四&lt;&#x2F;option&gt;&lt;option&gt;王五&lt;&#x2F;option&gt;&lt;option&gt;赵六&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;div id=&quot;btn&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;toRight&quot; value=&quot;--&gt;&quot;&gt;&lt;br&gt;&lt;input type=&quot;button&quot; id=&quot;toLeft&quot; value=&quot;&lt;--&quot;&gt;&lt;&#x2F;div&gt;&lt;select id=&quot;rightName&quot; multiple=&quot;multiple&quot;&gt;&lt;option&gt;钱七&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter和Listener</title>
      <link href="/JavaWeb/filter-listener.html"/>
      <url>/JavaWeb/filter-listener.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Filter：过滤器"><a href="#1-Filter：过滤器" class="headerlink" title="1. Filter：过滤器"></a>1. Filter：过滤器</h2><p>Filter也称之为过滤器，它是Servlet技术中最激动人心的技术，Web开发人员通过Filter技术，对Web服务器管理的所有Web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。</p><a id="more"></a><h3 id="1-1-过滤器的作用"><a href="#1-1-过滤器的作用" class="headerlink" title="1.1 过滤器的作用"></a>1.1 过滤器的作用</h3><p>一般用于完成通用的操作。如登录验证、统一编码处理、敏感字符过滤等</p><h3 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2 快速入门"></a>1.2 快速入门</h3><ol><li>定义一个类，实现接口Filter</li><li>复写方法</li><li>配置拦截路径。使用web.xml和注解配置。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@WebFilter(&quot;&#x2F;*&quot;) &#x2F;&#x2F; 访问所有资源之前，都会执行该过滤器public class FilterDemo1 implements Filter {    @Override    public void init(FilterConfig filterConfig) throws ServletException {    }    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        System.out.println(&quot;FilterDemo1执行了...&quot;);        &#x2F;&#x2F; 放行        filterChain.doFilter(servletRequest,servletResponse);    }    @Override    public void destroy() {    }}</code></pre><h3 id="1-3-过滤器细节"><a href="#1-3-过滤器细节" class="headerlink" title="1.3 过滤器细节"></a>1.3 过滤器细节</h3><h4 id="1-3-1-web-xml配置方法"><a href="#1-3-1-web-xml配置方法" class="headerlink" title="1.3.1 web.xml配置方法"></a>1.3.1 web.xml配置方法</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;filter&gt;    &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt;    &lt;filter-class&gt;cn.zero.web.filter.FilterDemo1&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt;    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt;</code></pre><h4 id="1-3-2-过滤器执行流程"><a href="#1-3-2-过滤器执行流程" class="headerlink" title="1.3.2 过滤器执行流程"></a>1.3.2 过滤器执行流程</h4><ol><li>执行过滤器</li><li>执行放行后的资源</li><li>回来执行过滤器放行代码下面的代码</li></ol><h4 id="1-3-3-过滤器生命周期方法"><a href="#1-3-3-过滤器生命周期方法" class="headerlink" title="1.3.3 过滤器生命周期方法"></a>1.3.3 过滤器生命周期方法</h4><ol><li><code>init</code>：在服务器启动后，会创建Filter对象，然后调用init方法，只执行一次。一般用于加载资源。</li><li><code>doFilter</code>：每一次请求被拦截资源时，会执行该方法，会执行多次</li><li><code>destroy</code>：在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。一般用于释放资源。`</li></ol><h4 id="1-3-4-过滤器配置详解"><a href="#1-3-4-过滤器配置详解" class="headerlink" title="1.3.4 过滤器配置详解"></a>1.3.4 过滤器配置详解</h4><h5 id="拦截路径配置："><a href="#拦截路径配置：" class="headerlink" title="拦截路径配置："></a>拦截路径配置：</h5><ul><li>具体资源路径：<code>/index.jsp</code>   ，只有访问index.jsp资源时，过滤器才会被执行</li><li>拦截目录： <code>/user/*</code>  ，访问/user下的所有资源时，过滤器都会被执行</li><li>后缀名拦截：<code>*.jsp</code> ， 访问所有后缀名为jsp资源时，过滤器都会被执行</li><li>拦截所有资源：<code>/*</code> ， 访问所有资源时，过滤器都会被执行</li></ul><h5 id="拦截方式配置：资源被访问的方式"><a href="#拦截方式配置：资源被访问的方式" class="headerlink" title="拦截方式配置：资源被访问的方式"></a>拦截方式配置：资源被访问的方式</h5><ul><li><p>注解配置：需要设置<code>dispatcharTypes</code>属性</p><ul><li>REQUEST：默认值。浏览器直接请求资源。</li><li>FORWARD：转发访问资源。</li><li>INCLUDE：包含访问资源</li><li>ERROR：错误跳转资源</li><li>ASYNC：异步访问资源</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;&#x2F;@WebFilter(value = &quot;&#x2F;index.jsp&quot;,dispatcherTypes = DispatcherType.REQUEST) &#x2F;&#x2F; 浏览器直接请求index.jsp资源时，该过滤器会被执行  &#x2F;&#x2F;@WebFilter(value = &quot;&#x2F;index.jsp&quot;,dispatcherTypes = DispatcherType.FORWARD) &#x2F;&#x2F; 转发访问index.jsp资源时，该过滤器会被执行  @WebFilter(value = &quot;&#x2F;index.jsp&quot;,dispatcherTypes = {DispatcherType.FORWARD,DispatcherType.REQUEST}) &#x2F;&#x2F; 直接访问或转发访问index.jsp资源时，该过滤器会被执行</code></pre></li></ul><ul><li><p>web.xml</p><ul><li>设置<code>&lt;dispatcher&gt;&lt;/dispatcher&gt;</code>标签即可</li></ul></li></ul><h4 id="1-3-5-过滤器链-配置多个过滤器"><a href="#1-3-5-过滤器链-配置多个过滤器" class="headerlink" title="1.3.5 过滤器链(配置多个过滤器)"></a>1.3.5 过滤器链(配置多个过滤器)</h4><p>如果有两个过滤器：过滤器1和过滤器2，那么他们的执行顺序是</p><ol><li>过滤器1</li><li>过滤器2</li><li>资源执行</li><li>过滤器2</li><li>过滤器1</li></ol><h5 id="过滤器先后顺序问题"><a href="#过滤器先后顺序问题" class="headerlink" title="过滤器先后顺序问题"></a>过滤器先后顺序问题</h5><ol><li>注解配置：按照类名的字符串比较规则比较，值小的先执行。例：<code>AFilter和BFilter，AFilter就会先执行。</code></li><li>web.xml配置：<code>&lt;filter-mapping&gt;</code> 谁定义在上边，谁先执行。</li></ol><h3 id="1-4-案例"><a href="#1-4-案例" class="headerlink" title="1.4 案例"></a>1.4 案例</h3><h4 id="1-登录验证"><a href="#1-登录验证" class="headerlink" title="1. 登录验证"></a>1. 登录验证</h4><p>将以前做的用户信息管理系统加上访问权限控制。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;** * 登录过滤器,访问除了登录资源以外的所有资源，都必须先登录 *&#x2F;@WebFilter(&quot;&#x2F;*&quot;)public class LoginFilter implements Filter {    public void destroy() {    }    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {        &#x2F;&#x2F; 0. 强制转换        HttpServletRequest request = (HttpServletRequest) req;        &#x2F;&#x2F; 1. 获取资源请求路径        String uri = request.getRequestURI();        &#x2F;&#x2F; 2. 判断是否是登录相关的资源,要注意排除掉css&#x2F;js&#x2F;图片&#x2F;验证码等资源        if (uri.contains(&quot;&#x2F;login.jsp&quot;) || uri.contains(&quot;loginServlet&quot;) || uri.contains(&quot;checkCodeServlet&quot;) || uri.contains(&quot;&#x2F;css&#x2F;&quot;) || uri.contains(&quot;&#x2F;js&#x2F;&quot;) || uri.contains(&quot;&#x2F;fonts&#x2F;&quot;)){            &#x2F;&#x2F; 是， 说明用户就是想登录，放行            chain.doFilter(req,resp);        }else {            &#x2F;&#x2F; 不是登录相关资源，需验证用户是否登录才能放行            &#x2F;&#x2F; 3. 从session中获取loginUser            Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;);            if(loginUser != null){                &#x2F;&#x2F; 登录过了，放行                chain.doFilter(req,resp);            }else {                &#x2F;&#x2F; 没有登录，跳转到登录页面                request.setAttribute(&quot;login_msg&quot;,&quot;你尚未登录，请登录&quot;);                request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,resp);            }        }        &#x2F;&#x2F; 2. 判断当前用户是否登录，通过session值是否有user来判断    }    public void init(FilterConfig config) throws ServletException {    }}</code></pre><h4 id="2-敏感词汇过滤"><a href="#2-敏感词汇过滤" class="headerlink" title="2. 敏感词汇过滤"></a>2. 敏感词汇过滤</h4><p>对用户管理系统项目的录入数据进行敏感词汇过滤，需要对request对象进行增强</p><h5 id="增强对象的功能："><a href="#增强对象的功能：" class="headerlink" title="增强对象的功能："></a>增强对象的功能：</h5><p>通过设计模式来解决。</p><blockquote><p><strong>设计模式</strong>：一些通用的解决固定问题的方式。</p></blockquote><p>这里主要使用代理模式来增强对象功能。</p><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><p>代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式；即通过<strong>代理对象</strong>访问<strong>目标对象</strong>。这样做的好处是：可以在目标对象实现的基础上，<strong>增强</strong>额外的<strong>功能</strong>操作，即扩展目标对象的功能。</p><p>详见：<a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">博客文章</a></p><blockquote><p>代理模式的关键点是：代理对象与目标对象。代理对象是对目标对象的扩展，并会调用目标对象，类似Python的装饰器。</p></blockquote><p>目标对象：真实的对象，被代理的对象。</p><p>代理对象：代理真实对象做一些操作。</p><p>代理模式：代理对象代理真实对象，达到增强真实对象功能的目的。</p><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>分静态代理和动态代理，这里主要讲解动态代理的使用。</p><h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>动态代理有以下特点：</p><ol><li>代理对象,不需要实现接口</li><li>代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</li><li>动态代理也叫做:JDK代理,接口代理</li></ol><h6 id="JDK生成代理对象的API"><a href="#JDK生成代理对象的API" class="headerlink" title="JDK生成代理对象的API"></a>JDK生成代理对象的API</h6><p>代理类所在包：<code>java.lang.reflect.Proxy</code></p><p>实现代理使用<code>newProxyInstance</code>方法，该方法需接收三个参数，分别是：</p><ul><li><code>ClassLoader loader</code>：指定当前目标对象使用类加载器，获取类加载器的方法是固定的。</li><li><code>Class&lt;?&gt;[] interfaces</code>：目标对象实现的接口类型，使用泛型方式确认类型</li><li><code>InvocationHandler()</code>：事件处理，执行目标对象的方法时，会触发事件处理器的方法，将当前执行目标对象的方法作为参数传入。</li></ul><p>增强方式：</p><ol><li>增强参数列表</li><li>增强返回值类型</li><li>增强方法体执行逻辑</li></ol><h5 id="代码示例：敏感词汇过滤器"><a href="#代码示例：敏感词汇过滤器" class="headerlink" title="代码示例：敏感词汇过滤器"></a>代码示例：敏感词汇过滤器</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class SensitiveWordsFilter implements Filter {    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {        &#x2F;&#x2F; 1. 创建代理对象，增强getParameter方法        ServletRequest proxy_req = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() {            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                &#x2F;&#x2F; 增强getParameter方法                &#x2F;&#x2F; 判断是否是getParameter方法                if (method.getName().equals(&quot;getParameter&quot;)){                    &#x2F;&#x2F; 增强返回值                    &#x2F;&#x2F; 1. 获取返回值                    String value = (String) method.invoke(req, args);                    &#x2F;&#x2F; 2. 判断不为空                    if (value != null){                        &#x2F;&#x2F; 3. 遍历敏感词汇数组,判断返回值是否有敏感词                        for (String str: list){                            if (value.contains(str)){                                &#x2F;&#x2F; 有，则替换为***                                value = value.replaceAll(str, &quot;***&quot;);                            }                        }                    }                    return value;                }            return method.invoke(req,args);            });            &#x2F;&#x2F; 放行            chain.doFilter(proxy_req,resp);        }        private List&lt;String&gt; list = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 敏感词汇集合    public void init(FilterConfig config) throws ServletException {        try{            &#x2F;&#x2F; 1. 获取文件真实路径            ServletContext servletContext = config.getServletContext();            String realPath = servletContext.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;SensitiveWords.txt&quot;);            &#x2F;&#x2F; 2. 读取文件            BufferedReader br = new BufferedReader(new FileReader(realPath));            &#x2F;&#x2F; 3. 将文件的每一行数据添加到list中            String line = null;            while((line = br.readLine()) != null){                list.add(line);            }            br.close();            System.out.println(list);        }catch (Exception e){            e.printStackTrace();        }    }    public void destroy() {    }}  </code></pre><h2 id="2-Listener：监听器"><a href="#2-Listener：监听器" class="headerlink" title="2. Listener：监听器"></a>2. Listener：监听器</h2><p>web的三大组件之一。用于监听web常见对象如：<code>HttpServletRequest,HttpSession,ServletContext。</code></p><h3 id="2-1-监听器的作用"><a href="#2-1-监听器的作用" class="headerlink" title="2.1 监听器的作用"></a>2.1 监听器的作用</h3><p>监听web对象创建与销毁。</p><p>监听web对象的属性变化。</p><p>监听session绑定JavaBean操作。</p><h3 id="2-2-事件监听机制基本概念"><a href="#2-2-事件监听机制基本概念" class="headerlink" title="2.2 事件监听机制基本概念"></a>2.2 事件监听机制基本概念</h3><ul><li>事件：一件事件</li><li>事件源：产生这件事情的源头。</li><li>监听器：对某件事情进行处理监听的一个对象</li><li>注册监听：将事件、事件源、监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码。</li></ul><h3 id="2-3-ServletContextListener"><a href="#2-3-ServletContextListener" class="headerlink" title="2.3 ServletContextListener"></a>2.3 <code>ServletContextListener</code></h3><p>用于监听<code>SeervletContext</code>对象的创建和销毁。有如下两个方法：</p><ul><li><code>void contextDestroyed(ServletContextEvent sce)</code>：<code>ServletContext</code>对象被销毁之前会调用该方法。</li><li><code>void contextInitialized(ServletContextEvent sce)</code>：<code>ServletContext</code>对象创建后会调用该方法。</li></ul><h3 id="2-4-步骤"><a href="#2-4-步骤" class="headerlink" title="2.4 步骤"></a>2.4 步骤</h3><ol><li><p>定义一个类，实现<code>ServletContextListener</code>接口</p></li><li><p>复写方法</p></li><li><p>配置</p><ul><li><p>web.xml配置</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">     &lt;listener&gt;         &lt;listener-class&gt;cn.zero.listener.ContextLoaderListener&lt;&#x2F;listener-class&gt;     &lt;&#x2F;listener&gt;</code></pre></li></ul></li></ol><ul><li>注解配置：<code>@WebListener</code></li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@WebListenerpublic class ContextLoaderListener implements ServletContextListener {    &#x2F;**     * 监听ServletContext对象创建的。ServletContext对象服务器启动后自动创建。     *     * 在服务器启动后自动调用     * @param servletContextEvent     *&#x2F;    @Override    public void contextInitialized(ServletContextEvent servletContextEvent) {        &#x2F;&#x2F; 加载资源文件        &#x2F;&#x2F; 1. 获取ServletContext对象        ServletContext servletContext = servletContextEvent.getServletContext();        &#x2F;&#x2F; 2. 加载资源文件        String contextConfigLocation = servletContext.getInitParameter(&quot;contextConfigLocation&quot;);        &#x2F;&#x2F; 3. 获取真实路径        String realPath = servletContext.getRealPath(contextConfigLocation);        &#x2F;&#x2F; 4. 加载进内存        try {            FileInputStream fis = new FileInputStream(realPath);            System.out.println(fis);        } catch (FileNotFoundException e) {            e.printStackTrace();        }        System.out.println(&quot;ServletContext对象被创建了....&quot;);    }    &#x2F;**     * 在服务器关闭后，ServletContext对象被销毁。     *     * 当服务器正常关闭后该方法被调用。     * @param servletContextEvent     *&#x2F;    @Override    public void contextDestroyed(ServletContextEvent servletContextEvent) {        System.out.println(&quot;ServletContext对象被销毁了....&quot;);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用户管理系统</title>
      <link href="/JavaWeb/exercise.html"/>
      <url>/JavaWeb/exercise.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-综合练习"><a href="#1-综合练习" class="headerlink" title="1. 综合练习"></a>1. 综合练习</h2><p>实现管理员登录，对用户信息进行增删改查的小项目</p><a id="more"></a><h3 id="1-1-简单功能"><a href="#1-1-简单功能" class="headerlink" title="1.1 简单功能"></a>1.1 简单功能</h3><h4 id="1-登录"><a href="#1-登录" class="headerlink" title="1. 登录"></a>1. 登录</h4><p>登录功能输入用户名密验证码，表单信息会提交到<code>loginServlet</code>进行登录校验，成功则跳转到首页，失败则返回失败信息。</p><h4 id="2-首页列表查询"><a href="#2-首页列表查询" class="headerlink" title="2. 首页列表查询"></a>2. 首页列表查询</h4><p>点击查询，会跳转到<code>findUserByPageServlet</code>，这个<code>Servlet</code>主要功能是查询总记录数据<code>findTotalCount()</code>和分页信息数据<code>findByPage()</code>，然后转发到前端做显示。</p><h4 id="3-添加"><a href="#3-添加" class="headerlink" title="3. 添加"></a>3. 添加</h4><p>点击添加联系人按钮，跳转到<code>add.jsp</code>页面，填写信息后点击提交，会将form表单填写的所有信息传递给<code>AddUserServlet</code>进行处理。</p><p><code>AddUserServlet</code>主要操作：</p><ol><li>设置编码<code>setCharacterEncoding(&quot;utf-8&quot;)</code></li><li>获取所有请求参数<code>request.getParameterMap()</code></li><li>使用<code>BeanUtils.populate</code>将请求参数封装成User对象</li><li>调用<code>service</code>的<code>addUser(User user)</code>方法完成保存</li><li>跳转回查询界面</li></ol><p><code>UserService</code>业务层主要进行保存操作。</p><p><code>UserDao</code>数据访问层，封装了对数据库的所有操作。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/23/3.%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD-1561276529181.bmp" alt="title"></p><h4 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h4><p>点击删除按钮，会将这条数据的ID获取，封装在请求头里面传递给后台</p><p><code>DelUserServlet</code>主要操作：</p><ol><li>获取要删除的用户ID，<code>getParameter</code></li><li>调用<code>service</code>的<code>delUser(String id)</code>方法完成删除</li><li>跳转回查询页面</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/23/4.%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD-1561276588764.bmp" alt="title"></p><h4 id="5-修改"><a href="#5-修改" class="headerlink" title="5. 修改"></a>5. 修改</h4><p>修改用到了两个<code>Servlet</code>进行处理。首先点击修改按钮，会将用户ID传递随请求头传递给<code>findUserServlet</code>。</p><p><code>findUserServlet</code>主要操作：</p><ol><li>获取用户ID</li><li>根据ID查询用户信息<code>findUser(id)</code>，返回一个User对象</li><li>将User对象存入request</li><li>转发到<code>update.jsp</code></li></ol><p><code>update.jsp</code>页面主要操作：</p><ol><li>从request域中获取User对象的数据</li><li>使用EL表达式将所有数据回写到页面里。<code>${user.xxx}</code></li><li>将获取的ID值填入隐藏域值，以确定修改用户。<code>&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${user.id}&quot;&gt;</code></li><li>点击提交，提交表单信息到<code>UpdateUserServlet</code>进行处理。</li></ol><p><code>UpdateUserServlet</code>主要操作：</p><ol><li>设置编码</li><li>获取表单数据，并封装成User对象</li><li>调用Service方法<code>updateUser(User user)</code>，将User对象传入，完成修改</li><li>跳转回查询页面</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/23/5.%E4%BF%AE%E6%94%B9%E5%8A%9F%E8%83%BD-1561276609416.bmp" alt="title"></p><h3 id="1-2-复杂功能"><a href="#1-2-复杂功能" class="headerlink" title="1.2 复杂功能"></a>1.2 复杂功能</h3><h4 id="1-删除选中"><a href="#1-删除选中" class="headerlink" title="1. 删除选中"></a>1. 删除选中</h4><p>点击删除选中按钮，主要问题就是要先获取选中的用户条目，在将这些选中条目的ID提交到后台进行批量删除操作。</p><h5 id="1-1-获取选中条目的ID-通过form表单提交到后台。"><a href="#1-1-获取选中条目的ID-通过form表单提交到后台。" class="headerlink" title="1.1 获取选中条目的ID,通过form表单提交到后台。"></a>1.1 获取选中条目的ID,通过form表单提交到后台。</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&#x2F;*为删除选中按钮绑定单击事件，提交每个条目复选框的值(该值就是条目的ID)1. 给每一个条目添加checkbox,值是条目对应的ID2. 获取当前页面的所有复选框标签，然后遍历，判断其是否有checked属性，有则允许提交表单3. 提交form表单*&#x2F;window.onload = function () {    &#x2F;&#x2F; 为删除选中绑定单击事件    document.getElementById(&quot;delSelected&quot;).onclick = function () {        if (confirm(&quot;确定要删除所有选中的信息么?&quot;)){            var flag = false;            &#x2F;&#x2F; 判断是否有选中信息            var cbs = document.getElementsByName(&quot;uid&quot;);            for (var i = 0; i &lt; cbs.length; i++) {                if(cbs[i].checked){ &#x2F;&#x2F; 如果有任何一个信息被选中(checkbox.checked返回布尔值，表示是否被选中)                    flag = true; &#x2F;&#x2F; 允许提交                    break;                }            }            if (flag)&#x2F;&#x2F;判断是否允许提交                &#x2F;&#x2F; 使用提交方法提交信息到后台                document.getElementById(&quot;form&quot;).submit();        }    }}&#x2F;*全选&#x2F;全不选功能JS代码1. 在表头单元格添加一个复选框2. 获取该复选框标签对象3. 为该对象绑定单击事件，点击就获取所有的复选框对象，然后遍历，设置这些复选框的checked=this.checked。(this:就是当前复选框对象,即&#39;firstCB&#39;)*&#x2F;document.getElementById(&quot;firstCB&quot;).onclick = function () {    &#x2F;&#x2F; 获取列表所有的cb    var cbs = document.getElementsByName(&quot;uid&quot;);    &#x2F;&#x2F; 遍历    for (var i = 0; i &lt; cbs.length; i++) {        &#x2F;&#x2F; 设置这些cbs[i]的checked状态等于firstCB.checked        cbs[i].checked = this.checked;    }}</code></pre><h5 id="1-2-后台DelSelectedServlet主要操作"><a href="#1-2-后台DelSelectedServlet主要操作" class="headerlink" title="1.2 后台DelSelectedServlet主要操作"></a>1.2 后台<code>DelSelectedServlet</code>主要操作</h5><ol><li>获取请求参数的ID数组。<code>getParameterValues()</code></li><li>调用<code>service</code>的<code>delUser(String[] ids)</code>进行批量删除。该方法会对id数组进行遍历，然后调用<code>dao</code>的<code>delUser(Int id)</code>方法操作数据库进行删除。</li><li>全部删除完毕，跳转回查询页面。</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/23/6.%E5%88%A0%E9%99%A4%E9%80%89%E4%B8%AD%E5%8A%9F%E8%83%BD-1561276629972.bmp" alt="title"></p><h4 id="2-分页查询"><a href="#2-分页查询" class="headerlink" title="2. 分页查询"></a>2. 分页查询</h4><h4 id="2-1-好处："><a href="#2-1-好处：" class="headerlink" title="2.1 好处："></a>2.1 好处：</h4><ol><li>减轻服务器内存的开销</li><li>提升用户的体验</li></ol><h4 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2 分析"></a>2.2 分析</h4><p>前端需要传递给后台的信息主要有两个，当前页码<code>currentPage</code>和每页显示条数<code>rows</code></p><ol><li>当前页码<code>currentPage</code>：需要查询数据库得到总记录数<code>totalCount=select count(*) from user;</code>，然后通过三元运算符<code>totalCount % rows == 0 ? totalCount / rows:totalCount / rows + 1</code>计算出<code>totalPage</code>总页码。将总页码数返回给前端页面做进一步处理</li><li>每页显示条数<code>rows</code>：自定义的条数。</li></ol><p>当第一次访问<code>findUserByPageServlet</code>时，后台会做两次SQL查询，查询总记录数和当前分页数据，然后全部封装进<code>PageBean</code>对象，存入request返回。前端接受到这个对象，会在分页查询功能区遍历该对象，进行当前页码计算，以确定有多少分页。当用户点击不同分页时，会将当前页码返回给<code>findUserByPageServlet</code>做进一步的查询操作。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%--分页查询部分代码,遍历生成li,有多少页就会生成多少li--%&gt;&lt;c:forEach begin=&quot;1&quot; end=&quot;${userPage.totalPage}&quot; var=&quot;i&quot;&gt;    &lt;c:if test=&quot;${userPage.currentPage == i}&quot;&gt; &lt;%--如果服务器返回的页码等于当前页码，则将按钮激活--%&gt;        &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;${pageContext.request.contextPath}&#x2F;findUserByPageServlet?currentPage=${i}&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}&quot;&gt;${i}&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;c:if&gt;    &lt;c:if test=&quot;${userPage.currentPage != i}&quot;&gt; &lt;%--如果服务器返回的页码不等于当前页码，则正常显示--%&gt;        &lt;li&gt;&lt;a href=&quot;${pageContext.request.contextPath}&#x2F;findUserByPageServlet?currentPage=${i}&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}&quot;&gt;${i}&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;c:if&gt;&lt;&#x2F;c:forEach&gt;</code></pre><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/23/7.%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD-1561276688555.bmp" alt="title"><br><code>findUserByPageServlet</code>主要操作：</p><ol><li>接受请求参数，获取当前页码和每页显示条目数</li><li>调用<code>service</code>的<code>findUserByPage(currentPage,rows,condition)</code>方法查询数据，返回<code>PageBean</code>对象，里面封装了当前分页数据对象。</li><li>将<code>PageBean</code>对象存入request域中</li><li>转发到<code>list.jsp</code>进行显示</li></ol><p><code>findUserByPage()</code>方法主要功能：</p><ol><li>创建一个空的<code>PageBean</code>对象</li><li>设置当前页码属性和显示条目属性</li><li>调用<code>dao</code>的<code>findTotalCount()</code>方法查询总记录数，并设置进<code>PageBean</code></li><li>计算开始索引<code>start = (currentPage - 1) * rows</code>，然后调用<code>dao</code>的<code>findByPage(start,rows)</code>方法查询当前分页数据集合。</li><li>计算总页码数，并设置。</li><li>返回<code>PageBean</code>对象</li></ol><p><code>findTotalCount</code>方法功能：</p><ol><li>定义模板初始化sql。<code>select count(*) from user where 1 = 1</code></li><li>遍历条件map，获取其值</li><li>如果值不为空或null，则拼接sql字符串，同时将对应值传入list集合。</li><li>使用<code>queryForObject()</code>方法查询出总记录数，并返回</li></ol><p><code>findByPage</code>方法功能：</p><ol><li>定义初始化sql。</li><li>遍历条件map，获取其值</li><li>如果值不为空或null，则拼接sql字符串，同时将对应值传入list集合。</li><li>将分页查询添加进sql字符串。<code>limit ?,?</code></li><li>将分页查询参数值添加入参数集合中。<code>params.add(start); params.add(rows);</code></li><li>使用<code>query</code>查询数据，返回分页数据对象集合。</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/23/7_2.%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD2-1561276716927.bmp" alt="title"></p><h4 id="3-复杂条件查询"><a href="#3-复杂条件查询" class="headerlink" title="3. 复杂条件查询"></a>3. 复杂条件查询</h4><p>前端主要就是要将复杂条件查询的数据通过表单参数提交到后台，后台获取参数map后，调用方法查询数据，返回当前分页数据。将<code>PageBean</code>和条件参数map存入request，交给前端做进一步处理。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/23/%E5%A4%8D%E6%9D%82%E6%9D%A1%E4%BB%B6%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-1561276734854.bmp" alt="title"></p><h3 id="项目成果"><a href="#项目成果" class="headerlink" title="项目成果"></a>项目成果</h3><p><a href="http://111.230.219.30/showUser/login.jsp" target="_blank" rel="noopener">用户信息管理系统</a></p><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><h4 id="6月26号"><a href="#6月26号" class="headerlink" title="6月26号"></a>6月26号</h4><p>完成了项目主体内容，前后端数据交互进行复杂条件查询，分页查询，增加用户，删除用户，批量删除等功能。</p><h4 id="6月27号"><a href="#6月27号" class="headerlink" title="6月27号"></a>6月27号</h4><ol><li>学习了filter过滤器，编写了过滤器实现访问权限控制。即访问除了登录相关页面以外的页面或者资源，会先进行判断用户是否登录，登录则放行，未登录则转发到登录页面。</li><li>将前端分页查询到的内容用户编号显示，进行了唯一操作。即查询到10个用户，第一页会显示编号1~5的用户，第二页显示5~10用户。</li></ol><h4 id="7月1号"><a href="#7月1号" class="headerlink" title="7月1号"></a>7月1号</h4><p>将复杂条件搜索框整合为了一个，实现了输入查询条件，显示符合条件的用户信息。其主要难点在于数据传递和SQL语句的编写。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;2019.6.24&#39;</title>
      <link href="/uncategorized/19.6.24.html"/>
      <url>/uncategorized/19.6.24.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="咕咕咕！"><a href="#咕咕咕！" class="headerlink" title="咕咕咕！"></a>咕咕咕！</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/24/gugugu-1561391154795.jpg" alt="title"></p><a id="more"></a><p>最近一直在做一个Web端小项目：用户管理系统</p><p>昨天也买了腾讯的云服务器，打算这两天就把项目部署一下。</p><p>然后Web阶段的学习预计六月底能结束，可以开始总结知识点，复习一下了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP和MVC</title>
      <link href="/JavaWeb/jsp.html"/>
      <url>/JavaWeb/jsp.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-JSP"><a href="#1-JSP" class="headerlink" title="1. JSP"></a>1. JSP</h2><p>JSP全称<code>Java Server Pages</code>，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以<code>&lt;%开头 以%&gt;</code>结束。</p><a id="more"></a><h3 id="1-1-指令"><a href="#1-1-指令" class="headerlink" title="1.1 指令"></a>1.1 指令</h3><p>指令主要用于配置JSP页面，导入资源文件。</p><ul><li><p>格式：<code>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;</code></p></li><li><p>主要有三种指令：page、include、taglib</p></li></ul><h4 id="1-1-1-page"><a href="#1-1-1-page" class="headerlink" title="1.1.1 page"></a>1.1.1 page</h4><p>主要用于配置JSP页面的</p><ol><li><code>contentType()</code>：设置响应体的mime类型以及字符集，设置当前jsp页面的编码(只有高级的IDE才能生效，如果使用低级工具，则需使用<code>pageEncoding</code>属性来设置当前页面的字符集)。</li><li><code>import</code>：导包，用法同Java中的导包。</li><li><code>errorPage</code>：当前页面发生异常后，会自动跳转到指定的错误页面</li><li><code>isErrorPage</code>：标识当前页面是否是错误页面，默认值false。设置为true代表当前页面是错误页面，就可以使用内置对象<code>exception</code>。</li></ol><h4 id="1-1-2-include"><a href="#1-1-2-include" class="headerlink" title="1.1.2 include"></a>1.1.2 include</h4><p>页面包含的，用于导入其他页面的资源文件</p><ul><li><code>&lt;%@include file=&quot;other.jsp&quot; %&gt;</code></li></ul><h4 id="1-1-3-taglib"><a href="#1-1-3-taglib" class="headerlink" title="1.1.3 taglib"></a>1.1.3 taglib</h4><p>导入外部资源</p><ul><li><code>&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;</code><ul><li><code>prefix</code>：前缀，自定义的。</li></ul></li></ul><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><ol><li>html注释<code>&lt;!--  --&gt;</code>：只能注释html代码片段。</li><li>JSP注释<code>&lt;%--  --%&gt;</code>：可以注释所有，推荐使用。</li></ol><h3 id="1-3-内置对象"><a href="#1-3-内置对象" class="headerlink" title="1.3 内置对象"></a>1.3 内置对象</h3><p>在jsp页面中不需要创建，直接使用的对象就是内置对象，一共有9个。     </p><table><thead><tr><th>变量名</th><th>真实类型</th><th>作用</th></tr></thead><tbody><tr><td><code>pageContext</code></td><td><code>PageContext</code></td><td>当前页面共享数据，还可以获取其他八个内置对象</td></tr><tr><td><code>request</code></td><td><code>HttpServletRequest</code></td><td>一次请求访问的多个资源(通过转发)</td></tr><tr><td><code>session</code></td><td><code>HttpSession</code></td><td>一次会话的多个请求间</td></tr><tr><td><code>application</code></td><td><code>ServletContext</code></td><td>所有用户间共享数据</td></tr><tr><td><code>response</code></td><td><code>HttpServletResponse</code></td><td>响应对象</td></tr><tr><td><code>page</code></td><td><code>Object</code></td><td>当前页面(Servlet)的对象，<code>this</code></td></tr><tr><td><code>out</code></td><td><code>JspWriter</code></td><td>输出对象，数据输出到页面上</td></tr><tr><td><code>config</code></td><td><code>ServletConfig</code></td><td>Servlet的配置对象</td></tr><tr><td><code>exception</code></td><td><code>Throwable</code></td><td>异常对象</td></tr></tbody></table><h4 id="面试题：写出JSP中的9个内置对象"><a href="#面试题：写出JSP中的9个内置对象" class="headerlink" title="面试题：写出JSP中的9个内置对象"></a>面试题：写出JSP中的9个内置对象</h4><h2 id="2-MVC开发模式"><a href="#2-MVC开发模式" class="headerlink" title="2. MVC开发模式"></a>2. MVC开发模式</h2><h3 id="2-1-JSP演变历史"><a href="#2-1-JSP演变历史" class="headerlink" title="2.1 JSP演变历史"></a>2.1 JSP演变历史</h3><ol><li>早期只有servlet，只能使用response输出标签数据，非常麻烦</li><li>后来出现了jsp，简化了Servlet的开发，但是如果过度的使用jsp，在jsp中既写大量的java代码，又写html标签，会造成代码很难维护，也很难分工协作。</li><li>故此后Java的Web开发，借鉴了MVC开发模式，使得程序的设计更加合理性。</li></ol><h3 id="2-2-MVC"><a href="#2-2-MVC" class="headerlink" title="2.2 MVC"></a>2.2 MVC</h3><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p><ol><li>M：Model(模型)，JavaBean。主要完成具体的业务操作，如：查询数据库，封装对象等。</li><li>V：View(视图)，JSP。主要展示数据</li><li>C：Controller(控制器)，Servlet。主要功能有获取用户的输入，调用模型，将模型返回的数据交给视图进行展示。</li></ol><h4 id="2-2-1-优缺点"><a href="#2-2-1-优缺点" class="headerlink" title="2.2.1 优缺点"></a>2.2.1 优缺点</h4><p>优点：</p><ol><li>耦合性低，方便维护，有利于分工协作</li><li>复用性高</li></ol><p>缺点：</p><ol><li>使得项目架构变得复杂，对开发人员要求高</li></ol><h2 id="3-EL表达式"><a href="#3-EL表达式" class="headerlink" title="3. EL表达式"></a>3. EL表达式</h2><p> EL（Expression Language） 是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。</p><ul><li>语法：<code>${表达式}</code></li><li>jsp默认支持el表达式，有两种方法可以忽略el表达式。<ol><li>忽略当前jsp页面中所有的el表达式：设置jsp中的page指令<code>isELIgnored=&quot;true&quot;</code>即可。</li><li>忽略当前el表达式：使用<code>\${表达式}</code></li></ol></li></ul><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a>3.1 基本使用</h3><h4 id="3-1-1-运算符"><a href="#3-1-1-运算符" class="headerlink" title="3.1.1 运算符"></a>3.1.1 运算符</h4><ol><li>算数运算符：<code>+ - * /(div) %(mod)</code></li><li>比较运算符：<code>&gt; &lt; = &gt;= &lt;= == !=</code></li><li>逻辑运算符：<code>&amp;&amp;(and)  ||(or)  !(not)</code></li><li>空运算符：empty<ul><li>功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0。</li><li><code>${empty list}</code>：判断list是否为null或者长度为0</li><li><code>${not empty str}</code>：表示判断str对象是否不为null并且长度&gt;0</li></ul></li></ol><h4 id="3-1-2-获取值"><a href="#3-1-2-获取值" class="headerlink" title="3.1.2 获取值"></a>3.1.2 获取值</h4><p>el表达式只能从域对象中获取值，语法如下</p><h5 id="1-域名称-键名"><a href="#1-域名称-键名" class="headerlink" title="1.${域名称.键名}"></a>1.<code>${域名称.键名}</code></h5><h5 id="表示从指定域中获取指定键的值。"><a href="#表示从指定域中获取指定键的值。" class="headerlink" title="表示从指定域中获取指定键的值。"></a>表示从指定域中获取指定键的值。</h5><p>域名称对应对象：</p><table><thead><tr><th>域名称</th><th>对象</th></tr></thead><tbody><tr><td>pageScope</td><td>pageContext</td></tr><tr><td>requestScope</td><td>request</td></tr><tr><td>sessionScope</td><td>session</td></tr><tr><td>applicationScope</td><td>application(ServletContext)</td></tr></tbody></table><p>例：在request域中存储了name=张三，使用<code>${requestScope.name}</code>即可获取值。</p><h5 id="2-键名"><a href="#2-键名" class="headerlink" title="2. ${键名"></a>2. <code>${键名</code></h5><p>表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p><h5 id="3-获取对象、List集合、Map集合的值"><a href="#3-获取对象、List集合、Map集合的值" class="headerlink" title="3. 获取对象、List集合、Map集合的值"></a>3. 获取对象、List集合、Map集合的值</h5><ul><li>获取对象：<code>${域名称.键名.属性名}</code>，其本质上会去调用对象的<code>getter</code>方法</li><li>获取List集合：<code>${域名称.键名[索引]}</code></li><li>获取Map集合：<code>${域名称.键名.key名称}</code>或者<code>${域名称.键名[&quot;key名称&quot;]}</code></li></ul><h4 id="3-1-3-隐式对象"><a href="#3-1-3-隐式对象" class="headerlink" title="3.1.3 隐式对象"></a>3.1.3 隐式对象</h4><p>EL表达式中有11个隐式对象，常用的就pageContext</p><p><code>pageContext</code>：获取jsp其他八个内置对象</p><p>通常用它来动态获取虚拟目录：<code>${pageContext.request.contextPath}</code></p><h2 id="4-JSTL标签"><a href="#4-JSTL标签" class="headerlink" title="4. JSTL标签"></a>4. JSTL标签</h2><ul><li><code>JavaServer Pages Tag Library</code>：JSP标准标签库，是由Apache组织提供的开源免费的jsp标签</li><li>作用：用于简化和替换jsp页面上的java代码</li></ul><h3 id="4-1-使用步骤"><a href="#4-1-使用步骤" class="headerlink" title="4.1 使用步骤"></a>4.1 使用步骤</h3><ol><li>导入JSTL相关jar包</li><li>引入标签库，使用taglib指令：<code>&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;</code></li><li>使用标签</li></ol><h3 id="4-2-常用的JSTL标签"><a href="#4-2-常用的JSTL标签" class="headerlink" title="4.2 常用的JSTL标签"></a>4.2 常用的JSTL标签</h3><h4 id="4-2-1-if"><a href="#4-2-1-if" class="headerlink" title="4.2.1 if"></a>4.2.1 if</h4><p>相当于java代码的if语句，有一个必须属性<code>test</code>。</p><ul><li><code>test</code>属性：接受布尔表达式<ul><li>如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容。</li><li>一般情况下，test属性值会结合el表达式一起使用</li></ul></li><li>注意：<code>c:if</code>标签没有else情况，想要else情况，则可以再定义一个<code>c:if</code>标签</li></ul><h4 id="4-2-2-choose"><a href="#4-2-2-choose" class="headerlink" title="4.2.2 choose"></a>4.2.2 choose</h4><p>相当于java代码的switch语句</p><h4 id="4-2-3-foreach"><a href="#4-2-3-foreach" class="headerlink" title="4.2.3 foreach"></a>4.2.3 foreach</h4><p>相当于java代码的for语句，代码举例如下</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;foreach标签&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;%--    foreach:相当于java的for语句        1. 完成重复性操作            属性：                begin:开始值                end：结束值                var：临时遍历                step：步长                varStatus:循环状态对象                    index: 容器中元素的索引，从0开始                    count：循环次数，从1开始        2. 遍历容器            属性：                items：容器对象                var：容器中元素的临时变量                varStatus:循环状态对象                    index: 容器中元素的索引，从0开始                    count：循环次数，从1开始--%&gt;&lt;c:forEach begin=&quot;0&quot; end=&quot;10&quot; var=&quot;i&quot; step=&quot;2&quot; varStatus=&quot;s&quot;&gt;    ${i} &lt;h3&gt;${s.index}&lt;&#x2F;h3&gt;&lt;&#x2F;c:forEach&gt;&lt;hr&gt;&lt;%    List list = new ArrayList();    list.add(&quot;a&quot;);    list.add(&quot;b&quot;);    list.add(&quot;c&quot;);    list.add(&quot;d&quot;);    request.setAttribute(&quot;list&quot;,list);%&gt;&lt;c:forEach items=&quot;${list}&quot; var=&quot;str&quot; varStatus=&quot;s&quot;&gt;    ${s.index} ${s.count} ${str}&lt;br&gt;&lt;&#x2F;c:forEach&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3 id="4-3-综合练习"><a href="#4-3-综合练习" class="headerlink" title="4.3 综合练习"></a>4.3 综合练习</h3><p>在request域中有一个存有User对象的List集合。需要使用jstl+el将List集合数据展示到jsp页面的表格table中。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;cn.zero.domain.User&quot; %&gt;&lt;%@ page import=&quot;java.util.Date&quot; %&gt;&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;综合练习&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;%--    在request域中有一个存有User对象的List集合。    请使用jstl+el将List集合数据展示到jsp页面的表格table中。--%&gt;&lt;%    List list = new ArrayList();    list.add(new User(&quot;小张&quot;,21,new Date()));    list.add(new User(&quot;小王&quot;,22,new Date()));    list.add(new User(&quot;小李&quot;,23,new Date()));    request.setAttribute(&quot;list&quot;,list);%&gt;&lt;table border=&quot;1&quot; width=&quot;500&quot; align=&quot;center&quot;&gt;    &lt;tr&gt;        &lt;th&gt;编号&lt;&#x2F;th&gt;        &lt;th&gt;姓名&lt;&#x2F;th&gt;        &lt;th&gt;年龄&lt;&#x2F;th&gt;        &lt;th&gt;生日&lt;&#x2F;th&gt;    &lt;&#x2F;tr&gt;    &lt;c:forEach items=&quot;${list}&quot; var=&quot;user&quot; varStatus=&quot;s&quot;&gt;        &lt;c:if test=&quot;${s.count % 2 == 0}&quot;&gt;            &lt;tr bgcolor=&quot;#f08080&quot;&gt;                &lt;td&gt;${s.count}&lt;&#x2F;td&gt;                &lt;td&gt;${user.name}&lt;&#x2F;td&gt;                &lt;td&gt;${user.age}&lt;&#x2F;td&gt;                &lt;td&gt;${user.birStr}&lt;&#x2F;td&gt;            &lt;&#x2F;tr&gt;        &lt;&#x2F;c:if&gt;        &lt;c:if test=&quot;${s.count % 2 != 0}&quot;&gt;            &lt;tr bgcolor=&quot;#00bfff&quot;&gt;                &lt;td&gt;${s.count}&lt;&#x2F;td&gt;                &lt;td&gt;${user.name}&lt;&#x2F;td&gt;                &lt;td&gt;${user.age}&lt;&#x2F;td&gt;                &lt;td&gt;${user.birStr}&lt;&#x2F;td&gt;            &lt;&#x2F;tr&gt;        &lt;&#x2F;c:if&gt;    &lt;&#x2F;c:forEach&gt;&lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="5-三层架构"><a href="#5-三层架构" class="headerlink" title="5. 三层架构"></a>5. 三层架构</h2><p>三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/19/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84-1560957316811.png" alt="title"></p><ul><li>界面层(表示层)：用户看的界面。用户可以通过界面上的组件和服务器进行交互。</li><li>业务逻辑层：处理业务逻辑的。</li><li>数据访问层：操作数据存储文件。</li></ul><h2 id="6-综合案例：用户信息列表展示"><a href="#6-综合案例：用户信息列表展示" class="headerlink" title="6. 综合案例：用户信息列表展示"></a>6. 综合案例：用户信息列表展示</h2><h3 id="6-1-需求"><a href="#6-1-需求" class="headerlink" title="6.1 需求"></a>6.1 需求</h3><p>用户点击查询，显示所有用户，可以对数据进行增删改查操作</p><h3 id="6-2-设计"><a href="#6-2-设计" class="headerlink" title="6.2 设计"></a>6.2 设计</h3><h4 id="6-2-1-技术选型"><a href="#6-2-1-技术选型" class="headerlink" title="6.2.1 技术选型"></a>6.2.1 技术选型</h4><p><code>Servlet+JSP+MySQL+JDBCTemplate+Duird+BeanUtils+tomcat</code></p><h4 id="6-2-2-数据库设计"><a href="#6-2-2-数据库设计" class="headerlink" title="6.2.2 数据库设计"></a>6.2.2 数据库设计</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">create database Users; -- 创建数据库use Users;create table user( -- 创建表id int primary key auto_increment,    name varchar(20) not null,    gender varchar(5),    age int,    address varchar(32),    qq varchar(20),    email varchar(50))</code></pre><h4 id="6-2-3-开发阶段"><a href="#6-2-3-开发阶段" class="headerlink" title="6.2.3 开发阶段"></a>6.2.3 开发阶段</h4><ol><li>环境搭建<ol><li>创建数据库环境</li><li>创建项目，导入所需jar包</li></ol></li><li>编码</li></ol><h4 id="6-2-4-测试"><a href="#6-2-4-测试" class="headerlink" title="6.2.4 测试"></a>6.2.4 测试</h4><h4 id="6-2-5-部署运维"><a href="#6-2-5-部署运维" class="headerlink" title="6.2.5 部署运维"></a>6.2.5 部署运维</h4><h3 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h3><h3 id="6-3-1-分析图"><a href="#6-3-1-分析图" class="headerlink" title="6.3.1 分析图"></a>6.3.1 分析图</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/19/1560959814288-1560959814341.png" alt="title"></p><p>代码后续见GitHub</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>会话技术Cookie和Session</title>
      <link href="/JavaWeb/CookieAndSession.html"/>
      <url>/JavaWeb/CookieAndSession.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-会话技术"><a href="#1-会话技术" class="headerlink" title="1. 会话技术"></a>1. 会话技术</h2><p>会话是浏览器和服务器之间的多次请求和响应，在一次会话中往往会产生一些数据，可以通过会话技术(Session和Cookie)保存会话中产生的数据</p><a id="more"></a><p>一次会话中包含多次请求和响应</p><ul><li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。</li><li>主要功能：在一次会话的范围内的多次请求之间，共享数据</li><li>客户端会话技术：Cookie</li><li>服务器端会话技术：Session</li></ul><h2 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h2><p>客户端会话技术，将数据保存到客户端</p><h3 id="2-1-快速入门"><a href="#2-1-快速入门" class="headerlink" title="2.1 快速入门"></a>2.1 快速入门</h3><ol><li>创建Cookie对象，绑定数据：<code>new Cookie(String name, String value)</code></li><li>发送Cookie对象：<code>response.addCookie(Cookie cookie)</code></li><li>获取Cookie，拿到数据：<code>Cookie[] request.getCookies()</code></li></ol><h3 id="2-2-实现原理"><a href="#2-2-实现原理" class="headerlink" title="2.2 实现原理"></a>2.2 实现原理</h3><p>基于响应头<code>set-cookie</code>和请求头<code>cookie</code>实现 </p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/16/Cookie%E5%8E%9F%E7%90%86-1560669241487.bmp" alt="title"></p><h3 id="2-3-cookie的细节"><a href="#2-3-cookie的细节" class="headerlink" title="2.3 cookie的细节"></a>2.3 cookie的细节</h3><ol><li><p>一次可不可以发送多个cookie？</p><p>可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可</p></li><li><p>cookie在浏览器中保存多长时间？</p><p>默认情况下，当浏览器关闭后，Cookie数据被销毁。可以通过设置<code>setMaxAge(int seconds)</code>来进行持久化存储，参数填写正数：将Cookie数据写到硬盘的文件中，持久化存储，并指定cookie存活时间，时间到后，cookie文件自动失效；负数是默认值，即浏览器关闭自动销毁；零表示删除cookie信息。</p></li><li><p>cookie能不能存储中文？</p><p>在tomcat8之前cookie中不能直接存储中文数据，需要将中文数据进行转码(一般采用URL编码，使用<code>URLEncoder</code>和<code>URLDecoder</code>来编解码)；在tomcat8之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，方便URL解码解析。</p></li><li><p>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享呢？</p><p>默认情况下cookie不能共享。可以通过<code>setPath(String path)</code>方法设置cookie的获取范围，默认情况下设置当前虚拟目录，如果要共享，将path设置为<code>&quot;/&quot;</code>即可。</p></li><li><p>在不同的tomcat服务器之间cookie能否共享？</p><p>可以通过<code>setDomain(String path)</code>方法设置域名，如果设置的一级域名相同，那么多个服务器之间cookie可以共享，例：<code>setDomain(&quot;.baidu.com&quot;)</code>，那么<code>tieba.baidu.com</code>和<code>news.baidu.com</code>中的cookie可以共享。</p></li></ol><blockquote><p>一级域名：一级域名中只含有一个<code>.</code>，且<code>.</code>左边要没有内容。最后一个点的右边被称为一级域名，一级域名又被称为顶级域名。一级域名左边有内容的是二级域名。例<code>tieba.baidu.com</code>中，<code>.baodu.com</code>就是一级域名。</p></blockquote><h3 id="2-4-Cookie的特点和作用"><a href="#2-4-Cookie的特点和作用" class="headerlink" title="2.4 Cookie的特点和作用"></a>2.4 Cookie的特点和作用</h3><ol><li>cookie存储数据在客户端浏览器</li><li>浏览器对于单个cookie的大小有限制(4kb)，以及对同一个域名下的总cookie数量也有限制(20个)</li><li>cookie一般用于存储少量的不敏感数据</li><li>在不登录的情况下，完成服务器对客户端的身份识别(记住我)</li></ol><h3 id="2-5-案例："><a href="#2-5-案例：" class="headerlink" title="2.5 案例："></a>2.5 案例：</h3><p>记住上一次访问时间</p><h4 id="2-5-1-需求"><a href="#2-5-1-需求" class="headerlink" title="2.5.1 需求"></a>2.5.1 需求</h4><ol><li>访问一个Servlet，如果是第一次访问，则提示：你好，欢迎你首次访问</li><li>如果不是第一次访问，则提示：欢迎回来，你上次访问时间是：xxxx</li></ol><h4 id="2-5-2-需求分析"><a href="#2-5-2-需求分析" class="headerlink" title="2.5.2 需求分析"></a>2.5.2 需求分析</h4><ol><li>采用cookie来完成</li><li>在服务器中的Servlet判断是否有一个名为lastTime的cookie<ul><li>有：代表不是第一次访问，先响应数据：欢迎回来，你上次访问时间是：xxxx。在回写cookie：将lasttime更新</li><li>没有：代表是第一次访问，响应数据：你好，欢迎首次访问。回写cookie：设置一个lasttime为当前时间。</li></ul></li></ol><h4 id="2-5-3-代码实现"><a href="#2-5-3-代码实现" class="headerlink" title="2.5.3 代码实现"></a>2.5.3 代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@WebServlet(&quot;&#x2F;CookieExercise&quot;)public class CookieExercise extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 设置响应的消息体的数据格式以及编码        response.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;);        &#x2F;&#x2F; 1. 获取所有cookie        Cookie[] cookies = request.getCookies();        boolean flag = false; &#x2F;&#x2F; 默认cookie没有lastTime        &#x2F;&#x2F; 如果有cookie，则进行遍历        if (cookies != null &amp;&amp; cookies.length &gt; 0){            &#x2F;&#x2F; 2. 遍历cookie数据            for (Cookie cookie : cookies) {                &#x2F;&#x2F; 3. 获取cookie的名称                String name = cookie.getName();                &#x2F;&#x2F; 4. 判断名称是否是：lastTime                if (&quot;lastTime&quot;.equals(name)){                    &#x2F;&#x2F; 有，则代表不是第一次访问                    flag = true; &#x2F;&#x2F; 代表有lastTime                    &#x2F;&#x2F; 设置cookie的value                    &#x2F;&#x2F; 获取当前时间的字符串，重新设置cookie的值，然后发送                    Date date = new Date();                    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);                    String str_date = sdf.format(date);                    System.out.println(&quot;编码前：&quot;+str_date);                    &#x2F;&#x2F; url编码                    str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);                    System.out.println(&quot;编码后：&quot;+str_date);                    &#x2F;&#x2F; 设置cookie的存活时间一个月                    cookie.setMaxAge(60 * 60 * 24 * 30);                    response.addCookie(cookie); &#x2F;&#x2F; 将cookie值添加                    &#x2F;&#x2F; 5. 响应数据                    &#x2F;&#x2F; 获取cookie的value值                    String value = cookie.getValue();                    System.out.println(&quot;解码前：&quot;+value);                    &#x2F;&#x2F; url解码                    value = URLDecoder.decode(value,&quot;utf-8&quot;);                    System.out.println(&quot;解码后：&quot;+value);                    &#x2F;&#x2F; 将数据响应                    response.getWriter().write(&quot;&lt;h3&gt;欢迎回来,你的上次访问时是&quot;+value+&quot;&lt;&#x2F;h3&gt;&quot;);                    break;                }            }        }        &#x2F;&#x2F; 如果没有cookie信息或者没有lastTime        if (cookies == null || cookies.length == 0 || flag == false){            &#x2F;&#x2F; 没有，代表是第一次访问            &#x2F;&#x2F; 获取当前时间字符串，设置cookie值发送            Date date = new Date();            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);            String str_date = sdf.format(date);            System.out.println(&quot;编码前：&quot;+str_date);            &#x2F;&#x2F; url编码            str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;);            System.out.println(&quot;编码后：&quot;+str_date);            &#x2F;&#x2F; 新建cookie对象，设置lastTime            Cookie cookie = new Cookie(&quot;lastTime&quot;, str_date);            &#x2F;&#x2F; 设置cookie存活时间            cookie.setMaxAge(60 * 60 * 24 * 30);            &#x2F;&#x2F; 发送cookie            response.addCookie(cookie);            &#x2F;&#x2F; 响应数据            response.getWriter().write(&quot;&lt;h3&gt;你好，欢迎首次访问&lt;&#x2F;h3&gt;&quot;);        }    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}</code></pre><h2 id="3-JSP简单入门"><a href="#3-JSP简单入门" class="headerlink" title="3. JSP简单入门"></a>3. JSP简单入门</h2><p>Java Server Pages（Java服务器端页面），简称JSP。可以理解为一个特殊的页面，其中既可以定义html标签，又可以定义java代码。主要用于简化书写。</p><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><ul><li>JSP本质上就是一个Servlet，通过<code>HttpJspBase</code>来生成Servlet。</li></ul><p><code>public abstract class HttpJspBase extends HttpServlet implements HttpJspPage</code></p><h3 id="3-2-JSP的脚本"><a href="#3-2-JSP的脚本" class="headerlink" title="3.2 JSP的脚本"></a>3.2 JSP的脚本</h3><p>就是JSP定义Java代码的方式</p><ol><li><code>&lt;% 代码 %&gt;</code>：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。</li><li><code>&lt;!% 代码 %&gt;</code>：定义的java代码，JSP转换后在java类的成员位置(成员变量、成员方法等)</li><li><code>&lt;%= 代码 %&gt;</code>：定义的java代码，会输出到页面上。 输出语句中可以定义什么，该脚本中就可以定义什么。</li></ol><h3 id="3-3-JSP的内置对象"><a href="#3-3-JSP的内置对象" class="headerlink" title="3.3 JSP的内置对象"></a>3.3 JSP的内置对象</h3><p>内置对象就是在JSP页面中不需要获取和创建，可以直接使用的对象。JSP一共有9个内置对象。今天简单学习3个。</p><ul><li>request</li><li>response</li><li>out：字符输出流对象。可以将数据输出到页面上。和<code>response.getWriter()</code>类似</li><li><code>response.getWriter()</code>和<code>out.write()</code>的区别<ol><li>在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据</li><li><code>response.getWriter()</code>数据输出永远在<code>out.write()</code>的之前</li></ol></li></ul><h2 id="4-Session"><a href="#4-Session" class="headerlink" title="4. Session"></a>4. Session</h2><p> 服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象(<code>HttpSession</code>)中。</p><h3 id="4-1-HttpSession对象"><a href="#4-1-HttpSession对象" class="headerlink" title="4.1 HttpSession对象"></a>4.1 <code>HttpSession</code>对象</h3><ol><li>获取<code>HttpSession</code>对象：<code>HttpSession session = request.getSession();</code></li><li>使用<code>HttpSession</code>对象，有三个常用方法<ul><li><code>Object getAttribute(String name)</code></li><li><code>void setAttribute(String name, Object value)</code></li><li><code>void removeAttribute(String name)</code></li></ul></li></ol><h3 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2 原理"></a>4.2 原理</h3><ul><li>服务器如何确保在一次会话范围内，多次获取的Session对象是同一个？</li></ul><p>Session的实现是依赖于Cookie的。当客户端第一次向服务器发起请求时，没有cookie。会在内存中创建一个新的Session对象，并通过响应头<code>set-cookie</code>将<code>JSESSIONID=xxxxx</code>传递给客户端，客户端保存在cookie信息中。第二次向服务器发起请求时，请求头中会携带这个<code>JSESSIONID=xxxxx</code>，服务器自动获取后会查找内存中是否有这个ID的session对象，能找到就说明是同一个session对象。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/16/Session%E5%8E%9F%E7%90%86-1560647657175.bmp" alt="title"></p><h3 id="4-3-细节问题"><a href="#4-3-细节问题" class="headerlink" title="4.3 细节问题"></a>4.3 细节问题</h3><h4 id="1-当客户端关闭后，服务器不关闭，两次获取的session是否为同一个？"><a href="#1-当客户端关闭后，服务器不关闭，两次获取的session是否为同一个？" class="headerlink" title="1. 当客户端关闭后，服务器不关闭，两次获取的session是否为同一个？"></a>1. 当客户端关闭后，服务器不关闭，两次获取的session是否为同一个？</h4><ul><li><p>默认情况下，不是</p></li><li><p>如果需要两次相同，可以创建Cookie，键为JSESSIONID，并设置cookie存活时间。在服务器不关闭的情况下，在存活时间内，只要是同一个cookie访问，两次获取的session对象就是同一个。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;&#x2F; 1. 获取session  HttpSession session = request.getSession();  &#x2F;&#x2F; 2. 期望客户端关闭后，session也相同  Cookie c = new Cookie(&quot;JSESSIONID&quot;, session.getId()); &#x2F;&#x2F; 手动设置sessionid为当前的session对象id  c.setMaxAge(60 * 60); &#x2F;&#x2F; 设置cookie最大存活时间  response.addCookie(c); &#x2F;&#x2F; 发送cookie</code></pre></li></ul><h4 id="2-客户端不关闭，服务器关闭后，两次获取的session是同一个吗？"><a href="#2-客户端不关闭，服务器关闭后，两次获取的session是同一个吗？" class="headerlink" title="2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？"></a>2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</h4><ul><li>不是同一个，但是我们要确保数据不丢失。</li><li>session的钝化：在服务器正常关闭之前，将session对象序列化到硬盘上。</li><li>session的活化：在服务器启动后，将session文件转化为内存中的session对象即可。</li></ul><h4 id="3-session什么时候被销毁"><a href="#3-session什么时候被销毁" class="headerlink" title="3. session什么时候被销毁"></a>3. session什么时候被销毁</h4><ol><li>服务器被关闭</li><li>session对象调用<code>invalidate()</code>方法</li><li>session默认失效时间是 30分钟，可以在web.xml中配置<code>session-config</code></li></ol><h3 id="4-4-session的特点"><a href="#4-4-session的特点" class="headerlink" title="4.4 session的特点"></a>4.4 session的特点</h3><ol><li>session用于存储一次会话的多次请求的数据，存储在服务器端</li><li>session可以存储任意类型，任意大小的数据</li></ol><h4 id="session与cookie的区别"><a href="#session与cookie的区别" class="headerlink" title="session与cookie的区别"></a>session与cookie的区别</h4><ol><li>session存储数据在服务器端，cookie在客户端</li><li>session没有数据大小限制，cookie有限制(4kb)</li><li>session数据安全，cookie相对而言不安全</li></ol><h2 id="5-案例"><a href="#5-案例" class="headerlink" title="5. 案例"></a>5. 案例</h2><h3 id="5-1-需求"><a href="#5-1-需求" class="headerlink" title="5.1 需求"></a>5.1 需求</h3><ol><li>访问带有验证码的登陆页面login.jsp</li><li>用户输入用户名，密码以及验证码<ul><li>如果用户名和密码输入错误，跳转登陆页面，提示：用户名或密码错误</li><li>如果验证码输入有误，跳转登陆页面，提示：验证码错误</li><li>如果全部输入正确，则跳转主页success.jsp，显示：用户名，欢迎你</li></ul></li></ol><h3 id="5-2-分析"><a href="#5-2-分析" class="headerlink" title="5.2 分析"></a>5.2 分析</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/16/%E7%99%BB%E5%BD%95%E6%A1%88%E4%BE%8B-1560651918633.bmp" alt="title"></p><h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h3><ol><li>登陆的Servlet</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@WebServlet(&quot;&#x2F;loginServlet&quot;)public class LoginServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 1. 设置request编码        request.setCharacterEncoding(&quot;utf-8&quot;);        &#x2F;&#x2F; 2. 获取参数        &#x2F;&#x2F; todo：改进，获取参数Map,封装进User对象        Map&lt;String, String[]&gt; map = request.getParameterMap();        User loginUser = new User();        try {            BeanUtils.populate(loginUser,map);        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        }        &#x2F;&#x2F; 获取用户输入的验证码        String checkCode = request.getParameter(&quot;checkCode&quot;);        &#x2F;&#x2F; 3. 获取生成的验证码        HttpSession session = request.getSession();        String checkCode_session = (String) session.getAttribute(&quot;checkCode_session&quot;);        &#x2F;&#x2F; 3.1 删除session中存储的验证码        session.removeAttribute(&quot;checkCode_session&quot;);        &#x2F;&#x2F; 4. 判断验证码是否正确        if (checkCode_session != null &amp;&amp; checkCode_session.equalsIgnoreCase(checkCode)){&#x2F;&#x2F; 忽略大小写比较            &#x2F;&#x2F; 验证码正确，调用UserDao的login方法进行登陆操作            UserDao dao = new UserDao();            User user = dao.login(loginUser);            &#x2F;&#x2F; 判断用户名是否成功登陆            if (user != null ){ &#x2F;&#x2F; todo: 需要调用UserDao查询数据库，进行数据对比                &#x2F;&#x2F; 登陆成功                &#x2F;&#x2F; 存储用户信息                session.setAttribute(&quot;User&quot;,user.getUsername());                &#x2F;&#x2F; 重定向到success.jsp                response.sendRedirect(request.getContextPath() + &quot;&#x2F;success.jsp&quot;);            }else {                &#x2F;&#x2F; 登陆失败                &#x2F;&#x2F; 存储信息到request                request.setAttribute(&quot;login_error&quot;,&quot;用户名或密码错误！&quot;);                &#x2F;&#x2F; 转发到登陆页面                request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,response);            }        }else {            &#x2F;&#x2F; 验证码不一致            &#x2F;&#x2F; 存储信息到request            request.setAttribute(&quot;cc_error&quot;,&quot;验证码错误！&quot;);            &#x2F;&#x2F; 转发到登陆页面            request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,response);        }    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request, response);    }}</code></pre><ol start="2"><li>登陆的前端页面</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-jsp">&lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Login&lt;&#x2F;title&gt;    &lt;script&gt;        window.onload = function () {            document.getElementById(&quot;img&quot;).onclick = function () {                this.src = &quot;&#x2F;Demo6_14&#x2F;checkCodeServlet?time=&quot; + new Date().getTime();            }        }    &lt;&#x2F;script&gt;    &lt;style&gt;        div{            color: red;        }    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form action=&quot;&#x2F;Demo6_14&#x2F;loginServlet&quot; method=&quot;post&quot;&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;用户名&lt;&#x2F;td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;密码&lt;&#x2F;td&gt;            &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;验证码&lt;&#x2F;td&gt;            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;checkCode&quot;&gt;&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td colspan=&quot;2&quot;&gt;&lt;img src=&quot;&#x2F;Demo6_14&#x2F;checkCodeServlet&quot; id=&quot;img&quot;&gt;&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;table&gt;&lt;&#x2F;form&gt;    &lt;div&gt;&lt;%= request.getAttribute(&quot;cc_error&quot;) == null ? &quot;&quot; : request.getAttribute(&quot;cc_error&quot;) %&gt;&lt;&#x2F;div&gt;    &lt;div&gt;&lt;%= request.getAttribute(&quot;login_error&quot;) == null ? &quot;&quot; : request.getAttribute(&quot;login_error&quot;) %&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ol start="3"><li>Dao类</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 操作数据库中User表的类，主要查询数据public class UserDao {    &#x2F;&#x2F; 声明JDBCTemplate对象共用    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());    &#x2F;&#x2F; 登陆方法    public User login(User loginUser){        try{            String sql = &quot;select * from user where username = ? and password = ?&quot;;            User user = template.queryForObject(sql,                    new BeanPropertyRowMapper&lt;User&gt;(User.class),                    loginUser.getUsername(), loginUser.getPassword());            return user;        }catch (DataAccessException e){            &#x2F;&#x2F; 登陆失败，打印异常，返回null            e.printStackTrace();            return null;        }    }}</code></pre><ol start="4"><li>验证码生成类在上一篇文章</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议和Response</title>
      <link href="/JavaWeb/http-response.html"/>
      <url>/JavaWeb/http-response.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-HTTP协议"><a href="#1-HTTP协议" class="headerlink" title="1. HTTP协议"></a>1. HTTP协议</h2><p>HTTP协议分为<strong>请求消息</strong>和<strong>响应消息</strong>两部分。请求消息是客户端发送给服务器端的数据，数据格式由请求行、请求头、请求空行、请求体4部分组成。下面讲解响应消息格式。</p><a id="more"></a><h2 id="1-1-响应消息"><a href="#1-1-响应消息" class="headerlink" title="1.1 响应消息"></a>1.1 响应消息</h2><p>响应消息是服务器端发送给客户端的数据，具体数据格式如下4部分。</p><h4 id="1-1-1-响应行"><a href="#1-1-1-响应行" class="headerlink" title="1.1.1 响应行"></a>1.1.1 响应行</h4><ol><li>格式：HTTP/1.1(协议/版本)  200(响应状态码)  OK(状态码描述)</li><li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态，状态码都是3位数字，具体分类如下。<ul><li>1xx：服务器接收客户端消息，但没有接收完毕，等待一段时间后，服务器会发送1xx状态码询问客户端是否还要继续发送数据。比较特殊的情况，了解即可。</li><li>2xx：成功。例：200表示成功</li><li>3xx：重定向。例：302(重定向)，304(访问缓存)</li><li>4xx：客户端错误。例：404(请求路径没有对应的资源或没权限访问)，405(请求方式没有对应的doXxx方法)</li><li>5xx：服务器端错误。例：500(服务器内部出现异常)</li></ul></li></ol><h4 id="1-1-2-响应头"><a href="#1-1-2-响应头" class="headerlink" title="1.1.2 响应头"></a>1.1.2 响应头</h4><ol><li>格式：头名称：值</li><li>常见响应头：<ul><li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li><li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据。默认值<code>in-line</code>：在当前页面内打开。<code>attachment;filename=xxx</code>：以附件形式打开响应体(用于文件下载)。</li></ul></li></ol><h4 id="1-1-3-响应空行"><a href="#1-1-3-响应空行" class="headerlink" title="1.1.3 响应空行"></a>1.1.3 响应空行</h4><h4 id="1-1-4-响应体"><a href="#1-1-4-响应体" class="headerlink" title="1.1.4 响应体"></a>1.1.4 响应体</h4><p>就是传输的数据。</p><h4 id="响应字符串格式"><a href="#响应字符串格式" class="headerlink" title="响应字符串格式"></a>响应字符串格式</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">HTTP&#x2F;1.1 200 OK&lt;-----响应行Content-Type: text&#x2F;html;charset=UTF-8&lt;-----响应头Content-Length: 90Date: Thu, 13 Jun 2019 10:01:19 GMT&lt;-----响应空行&lt;html&gt;&lt;-----响应体  &lt;head&gt;    &lt;title&gt;$Title$&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;  hello,response  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="2-Response对象"><a href="#2-Response对象" class="headerlink" title="2. Response对象"></a>2. Response对象</h2><p>主要功能是设置响应消息</p><h3 id="2-1-设置响应行"><a href="#2-1-设置响应行" class="headerlink" title="2.1 设置响应行"></a>2.1 设置响应行</h3><ul><li>设置状态码：<code>setStatus(int sc)</code></li></ul><h3 id="2-2-设置响应头"><a href="#2-2-设置响应头" class="headerlink" title="2.2 设置响应头"></a>2.2 设置响应头</h3><ul><li>设置响应头：<code>setHeader(String name,String value)</code></li></ul><h3 id="2-3-设置响应体数据"><a href="#2-3-设置响应体数据" class="headerlink" title="2.3 设置响应体数据"></a>2.3 设置响应体数据</h3><p>使用步骤有以下两步</p><h4 id="2-3-1-获取输出流"><a href="#2-3-1-获取输出流" class="headerlink" title="2.3.1 获取输出流"></a>2.3.1 获取输出流</h4><ul><li>字符输出流：<code>PrintWriter getWriter()</code></li><li>字节输出流：<code>ServletOutputStream getOutputSteam()</code></li></ul><h4 id="2-3-2-使用输出流"><a href="#2-3-2-使用输出流" class="headerlink" title="2.3.2 使用输出流"></a>2.3.2 使用输出流</h4><p>将数据输出到客户端浏览器</p><h3 id="2-4-小案例"><a href="#2-4-小案例" class="headerlink" title="2.4 小案例"></a>2.4 小案例</h3><h4 id="2-4-1-完成重定向"><a href="#2-4-1-完成重定向" class="headerlink" title="2.4.1 完成重定向"></a>2.4.1 完成重定向</h4><ul><li><p>重定向：资源的跳转方式</p></li><li><p>代码实现</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">  &#x2F;&#x2F; 1. 设置状态码为302  response.setStatus(302);  &#x2F;&#x2F; 2. 设置响应头location  response.setHeader(&quot;location&quot;,&quot;&#x2F;Demo6_13&#x2F;responseDemo2&quot;);  &#x2F;&#x2F; 简单的重定向方法  response.sendRedirect(&quot;&#x2F;Demo6_13&#x2F;responseDemo2&quot;);</code></pre></li></ul><ul><li><p>重定向(<code>redirect</code>)的特点</p><ul><li>地址栏发生变化</li><li>重定向可以访问其他站点(服务器)的资源</li><li>重定向是两次请求。所以不能使用request对象来共享数据</li></ul></li><li><p>转发(<code>forward</code>)的特点</p><ul><li>转发地址栏路径不变</li><li>转发只能访问当前服务器下的资源</li><li>转发是一次请求。故可以使用request对象来共享数据</li></ul></li><li><p>路径的写法分类</p><ul><li><p>相对路径：通过相对路径不可以确定唯一资源</p><ul><li>例：<code>./index.html</code>。不以<code>/</code>开头，而是以<code>.</code>开头的路径</li><li>规则：找到当前资源和目标资源之间的相对位置关系。例：<code>./</code>表示当前目录，<code>../</code>表示上一级目录。</li></ul></li><li><p>绝对路径：通过绝对路径可以确定唯一资源</p><ul><li>例：<code>http://localhost/Demo6_13/responseDemo2</code>或<code>/Demo6_13/responseDemo2</code>。这种以<code>/</code>开头的路径</li><li>规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出。给客户端浏览器使用需要加虚拟目录(项目的访问路径)，给服务器使用不需要加虚拟目录。</li></ul><blockquote><p>虚拟目录建议使用<code>request.getContextPath()</code>来动态获取</p></blockquote></li></ul></li></ul><h4 id="2-4-2-服务器输出字符数据到浏览器"><a href="#2-4-2-服务器输出字符数据到浏览器" class="headerlink" title="2.4.2 服务器输出字符数据到浏览器"></a>2.4.2 服务器输出字符数据到浏览器</h4><p>先获取字符输出流，再输出数据。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 3.1 获取流对象之前，将流的默认编码ISO-8859-1设置为utf-8response.setCharacterEncoding(&quot;utf-8&quot;);&#x2F;&#x2F; 3.2 告诉浏览器服务器发送的消息体数据的编码，建议浏览器使用该编码来解码response.setHeader(&quot;Content-type&quot;,&quot;text&#x2F;html;charset=utf-8&quot;);&#x2F;&#x2F; 3.3 可以使用简化的形式，设置编码response.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;);&#x2F;&#x2F; Notice: 3.1步骤可以省略，推荐使用3.3方法&#x2F;&#x2F; 1. 获取字符输出流PrintWriter pw = response.getWriter();&#x2F;&#x2F; 2. 输出数据pw.write(&quot;&lt;h1&gt;hello response&lt;&#x2F;h1&gt;&quot;);&#x2F;&#x2F; 3. 解决中文乱码问题pw.write(&quot;你好，response&quot;);&#x2F;* 乱码原因是：PrintWriter pw = response.getWriter(); 获取的流默认编码是ISO-8859-1故需在获取流之前，设置该流的默认编码，或者直接告诉浏览器响应体使用的编码，推荐其解码方式。*&#x2F;</code></pre><h4 id="2-4-3-服务器输出字节数据到浏览器"><a href="#2-4-3-服务器输出字节数据到浏览器" class="headerlink" title="2.4.3 服务器输出字节数据到浏览器"></a>2.4.3 服务器输出字节数据到浏览器</h4><p>获取字节输出流输出数据，一般用于获取图片字节数据然后输出到浏览器显示图片</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 1. 获取字节输出流ServletOutputStream sos = response.getOutputStream();&#x2F;&#x2F; 2. 输出数据sos.write(&quot;你好&quot;.getBytes());sos.write(&quot;hello&quot;.getBytes());</code></pre><h4 id="2-4-4-验证码"><a href="#2-4-4-验证码" class="headerlink" title="2.4.4 验证码"></a>2.4.4 验证码</h4><p>本质就是一张图片，主要作用是防止恶意表单注册</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@WebServlet(&quot;&#x2F;checkCodeServlet&quot;)public class CheckCodeServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 1. 创建一个对象，在内存中画图片(验证码图片对象)        int width = 100;        int height = 50;        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);        &#x2F;&#x2F; 2. 美化图片        &#x2F;&#x2F; 2.1 填充背景色        Graphics g = image.getGraphics(); &#x2F;&#x2F; 获取画笔对象        g.setColor(Color.PINK); &#x2F;&#x2F; 设置画笔颜色        g.fillRect(0,0,width,height); &#x2F;&#x2F; 填充颜色        &#x2F;&#x2F; 2.2 画边框        g.setColor(Color.blue);        g.drawRect(0,0,width-1, height-1);        &#x2F;&#x2F; 2.3 写验证码        String str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;        &#x2F;&#x2F; 2.3.1 生产随机角标        Random ran = new Random();        for (int i = 1; i &lt;= 4; i++) {            int index = ran.nextInt(str.length());            &#x2F;&#x2F; 2.3.2 获取字符            char ch = str.charAt(index);            g.drawString(ch+&quot;&quot; ,width&#x2F;5*i,height&#x2F;2);        }        &#x2F;&#x2F; 2.4 画干扰线        g.setColor(Color.GREEN);        for (int i = 0; i &lt; 10; i++) {            &#x2F;&#x2F; 2.4.1 随机生产坐标点            int x1 = ran.nextInt(width);            int x2 = ran.nextInt(width);            int y1 = ran.nextInt(height);            int y2 = ran.nextInt(height);            &#x2F;&#x2F; 根据坐标点画线            g.drawLine(x1,y1,x2,y2);        }        &#x2F;&#x2F; 3. 将图片输出到页面展示        ImageIO.write(image,&quot;jpg&quot;,response.getOutputStream());    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request,response);    }}</code></pre><h4 id="在网页中使用验证码"><a href="#在网页中使用验证码" class="headerlink" title="在网页中使用验证码"></a>在网页中使用验证码</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;验证码&lt;&#x2F;title&gt;    &lt;script&gt;        &#x2F;&#x2F; 1.给超链接和图片绑定单击事件        &#x2F;&#x2F; 2. 重新设置图片的src属性值        window.onload = function () {            &#x2F;&#x2F; 1. 获取图片对象            var img = document.getElementById(&quot;checkCode&quot;);            &#x2F;&#x2F; 2. 创建单击事件            changeimg = function () {                &#x2F;&#x2F; 获取时间戳                var date = new Date().getTime();                img.src = &quot;&#x2F;Demo6_13&#x2F;checkCodeServlet?&quot;+date;            }            &#x2F;&#x2F; 3. 绑定单击事件            img.onclick = changeimg;            document.getElementById(&quot;change&quot;).onclick = changeimg;        }    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;img src=&quot;&#x2F;Demo6_13&#x2F;checkCodeServlet&quot; id=&quot;checkCode&quot;&gt;&lt;a href=&quot;#&quot; id=&quot;change&quot; &gt;看不清？换一张&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="3-ServletContext对象"><a href="#3-ServletContext对象" class="headerlink" title="3. ServletContext对象"></a>3. ServletContext对象</h2><p>这个对象代表整个Web应用，可以和程序的容器(服务器)来进行通信</p><h3 id="3-1-获取"><a href="#3-1-获取" class="headerlink" title="3.1 获取"></a>3.1 获取</h3><ol><li>通过request对象获取：<code>request.getServletContext();</code></li><li>通过HttpServlet获取：<code>this.getServletContext();</code></li></ol><h3 id="3-2-功能"><a href="#3-2-功能" class="headerlink" title="3.2 功能"></a>3.2 功能</h3><h4 id="3-2-1-获取MIME类型"><a href="#3-2-1-获取MIME类型" class="headerlink" title="3.2.1 获取MIME类型"></a>3.2.1 获取MIME类型</h4><ul><li>MIME类型：在互联网通信过程中定义的一种文件数据类型，存储在服务器的<code>web.xml</code>文件中</li><li>格式：大类型/小类型，例：<code>text/html</code>，<code>image/jpeg</code></li><li>获取方法：<code>String getMimeType(String file)</code></li></ul><h4 id="3-2-2-域对象：共享数据"><a href="#3-2-2-域对象：共享数据" class="headerlink" title="3.2.2 域对象：共享数据"></a>3.2.2 域对象：共享数据</h4><p>常用方法如下：</p><ol><li><code>setAttribute(String name,Object value)</code></li><li><code>getAttribute(String name)</code></li><li><code>removeAttribute(String name)</code></li></ol><ul><li>ServletContext对象范围：所有用户所有请求的数据</li></ul><h4 id="3-2-3-获取文件的真实-服务器-路径"><a href="#3-2-3-获取文件的真实-服务器-路径" class="headerlink" title="3.2.3 获取文件的真实(服务器)路径"></a>3.2.3 获取文件的真实(服务器)路径</h4><ul><li><code>String getRealPath(String path)</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 获取文件的服务器路径String c = context.getRealPath(&quot;&#x2F;c.txt&quot;); &#x2F;&#x2F; web目录下的资源访问String b = context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;b.txt&quot;); &#x2F;&#x2F; WEB-INF目录下的资源访问String a = context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;a.txt&quot;); &#x2F;&#x2F; src目录下的资源访问</code></pre><h2 id="4-综合案例：文件下载"><a href="#4-综合案例：文件下载" class="headerlink" title="4. 综合案例：文件下载"></a>4. 综合案例：文件下载</h2><h3 id="4-1-案例需求"><a href="#4-1-案例需求" class="headerlink" title="4. 1 案例需求"></a>4. 1 案例需求</h3><ol><li>页面显示超链接</li><li>点击超链接后弹出下载提示框</li><li>完成图片文件下载</li></ol><h3 id="4-2-分析"><a href="#4-2-分析" class="headerlink" title="4.2 分析"></a>4.2 分析</h3><ol><li>浏览器默认超链接指向的资源如果能够被解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求！</li><li>任何资源都必须弹出下载提示框</li><li>使用响应头设置资源的打开方式：<code>content-disposition:attachment;filename=xxx</code></li></ol><h3 id="4-3-步骤"><a href="#4-3-步骤" class="headerlink" title="4.3 步骤"></a>4.3 步骤</h3><ol><li>定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename</li><li>定义Servlet<ol><li>获取文件名称</li><li>使用字节输入流加载文件进内存</li><li>指定response的响应头：<code>content-disposition:attachment;filename=xxx</code></li><li>将数据写出到response输出流，返回给客户端</li></ol></li></ol><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h3><p><code>downloadServlet</code>代码，主要实现文件的输入输出</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@WebServlet(&quot;&#x2F;downloadServlet&quot;)public class DownloadServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        &#x2F;&#x2F; 1. 获取请求参数，文件名称        String filename = request.getParameter(&quot;filename&quot;);        &#x2F;&#x2F; 2. 使用字节输入流加载文件进内存        &#x2F;&#x2F; 2.1 找到文件服务器路径        ServletContext context = this.getServletContext();        String realPath = context.getRealPath(&quot;&#x2F;img&#x2F;&quot; + filename);        &#x2F;&#x2F; 2.2 用字节流关联文件对象        FileInputStream fis = new FileInputStream(realPath);        &#x2F;&#x2F; 3. 设置response响应头        &#x2F;&#x2F; 3.1 设置响应头类型        String mimeType = context.getMimeType(filename); &#x2F;&#x2F; 获取文件的mime类型        response.setHeader(&quot;content-type&quot;,mimeType);        &#x2F;&#x2F; 3.2 解决中文文件名问题        &#x2F;&#x2F; 3.2.1 获取user-agent请求头        String agent = request.getHeader(&quot;user-agent&quot;);        &#x2F;&#x2F; 3.2.2 使用工具类方法编码文件名        filename = DownLoadUtils.getFileName(agent, filename);        response.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot;+filename);        &#x2F;&#x2F; 4. 将输入流的数据写出到输出流中，将文件输出到浏览器中        ServletOutputStream sos = response.getOutputStream();        byte[] buff = new byte[1024 * 8];        int len = 0;        while ((len = fis.read(buff)) != -1){            sos.write(buff,0,len);        }        fis.close();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        this.doPost(request,response);    }}</code></pre><p>前端html页面，提供了文件下载的超链接</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;下载文件&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h2&gt;文件下载&lt;&#x2F;h2&gt;&lt;br&gt;&lt;a href=&quot;&#x2F;Demo6_13&#x2F;downloadServlet?filename=九尾.jpg&quot;&gt;九尾&lt;&#x2F;a&gt;&lt;a href=&quot;&#x2F;Demo6_13&#x2F;downloadServlet?filename=2.jpg&quot;&gt;图片2&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><p>DownLoadUtils工具类，主要功能获取客户端的浏览器版本信息，然后根据不同的版本信息，设置filename的编码方式</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DownLoadUtils {    public static String getFileName(String agent, String filename) throws UnsupportedEncodingException {        if (agent.contains(&quot;MSIE&quot;)) {            &#x2F;&#x2F; IE浏览器            filename = URLEncoder.encode(filename, &quot;utf-8&quot;);            filename = filename.replace(&quot;+&quot;, &quot; &quot;);        } else if (agent.contains(&quot;Firefox&quot;)) {            &#x2F;&#x2F; 火狐浏览器            BASE64Encoder base64Encoder = new BASE64Encoder();            filename = &quot;=?utf-8?B?&quot; + base64Encoder.encode(filename.getBytes(&quot;utf-8&quot;)) + &quot;?=&quot;;        } else {            &#x2F;&#x2F; 其它浏览器            filename = URLEncoder.encode(filename, &quot;utf-8&quot;);        }        return filename;    }    public static void getFileName(String agent) {    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议和Request对象</title>
      <link href="/JavaWeb/http-request.html"/>
      <url>/JavaWeb/http-request.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-HTTP协议"><a href="#1-HTTP协议" class="headerlink" title="1. HTTP协议"></a>1. HTTP协议</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p><strong>HTTP协议</strong>：超文本传输协议(Hyper Text Transfer Protocol)</p><p><strong>传输协议</strong>：定义了客户端和服务器端通信时，发送数据的格式，特点如下：</p><ol><li>基于TCP/IP的高级协议</li><li>默认端口号：80</li><li>基于请求/响应模型的：一次请求对应一次响应</li><li>无状态的：每次请求之间相互独立，不能交互数据</li></ol><a id="more"></a><h3 id="1-2-请求消息数据格式"><a href="#1-2-请求消息数据格式" class="headerlink" title="1.2 请求消息数据格式"></a>1.2 请求消息数据格式</h3><h4 id="1-2-1-请求行"><a href="#1-2-1-请求行" class="headerlink" title="1.2.1 请求行"></a>1.2.1 请求行</h4><p><code>POST(请求方式) /login.html(请求URL)  HTTP/1.1(请求协议/版本)</code></p><p>HTTP协议有7种请求方式，常用的有2种</p><ul><li>GET：请求参数在请求行中，在URL后；请求的URL长度是有限制的；且不太安全。</li><li>POST：请求参数在请求体中；请求的URL长度没有限制；相对安全。</li></ul><h4 id="1-2-2-请求头"><a href="#1-2-2-请求头" class="headerlink" title="1.2.2 请求头"></a>1.2.2 请求头</h4><p>客户端浏览器告诉服务器一些信息</p><p>常见请求头：</p><ul><li>User-Agent：浏览器告诉服务器，我们访问你使用的浏览器版本信息；可以在服务器端获取该头的信息，解决浏览器兼容性问题</li><li><code>Referer: http://192.168.1.6/login.html</code>，告诉服务器，我(当前请求)从哪里来？一般用于防盗链和统计工作。</li></ul><h4 id="1-2-3-请求空行"><a href="#1-2-3-请求空行" class="headerlink" title="1.2.3 请求空行"></a>1.2.3 请求空行</h4><p>空行，就是用于分隔POST请求的请求头和请求体的</p><h4 id="1-2-4-请求体-正文"><a href="#1-2-4-请求体-正文" class="headerlink" title="1.2.4 请求体(正文)"></a>1.2.4 请求体(正文)</h4><p>封装POST请求消息的请求参数的</p><h4 id="请求消息字符串格式："><a href="#请求消息字符串格式：" class="headerlink" title="请求消息字符串格式："></a>请求消息字符串格式：</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">POST &#x2F;login.html  HTTP&#x2F;1.1Host: 192.168.1.6User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q=0.9,*&#x2F;*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http:&#x2F;&#x2F;192.168.1.6&#x2F;login.htmlContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 10Connection: keep-aliveUpgrade-Insecure-Requests: 1uname=aaaa</code></pre><h2 id="2-Request"><a href="#2-Request" class="headerlink" title="2. Request"></a>2. Request</h2><h3 id="2-1-request对象和response对象的原理"><a href="#2-1-request对象和response对象的原理" class="headerlink" title="2.1 request对象和response对象的原理"></a>2.1 request对象和response对象的原理</h3><ul><li>request和response对象是由服务器创建的，我们来使用它们。</li><li>request对象是来获取请求消息的，response对象是来设置响应消息的。</li></ul><p>插入原理图解</p><h3 id="2-2-request对象继承体系结构"><a href="#2-2-request对象继承体系结构" class="headerlink" title="2.2 request对象继承体系结构"></a>2.2 request对象继承体系结构</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">ServletRequest  -- 接口|继承HttpServletRequest -- 接口|实现org.apache.catalina.connector.RequestFacade 类(Tomcat实现的类)</code></pre><h3 id="2-3-request的功能"><a href="#2-3-request的功能" class="headerlink" title="2.3 request的功能"></a>2.3 request的功能</h3><h4 id="2-3-1-获取请求消息数据"><a href="#2-3-1-获取请求消息数据" class="headerlink" title="2.3.1 获取请求消息数据"></a>2.3.1 获取请求消息数据</h4><h4 id="2-3-1-1-获取请求行数据"><a href="#2-3-1-1-获取请求行数据" class="headerlink" title="2.3.1.1 获取请求行数据"></a>2.3.1.1 获取请求行数据</h4><ul><li>请求行：<code>GET /reqdemo/demo1?name=zero  HTTP/1.1</code></li><li>方法：<ul><li>获取请求方式(GET)：<code>String getMethod()</code></li><li><strong>获取虚拟目录</strong>(/reqdemo)：<code>String getContextPath()</code></li><li>获取Servlet路径(/demo1)：<code>String getServletPath()</code></li><li>获取get方式请求参数(name=zero):<code>String getQueryString()</code></li><li><strong>获取请求URI</strong>(<code>/reqdemo/demo1</code>)：<code>String getRequestURI()</code></li><li>获取请求URL(<code>http://localhost/reqdemo/demo1</code>)：<code>String getRequestURL()</code></li><li>获取协议及版本号(HTTP/1.1)：<code>String getProtocol()</code></li><li>获取客户端的IP地址：<code>String getRemoteAddr()</code></li></ul></li></ul><blockquote><p>URI：统一资源标识符</p></blockquote><h4 id="2-3-1-2-获取请求头数据"><a href="#2-3-1-2-获取请求头数据" class="headerlink" title="2.3.1.2 获取请求头数据"></a>2.3.1.2 获取请求头数据</h4><p>主要方法：</p><ol><li><code>String getHeader(String name)</code>：通过请求头的名称获取请求头的值，常用。</li><li><code>Enumeration&lt;String&gt; getHeaderNames()</code>：获取所有的请求头名称；返回值是一个枚举类，可以当做迭代器使用。</li></ol><h4 id="2-3-1-3-获取请求体数据"><a href="#2-3-1-3-获取请求体数据" class="headerlink" title="2.3.1.3 获取请求体数据"></a>2.3.1.3 获取请求体数据</h4><p>只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</p><p>步骤：</p><ul><li>1.获取流对象<ul><li><code>BufferedReader getReader()</code> ：获取字符输入流，只能操作字符数据。</li><li><code>ServletInputStream getInputStream()</code>：获取字节输入流，可以操作所有类型数据</li></ul></li><li>2.从流对象中拿数据</li></ul><h4 id="2-3-2-其他功能"><a href="#2-3-2-其他功能" class="headerlink" title="2.3.2 其他功能"></a>2.3.2 其他功能</h4><h4 id="2-3-2-1-获取请求参数通用方式"><a href="#2-3-2-1-获取请求参数通用方式" class="headerlink" title="2.3.2.1 获取请求参数通用方式"></a>2.3.2.1 获取请求参数通用方式</h4><p>不论是get还是post请求方式，都可以使用下列方法来获取请求参数</p><ol><li><code>String getParameter(String name)</code>：根据参数名称获取参数值</li><li><code>String[] getParameterValues(String name)</code>：根据参数名称获取参数值的数组，一般用于复选框</li><li><code>Enumeration&lt;String&gt; getParameterNames()</code>：获取所有请求从参数名称</li><li><code>Map&lt;String,String[]&gt; getParameterMap()</code>：获取所有参数的map集合</li></ol><blockquote><p>中文乱码问题：Tomcat8已解决get方式乱码问题，但post方式还是会乱码。需要在获取参数前，设置request的编码<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code></p></blockquote><h4 id="2-3-2-2-请求转发"><a href="#2-3-2-2-请求转发" class="headerlink" title="2.3.2.2 请求转发"></a>2.3.2.2 请求转发</h4><p>一种在服务器内部的资源跳转方式</p><p>使用步骤：</p><ol><li>通过request对象获取请求转发器对象：<code>RequestDispatcher getRequestDispatcher(String path);</code></li><li>使用RequestDispatcher对象来进行转发：<code>forward(ServletRequest request, ServletResponse response)</code></li></ol><p>特点：</p><ol><li>浏览器地址栏路径不会发生变化</li><li>只能转发到当前服务器内部资源中</li><li>转发是一次请求</li></ol><h4 id="2-3-2-3-共享数据"><a href="#2-3-2-3-共享数据" class="headerlink" title="2.3.2.3 共享数据"></a>2.3.2.3 共享数据</h4><ul><li>域对象：一个有作用范围的对象，可以在范围内共享数据</li><li>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</li><li>方法：<ul><li><code>void setAttribute(String name, Object obj)</code>：存储数据(键值对形式)。</li><li><code>Object getAttibute(String name)</code>：通过键获取值</li><li><code>void removeAttribute(String name)</code>：通过键移除键值对</li></ul></li></ul><h4 id="2-2-2-4-获取ServletContext"><a href="#2-2-2-4-获取ServletContext" class="headerlink" title="2.2.2.4 获取ServletContext"></a>2.2.2.4 获取ServletContext</h4><p><code>ServletContext getServletContext()</code></p><h2 id="3-综合案例：用户登录"><a href="#3-综合案例：用户登录" class="headerlink" title="3. 综合案例：用户登录"></a>3. 综合案例：用户登录</h2><h3 id="3-1-需求"><a href="#3-1-需求" class="headerlink" title="3.1 需求"></a>3.1 需求</h3><ol><li>编写login.html登录页面，有用户名和密码两个输入框</li><li>使用Druid数据库连接池技术，操作mysql</li><li>使用JdbcTemplate技术封装JDBC</li><li>登录成功跳转SuccessServlet展示：登录成功！用户名，欢迎你</li><li>登录失败跳转FailServlet展示：登录失败，用户名或密码错误。</li></ol><h3 id="3-2-开发步骤"><a href="#3-2-开发步骤" class="headerlink" title="3.2 开发步骤"></a>3.2 开发步骤</h3><ol><li><p>创建项目，导入html页面、配置文件、jar包。</p></li><li><p>创建数据库环境，创建user表</p></li><li><p>创建包domain，创建类User</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   &#x2F;&#x2F; 用户实体类   public class User{       private int id;       private String username;       private String password;       &#x2F;&#x2F; 生成get&#x2F;set方法       ...   &#x2F;&#x2F; 生成toString方法       ...   }</code></pre></li></ol><ol start="4"><li><p>创建util包，编写工具类JDBCUtils</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   &#x2F;&#x2F; JDBC工具类，使用Druid连接池   public class JDBCUtils{       private static DataSource ds = null;       static{ &#x2F;&#x2F; 使用静态代码块来加载配置文件等内容           try{               &#x2F;&#x2F; 1. 加载配置文件               Properties pro = new Properties();               &#x2F;&#x2F; 1.1 使用ClassLoader加载配置文件，获取字节输入流               InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);               pro.load(is);               &#x2F;&#x2F; 2. 使用Druid连接池技术，初始化连接池对象               ds = DruidDataSourceFactory.createDataSource(pro);           }catch(IOException e){               e.printStackTrace();           }catch(Exception e){               e.printStackTrace();           }       }       &#x2F;&#x2F; 获取连接池对象       public static DataSource getDataSource(){           return ds;       }       &#x2F;&#x2F; 获取连接Connection对象       public static Connection getConnection() throws SQLException{           return ds.getConnection();       }   }</code></pre></li></ol><ol start="5"><li><p>创建dao包，创建类UserDao，提供login方法</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   &#x2F;&#x2F; 操作数据库中User表的类   public class UserDao{       &#x2F;&#x2F; 声明JDBCTemplate对象共用       private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());       &#x2F;&#x2F; 定义登录方法       public User login(User loginUser){           try{               &#x2F;&#x2F; 1. 编写sql               String sql = &quot;select * form user where username = ? and password = ?&quot;;               &#x2F;&#x2F; 2. 调用query方法,查询数据               User user = template.queryForObject(sql,                        new BeanPropertyRowMaper&lt;User&gt;(User.class),                        loginUser.getUsername(),loginUser.getPassword());               return user; &#x2F;&#x2F; 返回查询到的数据对象           }catch{DataAccessException e}{               e.printStackTrace(); &#x2F;&#x2F; 一般做记录日志文件处理               return null;           }       }   }</code></pre></li></ol><ol start="6"><li><p>编写Servelt.LoginServlet类</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   &#x2F;&#x2F; 主要Servlet类,负责处理登录验证操作，登录成功失败后的转发操作   @WebServlet(&quot;&#x2F;loginServlet&quot;) &#x2F;&#x2F; 设置资源路径   public class LoginServlet extends HttpServlet{       @Override       protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{           &#x2F;&#x2F; 1. 设置编码           req.setCharacterEncoding(&quot;utf-8&quot;);           &#x2F;&#x2F; 2. 获取请求参数           String username = req.getParameter(&quot;username&quot;);           String password = req.getParameter(&quot;password&quot;);           &#x2F;&#x2F; 3. 将数据封装成user对象           User loginUser = new User();           loginUser.setUsername(username);           loginUser.setPassword(password);           &#x2F;&#x2F; 4. 调用UserDao的login方法          UserDao dao = new UserDao();           User user = dao.login(loginUser); &#x2F;&#x2F; 进行用户数据验证，返回一个User对象的完整数据           &#x2F;&#x2F; 5. 判断是否正常登录           if(user == null){               &#x2F;&#x2F; 登录失败，转发向失败页面               req.getRequestDispatcher(&quot;&#x2F;failServlet&quot;).forward(req,resp);           }else{               &#x2F;&#x2F; 登录成功，跳转成功页面               &#x2F;&#x2F; 将user对象放入request域中               req.setAttribute(&quot;user&quot;,user);               &#x2F;&#x2F; 转发               req.getRequestDispatcher(&quot;&#x2F;successServlet&quot;).forward(req,resp);           }       }       @Override       protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{           this.doGet(req,resp);       }   }</code></pre></li></ol><ol start="7"><li><p>编写FailServlet和SuccessServlet类</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   &#x2F;&#x2F; 失败处理页面,直接返回一句话   @WebServlet(&quot;&#x2F;failServlet&quot;)   public class FailServlet extends HttpServlet{       protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{           &#x2F;&#x2F; 设置编码           resp.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;);           &#x2F;&#x2F; 输出           resp.getWriter().write(&quot;登录失败，用户名或密码错误&quot;);       }       protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{           this.doPost(req,resp);       }   }   &#x2F;&#x2F; 成功页面   @WebServlet(&quot;&#x2F;successServlet&quot;)   public class SuccessServlet extends HttpServlet{       protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{           &#x2F;&#x2F; 获取request域中共享的user对象           User user = (User)request.getAttibute(&quot;user&quot;);           if(user != null){               &#x2F;&#x2F; 设置编码               resp.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;);               &#x2F;&#x2F; 输出               resp.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;欢迎你&quot;);       }       }       protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{           this.doPost(req,resp);       }   }</code></pre></li></ol><ol start="8"><li><p>将login.html中form表单的action路径设置为虚拟目录+Servlet的资源路径</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">   &lt;!DOCTYPE html&gt;   &lt;html lang=&quot;en&quot;&gt;   &lt;head&gt;   &lt;meta charset=&quot;UTF-8&quot;&gt;       &lt;title&gt;登录页面&lt;&#x2F;title&gt;   &lt;&#x2F;head&gt;   &lt;body&gt;   &lt;form action=&quot;&#x2F;LoginDemo&#x2F;loginServlet&quot; method=&quot;post&quot;&gt;           用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;           密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;           &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;       &lt;&#x2F;form&gt;       &lt;&#x2F;body&gt;   &lt;&#x2F;html&gt;</code></pre></li></ol><h4 id="3-2-1-BeanUtils"><a href="#3-2-1-BeanUtils" class="headerlink" title="3.2.1 BeanUtils"></a>3.2.1 BeanUtils</h4><p>apache提供的一个工具类，使用BeanUtils工具类，可以简化数据的封装，主要用于封装JavaBean</p><ul><li><p>JavaBean：标准的Java类，有以下要求</p><ul><li>类必须被public修饰</li><li>必须提供空参的构造器</li><li>成员变量必须使用private修饰</li><li>提供公共setter和getter方法</li></ul></li><li><p>功能：封装数据</p></li><li>概念：<ul><li>成员变量</li><li>属性：</li></ul></li><li>方法<ul><li><code>setProperty()</code>：设置值</li><li><code>getProperty()</code>：获取值</li><li><code>populate(Object obj, Map map)</code>：将map集合的键值对信息，封装到对应的JavaBean对象中</li></ul></li></ul><h4 id="3-2-2-简化LoginServlet"><a href="#3-2-2-简化LoginServlet" class="headerlink" title="3.2.2 简化LoginServlet"></a>3.2.2 简化LoginServlet</h4><p>将上述例子中的LoginServlet类中<strong>获取请求参数</strong>和<strong>封装User对象</strong>步骤进行简化</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{        &#x2F;&#x2F; 1. 设置编码        req.setCharacterEncoding(&quot;utf-8&quot;);        &#x2F;&#x2F; 2. 获取所有请求参数   Map&lt;String, String[]&gt; map = req.getParameterMap();        &#x2F;&#x2F; 3. 创建User对象        User loginUser = new User();    &#x2F;&#x2F; 3.1 使用populate方法将数据封装进loginUser对象    try{            BeanUtils.populate(loginUser,map);        }catch(Exception e){            e.printStackTrace();        }        &#x2F;&#x2F; 4. 调用UserDao的login方法       UserDao dao = new UserDao();        User user = dao.login(loginUser); &#x2F;&#x2F; 进行用户数据验证，返回一个User对象的完整数据        &#x2F;&#x2F; 5. 判断是否正常登录        if(user == null){            &#x2F;&#x2F; 登录失败，转发向失败页面            req.getRequestDispatcher(&quot;&#x2F;failServlet&quot;).forward(req,resp);        }else{            &#x2F;&#x2F; 登录成功，跳转成功页面            &#x2F;&#x2F; 将user对象放入request域中            req.setAttribute(&quot;user&quot;,user);            &#x2F;&#x2F; 转发            req.getRequestDispatcher(&quot;&#x2F;successServlet&quot;).forward(req,resp);        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet接口</title>
      <link href="/JavaWeb/servlet.html"/>
      <url>/JavaWeb/servlet.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1. Servlet"></a>1. Servlet</h2><p>Java Servlet是运行在服务器端的小程序，它是作为来自web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层</p><a id="more"></a><h3 id="1-1-创建"><a href="#1-1-创建" class="headerlink" title="1.1 创建"></a>1.1 创建</h3><p>Servlet有三种创建方式：</p><ol><li>实现Servlet接口</li><li>继承GenericServlet类</li><li>继承HttpServlet方法</li></ol><h4 id="1-1-1-实现Servlet接口"><a href="#1-1-1-实现Servlet接口" class="headerlink" title="1.1.1 实现Servlet接口"></a>1.1.1 实现Servlet接口</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;*Servlet的生命周期：从Servlet被创建到Servlet被销毁的过程。一次创建，到处服务一个Servlet只会有一个对象，服务所有的请求1. 实例化 (使用构造方法创建对象)2. 初始化 执行init方法3. 服务 执行service方法4. 销毁 执行destroy方法*&#x2F;@WebServlet(&quot;&#x2F;demo1&quot;) &#x2F;&#x2F; 添加注解，设置虚拟访问路径public class ServletDemo1 implements Servlet{ &#x2F;&#x2F; 实现Servlet接口，重写其全部方法    &#x2F;&#x2F; 生命周期方法：当Servlet第一次被创建对象时执行该方法，该方法在整个生命周期中只执行一次    @Override    public void init(ServletConfig servletConfig) throws ServletException{        System.out.println(&quot;====Servlet初始化了====&quot;);    }    &#x2F;&#x2F; 生命周期方法：对客户端响应的方法，该方法会被多次执行，每次请求该servlet都会执行该方法    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException{        System.out.println(&quot;====Servlet服务中====&quot;);    }    &#x2F;&#x2F; 生命周期方法： 当Servlet被销毁时执行该方法    @Override    public void destroy(){        System.out.println(&quot;====Servlet销毁了====&quot;);    }    &#x2F;&#x2F; 当停止Tomcat时也就会销毁的Servlet    @Override    public ServletConfig getServletConfig(){        return null;    }    @Override    public String getServletInfo(){        return null;    }}</code></pre><h4 id="1-1-2-继承GenericServlet类"><a href="#1-1-2-继承GenericServlet类" class="headerlink" title="1.1.2 继承GenericServlet类"></a>1.1.2 继承GenericServlet类</h4><p><code>GenericServlet</code>类默认将Servlet接口中其他方法做了默认空实现，只将<code>service()</code>方法作为抽象方法，在定义Servlet类时，可以继承<code>GenericeSerlvet</code>类，实现<code>service()</code>方法即可。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ServletDemo2 extends GenericServlet{    @Override    public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException,IOException{        System.out.println(&quot;创建方法2&quot;)    }}</code></pre><h4 id="1-1-3-继承HttpServlet方法"><a href="#1-1-3-继承HttpServlet方法" class="headerlink" title="1.1.3 继承HttpServlet方法"></a>1.1.3 继承HttpServlet方法</h4><p>HttpServlet是对HTTP协议的一种封装，简化操作</p><ol><li>定义类继承HttpServlet</li><li>复写doGet/doPost方法</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ServletDemo3 extends HttpServlet{    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{        System.out.println(&quot;get方法执行&quot;);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{        System.out.println(&quot;post方法执行&quot;);        doGet(req,resp);}</code></pre><h4 id="1-1-4-配置Servlet"><a href="#1-1-4-配置Servlet" class="headerlink" title="1.1.4 配置Servlet"></a>1.1.4 配置Servlet</h4><p>在web.xml中配置</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;!--配置servlet--&gt;&lt;servlet&gt;&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;    &lt;servlet-class&gt;servlet.ServletDemo1&lt;&#x2F;servlet-class&gt; &lt;!--全类名--&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;    &lt;url-pattern&gt;&#x2F;demo1&lt;&#x2F;url-pattern&gt; &lt;!--servlet访问路径--&gt;&lt;&#x2F;servlet-mapping&gt;</code></pre><p><code>urlpartten</code>：Servlet访问路径</p><ol><li>一个Servlet可以定义多个访问路径：<code>@WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;})</code></li><li>路径定义规则：<ul><li><code>/xxx</code>：路径匹配</li><li><code>/xxx/xxx</code>：多层路径，类似目录结构</li><li><code>*.do</code>：扩展名匹配</li></ul></li></ol><p><strong>Servlet执行原理</strong>：</p><ol><li>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</li><li>查询web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容</li><li>如果有，则在找到对应的<code>&lt;servlet-class&gt;</code>全类名</li><li>tomcat会将字节码文件加载进内存，并创建其对象</li><li>调用其方法</li></ol><blockquote><p>Notice：<code>Servlet3.0</code>以后可以使用注解配置，在类上使用<code>@WebServlet(&quot;资源路径&quot;)</code>，即可完成配置。</p></blockquote><h3 id="1-2-Servlet中的生命周期方法"><a href="#1-2-Servlet中的生命周期方法" class="headerlink" title="1.2 Servlet中的生命周期方法"></a>1.2 Servlet中的生命周期方法</h3><h4 id="1-2-1-被创建：执行init方法，只执行一次"><a href="#1-2-1-被创建：执行init方法，只执行一次" class="headerlink" title="1.2.1. 被创建：执行init方法，只执行一次"></a>1.2.1. 被创建：执行init方法，只执行一次</h4><p>默认情况下，第一次被访问时，Servlet被创建。可以在xml中配置执行Servlet的创建时机。</p><ul><li>在<code>&lt;servlet&gt;</code>标签下配置<ul><li>初次访问时就创建：<code>&lt;load-on-startup&gt;</code>的值为负数</li><li>在服务器启动时就创建：<code>&lt;load-on-startup&gt;</code>的值为0或正整数</li></ul></li></ul><p>Server的init方法只被执行一次，故一个Servlet在内存中只存在一个对象，Servlet是单例的</p><ul><li>多个用户同时访问时，可能存在线程安全问题</li><li>解决方式：尽量不要在Servlet中定义成员变量，即使定义了成员变量，也不要对其修改值。</li></ul><h4 id="1-2-2-提供服务：执行service方法，执行多次"><a href="#1-2-2-提供服务：执行service方法，执行多次" class="headerlink" title="1.2.2 提供服务：执行service方法，执行多次"></a>1.2.2 提供服务：执行service方法，执行多次</h4><ul><li>每次访问Servlet时，service方法都会被调用一次</li></ul><h4 id="1-2-3-被销毁：执行destroy方法，只执行一次"><a href="#1-2-3-被销毁：执行destroy方法，只执行一次" class="headerlink" title="1.2.3 被销毁：执行destroy方法，只执行一次"></a>1.2.3 被销毁：执行destroy方法，只执行一次</h4><ul><li>Servlet被销毁时执行。服务器关闭时，Servlet被销毁。</li><li>只有服务器正常关闭时，才会执行destroy方法。</li><li>destroy方法在Servlet被销毁之前执行，一般用于释放资源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat服务器</title>
      <link href="/JavaWeb/tomcat.html"/>
      <url>/JavaWeb/tomcat.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Web服务器软件"><a href="#1-Web服务器软件" class="headerlink" title="1. Web服务器软件"></a>1. Web服务器软件</h2><ul><li><p>安装了服务器软件的计算机就是<strong>服务器</strong></p></li><li><p>服务器软件：接收用户的请求，处理请求，返回响应</p></li><li>Web服务器软件：接收用户的请求，处理请求，做出响应。在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目</li></ul><a id="more"></a><h3 id="1-1-常见的Java相关的Web服务器软件"><a href="#1-1-常见的Java相关的Web服务器软件" class="headerlink" title="1.1 常见的Java相关的Web服务器软件"></a>1.1 常见的Java相关的Web服务器软件</h3><ol><li>WebLogic：Oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>WebSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>JBOSS：JBOOS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范Servlet/jsp。开源免费的</li></ol><blockquote><p>Tips：<strong>JavaEE</strong>是Java语言在企业开发中使用的技术规范的总和，一共规定了13项大的规范。</p></blockquote><h3 id="1-2-Tomcat"><a href="#1-2-Tomcat" class="headerlink" title="1.2 Tomcat"></a>1.2 Tomcat</h3><h4 id="1-2-1-下载"><a href="#1-2-1-下载" class="headerlink" title="1.2.1 下载"></a>1.2.1 下载</h4><ol><li>前往Tomcat官网<a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">下载</a>安装版：<code>Windows Service Installer</code>，也可以下载解压版。</li></ol><h4 id="1-2-2-安装"><a href="#1-2-2-安装" class="headerlink" title="1.2.2 安装"></a>1.2.2 安装</h4><ol><li>安装版点击安装即可，软件会自动注册服务</li><li>解压版解压即可使用</li></ol><h5 id="Tomcat目录结构："><a href="#Tomcat目录结构：" class="headerlink" title="Tomcat目录结构："></a>Tomcat目录结构：</h5><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/06/08/tomcat%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-1560005163914.png" alt="path"></p><blockquote><p>Notice：注意，安装或解压的路径不要有中文</p></blockquote><h4 id="1-2-3-卸载"><a href="#1-2-3-卸载" class="headerlink" title="1.2.3 卸载"></a>1.2.3 卸载</h4><ol><li>安装版进入文件夹点击<code>Uninstall.exe</code>即可卸载软件</li><li>解压版直接删除文件夹即可</li></ol><h4 id="1-2-4-启动"><a href="#1-2-4-启动" class="headerlink" title="1.2.4 启动"></a>1.2.4 启动</h4><p>安装版会自动注册并启动服务，无需手动启动</p><p>解压版启动方式：</p><ol><li>进入解压后的文件夹，进入bin目录，双击<code>startup.bat</code>运行该文件</li><li>访问：浏览器输入：<code>http://localhost:8080</code> 即可本地访问</li></ol><h4 id="1-2-5-关闭"><a href="#1-2-5-关闭" class="headerlink" title="1.2.5 关闭"></a>1.2.5 关闭</h4><p>解压版关闭</p><ol><li><code>bin/shutdows.bat</code>，双击即可关闭服务</li><li>直接关闭窗口或者<code>ctrl+c</code></li></ol><p>根据进程PID关闭</p><ol><li><code>cmd</code>输入<code>netstat -ano</code>，打印当前运行进程PID等信息，找到本地地址端口号8080的，查看其PID。</li><li>打开任务管理器，进程显示PID，然后根据PID号直接结束进程。</li></ol><blockquote><p> Tips: windows下删除服务命令：<code>sc delete 服务名称</code></p></blockquote><p><a href="https://blog.csdn.net/u011982967/article/details/80999552" target="_blank" rel="noopener">安装参考文章</a></p><h4 id="1-2-6-配置"><a href="#1-2-6-配置" class="headerlink" title="1.2.6 配置"></a>1.2.6 配置</h4><h5 id="项目部署的方式"><a href="#项目部署的方式" class="headerlink" title="项目部署的方式"></a>项目部署的方式</h5><ol><li>直接将项目文件夹放在webapps目录下即可，也可将项目打包成一个war包，再将war包放入wabapps目录下，war包会自动解压。</li><li><p>配置<code>conf/server.xml</code>文件完成部署，在<code>&lt;Host&gt;</code>标签体中配置：<code>&lt;Context docBase=&quot;D:\Project&quot; path=&quot;/index&quot; /&gt;</code>；docBase：项目存放的本地路径，path：虚拟目录。</p></li><li><p>在<code>conf\Catalina\localhost\</code>下创建任意名称(文件名称即虚拟路径)的xml文件。在文件中编写<code>&lt;Context docBase=&quot;D:\Project /&gt;&quot;</code></p></li></ol><h5 id="静态项目和动态项目"><a href="#静态项目和动态项目" class="headerlink" title="静态项目和动态项目"></a>静态项目和动态项目</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">Java动态项目目录结构：-- 项目名称    -- WEB-INF    -- web.xml：该项目的核心配置文件    -- classes目录：放置字节码文件    -- lib目录：放置项目依赖的jar包</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XML简单入门</title>
      <link href="/JavaWeb/xml.html"/>
      <url>/JavaWeb/xml.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-XML基础"><a href="#1-XML基础" class="headerlink" title="1. XML基础"></a>1. XML基础</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>XML指可扩展标记语言(Extensible Markup Language)，是一种<strong>标记语言</strong>，类似HTML。xml被设计用于<strong>传输和存储数据</strong>，而不是显示数据，标签都是自定义的。</p><a id="more"></a><h3 id="1-2-功能"><a href="#1-2-功能" class="headerlink" title="1.2 功能"></a>1.2 功能</h3><ul><li>存储数据：项目配置文件</li><li>传输数据：在网络中传输</li></ul><h3 id="1-3-xml与html的区别"><a href="#1-3-xml与html的区别" class="headerlink" title="1.3 xml与html的区别"></a>1.3 xml与html的区别</h3><ol><li>xml标签都是自定义的，html标签是预定义</li><li>xml的语法严格，html语法松散</li><li>xml是存储数据的，html是展示数据</li></ol><blockquote><p>W3C：万维网联盟，是Web技术领域最具权威和影响力的国际中立性技术标准机构</p></blockquote><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><ol><li>xml文档的后缀名 <code>.xml</code></li><li>xml第一行必须定义为文档声明：<code>&lt;?xml version=&#39;1.0&#39; ?&gt;</code></li><li>xml文档中有且仅有一个根标签</li><li>属性值必须使用引号引起来</li><li>标签必须正确关闭</li><li>xml标签名称区分大小写</li></ol><h4 id="2-1-1-快速入门"><a href="#2-1-1-快速入门" class="headerlink" title="2.1.1 快速入门"></a>2.1.1 快速入门</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-xml">&lt;?xml version=&#39;1.0&#39; ?&gt;&lt;users&gt;    &lt;user id=&quot;1&quot;&gt;        &lt;name&gt;张三&lt;&#x2F;name&gt;        &lt;age&gt;20&lt;&#x2F;age&gt;        &lt;gender&gt;男&lt;&#x2F;gender&gt;    &lt;&#x2F;user&gt;    &lt;user id=&quot;2&quot;&gt;        &lt;name&gt;李四&lt;&#x2F;name&gt;        &lt;age&gt;21&lt;&#x2F;age&gt;        &lt;gender&gt;男&lt;&#x2F;gender&gt;    &lt;&#x2F;user&gt;&lt;&#x2F;users&gt;</code></pre><h3 id="2-2-组成部分"><a href="#2-2-组成部分" class="headerlink" title="2.2 组成部分"></a>2.2 组成部分</h3><h4 id="2-2-1-文档声明"><a href="#2-2-1-文档声明" class="headerlink" title="2.2.1 文档声明"></a>2.2.1 文档声明</h4><ol><li>格式：<code>&lt;?xml 属性列表 ?&gt;</code></li><li>属性列表：<ul><li><code>version</code>：版本号。必须的属性</li><li><code>encoding</code>：编码方式。告知解析引擎当前文档使用的字符集，默认值<code>ISO-8859-1</code></li><li><code>standalone</code>：是否独立。<code>yes</code>表示不依赖其他文件，<code>no</code>表示依赖其他文件</li></ul></li></ol><h4 id="2-2-2-指令-了解即可"><a href="#2-2-2-指令-了解即可" class="headerlink" title="2.2.2 指令(了解即可)"></a>2.2.2 指令(了解即可)</h4><p>可以结合css样式，解析页面，需加入声明：<code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;style.css&quot; ?&gt;</code></p><h4 id="2-2-3-标签"><a href="#2-2-3-标签" class="headerlink" title="2.2.3 标签"></a>2.2.3 标签</h4><p>标签名称都是自定义的，不过有以下几点规则：</p><ol><li>名称可以包含字母、数字及其他的字符</li><li>名称不能以数字或者标点符号开始</li><li>名称不能以字母xml(或者XML、XmL等等)开始</li><li>名称不能包含空格</li></ol><h4 id="2-2-4-属性"><a href="#2-2-4-属性" class="headerlink" title="2.2.4 属性"></a>2.2.4 属性</h4><p>id属性值唯一</p><h4 id="2-2-5-文本"><a href="#2-2-5-文本" class="headerlink" title="2.2.5 文本"></a>2.2.5 文本</h4><ul><li>CDATA区：在该区域中的数据会被原样展示，格式：<code>&lt;![CDATA[ 数据]]&gt;</code></li></ul><h3 id="2-3-约束"><a href="#2-3-约束" class="headerlink" title="2.3 约束"></a>2.3 约束</h3><p>规定xml文档的书写规则，作为框架的使用者，我们只要能够在xml中引入约束文档，并能简单的读懂约束文档即可。</p><h4 id="2-3-1-分类"><a href="#2-3-1-分类" class="headerlink" title="2.3.1 分类"></a>2.3.1 分类</h4><ol><li>DTO：一种简单的约束技术</li><li>Schema：一种复杂的约束技术</li></ol><h4 id="2-3-2-DTD"><a href="#2-3-2-DTD" class="headerlink" title="2.3.2 DTD"></a>2.3.2 DTD</h4><p>引入dtd文档到xml文档中</p><ul><li>内部dtd：将约束规则直接定义在xml文档中</li><li>外部dtd：将约束规则定义在外部的dtd文件中<ul><li>引入<strong>本地dtd</strong>文档：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件位置&quot;</code></li><li>引入<strong>网络dtd</strong>文档：<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名&quot; &quot;dtd文件URL&quot;</code></li></ul></li></ul><h4 id="2-3-3-Schema"><a href="#2-3-3-Schema" class="headerlink" title="2.3.3 Schema"></a>2.3.3 Schema</h4><p>引入</p><ol><li>填写xml文档的根元素</li><li>引入xsi前缀：<code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code></li><li>引入xsd文件命名空间：<code>xsi:schemaLocation=&quot;http://www.zero.cn/xml  student.xsd&quot;</code></li><li>为每一个xsd约束声明一个前缀，作为标识：<code>xmlns:z1=&quot;http://www.zero.cn/xml&quot;</code></li></ol><h2 id="3-解析"><a href="#3-解析" class="headerlink" title="3. 解析"></a>3. 解析</h2><p>操作xml文档，将文档中的数据读取到内存中</p><h4 id="3-1-主要操作"><a href="#3-1-主要操作" class="headerlink" title="3.1 主要操作"></a>3.1 主要操作</h4><ol><li>解析(读取)：将文档中的数据读取到内存中</li><li>写入：将内存中的数据保存到xml文档中。持久化存储</li></ol><h4 id="3-2-解析xml的方式"><a href="#3-2-解析xml的方式" class="headerlink" title="3.2 解析xml的方式"></a>3.2 解析xml的方式</h4><ol><li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<ul><li>优点：操作方便，可以对文档进行CRUD的所有操作</li><li>缺点：占内存</li></ul></li><li>SAX：逐行读取，基于事件驱动的。<ul><li>优点：不占内存</li><li>缺点：只能读取，不能增删改</li></ul></li></ol><h4 id="3-3-xml常见的解析器"><a href="#3-3-xml常见的解析器" class="headerlink" title="3.3 xml常见的解析器"></a>3.3 xml常见的解析器</h4><ol><li>JAXP：sun公司提供的解析器，支持dom和sax两种思想</li><li>DOM4J：一款非常优秀的解析器</li><li>Jsoup：一款Java的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于JQuery的操作方法来取出和操作数据。</li><li>PULL：Android操作系统内置的解析器，sax方式。</li></ol><h4 id="3-4-Jsoup解析器"><a href="#3-4-Jsoup解析器" class="headerlink" title="3.4 Jsoup解析器"></a>3.4 Jsoup解析器</h4><p>使用步骤：</p><ol><li>导入jar包</li><li>获取Document对象</li><li>获取对应的标签Element对象</li><li>获取数据</li></ol><h4 id="3-4-1-代码示例"><a href="#3-4-1-代码示例" class="headerlink" title="3.4.1 代码示例"></a>3.4.1 代码示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoJsoup01 {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 1.获取Document对象，根据xml文档获取        &#x2F;&#x2F; 1.1 获取users.xml的path        String path = DemoJsoup01.class.getClassLoader().getResource(&quot;Demo6_7&#x2F;users.xml&quot;).getPath();        &#x2F;&#x2F; 1.2 解析xml文档，加载文档进内存，获取dom树---&gt; Document        Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);        &#x2F;&#x2F; 2. 获取所有name元素对象        Elements elements = document.getElementsByTag(&quot;name&quot;);        System.out.println(elements.size()); &#x2F;&#x2F; 2        &#x2F;&#x2F; 2.1 获取第一个name的element对象        Element element = elements.get(0);        String name = element.text();        System.out.println(name);    }}</code></pre><h4 id="3-4-2-对象的使用"><a href="#3-4-2-对象的使用" class="headerlink" title="3.4.2 对象的使用"></a>3.4.2 对象的使用</h4><ul><li><p>Jsoup：工具类，可以解析html或xml文档，返回document</p><ul><li>主要方法：<code>parse</code>，解析html和xml文档，返回document<ul><li><code>parse(File in, String charsetName)</code>：解析xml或html文件的，最常用方法。</li><li><code>parse(String html)</code>：解析xml或html字符串</li><li><code>parse(URL url,int timeoutMillis)</code>：通过网络路径获取指定的html或xml的文档对象。</li></ul></li></ul></li><li><p>Document：文档对象。代表内存中的dom树</p><ul><li><p>获取Element对象常用方法</p><ul><li><code>getElementById(String id)</code>：根据id属性值获取唯一的element对象</li><li><code>getElementsByTag(String tagName)</code>：根据标签名称获取元素对象集合</li><li><code>getElementsByAttribute(String key)</code>：根据属性名称获取元素对象集合</li><li><code>getElementsByAttributeValue(String key, String value)</code>：根据对应的属性名和属性值获取元素对象集合</li></ul><p><strong>代码示例</strong>：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">     public class DemoJsoup02 {         public static void main(String[] args) throws IOException {             &#x2F;&#x2F; 1. 获取users.xml的path             String path = DemoJsoup02.class.getClassLoader().getResource(&quot;Demo6_7&#x2F;users.xml&quot;).getPath();             &#x2F;&#x2F; 1.1 解析xml文档，加载文档进内存，获取dom树             Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);             &#x2F;&#x2F; 2. 获取所有的user元素对象             Elements users = document.getElementsByTag(&quot;user&quot;);             System.out.println(users);             System.out.println(&quot;----------------------------&quot;);             &#x2F;&#x2F; 3.获取属性名为id的元素对象们             Elements ids = document.getElementsByAttribute(&quot;id&quot;);             System.out.println(ids);             System.out.println(&quot;----------------------------&quot;);             &#x2F;&#x2F; 4. 获取uid属性值为1的元素对象们             Elements uid = document.getElementsByAttributeValue(&quot;uid&quot;, &quot;1&quot;);             System.out.println(uid);             System.out.println(&quot;----------------------------&quot;);             &#x2F;&#x2F; 5. 获取id属性值为“z1”的元素对象             Element z1 = document.getElementById(&quot;z1&quot;);             System.out.println(z1);         }     }</code></pre></li></ul></li></ul><ul><li><p>Elements：元素Element对象的集合。可以当做<code>ArrayList&lt;Element&gt;</code>来使用</p></li><li><p>Element：元素对象</p><ol><li>获取子元素对象<ul><li><code>getElementById(String id)</code>：根据id属性值获取唯一的element对象</li><li><code>getElementsByTag(String tagName)</code>：根据标签名称获取元素对象集合</li><li><code>getElementsByAttribute(String key)</code>：根据属性名称获取元素对象集合</li><li><code>getElementsByAttributeValue(String key, String value)</code>：根据对应的属性名和属性值获取元素对象集合</li></ul></li><li>获取属性值<ul><li><code>String attr(String key)</code>：根据属性名称获取属性值</li></ul></li><li><p>获取文本内容</p><ul><li><code>String text()</code>：获取文本内容</li><li><code>String html()</code>：获取标签体的所有内容(包括子标签的字符串内容)</li></ul><p><strong>代码示例</strong>:</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   public class DemoJsoup03 {       public static void main(String[] args) throws IOException {           &#x2F;&#x2F; 1. 获取student.xml的path           String path = DemoJsoup03.class.getClassLoader().getResource(&quot;Demo6_7&#x2F;users.xml&quot;).getPath();           &#x2F;&#x2F; 1.1 解析xml文档，加载文档进内存，获取dom树---&gt; Document           Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);           &#x2F;&#x2F; 2. 获取第一个user元素对象           Element user = document.getElementsByTag(&quot;user&quot;).get(0);           &#x2F;&#x2F; 2.1 根据元素对象获取下面的子元素name           Elements name = user.getElementsByTag(&quot;name&quot;);           &#x2F;&#x2F; 2.2 根据属性名称获取属性值           String id = name.attr(&quot;id&quot;);           System.out.println(id); &#x2F;&#x2F; z1           &#x2F;&#x2F; 2.3 获取name元素的文本内容           System.out.println(name.text()); &#x2F;&#x2F; 张三           &#x2F;&#x2F; 2.4 获取第一个user元素对象下面的所有标签体内容           System.out.println(user.html());       }   }</code></pre></li></ol></li></ul><ul><li><p>Node：节点对象</p><ul><li>是Document和Element的父类</li></ul></li></ul><h4 id="3-4-3-快捷查询方式"><a href="#3-4-3-快捷查询方式" class="headerlink" title="3.4.3 快捷查询方式"></a>3.4.3 快捷查询方式</h4><ul><li><p>selector：选择器</p><ul><li><p><code>Elements select(String cssQuery)</code>：语法类似CSS的元素选择器，具体使用参考<a href="https://jsoup.org/apidocs/org/jsoup/select/Selector.html" target="_blank" rel="noopener">Selector类</a>中定义的语法</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   public class DemoJsoup04 {       public static void main(String[] args) throws IOException {           &#x2F;&#x2F; 1. 获取student.xml的path           String path = DemoJsoup04.class.getClassLoader().getResource(&quot;Demo6_7&#x2F;users.xml&quot;).getPath();           &#x2F;&#x2F; 2. 解析xml文档，加载文档进内存，获取dom树           Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);           &#x2F;&#x2F; 3. 查询name标签           Elements names = document.select(&quot;name&quot;);           System.out.println(names);           &#x2F;&#x2F; 4. 查询id值为“z1”的元素           Elements ids = document.select(&quot;#z1&quot;);           System.out.println(ids);           &#x2F;&#x2F; 5. 获取user标签且uid属性值为1的age子标签           Elements age = document.select(&quot;user[uid=&#39;1&#39;] &gt; age&quot;);           System.out.println(age);       }   }</code></pre></li></ul></li></ul><ul><li>XPath：</li></ul><p>XPath即为XML路径语言，它是一种用来确定XML(标准通用标记语言的子集)文档中某部分位置的语言</p><ul><li>使用Jsoup的Xpath需额外导入jar包</li><li>Xpath使用语法查询w3cshool的<a href="http://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="noopener">参考手册</a></li></ul><p><strong>代码示例</strong>：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoJsoup05 {    public static void main(String[] args) throws IOException, XpathSyntaxErrorException {        &#x2F;&#x2F; 1. 获取student.xml的path        String path = DemoJsoup05.class.getClassLoader().getResource(&quot;Demo6_7&#x2F;users.xml&quot;).getPath();        &#x2F;&#x2F; 2. 解析xml文档，加载文档进内存，获取dom树        Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);        &#x2F;&#x2F; 3. 根据document，创建JXDocument对象        JXDocument jxDocument = new JXDocument(document);        &#x2F;&#x2F; 4. 结合xpath语法查询        &#x2F;&#x2F; 4.1 查询所有的user标签        List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;&#x2F;&#x2F;user&quot;);        for (JXNode jxNode : jxNodes) {            System.out.println(jxNode);        }        &#x2F;&#x2F; 4.2 所有user标签下的name标签        List&lt;JXNode&gt; jxNames = jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name&quot;);        for (JXNode jxName : jxNames) {            System.out.println(jxName);        }        &#x2F;&#x2F; 4.3 查询user标签下带有id属性的name标签        List&lt;JXNode&gt; jxId = jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name[@id]&quot;);        for (JXNode jxNode : jxId) {            System.out.println(jxNode);        }        &#x2F;&#x2F; 4.4 查询user标签下id属性值为“z1”的name标签        List&lt;JXNode&gt; jxIdisz1 = jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name[@id=&#39;z1&#39;]&quot;);        for (JXNode jxNode : jxIdisz1) {            System.out.println(jxNode);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap简单入门</title>
      <link href="/JavaWeb/Bootstrap.html"/>
      <url>/JavaWeb/Bootstrap.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Bootstrap概述"><a href="#1-Bootstrap概述" class="headerlink" title="1. Bootstrap概述"></a>1. Bootstrap概述</h2><p>Bootstrap是一个前端开发框架，来自Twitter。Bootstrap是基于HTML、CSS、JavaScript的，它简洁灵活，使得Web开发更加快捷。</p><a id="more"></a><ul><li>框架：一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。</li></ul><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h2><h3 id="2-1-Bootstrap环境安装"><a href="#2-1-Bootstrap环境安装" class="headerlink" title="2.1 Bootstrap环境安装"></a>2.1 Bootstrap环境安装</h3><ol><li>从<a href="https://v3.bootcss.com" target="_blank" rel="noopener">https://v3.bootcss.com</a>上下载Bootstrap的最新版本</li><li>将解压后的三个文件夹复制进项目</li></ol><h3 id="2-2-基本模板"><a href="#2-2-基本模板" class="headerlink" title="2.2 基本模板"></a>2.2 基本模板</h3><p>创建html页面，引入必要的资源文件</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap HelloWorld&lt;&#x2F;title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href=&quot;css&#x2F;bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;    &lt;script src=&quot;js&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;    &lt;script src=&quot;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="3-响应式布局"><a href="#3-响应式布局" class="headerlink" title="3. 响应式布局"></a>3. 响应式布局</h2><p>同一套页面能够兼容多个终端，不同分辨率的设备。其实现依赖于<a href="https://v3.bootcss.com/css/#grid" target="_blank" rel="noopener">栅格系统</a>：将一行平均分成12个格子，可以指定元素占几个格子。</p><h3 id="3-1-使用步骤"><a href="#3-1-使用步骤" class="headerlink" title="3.1 使用步骤"></a>3.1 使用步骤</h3><h4 id="3-1-1-定义容器"><a href="#3-1-1-定义容器" class="headerlink" title="3.1.1 定义容器"></a>3.1.1 定义容器</h4><p>相当于之前的table，容器分类：</p><ol><li><code>container</code>：固定宽度，两边留白</li><li><code>container-fluid</code>：每一种设备都是100%宽度</li></ol><h4 id="3-1-2-定义行"><a href="#3-1-2-定义行" class="headerlink" title="3.1.2 定义行"></a>3.1.2 定义行</h4><p>相当于之前的tr</p><h4 id="3-1-3-定义元素"><a href="#3-1-3-定义元素" class="headerlink" title="3.1.3 定义元素"></a>3.1.3 定义元素</h4><p>指定该元素在不同设备上，所占的格子数目。样式：col-设备代号-格子数目</p><p>设备代号：</p><ol><li>xs：超小屏幕(手机，&lt;768px)：col-xs-12</li><li>sm：小屏幕(平板电脑，≥768px)</li><li>md：中等屏幕(笔记本电脑，≥992px)</li><li>lg：大屏幕(桌面显示器，≥1200px)</li></ol><blockquote><p>Notice：</p><ol><li>一行中如果格子数目超过12，则超出部分自动换行。</li><li>栅格类属性可以向上兼容。栅格类适用于屏幕宽度大于或等于分界点大小的设备。</li><li>如果真实设备宽度小于了设置栅格类属性的设备代码最小值，将会一个元素占满一整行。</li></ol></blockquote><h2 id="4-CSS样式和JS插件"><a href="#4-CSS样式和JS插件" class="headerlink" title="4. CSS样式和JS插件"></a>4. CSS样式和JS插件</h2><h3 id="4-1-全局CSS样式"><a href="#4-1-全局CSS样式" class="headerlink" title="4.1 全局CSS样式"></a>4.1 全局CSS样式</h3><p><a href="https://v3.bootcss.com/css/" target="_blank" rel="noopener">全局CSS样式</a>可查阅网站</p><ul><li><p>按钮：<code>class=&quot;btn btn-default</code></p></li><li><p>图片：</p><ul><li><code>class=&quot;img-responsive&quot;</code>：图片在任意尺寸都占100%</li><li>图片形状</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt; :方形  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; :圆形  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; :相框</code></pre></li></ul><ul><li><p>表格</p><ul><li>为任意 <code>&lt;table&gt;</code> 标签添加 <code>class=&quot;table&quot;</code> 可以为其赋予基本的样式 </li><li>添加 <code>class=&quot;table-bordered&quot;</code> 为表格和其中的每个单元格增加边框。</li><li>通过添加 <code>class=&quot;table-hover&quot;</code> 类可以让 <code>&lt;tbody&gt;</code> 中的每一行对鼠标悬停状态作出响应。</li></ul></li><li><p>表单</p><ul><li>给表单项添加<code>class=&quot;form-control&quot;</code>可以获得更好的表单显示效果</li></ul></li></ul><h3 id="4-2-组件"><a href="#4-2-组件" class="headerlink" title="4.2 组件"></a>4.2 组件</h3><p><a href="https://v3.bootcss.com/components/" target="_blank" rel="noopener">组件查阅网站</a></p><ul><li>导航条</li><li>分页条</li></ul><h3 id="4-3-插件"><a href="#4-3-插件" class="headerlink" title="4.3 插件"></a>4.3 插件</h3><p><a href="https://v3.bootcss.com/javascript/" target="_blank" rel="noopener">JS插件查阅</a></p><ul><li>轮播图</li></ul><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;综合案例_旅游网&lt;&#x2F;title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href=&quot;css&#x2F;bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;    &lt;script src=&quot;js&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;    &lt;script src=&quot;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;style&gt;        .paddtop{            padding-top: 15px;        }        .search-btn{            float: left;            border: 1px solid #ffc900;            width: 90px;            height: 35px;            background-color: #ffc900;            text-align: center;            line-height: 35px;            margin-top: 15px;        }        .search-input{            float: left;            border: 2px solid #ffc900;            width: 400px;            height: 35px;            padding-left: 5px;            margin-top: 15px;        }        .jingxuan{            border-bottom: 2px solid #ffc900;            padding: 5px;        }        .company{            height: 40px;            background-color: #ffc900;            text-align: center;            line-height: 40px;            font-size: 8px;        }    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;!--1. 页眉部分--&gt;    &lt;header class=&quot;container-fluid&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;img src=&quot;img&#x2F;top_banner.jpg&quot; class=&quot;img-responsive&quot;&gt;        &lt;&#x2F;div&gt;        &lt;div class=&quot;row paddtop&quot;&gt;            &lt;div class=&quot;col-md-3&quot;&gt;                &lt;img src=&quot;img&#x2F;logo.jpg&quot; class=&quot;img-responsive&quot;&gt;            &lt;&#x2F;div&gt;            &lt;div class=&quot;col-md-5&quot;&gt;                &lt;input class=&quot;search-input&quot; type=&quot;text&quot; placeholder=&quot;请输入线路名称&quot;&gt;                &lt;a class=&quot;search-btn&quot; href=&quot;#&quot;&gt;搜索&lt;&#x2F;a&gt;            &lt;&#x2F;div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;                &lt;img src=&quot;img&#x2F;hotel_tel.png&quot; class=&quot;img-responsive&quot;&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;        &lt;!--导航栏--&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;nav class=&quot;navbar navbar-default&quot;&gt;                &lt;div class=&quot;container-fluid&quot;&gt;                    &lt;!-- Brand and toggle get grouped for better mobile display --&gt;                    &lt;div class=&quot;navbar-header&quot;&gt;                        &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;                            &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;&#x2F;span&gt;                            &lt;span class=&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt;                            &lt;span class=&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt;                            &lt;span class=&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt;                        &lt;&#x2F;button&gt;                        &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;&#x2F;a&gt;                    &lt;&#x2F;div&gt;                    &lt;!-- Collect the nav links, forms, and other content for toggling --&gt;                    &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;                        &lt;ul class=&quot;nav navbar-nav&quot;&gt;                            &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;                        &lt;&#x2F;ul&gt;                    &lt;&#x2F;div&gt;&lt;!-- &#x2F;.navbar-collapse --&gt;                &lt;&#x2F;div&gt;&lt;!-- &#x2F;.container-fluid --&gt;            &lt;&#x2F;nav&gt;        &lt;&#x2F;div&gt;        &lt;!--轮播图--&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;                &lt;!-- Indicators --&gt;                &lt;ol class=&quot;carousel-indicators&quot;&gt;                    &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;&#x2F;li&gt;                    &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;&#x2F;li&gt;                    &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;&#x2F;li&gt;                &lt;&#x2F;ol&gt;                &lt;!-- Wrapper for slides --&gt;                &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;                    &lt;div class=&quot;item active&quot;&gt;                        &lt;img src=&quot;img&#x2F;banner_1.jpg&quot; alt=&quot;...&quot;&gt;                        &lt;div class=&quot;carousel-caption&quot;&gt;                        &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                    &lt;div class=&quot;item&quot;&gt;                        &lt;img src=&quot;img&#x2F;banner_2.jpg&quot; alt=&quot;...&quot;&gt;                        &lt;div class=&quot;carousel-caption&quot;&gt;                        &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                    &lt;div class=&quot;item&quot;&gt;                        &lt;img src=&quot;img&#x2F;banner_3.jpg&quot; alt=&quot;...&quot;&gt;                        &lt;div class=&quot;carousel-caption&quot;&gt;                        &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                &lt;&#x2F;div&gt;                &lt;!-- Controls --&gt;                &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;                    &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;&#x2F;span&gt;                    &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;&#x2F;span&gt;                &lt;&#x2F;a&gt;                &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;                    &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;&#x2F;span&gt;                    &lt;span class=&quot;sr-only&quot;&gt;Next&lt;&#x2F;span&gt;                &lt;&#x2F;a&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;header&gt;    &lt;!--1. 主体部分--&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row jingxuan&quot;&gt;            &lt;img src=&quot;img&#x2F;icon_5.jpg&quot; alt=&quot;&quot;&gt;            &lt;span&gt;旅游精选&lt;&#x2F;span&gt;        &lt;&#x2F;div&gt;        &lt;div class=&quot;row paddtop&quot;&gt;            &lt;div class=&quot;col-md-3&quot;&gt;                &lt;div class=&quot;thumbnail&quot;&gt;                    &lt;img src=&quot;img&#x2F;jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                    &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt;                    &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt;                &lt;&#x2F;div&gt;            &lt;&#x2F;div&gt;            &lt;div class=&quot;col-md-3&quot;&gt;                &lt;div class=&quot;thumbnail&quot;&gt;                    &lt;img src=&quot;img&#x2F;jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                    &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt;                    &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt;                &lt;&#x2F;div&gt;            &lt;&#x2F;div&gt;            &lt;div class=&quot;col-md-3&quot;&gt;                &lt;div class=&quot;thumbnail&quot;&gt;                    &lt;img src=&quot;img&#x2F;jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                    &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt;                    &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt;                &lt;&#x2F;div&gt;            &lt;&#x2F;div&gt;            &lt;div class=&quot;col-md-3&quot;&gt;                &lt;div class=&quot;thumbnail&quot;&gt;                    &lt;img src=&quot;img&#x2F;jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                    &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt;                    &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt;                &lt;&#x2F;div&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;        &lt;div class=&quot;row jingxuan&quot;&gt;            &lt;img src=&quot;img&#x2F;icon_6.jpg&quot; alt=&quot;&quot;&gt;            &lt;span&gt;国内游&lt;&#x2F;span&gt;        &lt;&#x2F;div&gt;        &lt;div class=&quot;row paddtop&quot;&gt;            &lt;div class=&quot;col-md-4&quot;&gt;                &lt;img src=&quot;img&#x2F;guonei_1.jpg&quot; alt=&quot;&quot;&gt;            &lt;&#x2F;div&gt;            &lt;div class=&quot;col-md-8&quot;&gt;                &lt;div class=&quot;row&quot;&gt;                    &lt;div class=&quot;col-md-4&quot;&gt;                        &lt;div class=&quot;thumbnail&quot;&gt;                            &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt;                        &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                    &lt;div class=&quot;col-md-4&quot;&gt;                        &lt;div class=&quot;thumbnail&quot;&gt;                            &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt;                        &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                    &lt;div class=&quot;col-md-4&quot;&gt;                        &lt;div class=&quot;thumbnail&quot;&gt;                            &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt;                        &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                &lt;&#x2F;div&gt;                &lt;div class=&quot;row&quot;&gt;                    &lt;div class=&quot;col-md-4&quot;&gt;                        &lt;div class=&quot;thumbnail&quot;&gt;                            &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt;                        &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                    &lt;div class=&quot;col-md-4&quot;&gt;                        &lt;div class=&quot;thumbnail&quot;&gt;                            &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt;                        &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                    &lt;div class=&quot;col-md-4&quot;&gt;                        &lt;div class=&quot;thumbnail&quot;&gt;                            &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt;                        &lt;&#x2F;div&gt;                    &lt;&#x2F;div&gt;                &lt;&#x2F;div&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;!--1. 页脚部分--&gt;    &lt;footer class=&quot;container-fluid&quot;&gt;        &lt;div class=&quot;row paddtop&quot;&gt;            &lt;img src=&quot;img&#x2F;footer_service.png&quot; alt=&quot;&quot; class=&quot;img-responsive&quot;&gt;        &lt;&#x2F;div&gt;        &lt;div class=&quot;row company&quot;&gt;            浙江零度科技股份有限公司 版权所&amp;Copyright; 2026-2036, All Rights Reserved 浙ICP备16007882        &lt;&#x2F;div&gt;    &lt;&#x2F;footer&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript进阶</title>
      <link href="/JavaWeb/JavaScriptHigh.html"/>
      <url>/JavaWeb/JavaScriptHigh.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-DOM概述"><a href="#1-DOM概述" class="headerlink" title="1. DOM概述"></a>1. DOM概述</h2><p>DOM (Document Object Model) 译为<strong>文档对象模型</strong>，是 HTML 和 XML 文档的编程接口。HTML DOM 定义了访问和操作 HTML 文档的标准方法。</p><a id="more"></a><ul><li>功能：将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作。</li><li>获取页面标签(元素Element)对象。例：<code>document.getElementById(&quot;id值&quot;)</code>，通过元素id获取元素对象。</li></ul><h3 id="1-1-DOM的3个部分"><a href="#1-1-DOM的3个部分" class="headerlink" title="1.1 DOM的3个部分"></a>1.1 DOM的3个部分</h3><p>W3C的DOM标准被分为3个同的部分：</p><ul><li>核心DOM(针对任何结构化文档的标准模型)<ul><li><code>Document</code>：文档对象</li><li><code>Element</code>：元素对象</li><li><code>Attribute</code>：属性对象</li><li><code>Text</code>：文本对象</li><li><code>Comment</code>：注释对象</li><li><code>Node</code>：节点对象，上述5个对象的父对象</li></ul></li><li>XML DOM(针对XML文档的标准模型)</li><li>HTML DOM(针对HTML文档的标准模型)</li></ul><h3 id="1-2-核心DOM模型"><a href="#1-2-核心DOM模型" class="headerlink" title="1.2 核心DOM模型"></a>1.2 核心DOM模型</h3><h4 id="1-2-1-Document：文档对象"><a href="#1-2-1-Document：文档对象" class="headerlink" title="1.2.1 Document：文档对象"></a>1.2.1 Document：文档对象</h4><h5 id="1-2-1-1-创建-获取"><a href="#1-2-1-1-创建-获取" class="headerlink" title="1.2.1.1 创建(获取)"></a>1.2.1.1 创建(获取)</h5><p>在html dom模型中可以使用window对象来获取</p><ol><li><code>window.document</code></li><li><code>document</code></li></ol><h5 id="1-2-1-2-方法"><a href="#1-2-1-2-方法" class="headerlink" title="1.2.1.2 方法"></a>1.2.1.2 方法</h5><p>获取Element对象：</p><ul><li><code>getElementById()</code>：根据id属性值获取元素对象。id属性一般唯一</li><li><code>getElementByTagName()</code>：根据元素名称获取元素对象们。返回值是一个数组</li><li><code>getElementByClassName()</code>：根据Class属性值获取元素对象们。返回值是一个数组</li><li><code>getElementsByName()</code>：根据name属性值获取元素对象们。返回值是一个数组</li></ul><p>创建其他DOM对象：</p><ul><li><code>createAttribute(name)</code></li><li><code>createComment()</code></li><li><code>createElement()</code></li><li><code>createTextNode()</code></li></ul><h5 id="1-2-1-3-属性"><a href="#1-2-1-3-属性" class="headerlink" title="1.2.1.3 属性"></a>1.2.1.3 属性</h5><p>Element：元素对象</p><ol><li>获取/创建：通过document来获取和创建</li><li>方法：<ol><li><code>removeAttribute()</code>：删除属性</li><li><code>setAttribute()</code>：设置属性</li></ol></li></ol><p>Node：节点对象，其他5个的父对象</p><ul><li>特点：所有dom对象都可以被认为是一个节点</li><li>方法：<ul><li><code>appendChild()</code>：向节点的子节点列表的结尾添加新的子节点</li><li><code>removeChild()</code>：删除(并返回)当前节点的指定子节点。</li><li><code>replaceChild()</code>：用新节点替换一个子节点。</li></ul></li><li>属性：<ul><li><code>parentNode</code>：返回节点的父节点</li></ul></li></ul><h5 id="表格增删案例"><a href="#表格增删案例" class="headerlink" title="表格增删案例"></a>表格增删案例</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;动态表格&lt;&#x2F;title&gt;    &lt;style&gt;        table{            border: 1px solid;            margin: auto;            width: 500px;        }        td,th{            text-align: center;            border: 1px solid;        }        div{            text-align: center;            margin: 50px;        }    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt;    &lt;input type=&quot;text&quot; id=&quot;id&quot; placeholder=&quot;请输入编号&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;name&quot;  placeholder=&quot;请输入姓名&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;gender&quot;  placeholder=&quot;请输入性别&quot;&gt;    &lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;btn_add&quot;&gt;&lt;&#x2F;div&gt;&lt;table&gt;    &lt;caption&gt;学生信息表&lt;&#x2F;caption&gt;    &lt;tr&gt;        &lt;th&gt;编号&lt;&#x2F;th&gt;        &lt;th&gt;姓名&lt;&#x2F;th&gt;        &lt;th&gt;性别&lt;&#x2F;th&gt;        &lt;th&gt;操作&lt;&#x2F;th&gt;    &lt;&#x2F;tr&gt;    &lt;tr&gt;        &lt;td&gt;1&lt;&#x2F;td&gt;        &lt;td&gt;钢铁侠&lt;&#x2F;td&gt;        &lt;td&gt;男&lt;&#x2F;td&gt;        &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;deltr(this)&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;    &lt;tr&gt;        &lt;td&gt;2&lt;&#x2F;td&gt;        &lt;td&gt;蜘蛛侠&lt;&#x2F;td&gt;        &lt;td&gt;男&lt;&#x2F;td&gt;        &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;deltr(this)&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;    &lt;tr&gt;        &lt;td&gt;3&lt;&#x2F;td&gt;        &lt;td&gt;绿巨人&lt;&#x2F;td&gt;        &lt;td&gt;男&lt;&#x2F;td&gt;        &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;deltr(this)&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;script&gt;    &#x2F;&#x2F; 1. 获取按钮    var btn_add = document.getElementById(&quot;btn_add&quot;);    btn_add.onclick = function () {        &#x2F;&#x2F; 2. 获取文本框内容        var id = document.getElementById(&quot;id&quot;).value;        var name = document.getElementById(&quot;name&quot;).value;        var gender = document.getElementById(&quot;gender&quot;).value;        &#x2F;&#x2F; 3. 创建td，赋值td的标签体        &#x2F;&#x2F; id的td        var td_id = document.createElement(&quot;td&quot;); &#x2F;&#x2F; 创建一个td元素        var text_id = document.createTextNode(id); &#x2F;&#x2F; 将获取的id标签内容字符串转换为文本节点        td_id.appendChild(text_id); &#x2F;&#x2F; 将节点添加进td中        &#x2F;&#x2F; name的td        var td_name = document.createElement(&quot;td&quot;);        td_name.appendChild(document.createTextNode(name));        &#x2F;&#x2F; gender的td        var td_gender = document.createElement(&quot;td&quot;);        td_gender.appendChild(document.createTextNode(gender));        &#x2F;&#x2F; 删除操作        var del_td = document.createElement(&quot;td&quot;); &#x2F;&#x2F; 创建td        var del_a = document.createElement(&quot;a&quot;); &#x2F;&#x2F; 创建a标签        del_a.setAttribute(&quot;href&quot;,&quot;javascript:void(0);&quot;); &#x2F;&#x2F; 设置a标签属性        del_a.setAttribute(&quot;onclick&quot;,&quot;deltr(this)&quot;); &#x2F;&#x2F; 绑定onclick事件        var text_a = document.createTextNode(&quot;删除&quot;); &#x2F;&#x2F; 创建一个文本节点，并设置内容        del_a.appendChild(text_a); &#x2F;&#x2F; 将文本节点添加进a标签中        del_td.appendChild(del_a); &#x2F;&#x2F; 将a标签添加进td中        &#x2F;&#x2F; 创建tr，将td添加进去        var tr = document.createElement(&quot;tr&quot;);        tr.appendChild(td_id);        tr.appendChild(td_name);        tr.appendChild(td_gender);        tr.appendChild(del_td);        &#x2F;&#x2F; 获取table，将tr添加到table中        var table = document.getElementsByTagName(&quot;table&quot;)[0]; &#x2F;&#x2F; 返回一个数组列表，故取第一个        table.appendChild(tr);    }    &#x2F;&#x2F; 可使用innerHTML优化上述内容    btn_add.onclick = function ·() {        &#x2F;&#x2F; 2. 获取文本框内容        var id = document.getElementById(&quot;id&quot;).value;        var name = document.getElementById(&quot;name&quot;).value;        var gender = document.getElementById(&quot;gender&quot;).value;        var table = document.getElementsByTagName(&quot;table&quot;)[0];        table.innerHTML += &quot;&lt;tr&gt;\n&quot; +            &quot;        &lt;td&gt;&quot;+id+&quot;&lt;&#x2F;td&gt;\n&quot; +            &quot;        &lt;td&gt;&quot;+name+&quot;&lt;&#x2F;td&gt;\n&quot; +            &quot;        &lt;td&gt;&quot;+gender+&quot;&lt;&#x2F;td&gt;\n&quot; +            &quot;        &lt;td&gt;&lt;a href=\&quot;javascript:void(0);\&quot; onclick=\&quot;deltr(this)\&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\n&quot; +            &quot;    &lt;&#x2F;tr&gt;&quot;    }    function deltr(obj) {        var table = obj.parentNode.parentNode.parentNode; &#x2F;&#x2F; 获取当前a标签的父父父级元素table        var tr = obj.parentNode.parentNode; &#x2F;&#x2F; 获取父父级tr        table.removeChild(tr);    }&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3 id="1-3-HTML-DOM"><a href="#1-3-HTML-DOM" class="headerlink" title="1.3 HTML DOM"></a>1.3 HTML DOM</h3><ul><li><p>标签体的设置和获取：<code>innerHTML</code></p></li><li><p>使用html元素对象的属性，详见<a href="http://www.w3school.com.cn/jsref/index.asp" target="_blank" rel="noopener">W3C参考书</a></p></li><li><p>控制元素样式：</p><ul><li><p>使用元素的<code>style</code>属性来设置</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">  div1.style.border = &quot;1px solid red&quot;;  div1.style.width = &quot;200px&quot;;  div1.style.fontSize = &quot;20px&quot;; &#x2F;&#x2F; font-size = fontSize</code></pre></li><li><p>提前定义好类选择器的样式，通过元素的<code>className</code>属性来设置class属性值。</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">  &lt;style&gt;      .d1{          border: 1px solid red;          width: 100px;          height: 100px;      }  &lt;&#x2F;style&gt;  &lt;script&gt;  var div2 = document.getElementById(&quot;div2&quot;);      div2.onclick = function () {          div2.className = &quot;d1&quot;;      }  &lt;&#x2F;script&gt;</code></pre></li></ul><h2 id="2-BOM"><a href="#2-BOM" class="headerlink" title="2. BOM"></a>2. BOM</h2><p>BOM(Browser Object Model)浏览器对象模型，将浏览器的各个组成部分封装成对象</p><h3 id="2-1-主要组成"><a href="#2-1-主要组成" class="headerlink" title="2.1 主要组成"></a>2.1 主要组成</h3><ul><li>Window：窗口对象</li><li>Navigator：浏览器对象</li><li>Screen：显示器屏幕对象</li><li>History：历史记录对象</li><li>Location：地址栏对象</li></ul><p>主要学习窗口对象，历史记录对象和地址栏对象，属性方法可参考：<a href="http://www.w3school.com.cn/jsref/index.asp" target="_blank" rel="noopener">W3School</a></p><h3 id="2-2-Window对象"><a href="#2-2-Window对象" class="headerlink" title="2.2 Window对象"></a>2.2 Window对象</h3><h4 id="2-2-1-创建"><a href="#2-2-1-创建" class="headerlink" title="2.2.1 创建"></a>2.2.1 创建</h4><p>window对象无需创建，可直接使用。</p><h4 id="2-2-2-方法"><a href="#2-2-2-方法" class="headerlink" title="2.2.2 方法"></a>2.2.2 方法</h4><h5 id="2-2-2-1-与弹出框有关的方法"><a href="#2-2-2-1-与弹出框有关的方法" class="headerlink" title="2.2.2.1 与弹出框有关的方法"></a>2.2.2.1 与弹出框有关的方法</h5><ul><li><code>alert()</code>：显示带有一段信息和一个确认按钮的警告框。</li><li><code>confirm()</code>：显示带有一段消息以及确认按钮和取消按钮的对话框。返回一个布尔值。</li><li><code>prompt()</code>：显示可提示用户输入的对话框。返回值是用户输入的值。</li></ul><h5 id="2-2-2-2-与打开关闭有关的方法"><a href="#2-2-2-2-与打开关闭有关的方法" class="headerlink" title="2.2.2.2 与打开关闭有关的方法"></a>2.2.2.2 与打开关闭有关的方法</h5><ul><li><code>close()</code>：关闭浏览器窗口，谁调用关闭谁。</li><li><code>open()</code>：打开一个新的浏览器窗口。返回值是新的窗口对象。</li></ul><h5 id="2-2-2-3-与定时器有关的方法"><a href="#2-2-2-3-与定时器有关的方法" class="headerlink" title="2.2.2.3 与定时器有关的方法"></a>2.2.2.3 与定时器有关的方法</h5><ul><li><code>setTimeout()</code>：在指定的毫秒数后调用函数或计算表达式。<ul><li>参数1：js代码或者方法对象</li><li>参数2：毫秒值</li><li>返回值：唯一标识，用于取消定时器</li></ul></li><li><code>clearTimeout()</code>：取消由<code>setTimeout()</code>方法设置的timeout。</li><li><code>setInterval()</code>：按照指定的周期来循环调用函数或计算表达式。</li><li><code>clearInterval()</code>：取消由setInterval()设置的timeout。</li></ul><h5 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;轮播图&lt;&#x2F;title&gt;    &lt;script&gt;        var number = 1;        function fun() {            number++;            var banner = document.getElementById(&quot;banner&quot;);            banner.src = &quot;img&#x2F;banner_&quot;+number+&quot;.jpg&quot;;            if (number==3){                number = 0;            }        }        setInterval(fun,3000);    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;img src=&quot;img&#x2F;banner_1.jpg&quot; id=&quot;banner&quot; width=&quot;100%&quot;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4 id="2-2-3-属性"><a href="#2-2-3-属性" class="headerlink" title="2.2.3 属性"></a>2.2.3 属性</h4><p>获取其他BOM对象：</p><p><code>window.history</code>，<code>window.localtion</code>，<code>window.Navigator</code>，<code>window.Screen</code></p><p>获取DOM对象：<code>window.document</code></p><h4 id="2-2-4-特点"><a href="#2-2-4-特点" class="headerlink" title="2.2.4 特点"></a>2.2.4 特点</h4><ul><li>Window对象不需要创建可以直接使用。例：<code>window.方法名();</code></li><li>window引用<strong>可以省略</strong>。直接<code>方法名();</code>即可</li></ul><h3 id="2-3-Location对象"><a href="#2-3-Location对象" class="headerlink" title="2.3 Location对象"></a>2.3 Location对象</h3><ol><li>创建(获取)：<code>window.location</code></li><li>方法：<code>reload()</code>：重新加载当前页面(刷新)。</li><li>属性：<code>href</code>：设置或返回完整的URL</li></ol><h4 id="地址栏对象案例"><a href="#地址栏对象案例" class="headerlink" title="地址栏对象案例"></a>地址栏对象案例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;自动跳转&lt;&#x2F;title&gt;    &lt;style&gt;        p{            text-align: center;        }        span{            color: red;        }    &lt;&#x2F;style&gt;    &lt;script&gt;        var t = 5;        function fun() {            t--;            if (t&lt;=0){                clearInterval();                location.href = &quot;https:&#x2F;&#x2F;www.baidu.com&quot;;            }            var times = document.getElementById(&quot;time&quot;);            times.innerHTML = t;        }        setInterval(fun,1000);    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p&gt;&lt;span id=&quot;time&quot;&gt;5&lt;&#x2F;span&gt;秒之后自动跳转页面&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3 id="2-4-History对象"><a href="#2-4-History对象" class="headerlink" title="2.4 History对象"></a>2.4 History对象</h3><ol><li>创建(获取)：<code>window.histtory</code></li><li>方法<ul><li><code>back()</code>：加载历史列表中的前一个URL。</li><li><code>forward()</code>：加载历史列表中的下一个URL。</li><li><code>go(参数)</code>：加载历史列表中的某个具体页面。参数是正负数，代表前进/后退几个历史记录。</li></ul></li><li>属性：<code>length</code>，返回当前窗口历史列表中的URL数量。</li></ol><h2 id="3-事件监听机制"><a href="#3-事件监听机制" class="headerlink" title="3. 事件监听机制"></a>3. 事件监听机制</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>某些组件被执行了某些操作后，触发某些代码的执行。</p><ul><li>事件：某些操作。如单击、双击，键盘按下，鼠标移动等</li><li>事件源：组件。如按钮、文本输入框…</li><li>监听器：js代码</li><li>注册监听：将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。</li></ul><h3 id="3-2-常见的事件"><a href="#3-2-常见的事件" class="headerlink" title="3.2 常见的事件"></a>3.2 常见的事件</h3><h4 id="3-2-1-点击事件"><a href="#3-2-1-点击事件" class="headerlink" title="3.2.1 点击事件"></a>3.2.1 点击事件</h4><ol><li><code>onclick</code>：单击事件</li><li><code>ondblclick</code>：双击事件</li></ol><h4 id="3-2-2-焦点事件"><a href="#3-2-2-焦点事件" class="headerlink" title="3.2.2 焦点事件"></a>3.2.2 焦点事件</h4><ol><li><code>onblur</code>：失去焦点，一般用于表单校验</li><li><code>onfocus</code>：元素获得焦点</li></ol><h4 id="3-2-3-加载事件"><a href="#3-2-3-加载事件" class="headerlink" title="3.2.3 加载事件"></a>3.2.3 加载事件</h4><p><code>onload</code>：一张页面或一副图像完成加载。</p><h4 id="3-2-4-鼠标事件"><a href="#3-2-4-鼠标事件" class="headerlink" title="3.2.4 鼠标事件"></a>3.2.4 鼠标事件</h4><ol><li><code>onmousedown</code>：鼠标按钮被按下。可以定义形参接收<code>event</code>对象，使用<code>event.button</code>，返回点击的鼠标值：左键0，中键1，右键2</li><li><code>onmouseup</code>：鼠标按钮被松开。</li><li><code>onmousemove</code>：鼠标被移动。</li><li><code>onmouseover</code>：鼠标移到某元素之上。</li><li><code>onmouseout</code>：鼠标从某元素移开。</li></ol><h4 id="3-2-5-键盘事件"><a href="#3-2-5-键盘事件" class="headerlink" title="3.2.5 键盘事件"></a>3.2.5 键盘事件</h4><ol><li><code>onkeydown</code>：某个键盘按键被按下。</li><li><code>onkeyup</code>：某个键盘按键被松开。</li><li><code>onkeypress</code>：某个键盘按键被按下并松开。</li></ol><h4 id="3-2-6-选择和改变"><a href="#3-2-6-选择和改变" class="headerlink" title="3.2.6 选择和改变"></a>3.2.6 选择和改变</h4><ol><li><code>onchange</code>：域的内容被改变</li><li><code>onselect</code>：文本被选中</li></ol><h4 id="3-2-7-表单事件"><a href="#3-2-7-表单事件" class="headerlink" title="3.2.7 表单事件"></a>3.2.7 表单事件</h4><ol><li><code>onsubmit</code>：确认按钮被点击，一般用于表单校验</li><li><code>onreset</code>：重置按钮被点击</li></ol><h3 id="3-3-表格全选案例"><a href="#3-3-表格全选案例" class="headerlink" title="3.3 表格全选案例"></a>3.3 表格全选案例</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;表格全选&lt;&#x2F;title&gt;    &lt;style&gt;        table{            border: 1px solid;            width: 500px;            margin-left: 30%;        }        td,th{            text-align: center;            border: 1px solid;        }        div{            margin-top: 10px;            margin-left: 30%;        }        .out{            background-color: white;        }        .over{            background-color: pink;        }    &lt;&#x2F;style&gt;    &lt;script&gt;        &#x2F;&#x2F; 在页面加载完成后绑定事件        window.onload = function () {            &#x2F;&#x2F; 给全选按钮绑定单击事件            document.getElementById(&quot;selectAll&quot;).onclick = function () {                &#x2F;&#x2F; 1.获取所有的checkbox                var cbs = document.getElementsByName(&quot;cb&quot;);                &#x2F;&#x2F; 2. 遍历                for(var i = 0; i &lt; cbs.length; i++){                    &#x2F;&#x2F; 3. 设置每一个cb的状态为选中                    cbs[i].checked = true;                }            }            &#x2F;&#x2F; 给全不选绑定事件            document.getElementById(&quot;unSelectAll&quot;).onclick = function () {                &#x2F;&#x2F; 1.获取所有的checkbox                var cbs = document.getElementsByName(&quot;cb&quot;);                &#x2F;&#x2F; 2. 遍历                for(var i = 0; i &lt; cbs.length; i++){                    &#x2F;&#x2F; 3. 设置每一个cb的状态为未选中                    cbs[i].checked = false;                }            }            &#x2F;&#x2F;给反选绑定事件            document.getElementById(&quot;selectRev&quot;).onclick = function () {                &#x2F;&#x2F; 1.获取所有的checkbox                var cbs = document.getElementsByName(&quot;cb&quot;);                &#x2F;&#x2F; 2. 遍历                for(var i = 0; i &lt; cbs.length; i++){                    &#x2F;&#x2F; 3. 获取当前cb的状态，直接取反赋值                    cbs[i].checked = !cbs[i].checked;                }            }            &#x2F;&#x2F; 第一个cb            document.getElementById(&quot;firstCb&quot;).onclick = function () {                &#x2F;&#x2F; 1.获取所有的checkbox                var cbs = document.getElementsByName(&quot;cb&quot;);                &#x2F;&#x2F; 2. 遍历                for(var i = 0; i &lt; cbs.length; i++){                    &#x2F;&#x2F; 3. 获取每一个cb的状态和第一个cb的状态一致                    cbs[i].checked = this.checked;                }            }            &#x2F;&#x2F; 给所有tr绑定鼠标移到元素上和移出元素事件            var trs = document.getElementsByTagName(&quot;tr&quot;);            &#x2F;&#x2F; 遍历            for (var i = 0; i &lt; trs.length; i++){                &#x2F;&#x2F; 移到元素上事件                trs[i].onmouseover = function () {                    this.className = &quot;over&quot;;                }                &#x2F;&#x2F; 移出元素事件                trs[i].onmouseout = function () {                    this.className = &quot;out&quot;;                }            }        }    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;table&gt;    &lt;caption&gt;学生信息表&lt;&#x2F;caption&gt;    &lt;tr&gt;        &lt;th&gt;&lt;input type=&quot;checkbox&quot; name=&quot;cb&quot; id=&quot;firstCb&quot;&gt;&lt;&#x2F;th&gt;        &lt;th&gt;编号&lt;&#x2F;th&gt;        &lt;th&gt;姓名&lt;&#x2F;th&gt;        &lt;th&gt;性别&lt;&#x2F;th&gt;        &lt;th&gt;操作&lt;&#x2F;th&gt;    &lt;&#x2F;tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;  name=&quot;cb&quot;&gt;&lt;&#x2F;td&gt;        &lt;td&gt;1&lt;&#x2F;td&gt;        &lt;td&gt;钢铁侠&lt;&#x2F;td&gt;        &lt;td&gt;男&lt;&#x2F;td&gt;        &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;  name=&quot;cb&quot;&gt;&lt;&#x2F;td&gt;        &lt;td&gt;2&lt;&#x2F;td&gt;        &lt;td&gt;绿巨人&lt;&#x2F;td&gt;        &lt;td&gt;男&lt;&#x2F;td&gt;        &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input type=&quot;checkbox&quot;  name=&quot;cb&quot;&gt;&lt;&#x2F;td&gt;        &lt;td&gt;3&lt;&#x2F;td&gt;        &lt;td&gt;雷神&lt;&#x2F;td&gt;        &lt;td&gt;?&lt;&#x2F;td&gt;        &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;div&gt;    &lt;input type=&quot;button&quot; id=&quot;selectAll&quot; value=&quot;全选&quot;&gt;    &lt;input type=&quot;button&quot; id=&quot;unSelectAll&quot; value=&quot;全不选&quot;&gt;    &lt;input type=&quot;button&quot; id=&quot;selectRev&quot; value=&quot;反选&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3 id="3-4-表单检验案例"><a href="#3-4-表单检验案例" class="headerlink" title="3.4 表单检验案例"></a>3.4 表单检验案例</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;注册页面&lt;&#x2F;title&gt;&lt;style&gt;    *{        margin: 0px;        padding: 0px;        box-sizing: border-box;    }    body{        background: url(&quot;img&#x2F;register_bg.png&quot;) no-repeat center;        padding-top: 25px;    }    .rg_layout{        width: 900px;        height: 500px;        border: 8px solid #EEEEEE;        background-color: white;        &#x2F;*让div水平居中*&#x2F;        margin: auto;    }    .rg_left{        &#x2F;*border: 1px solid red;*&#x2F;        float: left;        margin: 15px;    }    .rg_left &gt; p:first-child{        color:#FFD026;        font-size: 20px;    }    .rg_left &gt; p:last-child{        color:#A6A6A6;        font-size: 20px;    }    .rg_center{        float: left;       &#x2F;* border: 1px solid red;*&#x2F;    }    .rg_right{        &#x2F;*border: 1px solid red;*&#x2F;        float: right;        margin: 15px;    }    .rg_right &gt; p:first-child{        font-size: 15px;    }    .rg_right p a {        color:pink;    }    .td_left{        width: 100px;        text-align: right;        height: 45px;    }    .td_right{        padding-left: 50px ;    }    #username,#password,#email,#name,#tel,#birthday,#checkcode{        width: 251px;        height: 32px;        border: 1px solid #A6A6A6 ;        &#x2F;*设置边框圆角*&#x2F;        border-radius: 5px;        padding-left: 10px;    }    #checkcode{        width: 110px;    }    #img_check{        height: 32px;        vertical-align: middle;    }    #btn_sub{        width: 150px;        height: 40px;        background-color: #FFD026;        border: 1px solid #FFD026 ;    }    .error{        color: red;    }    #td_sub{        padding-left: 150px;    }&lt;&#x2F;style&gt;&lt;script&gt;    &#x2F;&#x2F; 1. 给表单绑定submit事件。监听器中判断每个方法校验的结果。如果都为true中返回true,有一项false则返回false    &#x2F;&#x2F; 2. 定义一些方法分别校验各个表单项    &#x2F;&#x2F; 3. 给各个表单项绑定失去焦点onblur事件    window.onload = function () {        &#x2F;&#x2F; 1. 给表单绑定submit事件。        document.getElementById(&quot;form&quot;).onsubmit = function () {            &#x2F;&#x2F; 调用用户名校验方法 checkName();            &#x2F;&#x2F; 调用密码校验方法 checkPwd();            return checkName() &amp;&amp; checkPwd() &amp;&amp; checkEmail() &amp;&amp; checkTname() &amp;&amp; checkPhone();        }        &#x2F;&#x2F; 给各个表单项分别绑定离焦事件        document.getElementById(&quot;username&quot;).onblur = checkName;        document.getElementById(&quot;password&quot;).onblur = checkPwd;        document.getElementById(&quot;email&quot;).onblur = checkEmail;        document.getElementById(&quot;name&quot;).onblur = checkTname;        document.getElementById(&quot;tel&quot;).onblur = checkPhone;        &#x2F;&#x2F; 校验用户名方法        function checkName() {            &#x2F;&#x2F; 1. 获取用户名值            var username = document.getElementById(&quot;username&quot;).value;            &#x2F;&#x2F; 2. 定义正则表达式            var reg_username = &#x2F;^\w{6,12}$&#x2F;;            &#x2F;&#x2F; 3. 判断值是否符合正则规则            var flag = reg_username.test(username);            &#x2F;&#x2F; 4. 提示信息            var s_username = document.getElementById(&quot;s_username&quot;);            if (flag){                &#x2F;&#x2F; 提示绿色对勾                s_username.innerHTML = &quot;&lt;img width=&#39;30&#39; height=&#39;20&#39; src=&#39;img&#x2F;gou.png&#39;&#x2F;&gt;&quot;            } else{                &#x2F;&#x2F; 提示红色用户名错误                s_username.innerHTML = &quot;用户名格式错误！&quot;            }            return flag;        }        &#x2F;&#x2F; 校验密码        function checkPwd() {            &#x2F;&#x2F; 1. 获取密码值            var password = document.getElementById(&quot;password&quot;).value;            &#x2F;&#x2F; 2. 定义正则表达式            var reg_password = &#x2F;^(?![^a-zA-Z]+$)(?!\D+$)&#x2F;;            &#x2F;&#x2F; 3. 判断值是否符合正则规则            var flag = reg_password.test(password);            &#x2F;&#x2F; 4. 提示信息            var s_pwd = document.getElementById(&quot;s_pwd&quot;);            if (flag){                &#x2F;&#x2F; 提示绿色对勾                s_pwd.innerHTML = &quot;&lt;img width=&#39;30&#39; height=&#39;20&#39; src=&#39;img&#x2F;gou.png&#39;&#x2F;&gt;&quot;            } else{                &#x2F;&#x2F; 提示红色密码错误                s_pwd.innerHTML = &quot;密码格式错误！&quot;            }            return flag;        }        &#x2F;&#x2F; 校验邮箱        function checkEmail() {            var reg_email = &#x2F;^([a-zA-Z]|[0-9])(\w|\-)+@[a-zA-Z0-9]+\.([a-zA-Z]{2,4})$&#x2F;;            var flag = reg_email.test(document.getElementById(&quot;email&quot;).value);            var s_email = document.getElementById(&quot;s_email&quot;);            if (flag){                s_email.innerHTML = &quot;&lt;img width=&#39;30&#39; height=&#39;20&#39; src=&#39;img&#x2F;gou.png&#39;&#x2F;&gt;&quot;;            }else{                s_email.innerHTML = &quot;邮箱格式错误&quot;;            }        }        &#x2F;&#x2F; 校验姓名        function checkTname() {            var flag = &#x2F;^[\u4E00-\u9FA5\uf900-\ufa2d]{2,4}$&#x2F;.test(document.getElementById(&quot;name&quot;).value);            var s_name = document.getElementById(&quot;s_name&quot;);            if (flag){                s_name.innerHTML = &quot;&lt;img width=&#39;30&#39; height=&#39;20&#39; src=&#39;img&#x2F;gou.png&#39;&#x2F;&gt;&quot;;            }else{                s_name.innerHTML = &quot;姓名格式错误&quot;;            }        }        &#x2F;&#x2F; 校验手机号        function checkPhone() {            var flag = &#x2F;^1[3|4|5|8][0-9]\d{4,8}$&#x2F;.test(document.getElementById(&quot;tel&quot;).value);            var s_phone = document.getElementById(&quot;s_phone&quot;);            if (flag){                s_phone.innerHTML = &quot;&lt;img width=&#39;30&#39; height=&#39;20&#39; src=&#39;img&#x2F;gou.png&#39;&#x2F;&gt;&quot;;            } else{                s_phone.innerHTML = &quot;手机号码格式错误&quot;            }        }    }&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class=&quot;rg_layout&quot;&gt;    &lt;div class=&quot;rg_left&quot;&gt;        &lt;p&gt;新用户注册&lt;&#x2F;p&gt;        &lt;p&gt;USER REGISTER&lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;    &lt;div class=&quot;rg_center&quot;&gt;        &lt;div class=&quot;rg_form&quot;&gt;            &lt;!--定义表单 form--&gt;            &lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;form&quot;&gt;                &lt;table&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;                            &lt;span id=&quot;s_username&quot; class=&quot;error&quot;&gt;&lt;&#x2F;span&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;                            &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;                            &lt;span id=&quot;s_pwd&quot; class=&quot;error&quot;&gt;&lt;&#x2F;span&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;                            &lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;                            &lt;span id=&quot;s_email&quot; class=&quot;error&quot;&gt;&lt;&#x2F;span&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;                            &lt;span id=&quot;s_name&quot; class=&quot;error&quot;&gt;&lt;&#x2F;span&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;                            &lt;span id=&quot;s_phone&quot; class=&quot;error&quot;&gt;&lt;&#x2F;span&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;                            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked&gt; 男                            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;                            &lt;img id=&quot;img_check&quot; src=&quot;img&#x2F;verify_code.jpg&quot;&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td colspan=&quot;2&quot; id=&quot;td_sub&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                &lt;&#x2F;table&gt;            &lt;&#x2F;form&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;div class=&quot;rg_right&quot;&gt;        &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/JavaWeb/JavaScriptBasic.html"/>
      <url>/JavaWeb/JavaScriptBasic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-JavaScript概述"><a href="#1-JavaScript概述" class="headerlink" title="1. JavaScript概述"></a>1. JavaScript概述</h2><p>JavaScript是一种运行在浏览器中的解释型的编程语言。每一个浏览器都有JavaScript的解析引擎，不需要编译就可以直接被浏览器解析执行了。</p><a id="more"></a><ul><li>功能：主要用来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</li></ul><h2 id="2-ECMAScript"><a href="#2-ECMAScript" class="headerlink" title="2. ECMAScript"></a>2. ECMAScript</h2><p>1997年，ECMA(欧洲计算机制造商协会)，制定出<strong>客户端脚本语言的标准</strong>：<code>ECMAScript</code>，就是统一了所有客户端脚本语言的编码方式。</p><ul><li><code>JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)</code></li></ul><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><h4 id="2-1-1-与html结合方式"><a href="#2-1-1-与html结合方式" class="headerlink" title="2.1.1 与html结合方式"></a>2.1.1 与html结合方式</h4><ol><li>内部JS：定义<code>&lt;script&gt;</code>，标签体内容就是js代码</li><li>外部JS：定义<code>&lt;script&gt;</code>，通过<code>src</code>属性引入外部的js文件</li></ol><blockquote><p>Tips: <code>script</code>可以定义在html页面的任何地方，但定义的文字会影响执行顺序。且可以定义多个。</p></blockquote><h4 id="2-1-2-注释"><a href="#2-1-2-注释" class="headerlink" title="2.1.2 注释"></a>2.1.2 注释</h4><ol><li>单行注释：<code>// 注释内容</code></li><li>多行注释：<code>/*注释内容*/</code></li></ol><h4 id="2-1-3-数据类型"><a href="#2-1-3-数据类型" class="headerlink" title="2.1.3 数据类型"></a>2.1.3 数据类型</h4><ol><li>原始数据类型<ol><li><code>number</code>：<code>JavaScript</code>不区分整数和浮点数，统一用<code>number</code>表示。可以表示整数/小数/NaN(NaN表示Not a Number，当无法计算结果时用NaN表示)。</li><li><code>string</code>：字符串。可以使用单双引号。</li><li><code>boolean</code>：布尔值。true和false。</li><li><code>null</code>：一个对象为空的占位符。</li><li><code>undefined</code>：表示值未定义。</li></ol></li><li>引用数据类型：对象，<code>JavaScript</code>的对象是一组由键-值组成的无序集合。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">&lt;script&gt;        var num = 123; &#x2F;&#x2F; 定义一个整数123        var float = 0.456; &#x2F;&#x2F; 定义一个浮点数0.456        var str = &quot;abc&quot;; &#x2F;&#x2F; 定义一个字符串abc        var flag = true; &#x2F;&#x2F; 定义一个布尔值true        var a = null; &#x2F;&#x2F; 定义对象a为空        var b = undefined; &#x2F;&#x2F; 表示值b未定义        var person = { &#x2F;&#x2F; 定义了一个person对象            name:&#39;xiaozhang&#39;,            age:20,            city:&#39;hangzhou&#39;        }&lt;&#x2F;script&gt;</code></pre><h4 id="2-1-4-变量"><a href="#2-1-4-变量" class="headerlink" title="2.1.4 变量"></a>2.1.4 变量</h4><p>变量是一小块存储数据的内存空间。Java语言是强类型语言，而JavaScript是弱类型语言。</p><ul><li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</li><li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</li><li>语法：<code>var 变量名 = 初始化值;</code></li></ul><blockquote><p>Tips: 可以使用<code>typeof</code>运算符获取变量的类型。null运算后得到的是object类型。</p></blockquote><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">document.write(num+&quot;--&gt;&quot;+typeof(num)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 123--&gt;numberdocument.write(str+&quot;--&gt;&quot;+typeof(str)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; abc--&gt;stringdocument.write(flag+&quot;--&gt;&quot;+typeof(flag)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; true--&gt;booleandocument.write(a+&quot;--&gt;&quot;+typeof(a)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; null--&gt;objectdocument.write(b+&quot;--&gt;&quot;+typeof(b)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; undefined--&gt;undefineddocument.write(&quot;person--&gt;&quot;+typeof(person)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; person--&gt;object</code></pre><h4 id="2-1-5-运算符"><a href="#2-1-5-运算符" class="headerlink" title="2.1.5 运算符"></a>2.1.5 运算符</h4><ol><li>一元运算符：只有一个运算数的运算符。例：<code>++,--</code></li><li>算数运算符：<code>+ - * / % ...</code></li><li>赋值运算符：<code>=,+=,-=...</code></li><li>比较运算符：<code>&gt;,&lt;,&gt;=,&lt;=,==,===(全等于)</code>，全等于在比较之前先判断类型，如果类型不一样，直接返回false。</li><li>逻辑运算符：<code>&amp;&amp;,||,!</code>。</li><li>三元运算符：<code>表达式?值1:值2;</code>，判断表达式的值，如果是true则取值1，反之取值2。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">var a = 1;document.write(++a+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 一元运算符var b = 2;document.write(a+b+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 二元运算符: +-*&#x2F;%document.write(b+=1+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 3, 赋值运算符&#x2F;&#x2F; document.write(a&gt;b+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; false,比较运算符var str = &#39;1&#39;;document.write((a==str)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; true，string类型转number，按照字面值转换为1，1==1，故truedocument.write(a===str+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; false,全等于会先进行类型判断，类型不同直接返回falsedocument.write(a&gt;false); &#x2F;&#x2F; a&gt;0 , truedocument.write(a&gt;0?1:0); &#x2F;&#x2F; 三元运算符&#x2F;*在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换* 其他类型转number：     * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）     * boolean转number：true转为1，false转为0逻辑运算符类型转换：1. number：0或NaN为假，其他都为真2. string：除了空字符串(&quot;&quot;)，其他都是true3. null&amp;undefined:都是false4. 对象：所有对象都是true*&#x2F;</code></pre><h4 id="2-1-6-流程控制语句"><a href="#2-1-6-流程控制语句" class="headerlink" title="2.1.6 流程控制语句"></a>2.1.6 流程控制语句</h4><ol><li><code>if...else...</code></li><li><code>switch(变量)：case 值:具体内容;break;</code>，在JS中，switch语句可以接受任意的原始数据类型</li><li><code>while</code></li><li><code>do...while</code></li><li><code>for</code></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">var a = 4;var b = 7;if (a&gt;b){    document.write(&quot;a&gt;b&quot;)} else{    document.write(&quot;b&gt;a&quot;)}var day = 3;switch (day) {    case 1:        document.write(&quot;Monday&quot;);        break;    case 2:        document.write(&quot;Tuesday&quot;);        break;    case 3:        document.write(&quot;Wednesday&quot;);        break;    case 4:        document.write(&quot;Thursday&quot;);        break;    case 5:        document.write(&quot;Friday&quot;);        break;    case 6:        document.write(&quot;Saturday&quot;);        break;    case 7:        document.write(&quot;Sunday&quot;);        break;}var c = 1;while (c&lt;=5){    document.write(c+&quot;&lt;br&gt;&quot;);    c++;}for (i=1;i&lt;=5;i++){    document.write(i+&quot;&lt;br&gt;&quot;)}</code></pre><h4 id="2-1-7-JS特殊语法"><a href="#2-1-7-JS特殊语法" class="headerlink" title="2.1.7 JS特殊语法"></a>2.1.7 JS特殊语法</h4><ol><li>语句以<code>;</code>结尾，如果一行只有一条语句则可省略<code>;</code>(不建议)</li><li>变量的定义使用<code>var</code>关键字，也可以不使用。<ol><li>使用：定义的变量是局部变量</li><li>不用：定义的变量是全局变量(不建议)</li></ol></li></ol><h4 id="2-1-8-小练习：99乘法表"><a href="#2-1-8-小练习：99乘法表" class="headerlink" title="2.1.8 小练习：99乘法表"></a>2.1.8 小练习：99乘法表</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">document.write(&quot;&lt;table&gt;&quot;)for (i=1;i&lt;=9;i++){    document.write(&quot;&lt;tr&gt;&quot;)    for (j=1;j&lt;=i;j++){        document.write(&quot;&lt;td&gt;&quot;)        document.write(j+&quot;*&quot;+i+&quot;=&quot;+j*i)        document.write(&quot;&lt;&#x2F;td&gt;&quot;)    }    document.write(&quot;&lt;&#x2F;tr&gt;&quot;)}document.write(&quot;&lt;&#x2F;table&gt;&quot;)</code></pre><h2 id="3-基本对象"><a href="#3-基本对象" class="headerlink" title="3. 基本对象"></a>3. 基本对象</h2><h3 id="3-1-Function：函数对象"><a href="#3-1-Function：函数对象" class="headerlink" title="3.1 Function：函数对象"></a>3.1 Function：函数对象</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">    &lt;script&gt;        &#x2F;*            1.创建函数对象：                1. function 方法名称(形参列表){                    方法体                }                2. var 方法名 = function(形参列表){                    方法体                }            2. 属性：                length：返回形参的个数            3. 特点：                1. 方法定义时形参的类型不用写                2. 方法是一个对象，如果定义名称相同的方法，会覆盖                3. 在JS中，方法的调用只与方法名称有关                4. 在方法声明中有一个隐藏的内置关键字：argument,用于接收所有形参，封装成了一个数组            4. 调用：                方法名称(参数列表);         *&#x2F;        function fun(a,b) {            document.write(a+b);        }        &#x2F;&#x2F; fun(3,4); &#x2F;&#x2F; 7        var fun2 = function (a,b) {            document.write(a+b);        }        document.write(fun2.length); &#x2F;&#x2F; 2        fun2(3) &#x2F;&#x2F; NaN,原因b是undefined        &#x2F;*            定义一个求和函数         *&#x2F;        function add() {            var sum = 0;            for (i=0;i&lt;arguments.length;i++){                sum+=arguments[i];            }            return sum;        }        document.write(add(1,2,3,4,5)); &#x2F;&#x2F; 15    &lt;&#x2F;script&gt;</code></pre><h3 id="3-2-Array：数组对象"><a href="#3-2-Array：数组对象" class="headerlink" title="3.2 Array：数组对象"></a>3.2 Array：数组对象</h3><h4 id="3-2-1-创建"><a href="#3-2-1-创建" class="headerlink" title="3.2.1 创建"></a>3.2.1 创建</h4><ol><li><code>var arr = new Array(元素列表);</code></li><li><code>var arr = new Array(默认长度);</code></li><li><code>var arr = [元素列表];</code></li></ol><h4 id="3-2-2-方法"><a href="#3-2-2-方法" class="headerlink" title="3.2.2 方法"></a>3.2.2 方法</h4><ol><li><code>join(参数)</code>：将数组中的元素按照指定的分隔符拼接为字符串</li><li><code>push()</code>：向数组的末尾添加一个或更多元素，并返回新的长度。</li></ol><h4 id="3-2-3-属性"><a href="#3-2-3-属性" class="headerlink" title="3.2.3 属性"></a>3.2.3 属性</h4><p><code>length</code>：数组长度</p><h4 id="3-2-4-特点"><a href="#3-2-4-特点" class="headerlink" title="3.2.4 特点"></a>3.2.4 特点</h4><ol><li>在JS中，数组可以存储不同的类型元素</li><li>JS中，数组长度是可变的。</li></ol><h4 id="3-2-5-示例"><a href="#3-2-5-示例" class="headerlink" title="3.2.5 示例"></a>3.2.5 示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">var arr1 = new Array(1,2,3);var arr2 = new Array(5);var arr3 = [1,&quot;abc&quot;,true]; &#x2F;&#x2F; 数组可以存储不同的类型元素document.write(arr1.join(&quot;--&gt;&quot;)); &#x2F;&#x2F; 1--&gt;2--&gt;3arr1.push(4,5);document.write(arr1); &#x2F;&#x2F; 1,2,3,4,5document.write(arr2.length); &#x2F;&#x2F; 5</code></pre><h3 id="3-3-Date：日期对象"><a href="#3-3-Date：日期对象" class="headerlink" title="3.3 Date：日期对象"></a>3.3 Date：日期对象</h3><ol><li>创建：<code>var date = new Date();</code></li><li>方法：<ul><li><code>toLocaleString()</code>：返回当前date对象对应的时间本地字符串格式。</li><li><code>getTime()</code>：获取毫秒值。返回当前日期对象描述的时间到1970年1月1日零点的毫秒值差。</li></ul></li></ol><h3 id="3-4-Math：数学对象"><a href="#3-4-Math：数学对象" class="headerlink" title="3.4 Math：数学对象"></a>3.4 Math：数学对象</h3><ol><li>创建：Math对象不用创建，可以直接使用。例：<code>Math.方法名();</code></li><li>方法：<ul><li><code>random()</code>：返回0~1之间的随机数。含0不含1</li><li><code>ceil(x)</code>：对数进行上舍入(向上取整)</li><li><code>floor(x)</code>：对数进行下舍入(向下取整)</li><li><code>round(x)</code>：把数四舍五入为最接近的整数</li></ul></li><li>属性：<code>PI</code></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">document.write(Math.PI+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 3.141592653589793document.write(Math.random()+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 0.16764969291724752document.write(Math.ceil(3.14)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 4document.write(Math.floor(3.14)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 3document.write(Math.round(3.14)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 3&#x2F;&#x2F; 取一个0~100之间的随机整数var number = Math.floor(Math.random()*100+1);document.write(number);</code></pre><h3 id="3-5-RegExp：正则表达式对象"><a href="#3-5-RegExp：正则表达式对象" class="headerlink" title="3.5 RegExp：正则表达式对象"></a>3.5 RegExp：正则表达式对象</h3><ol><li>创建：<ul><li><code>var reg = new RegExp(&quot;正则表达式&quot;);</code></li><li><code>var reg = /正则表达式/;</code></li></ul></li><li>方法：test(参数)：验证指定的字符串是否符合正则定义的规范</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">var reg1 = new RegExp(&quot;\\d&quot;);var reg2 = &#x2F;[a-z]&#x2F;;document.write(reg1.test(&quot;a&quot;)); &#x2F;&#x2F; falsedocument.write(reg1.test(2)); &#x2F;&#x2F; truedocument.write(reg2.test(&quot;b&quot;)); &#x2F;&#x2F; true</code></pre><h3 id="3-6-Global"><a href="#3-6-Global" class="headerlink" title="3.6 Global"></a>3.6 Global</h3><h4 id="3-6-1-特点"><a href="#3-6-1-特点" class="headerlink" title="3.6.1 特点"></a>3.6.1 特点</h4><p>全局对象，这个Global中封装的方法不需要对象就可以直接调用。例：<code>方法名();</code></p><h4 id="3-6-2-方法"><a href="#3-6-2-方法" class="headerlink" title="3.6.2 方法"></a>3.6.2 方法</h4><ul><li><code>encodeURI()</code>：url编码</li><li><code>encodeURI()</code>：url编码</li><li><code>encodeURIComponent()</code>：url编码，能编码的字符更多</li><li><code>decodeURIComponent()</code>：url解码</li><li><code>parseInt()</code>：将字符串转为数字。逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number类型。</li><li><code>isNaN()</code>：判断一个值是否是NaN。NaN参与的==比较全部为false。</li><li><code>eval()</code>：将可执行的<code>JavaScript</code>字符串转换为JS脚本来执行。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-javascript">var str = &quot;零度科技&quot;; &#x2F;&#x2F; UTF8编码转换中文，一个中文代表3个字节,即&#39;零= %E9%9B%B6&#39;var encode = encodeURI(str);document.write(encode); &#x2F;&#x2F; %E9%9B%B6%E5%BA%A6%E7%A7%91%E6%8A%80document.write(decodeURI(encode)); &#x2F;&#x2F; 零度科技var number = &quot;123木头人321&quot;;document.write(parseInt(number)); &#x2F;&#x2F; 123var a = NaN;document.write(isNaN(number)); &#x2F;&#x2F; falsedocument.write(isNaN(a)); &#x2F;&#x2F; truevar b = &quot;alert(123)&quot;;eval(b); &#x2F;&#x2F; 将会执行alert(123)这段js代码，在浏览器弹出123</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS基础</title>
      <link href="/JavaWeb/cssBasic.html"/>
      <url>/JavaWeb/cssBasic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-CSS基础"><a href="#1-CSS基础" class="headerlink" title="1. CSS基础"></a>1. CSS基础</h2><p>概念：Cascading Style Sheets(层叠样式表)。功能强大，可以将内容展示和样式控制分离。</p><blockquote><p>层叠：多个样式可以作用在用一个html的元素上，同时生效</p></blockquote><a id="more"></a><h3 id="1-1-CSS的使用：CSS与HTML结合方式"><a href="#1-1-CSS的使用：CSS与HTML结合方式" class="headerlink" title="1.1 CSS的使用：CSS与HTML结合方式"></a>1.1 CSS的使用：CSS与HTML结合方式</h3><ol><li>内联样式：在标签内使用<code>style</code>属性指定css代码，例<code>&lt;div style=&quot;color:red;&quot;&gt;this is css style&lt;/div&gt;</code></li><li><p>内部样式：在head标签内，定义style标签，style标签体内容就是css代码</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;style&gt;    div{        color:blue;    }&lt;&#x2F;style&gt;&lt;div&gt;    this is inner style&lt;&#x2F;div&gt;</code></pre></li><li><p>外部样式：定义css资源文件，在head标签内，定义link标签，引入外部的资源文件。</p></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">1. 新建一个a.css的文件，内容如下div{color:red;}2. head标签内使用link标签引入&lt;head&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css&#x2F;a.css&quot;&gt;&lt;&#x2F;head&gt;&lt;div&gt; this is outer style&lt;&#x2F;div&gt;</code></pre><h2 id="2-CSS语法"><a href="#2-CSS语法" class="headerlink" title="2. CSS语法"></a>2. CSS语法</h2><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">格式如下：选择器{属性名1：属性值1;属性名2：属性值2;....}</code></pre><ul><li>选择器：筛选具有相似特征的元素</li></ul><blockquote><p>Notice：每一对属性需要使用;分隔开，最后一对属性可以不加;</p></blockquote><h2 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3. 选择器"></a>3. 选择器</h2><p>分类有：基础选择器和扩展选择器</p><h3 id="3-1-基础选择器"><a href="#3-1-基础选择器" class="headerlink" title="3.1 基础选择器"></a>3.1 基础选择器</h3><h4 id="3-1-1-ID选择器"><a href="#3-1-1-ID选择器" class="headerlink" title="3.1.1 ID选择器"></a>3.1.1 ID选择器</h4><p>选择具体的id属性值的元素，建议在一个html页面中id值唯一</p><ul><li>语法：<code>#id属性值{css}</code></li></ul><h4 id="3-1-2-元素选择器"><a href="#3-1-2-元素选择器" class="headerlink" title="3.1.2 元素选择器"></a>3.1.2 元素选择器</h4><p>选择具有相同标签名称的元素</p><ul><li><p>语法：<code>标签名称{css}</code></p></li><li><p>注意：id选择器优先级高于元素选择器</p></li></ul><h4 id="3-1-3-类选择器"><a href="#3-1-3-类选择器" class="headerlink" title="3.1.3 类选择器"></a>3.1.3 类选择器</h4><p>选择具有相同的class属性值的元素</p><ul><li>语法：<code>.class属性值{css}</code></li><li>注意：类选择器优先级高于元素选择器</li></ul><h3 id="3-2-扩展选择器"><a href="#3-2-扩展选择器" class="headerlink" title="3.2 扩展选择器"></a>3.2 扩展选择器</h3><h4 id="3-2-1-选择所有元素"><a href="#3-2-1-选择所有元素" class="headerlink" title="3.2.1 选择所有元素"></a>3.2.1 选择所有元素</h4><ul><li>语法： <code>*{}</code></li></ul><h4 id="3-2-2-并集选择器"><a href="#3-2-2-并集选择器" class="headerlink" title="3.2.2 并集选择器"></a>3.2.2 并集选择器</h4><ul><li>语法：<code>选择器1,选择器2{}</code></li></ul><h4 id="3-2-3-子选择器"><a href="#3-2-3-子选择器" class="headerlink" title="3.2.3 子选择器"></a>3.2.3 子选择器</h4><p>筛选选择器1元素下的选择器2元素</p><ul><li>语法：<code>选择器1 选择器2{}</code></li></ul><h4 id="3-2-4-父选择器"><a href="#3-2-4-父选择器" class="headerlink" title="3.2.4 父选择器"></a>3.2.4 父选择器</h4><p>筛选选择器2的父元素选择器1</p><ul><li>语法：<code>选择器1&gt;选择器2{}</code></li></ul><h4 id="3-2-5-属性选择器"><a href="#3-2-5-属性选择器" class="headerlink" title="3.2.5 属性选择器"></a>3.2.5 属性选择器</h4><p>选择元素名称，属性名=属性值的元素</p><ul><li>语法：<code>元素名称[属性名=“属性值”]{}</code></li></ul><h4 id="3-2-6-伪类选择器"><a href="#3-2-6-伪类选择器" class="headerlink" title="3.2.6 伪类选择器"></a>3.2.6 伪类选择器</h4><p>选择一些元素具体的状态</p><ul><li>语法：<code>元素:状态{}</code></li><li>例：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;a&gt;&lt;&#x2F;a&gt;标签状态有：1. link：初始化的状态2. visited：被访问过的状态3. active：正在访问状态4. hover：鼠标悬浮状态</code></pre><h2 id="4-属性"><a href="#4-属性" class="headerlink" title="4. 属性"></a>4. 属性</h2><h3 id="4-1-字体、文本"><a href="#4-1-字体、文本" class="headerlink" title="4.1 字体、文本"></a>4.1 字体、文本</h3><ol><li><code>font-size</code>：字体大小</li><li><code>color</code>：文本颜色</li><li><code>text-align</code>：对齐方式</li><li><code>line-heigh</code>t：行高</li></ol><h3 id="4-2背景"><a href="#4-2背景" class="headerlink" title="4.2背景"></a>4.2背景</h3><ul><li><code>background</code></li></ul><h3 id="4-3-边框"><a href="#4-3-边框" class="headerlink" title="4.3 边框"></a>4.3 边框</h3><ul><li><code>border</code>：设置边框，符合属性</li></ul><h3 id="4-4-尺寸"><a href="#4-4-尺寸" class="headerlink" title="4.4 尺寸"></a>4.4 尺寸</h3><ul><li><code>width</code>：宽度</li><li><code>height</code>：高度</li></ul><h3 id="4-5-盒子模型"><a href="#4-5-盒子模型" class="headerlink" title="4.5 盒子模型"></a>4.5 盒子模型</h3><p>主要用于控制布局</p><ul><li><code>margin</code>：外边距</li><li><code>padding</code>：内边距<ul><li>默认情况下内边距会影响整个盒子的大小</li><li><code>box-sizing: border-box;</code>，设置盒子的属性，让<code>width</code>和<code>height</code>就是最终盒子的大小</li></ul></li><li><code>float</code>：浮动<ul><li><code>float: left;</code> 左浮动</li><li><code>float: right;</code> 右浮动</li></ul></li></ul><h2 id="5-综合案例"><a href="#5-综合案例" class="headerlink" title="5. 综合案例"></a>5. 综合案例</h2><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;注册页面&lt;&#x2F;title&gt;    &lt;style&gt;        *{            margin: 0px; &#x2F;*外边距*&#x2F;            padding: 0px;&#x2F;*内边距*&#x2F;            box-sizing: border-box;        }        body{            background: url(&quot;img&#x2F;register_bg.png&quot;) no-repeat center;&#x2F;*背景图居中*&#x2F;        }        .rg_foreign{            width: 900px;            height: 500px;            border: 8px solid #EEEEEE;&#x2F;*边框颜色*&#x2F;            background-color: white;&#x2F;*背景色白色*&#x2F;            &#x2F;*div水平居中*&#x2F;            margin: auto;            margin-top: 15px; &#x2F;*外上边距*&#x2F;        }        .rg_left{            float: left;            margin: 15px;        }        .rg_left &gt; p:first-child{            color: #FFD026;            font-size: 22px;        }        .rg_left &gt; p:last-child{            color: #A6A6A6;            font-size: 22px;        }        .rg_center{            float: left;            width: 450px;        }        .rg_right{            float: right;            margin: 15px;        }        .rg_right p{            font-size: 15px;        }        .rg_right p a{            color: pink;        }        .td_left{            width: 100px;            text-align: right;            height: 45px;        }        .td_right{            padding-left: 35px;        }        #uname,#password,#email,#name,#tel,#birthday,#checked{            width: 250px;            height: 32px;            border: 1px solid #A6A6A6;            &#x2F;*设置边框圆角*&#x2F;            border-radius: 5px;            padding-left: 10px;        }        #checked{            width: 110px;        }        #img_check{            height: 32px;            vertical-align: middle; &#x2F;*设置垂直居中*&#x2F;        }        #btn_submit{           width: 150px;            height: 40px;            background-color: #FFD026;            border: 1px solid #FFD026;        }    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class=&quot;rg_foreign&quot;&gt;    &lt;div class=&quot;rg_left&quot;&gt;        &lt;p&gt;新用户注册&lt;&#x2F;p&gt;        &lt;p&gt;USER REGISTER&lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;    &lt;div class=&quot;rg_center&quot;&gt;        &lt;div class=&quot;rg_form&quot;&gt;            &lt;form action=&quot;.&#x2F;login.html&quot; method=&quot;post&quot;&gt;                &lt;table&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;uname&quot;&gt;用户名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;uname&quot; id=&quot;uname&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入真实姓名&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;性别&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;                            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked&gt;男                            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt;女                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checked&quot;&gt;验证码&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td class=&quot;td_right&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;checked&quot; id=&quot;checked&quot; placeholder=&quot;请输入验证码&quot;&gt;                            &lt;img src=&quot;img&#x2F;verify_code.jpg&quot; alt=&quot;&quot; id=&quot;img_check&quot;&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_submit&quot; value=&quot;注册&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                &lt;&#x2F;table&gt;            &lt;&#x2F;form&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;div class=&quot;rg_right&quot;&gt;        &lt;p&gt;已有账号? &lt;a href=&quot;#&quot;&gt;立即登录&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础</title>
      <link href="/JavaWeb/html.html"/>
      <url>/JavaWeb/html.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Web概述"><a href="#1-Web概述" class="headerlink" title="1. Web概述"></a>1. Web概述</h2><h3 id="1-1-软件架构"><a href="#1-1-软件架构" class="headerlink" title="1.1 软件架构"></a>1.1 软件架构</h3><p>主要有如下两种架构</p><ol><li>C/S：Client/Server 客户端/服务器端</li><li>B/S：Browser/Server 浏览器/服务器端</li></ol><a id="more"></a><h3 id="1-2-资源分类"><a href="#1-2-资源分类" class="headerlink" title="1.2 资源分类"></a>1.2 资源分类</h3><h4 id="1-2-1-静态资源"><a href="#1-2-1-静态资源" class="headerlink" title="1.2.1 静态资源"></a>1.2.1 静态资源</h4><p>使用静态网页开发技术发布的资源，特点如下：</p><ul><li>所有用户访问，得到的结果是一样的，如：文本、图片、音视频等资源</li><li>静态网页开发技术：<code>HTML、CSS、JavaScript</code></li><li>如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</li></ul><table><thead><tr><th>名称</th><th>作用概述</th></tr></thead><tbody><tr><td>HTML</td><td>用于搭建基础网页，展示页面的内容</td></tr><tr><td>CSS</td><td>用于美化页面，布局页面</td></tr><tr><td>JavaScript</td><td>控制页面的元素，让页面有一些动态的效果</td></tr></tbody></table><h4 id="1-2-2-动态资源"><a href="#1-2-2-动态资源" class="headerlink" title="1.2.2 动态资源"></a>1.2.2 动态资源</h4><p>使用动态网页及时发布的资源，特点：</p><ul><li>所有用户访问，得到的结果可能不一样</li><li>动态网页开发技术：<code>jsp/servlet，php,asp</code>等</li><li>如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器</li></ul><h2 id="2-HTML"><a href="#2-HTML" class="headerlink" title="2. HTML"></a>2. HTML</h2><p>html是最基础的网页开发语言</p><ul><li><code>Hyper Text Markup Language</code>(超文本标记语言)<ul><li>超文本：是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本</li><li>标记语言：由标签构成的语言。&lt;标签名称&gt; 如 html，xml</li></ul></li></ul><blockquote><p>Notice：标记语言不是编程语言</p></blockquote><h3 id="2-1-快速入门"><a href="#2-1-快速入门" class="headerlink" title="2.1 快速入门"></a>2.1 快速入门</h3><h4 id="2-1-1-语法"><a href="#2-1-1-语法" class="headerlink" title="2.1.1 语法"></a>2.1.1 语法</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-tex">1. html文档后缀名 .html 或者 .htm2. 标签分为：围堵标签(&lt;html&gt;&lt;&#x2F;html&gt;)和自闭标签(&lt;link&#x2F;&gt;)3. 标签可以嵌套：例&lt;a&gt;&lt;b&gt;&lt;&#x2F;b&gt;&lt;&#x2F;a&gt;4. 在开始标签中可以定义属性。属性是由键值对构成，值需用单双引号引起来。5. html的标签不区分大小写，但建议使用小写</code></pre><h4 id="特殊字符表"><a href="#特殊字符表" class="headerlink" title="特殊字符表"></a>特殊字符表</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/26/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%A1%A8-1558883012702.png" alt="特殊字符表"></p><h3 id="2-2-标签"><a href="#2-2-标签" class="headerlink" title="2.2 标签"></a>2.2 标签</h3><h4 id="2-2-1-文件标签：构成html最基本的标签"><a href="#2-2-1-文件标签：构成html最基本的标签" class="headerlink" title="2.2.1 文件标签：构成html最基本的标签"></a>2.2.1 文件标签：构成html最基本的标签</h4><table><thead><tr><th>标签类型</th><th>标签名称</th><th>标签作用</th></tr></thead><tbody><tr><td>根标签</td><td><code>html</code></td><td>html文档的根标签</td></tr><tr><td>头标签</td><td><code>head</code></td><td>用于指导html文档的一些属性，引入外部的资源</td></tr><tr><td>标题标签</td><td><code>title</code></td><td>该页面标题</td></tr><tr><td>体标签</td><td><code>body</code></td><td>写主体内容</td></tr><tr><td>注解标签</td><td><code>&lt;!DOCTYPE html&gt;</code></td><td>html5中定义该文档是html文档</td></tr></tbody></table><h4 id="2-2-2-文本标签：和文本有关的标签"><a href="#2-2-2-文本标签：和文本有关的标签" class="headerlink" title="2.2.2 文本标签：和文本有关的标签"></a>2.2.2 文本标签：和文本有关的标签</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">1. 注释：&lt;!-- 注释内容 --&gt;2. &lt;h1&gt; to &lt;h6&gt; ：标题标签3. &lt;p&gt;：段落标签4. &lt;br&gt;：换行标签5. &lt;hr&gt;：水平线属性：- color：颜色- width：宽度- size：高度- align：对其方式1. center：居中2. left：左对齐3. right：右对齐6. &lt;b&gt;：字体加粗7. &lt;i&gt;：字体斜体8. &lt;font&gt;：字体标签9. &lt;center&gt;：文本居中属性：- color：颜色- size：大小- face：字体10. 属性定义：- color：1. 可以使用颜色的英文单词：red、green、blue2. rgb(值1，值2，值3)：值的范围：0~255,。例：rgb(0,0,255)3. #值1值2值3：值的范围00~FF之间。例：#FF00FF- width：1. 数值：width=&#39;20&#39;，数值的单位，默认是px(像素)2. 数值%：占比相对于父元素的比例</code></pre><h4 id="2-2-3-图片标签：img展示图片，属性：src-指定图片的位置"><a href="#2-2-3-图片标签：img展示图片，属性：src-指定图片的位置" class="headerlink" title="2.2.3 图片标签：img展示图片，属性：src(指定图片的位置)"></a>2.2.3 图片标签：<code>img展示图片，属性：src(指定图片的位置)</code></h4><h4 id="2-2-4-列表标签：有序列表-ol，li-和无序列表-ul，li"><a href="#2-2-4-列表标签：有序列表-ol，li-和无序列表-ul，li" class="headerlink" title="2.2.4 列表标签：有序列表(ol，li)和无序列表(ul，li)"></a>2.2.4 列表标签：有序列表<code>(ol，li)</code>和无序列表<code>(ul，li)</code></h4><h4 id="2-2-5-链接标签"><a href="#2-2-5-链接标签" class="headerlink" title="2.2.5 链接标签"></a>2.2.5 链接标签</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">a标签：定义一个超链接属性：1. href：指定访问资源的URL2. target：指定打开资源的方式(_self:默认值，在当前页面打开；_blank:在新页面打开)</code></pre><h4 id="2-2-6-div和span"><a href="#2-2-6-div和span" class="headerlink" title="2.2.6 div和span"></a>2.2.6 div和span</h4><table><thead><tr><th>类型</th><th>标签名称</th><th>作用</th></tr></thead><tbody><tr><td>块级标签</td><td>div</td><td>每一个div占满一整行</td></tr><tr><td>行内标签</td><td>span</td><td>文本信息在一行展示</td></tr></tbody></table><h4 id="2-2-7-语义化标签：html5中为了提高程序的可读性，提供了一些标签。分别是页眉-lt-header-gt-和页脚-lt-footer-gt"><a href="#2-2-7-语义化标签：html5中为了提高程序的可读性，提供了一些标签。分别是页眉-lt-header-gt-和页脚-lt-footer-gt" class="headerlink" title="2.2.7 语义化标签：html5中为了提高程序的可读性，提供了一些标签。分别是页眉&lt;header&gt;和页脚&lt;footer&gt;"></a>2.2.7 语义化标签：html5中为了提高程序的可读性，提供了一些标签。分别是页眉<code>&lt;header&gt;</code>和页脚<code>&lt;footer&gt;</code></h4><h4 id="2-2-8-表格标签"><a href="#2-2-8-表格标签" class="headerlink" title="2.2.8 表格标签"></a>2.2.8 表格标签</h4><table><thead><tr><th>标签名称</th><th>标签作用</th><th>标签属性</th></tr></thead><tbody><tr><td>table</td><td>定义表格</td><td><code>width：宽度、border：边框、cellpadding：定义内容和单元格的距离、cellspacing：定义单元格之间的距离。如为0,则单元格的线会合为一条、bgcolor：背景色、align：对齐方式</code></td></tr><tr><td>tr</td><td>定义行</td><td><code>bgcolor：背景色、align：对齐方式</code></td></tr><tr><td>td</td><td>定义单元格</td><td><code>colspan：合并列、rowspan：合并行</code></td></tr><tr><td><code>&lt;caption&gt;</code></td><td>表格标题</td><td>\</td></tr><tr><td><code>&lt;thead&gt;</code></td><td>表示表格的头部分</td><td>\</td></tr><tr><td><code>&lt;tbody&gt;</code></td><td>表示表格的体部分</td><td>\</td></tr><tr><td><code>&lt;tfoot&gt;</code></td><td>表示表格的脚部分</td><td>\</td></tr></tbody></table><p><strong>演示</strong>：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;表格标签&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;table border=&quot;1&quot; width=&quot;50%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; bgcolor=&quot;#faebd7&quot; align=&quot;center&quot;&gt;        &lt;tr&gt;           &lt;!-- &lt;td&gt;编号&lt;&#x2F;td&gt;            &lt;td&gt;姓名&lt;&#x2F;td&gt;            &lt;td&gt;成绩&lt;&#x2F;td&gt;--&gt;            &lt;th&gt;编号&lt;&#x2F;th&gt;            &lt;th&gt;姓名&lt;&#x2F;th&gt;            &lt;th&gt;成绩&lt;&#x2F;th&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;1&lt;&#x2F;td&gt;            &lt;td&gt;小龙女&lt;&#x2F;td&gt;            &lt;td&gt;100&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;2&lt;&#x2F;td&gt;            &lt;td&gt;杨过&lt;&#x2F;td&gt;            &lt;td&gt;50&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;table&gt;    &lt;hr&gt;    &lt;table border=&quot;1&quot; width=&quot;50%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; bgcolor=&quot;#faebd7&quot; align=&quot;center&quot;&gt;        &lt;thead&gt;            &lt;caption&gt;学生信息表&lt;&#x2F;caption&gt;            &lt;tr&gt;                &lt;!-- &lt;td&gt;编号&lt;&#x2F;td&gt;                 &lt;td&gt;姓名&lt;&#x2F;td&gt;                 &lt;td&gt;成绩&lt;&#x2F;td&gt;--&gt;                &lt;th&gt;编号&lt;&#x2F;th&gt;                &lt;th&gt;姓名&lt;&#x2F;th&gt;                &lt;th&gt;成绩&lt;&#x2F;th&gt;            &lt;&#x2F;tr&gt;        &lt;&#x2F;thead&gt;        &lt;tbody&gt;            &lt;tr bgcolor=&quot;#7fffd4&quot; align=&quot;center&quot;&gt;                &lt;td&gt;1&lt;&#x2F;td&gt;                &lt;td&gt;小龙女&lt;&#x2F;td&gt;                &lt;td&gt;100&lt;&#x2F;td&gt;            &lt;&#x2F;tr&gt;            &lt;tr&gt;                &lt;td&gt;2&lt;&#x2F;td&gt;                &lt;td&gt;杨过&lt;&#x2F;td&gt;                &lt;td&gt;50&lt;&#x2F;td&gt;            &lt;&#x2F;tr&gt;        &lt;&#x2F;tbody&gt;        &lt;tfoot&gt;            &lt;tr&gt;                &lt;td&gt;3&lt;&#x2F;td&gt;                &lt;td&gt;尹志平&lt;&#x2F;td&gt;                &lt;td&gt;10&lt;&#x2F;td&gt;            &lt;&#x2F;tr&gt;        &lt;&#x2F;tfoot&gt;    &lt;&#x2F;table&gt;    &lt;hr&gt;    &lt;table border=&quot;1&quot; width=&quot;50%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; bgcolor=&quot;#faebd7&quot; align=&quot;center&quot;&gt;        &lt;tr&gt;            &lt;th rowspan=&quot;2&quot;&gt;编号&lt;&#x2F;th&gt;            &lt;th&gt;姓名&lt;&#x2F;th&gt;            &lt;th&gt;成绩&lt;&#x2F;th&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;小龙女&lt;&#x2F;td&gt;            &lt;td&gt;100&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;2&lt;&#x2F;td&gt;            &lt;td colspan=&quot;2&quot;&gt;杨过&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;table&gt;    &lt;hr&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></p><h4 id="2-2-9-表单标签"><a href="#2-2-9-表单标签" class="headerlink" title="2.2.9 表单标签"></a>2.2.9 表单标签</h4><p>用于采集用户输入的数据，和服务进行交互</p><ul><li>form：用于定义表单的，可以定义一个范围(代表采集用户数据的范围)，属性如下：<ul><li>action：指定提交数据的URL</li><li>method：指定提交方式。主要使用<code>get</code>和<code>post</code></li></ul></li></ul><blockquote><p>Tips：表单项中的数据要想被提交，必须指定其name属性</p></blockquote><ul><li>表单项标签<code>input</code>。可以通过type属性值，改变元素展示的样式</li></ul><h5 id="type属性："><a href="#type属性：" class="headerlink" title="type属性："></a>type属性：</h5><ol><li>text：文本输入框，可使用<code>placeholder</code>属性，指定输入框的提示信息</li><li>password：密码输入框</li><li>radio：单选框</li><li>checkbox：复选框</li><li>file：文件选择框</li><li>hidden：隐藏域</li><li>submit：提交按钮，可以提交表单</li><li>button：普通按钮</li><li>image：图片提交按钮，src属性指定图片的路径</li></ol><h5 id="label：指定输入项的文字描述信息"><a href="#label：指定输入项的文字描述信息" class="headerlink" title="label：指定输入项的文字描述信息"></a>label：指定输入项的文字描述信息</h5><ul><li>select：下拉列表。子元素：option，指定列表项</li><li>textarea：文本域<ul><li>cols：指定列数，每一行有多少个字符</li><li>rows：默认多少行</li></ul></li></ul><h4 id="2-3-综合案例演示"><a href="#2-3-综合案例演示" class="headerlink" title="2.3 综合案例演示"></a>2.3 综合案例演示</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;旅游网&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;!--采用table来完成布局--&gt;    &lt;!--最外层的table，用于整个页面的布局--&gt;    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;        &lt;!--第1行--&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;img src=&quot;image&#x2F;top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;!--第2行--&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                    &lt;tr&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;logo.jpg&quot; alt=&quot;&quot;&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;search.png&quot; alt=&quot;&quot;&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;hotel_tel.png&quot; alt=&quot;&quot;&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                &lt;&#x2F;table&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;!--第3行--&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                    &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; heigth=&quot;45&quot;&gt;                        &lt;td&gt;                            &lt;a href=&quot;&quot;&gt;首页&lt;&#x2F;a&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            门票                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            酒店                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            香港车票                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            出境游                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            国内游                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            港澳游                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            抱团定制                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            全球自由行                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            收藏排行榜                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                &lt;&#x2F;table&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;!--第4行--&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;img src=&quot;image&#x2F;banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;!--第5行:旅游精选--&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;img src=&quot;image&#x2F;icon_5.jpg&quot; alt=&quot;&quot;&gt;                旅游精选                &lt;hr color=&quot;#ffd700&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;!--第6行--&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                    &lt;tr&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;&#x2F;font&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;&#x2F;font&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;&#x2F;font&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;&#x2F;font&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                &lt;&#x2F;table&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;!--第7行：国内游--&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;img src=&quot;image&#x2F;icon_6.jpg&quot; alt=&quot;&quot;&gt;                国内游                &lt;hr color=&quot;#ffd700&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;!--第8行--&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                    &lt;tr&gt;                        &lt;td rowspan=&quot;2&quot;&gt;                            &lt;img src=&quot;image&#x2F;guonei_1.jpg&quot; alt=&quot;&quot;&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt;                        &lt;&#x2F;td&gt;                        &lt;td&gt;                            &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                            &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt;                            &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt;                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                &lt;&#x2F;table&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;!--第9行:境外游--&gt;        &lt;!--第10行--&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;img src=&quot;image&#x2F;footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;!--第11行--&gt;        &lt;tr&gt;            &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt;                &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                    浙江零度科技有限公司                    版权所有 Copyright 2022-2030&amp;copy; All Right Reserved                &lt;&#x2F;font&gt;            &lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC连接池</title>
      <link href="/JavaWeb/JDBCPool.html"/>
      <url>/JavaWeb/JDBCPool.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-数据库连接池"><a href="#1-数据库连接池" class="headerlink" title="1. 数据库连接池"></a>1. 数据库连接池</h2><p>其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象。当用户来访问数据库时，从容器中获取连接对象，用户访问完后，会将连接对象归还给容器。</p><a id="more"></a><h3 id="1-1-好处"><a href="#1-1-好处" class="headerlink" title="1.1 好处"></a>1.1 好处</h3><ol><li>节约资源</li><li>用户访问高效</li></ol><h3 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a>1.2 实现</h3><p>标准接口：<code>DataSource</code> ，<code>javax.sql</code>包下的，主要方法如下：</p><ol><li>获取连接：<code>getConnection()</code></li><li>归还连接：<code>close()</code>。 如果连接对象Connection是从连接池中获取的，那么调用<code>close()</code>方法，则不会关闭连接，而是归还连接。</li></ol><p>一般我们不去实现它，有数据库厂商来实现</p><ol><li>C3P0：数据库连接池技术</li><li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li></ol><h2 id="2-C3P0数据库连接池技术"><a href="#2-C3P0数据库连接池技术" class="headerlink" title="2. C3P0数据库连接池技术"></a>2. C3P0数据库连接池技术</h2><h3 id="2-1-导入Jar包"><a href="#2-1-导入Jar包" class="headerlink" title="2.1 导入Jar包"></a>2.1 导入Jar包</h3><p><a href="https://sourceforge.net/projects/c3p0/" target="_blank" rel="noopener">官方下载地址</a></p><p>下载完后解压，然后导入两个包：<code>c3p0-0.9.5.2.jar</code>和<code>mchange-commons-java-0.2.12.jar</code></p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/25/c3p0-1558796235077.jpg" alt="c3p0"></p><blockquote><p>Notice：不要忘记导入数据库驱动Jar包</p></blockquote><h3 id="2-2-定义配置文件"><a href="#2-2-定义配置文件" class="headerlink" title="2.2 定义配置文件"></a>2.2 定义配置文件</h3><ul><li>名称：<code>c3p0.properties</code>或者<code>c3p0-config.xml</code></li><li>路径：将文件放在src目录下即可。</li></ul><h3 id="2-3-创建核心对象"><a href="#2-3-创建核心对象" class="headerlink" title="2.3 创建核心对象"></a>2.3 创建核心对象</h3><ul><li>数据库连接池对象：<code>ComboPooledDataSource</code></li><li>基本使用如下：</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class C3P0Demo1 {    public static void main(String[] args) throws SQLException {        &#x2F;&#x2F; 1. 创建数据库连接池对象        ComboPooledDataSource dataSource = new ComboPooledDataSource();        &#x2F;&#x2F; 2. 获取一个连接对象        Connection conn = dataSource.getConnection();        &#x2F;&#x2F; 3. 进行具体操作        System.out.println(conn);    }}</code></pre><h2 id="3-Druid：数据库连接池实现技术"><a href="#3-Druid：数据库连接池实现技术" class="headerlink" title="3. Druid：数据库连接池实现技术"></a>3. Druid：数据库连接池实现技术</h2><h3 id="3-1-使用步骤"><a href="#3-1-使用步骤" class="headerlink" title="3.1 使用步骤"></a>3.1 使用步骤</h3><ol><li>导入jar包：<code>druid-1.0.9.jar</code></li><li>定义配置文件：<code>properties</code>形式的，可以叫任意名称，可以放任意目录下</li><li>加载配置文件：使用<code>Properties</code>对象来加载</li><li>获取数据库连接池对象：通过工厂类<code>DruidDataSourceFactory</code>来获取</li><li>获取连接：<code>getConnection</code></li></ol><h3 id="3-2-基本使用示例"><a href="#3-2-基本使用示例" class="headerlink" title="3.2 基本使用示例"></a>3.2 基本使用示例</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; Druid演示public class DruidDemo1 {    public static void main(String[] args) throws Exception {        &#x2F;&#x2F; 1. 定义配置文件        &#x2F;&#x2F; 2. 加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        &#x2F;&#x2F; 3. 获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        &#x2F;&#x2F; 4. 获取连接        Connection conn = ds.getConnection();        &#x2F;&#x2F; 5. 进行具体操作        System.out.println(conn);    }}</code></pre><h3 id="3-3-定义工具类"><a href="#3-3-定义工具类" class="headerlink" title="3.3 定义工具类"></a>3.3 定义工具类</h3><ol><li>定义一个类</li><li>提供静态代码块加载配置文件，初始化连接池对象</li><li>提供方法<ol><li>获取连接方法：通过数据库连接池获取连接</li><li>释放资源</li><li>获取连接池的方法</li></ol></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; Druid连接池的工具类public class DruidUtils {    &#x2F;&#x2F; 1. 定义成员变量    private static DataSource ds;    &#x2F;&#x2F; 静态初始化代码块    static{        try {            Properties pro = new Properties();            pro.load(DruidUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));            &#x2F;&#x2F; 获取DataSource对象            ds = DruidDataSourceFactory.createDataSource(pro);        } catch (Exception e) {            e.printStackTrace();        }    }    &#x2F;&#x2F; 获取连接    public static Connection getConnection() throws SQLException {        return ds.getConnection();    }    &#x2F;&#x2F; 释放资源    public static void close(Statement stmt,Connection conn){        close(null,stmt,conn);    }    public static void close(ResultSet rs, Statement stmt, Connection conn){        if (rs!=null){            try {                rs.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if (stmt!=null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if (conn!=null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }    &#x2F;&#x2F; 获取连接池方法    public static DataSource getDataSource(){        return ds;    }}&#x2F;&#x2F; 测试工具类&#x2F;&#x2F; 使用工具类public class DruidDemo2 {    public static void main(String[] args) {        &#x2F;&#x2F; 完成添加操作，给account表添加一条记录        Connection conn = null;        PreparedStatement pstmt = null;        try {            &#x2F;&#x2F; 获取连接池对象            conn = DruidUtils.getConnection();            &#x2F;&#x2F; 定义sql            String sql = &quot;insert into account values(null,?,?)&quot;;            &#x2F;&#x2F; 获取执行sql对象            pstmt = conn.prepareStatement(sql);            &#x2F;&#x2F; 给？赋值            pstmt.setString(1,&quot;小六&quot;);            pstmt.setDouble(2,2699);            &#x2F;&#x2F; 执行sql            int count = pstmt.executeUpdate();            System.out.println(count);        } catch (SQLException e) {            e.printStackTrace();        }finally {            DruidUtils.close(pstmt,conn);        }    }}</code></pre><h2 id="4-Spring-JDBC"><a href="#4-Spring-JDBC" class="headerlink" title="4. Spring JDBC"></a>4. Spring JDBC</h2><p>是Spring框架对JDBC的简单封装，提供了一个JDBCTemplate对象简化JDBC的开发</p><h3 id="4-1-使用步骤"><a href="#4-1-使用步骤" class="headerlink" title="4.1 使用步骤"></a>4.1 使用步骤</h3><ol><li>导入Jar包</li><li>创建<code>JDBCTemplate</code>对象，该对象依赖于数据源<code>DataSource</code>，例：<code>JdbcTemplate template = new JdbcTemplate(ds);</code></li><li>调用<code>JDBCTemaplate</code>的方法来完成CRUD的操作</li></ol><p><strong>常用方法</strong>：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td><code>update()</code></td><td>执行DML语句。增、删、改语句</td></tr><tr><td><code>queryForMap()</code></td><td>查询结果，将结果集封装为Map集合。列名作key，值作value，将这条记录封装为一个Map集合返回。注：该方法查询结果集长度只能是1</td></tr><tr><td><code>queryForList()</code></td><td>查询结果，将结果集封装为List集合。将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</td></tr><tr><td><code>queryForObject()</code></td><td>查询结果，将结果封装为对象。一般用于聚合函数的查询</td></tr><tr><td><code>query()</code></td><td>查询结果，将结果封装为JavaBean对象。一般我们使用<code>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</code>来完成数据到JavaBean的自动封装。</td></tr></tbody></table><h3 id="4-2-使用示例"><a href="#4-2-使用示例" class="headerlink" title="4.2 使用示例"></a>4.2 使用示例</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; jdbcTemplate基础入门public class JDBCTemplateDemo1 {    public static void main(String[] args) {        &#x2F;&#x2F; 创建jdbcTemplate对象        JdbcTemplate jt = new JdbcTemplate(DruidUtils.getDataSource());        &#x2F;&#x2F; 调用方法        String sql = &quot;update account set balance=3000 where id=?&quot;;        int count = jt.update(sql, 6); &#x2F;&#x2F; 返回值是影响的行数        System.out.println(count); &#x2F;&#x2F; 1    }}</code></pre><h3 id="4-3-练习"><a href="#4-3-练习" class="headerlink" title="4.3 练习"></a>4.3 练习</h3><ol><li>修改6号数据的salary为10000</li><li>添加一条记录</li><li>删除刚刚添加的记录</li><li>查询id为8的记录，将其封装为Map集合</li><li>查询所有记录，将其封装为List</li><li>查询所有记录，将其封装为Emp对象的List集合</li><li>查询总记录数</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Exercise {        &#x2F;&#x2F; 获取JdbcTemplate对象        &#x2F;&#x2F; 使用Junit单元测试，让方法单独执行        private JdbcTemplate jt = new JdbcTemplate(DruidUtils.getDataSource());        &#x2F;&#x2F; 编写sql语句并执行        @Test        public void test1(){            &#x2F;&#x2F; 1. 修改6号数据的salary为10000            String update = &quot;update staff set salary=10000 where id=?&quot;;            jt.update(update,6);        }        @Test        public void test2(){            &#x2F;&#x2F; 2. 添加一条记录,字段分别为id，name，性别，工资，入职时间，部门id            jt.update(&quot;insert into staff(id,name,salary) values(?,?,?)&quot;,13,&quot;冬兵&quot;,7889);        }        @Test        public void test3(){            &#x2F;&#x2F; 3. 删除刚刚添加的记录            jt.update(&quot;delete from staff where name=?&quot;,&quot;冬兵&quot;);        }        @Test        public void test4(){            &#x2F;&#x2F; 4. 查询id为8的记录，将其封装为Map集合            &#x2F;&#x2F; 注意：这个方法查询的结果集只能是1            Map&lt;String, Object&gt; stringObjectMap = jt.queryForMap(&quot;select * from staff where id=?&quot;, 8);            System.out.println(stringObjectMap); &#x2F;&#x2F; {id=8, name=美队, gender=男, salary=8000.0, join_date=2008-08-08, dept_id=2}        }        @Test        public void test5(){            &#x2F;&#x2F; 5. 查询所有记录，将其封装为List            List&lt;Map&lt;String, Object&gt;&gt; maplist = jt.queryForList(&quot;select * from staff&quot;);            for (Map&lt;String, Object&gt; stringObjectMap : maplist) {                System.out.println(stringObjectMap);            }        }        @Test        public void test6(){            &#x2F;&#x2F; 6. 查询所有记录，将其封装为Emp对象的List集合，自己完成实现类            String sql = &quot;select * from staff&quot;;            List&lt;Emp&gt; list = jt.query(sql, new RowMapper&lt;Emp&gt;() {                @Override                public Emp mapRow(ResultSet rs, int i) throws SQLException {                    Emp emp = new Emp();                    int id = rs.getInt(&quot;id&quot;);                    String name = rs.getString(&quot;name&quot;);                    String gender = rs.getString(&quot;gender&quot;);                    double salary = rs.getDouble(&quot;salary&quot;);                    Date join_date = rs.getDate(&quot;join_date&quot;);                    int dept_id = rs.getInt(&quot;dept_id&quot;);                    emp.setId(id);                    emp.setName(name);                    emp.setGender(gender);                    emp.setSalary(salary);                    emp.setJoin_date(join_date);                    emp.setDept_id(dept_id);                    return emp;                }            });            for (Emp emp : list) {                System.out.println(emp);            }        }        @Test        public void test6_2() {            &#x2F;&#x2F; 6. 查询所有记录，将其封装为Emp对象的List集合,使用jdbc提供的实现类来完成            String sql = &quot;select * from staff&quot;;            List&lt;Emp&gt; list = jt.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));            for (Emp emp : list) {                System.out.println(emp);            }            &#x2F;*            Failed to convert property value of type &#39;null&#39; to required type &#39;int&#39; for property &#39;dept_id&#39;            需要将Emp类中变量改为为引用数据类型,然后重新生成方法             *&#x2F;        }        @Test        public void test7(){            &#x2F;&#x2F; 7. 查询总记录数            String sql = &quot;select count(id) from staff&quot;;            Long count = jt.queryForObject(sql, Long.class);            System.out.println(count);        }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/JavaWeb/JDBC.html"/>
      <url>/JavaWeb/JDBC.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1. JDBC"></a>1. JDBC</h2><p>Java数据库连接(Java DataBase Connectivity)，简称JDBC。是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组Java语言编写的类好接口组成。</p><a id="more"></a><h3 id="1-1-客户端操作MySQL数据库的方式"><a href="#1-1-客户端操作MySQL数据库的方式" class="headerlink" title="1.1 客户端操作MySQL数据库的方式"></a>1.1 客户端操作MySQL数据库的方式</h3><ol><li>使用第三方客户端访问：SQLyog、Navicat、SQLWave、MyDB Studio等等</li><li>使用MySQL自带的命令行方式</li><li>通过Java API来访问MySQL数据库</li></ol><h3 id="1-2-什么是JDBC"><a href="#1-2-什么是JDBC" class="headerlink" title="1.2 什么是JDBC"></a>1.2 什么是JDBC</h3><p><strong>JDBC本质</strong>：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动jar包中的实现类。</p><ul><li>使用JDBC的好处<ul><li>如果要开发访问数据库的程序，只需会调用JDBC接口中的方法即可，不用关注类具体实现</li><li>使用同一套Java代码，进行少量的修改就可以访问其他JDBC支持的数据库了</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/25/JDBC-1558754492770.jpg" alt="JDBC"></p><h3 id="1-3-使用JDBC开发使用到的包"><a href="#1-3-使用JDBC开发使用到的包" class="headerlink" title="1.3 使用JDBC开发使用到的包"></a>1.3 使用JDBC开发使用到的包</h3><table><thead><tr><th>使用的包</th><th>说明</th></tr></thead><tbody><tr><td>java.sql</td><td>所有与JDBC访问数据库相关的接口和类</td></tr><tr><td>javax.sql</td><td>数据库扩展包，提供数据库额外的功能。如连接池</td></tr><tr><td>数据库的驱动</td><td>由各大数据库厂商提供，需要额外去下载，是对JDBC接口实现的类</td></tr></tbody></table><h3 id="1-4-JDBC的核心API"><a href="#1-4-JDBC的核心API" class="headerlink" title="1.4 JDBC的核心API"></a>1.4 JDBC的核心API</h3><table><thead><tr><th>接口或类</th><th>作用</th></tr></thead><tbody><tr><td>DriverManager类</td><td>1. 管理和注册数据库驱动；2. 得到数据库连接对象</td></tr><tr><td>Connection接口</td><td>一个连接对象，可用于创建Statement和PreparedStatement对象</td></tr><tr><td>Statement接口</td><td>一个SQL语句对象，用于将SQL语句发送给数据库服务器</td></tr><tr><td>PrepareStatement接口</td><td>一个SQL语句对象，是Statement的子接口</td></tr><tr><td>ResultSet接口</td><td>用于封装数据库查询的结果集，返回给客户端Java程序</td></tr></tbody></table><h3 id="1-5-导入驱动Jar包"><a href="#1-5-导入驱动Jar包" class="headerlink" title="1.5 导入驱动Jar包"></a>1.5 导入驱动Jar包</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/25/1558669057920-1558754599644.png" alt="import_Jar"></p><h3 id="1-6-加载和注册驱动"><a href="#1-6-加载和注册驱动" class="headerlink" title="1.6 加载和注册驱动"></a>1.6 加载和注册驱动</h3><table><thead><tr><th>加载和注册驱动的方法</th><th>描述</th></tr></thead><tbody><tr><td>Class.forName(数据库驱动实现类)</td><td>加载和注册数据库驱动，数据库驱动由mysql厂商提供：”com.mysql.jdbc.Driver”</td></tr></tbody></table><blockquote><p>从JDBC3开始，弃用了驱动类“com.mysql.jdbc.Driver”，新的驱动程序类是“com.mysql.cj.jdbc.Driver”。驱动程序是通过SPI自动注册的，通常不需要手动加载驱动程序类。</p></blockquote><h2 id="2-DriverManager类"><a href="#2-DriverManager类" class="headerlink" title="2. DriverManager类"></a>2. DriverManager类</h2><p>驱动管理对象类，该类的作用是管理和注册驱动，以及创建数据库的连接。</p><blockquote><p>注：mysql5之后的驱动jar包可以省略注册驱动的步骤。</p></blockquote><h3 id="2-1-获取数据库连接"><a href="#2-1-获取数据库连接" class="headerlink" title="2.1 获取数据库连接"></a>2.1 获取数据库连接</h3><ul><li><code>Connection getConnection(String url,String user,String password)</code>：通过连接字符串，用户名，密码来得到数据库的连接对象</li><li><p><code>Connection getConnection(String url,Properties info)</code>：通过连接字符串，属性对象来得到连接对象</p></li><li><p><strong>参数说明</strong>：</p></li></ul><table><thead><tr><th>参数列表</th><th>说明</th></tr></thead><tbody><tr><td>用户名</td><td>登录的用户名</td></tr><tr><td>密码</td><td>登录的密码</td></tr><tr><td>连接字符串URL</td><td>不同的数据库URL是不同的，MySQL的写法：jdbc:mysql://localhost:3306/数据库名[?参数名=参数值]</td></tr><tr><td>驱动类的字符串名</td><td>com.mysql.cj.jdbc.Driver</td></tr></tbody></table><ul><li><strong>连接数据库URL地址格式</strong>：<code>协议名:子协议://服务器名或IP地址:端口号/数据库名?参数=参数值&amp;参数2=值2</code></li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/25/DBURL-1558754637745.jpg" alt="DBURL"></p><blockquote><p>在本地服务器的情况下：MySQL中可简写为<code>jdbc:mysql:///数据库名</code></p></blockquote><ul><li><strong>乱码问题处理</strong></li></ul><p>如果数据库出现乱码，可以指定参数：<code>?characterEncoding=utf8</code>，表示让数据库以UTF-8编码来处理数据。</p><h3 id="2-2-快速入门"><a href="#2-2-快速入门" class="headerlink" title="2.2 快速入门"></a>2.2 快速入门</h3><ol><li>使用用户名、密码、URL来得到连接对象<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo01JDBC {    public static void main(String[] args) throws Exception{        &#x2F;&#x2F; 1. 导入jar驱动包        &#x2F;&#x2F; 2.注册驱动        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); &#x2F;&#x2F; com.mysql.jdbc.Driver已弃用，且该语句jdbc3后可省略        &#x2F;&#x2F; 3. 使用用户名密码来获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db1?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;123456&quot;);        &#x2F;&#x2F; 4. 定义sql语句        String sql = &quot;update account set balance=1000 where id=1&quot;;        &#x2F;&#x2F; 5. 获取执行sql语句的对象        Statement stat = conn.createStatement();        &#x2F;&#x2F; 6. 执行sql语句        int count = stat.executeUpdate(sql);        &#x2F;&#x2F; 7. 处理结果        System.out.println(count);        &#x2F;&#x2F; 8. 释放资源        stat.close();        conn.close();    }}</code></pre></li></ol><blockquote><p>从JDBC3开始，弃用了驱动类“com.mysql.jdbc.Driver”，新的驱动程序类是“com.mysql.cj.jdbc.Driver”。驱动程序是通过SPI自动注册的，通常不需要手动加载驱动程序类。</p></blockquote><ol start="2"><li>使用属性文件和URL得到连接对象<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02JDBC {    public static void main(String[] args) throws SQLException {        &#x2F;&#x2F; 1. 定义URL连接字符串        String url = &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?serverTimezone=UTC&quot;; &#x2F;&#x2F; 本地服务器且端口号3306.故省略        &#x2F;&#x2F; 2. 创建属性对象        Properties info = new Properties();        &#x2F;&#x2F; 3. 将用户名和密码放入info对象中        info.setProperty(&quot;user&quot;,&quot;root&quot;);        info.setProperty(&quot;password&quot;,&quot;123456&quot;);        &#x2F;&#x2F; 4. 通过属性文件来获取数据库连接对象        Connection conn = DriverManager.getConnection(url, info);        System.out.println(conn); &#x2F;&#x2F; com.mysql.cj.jdbc.ConnectionImpl@51cdd8a：获取的是连接对象的内存地址值    }}</code></pre></li></ol><h2 id="3-Connection接口"><a href="#3-Connection接口" class="headerlink" title="3. Connection接口"></a>3. Connection接口</h2><p>Connection 接口，具体的实现类由数据库的厂商实现，代表一个连接对象。</p><h3 id="3-1-主要方法"><a href="#3-1-主要方法" class="headerlink" title="3.1 主要方法"></a>3.1 主要方法</h3><ul><li>获取执行sql的对象：<ul><li><code>Statement createStatement(String sql)</code></li><li><code>PreparedStatement preparedStatement(String sql)</code></li></ul></li><li>管理事务：<ul><li>开启事务：<code>setAutoCommit(boolean autoCommit)</code>:调用该方法设置参数为fasle，即开启事务</li><li>提交事务：<code>commit()</code></li><li>回滚事务：<code>rollback()</code></li></ul></li></ul><h2 id="4-Statement接口"><a href="#4-Statement接口" class="headerlink" title="4. Statement接口"></a>4. Statement接口</h2><p>用于执行静态SQL语句并返回其生成的结果对象</p><h3 id="4-1-主要方法"><a href="#4-1-主要方法" class="headerlink" title="4.1 主要方法"></a>4.1 主要方法</h3><ol><li><code>boolean execute(String sql)</code>：可以执行任意的sql</li><li><code>int executeUpdate(String sql)</code>：执行DML(insert、update、delete)语句、DDL(create、alter、drop)语句。返回值：<strong>影响的行数</strong>，可以通过判断行数来确定语句是否执行成功。</li><li><code>ResultSet executeQuery(String sql)</code>：执行DQL(select)语句。返回结果集对象</li></ol><h3 id="4-2-演示案例"><a href="#4-2-演示案例" class="headerlink" title="4.2 演示案例"></a>4.2 演示案例</h3><ol><li>account表中添加一条记录，使用insert语句<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo03JDBC {    public static void main(String[] args) {        Statement stmt = null;        Connection conn = null;        try {            &#x2F;&#x2F; 1. 注册驱动            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);            &#x2F;&#x2F; 2. 定义sql            String sql = &quot;insert into account values(null,&#39;小王&#39;,3000)&quot;;            &#x2F;&#x2F; 3. 获取连接数据库对象            conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?serverTimezone=UTC&amp;characterEncoding=gbk&quot;, &quot;root&quot;, &quot;123456&quot;);            &#x2F;&#x2F; 4. 获取执行sql的对象 Statement，并传入sql语句执行            stmt = conn.createStatement();            int count = stmt.executeUpdate(sql); &#x2F;&#x2F; 返回值影响的行数            &#x2F;&#x2F; 5. 处理结果            if (count&gt;0)                System.out.println(&quot;添加成功&quot;);            else                System.out.println(&quot;添加失败&quot;);        } catch (Exception e) {            e.printStackTrace();        }finally {            &#x2F;&#x2F;stmt.close();            &#x2F;&#x2F; 避免空指针异常            if(stmt!=null &amp;&amp; conn!=null){                try {                    stmt.close();                    conn.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }        }    }}</code></pre></li></ol><ol start="2"><li>修改一条表记录<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 只需在上述代码基础上改动sql语句即可String sql = &quot;update account set balance=2000 where name=&#39;小王&#39;&quot;;     conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?serverTimezone=UTC&amp;characterEncoding=gbk&quot;, &quot;root&quot;, &quot;123456&quot;);stmt = conn.createStatement();int count = stmt.executeUpdate(sql); &#x2F;&#x2F; 返回值影响的行数if (count&gt;0)    System.out.println(&quot;修改成功&quot;);else    System.out.println(&quot;修改失败&quot;);</code></pre></li></ol><ol start="3"><li>删除一条表记录<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 改动sql语句即可public class DelJDBC {    public static void main(String[] args) {        Connection conn = null;        Statement stmt = null;        try {            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);            conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?serverTimezone=UTC&quot;,&quot;root&quot;,&quot;123456&quot;);            stmt = conn.createStatement();            int count = stmt.executeUpdate(&quot;delete from account where id=3&quot;);            if (count&gt;0)                System.out.println(&quot;delete success!&quot;);            else                System.out.println(&quot;delete failed!&quot;);        } catch (Exception e) {            e.printStackTrace();        }finally {            if (stmt!=null &amp;&amp; conn!=null) {                try {                    stmt.close();                    conn.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }        }    }}</code></pre></li></ol><h2 id="5-ResultSet接口"><a href="#5-ResultSet接口" class="headerlink" title="5. ResultSet接口"></a>5. ResultSet接口</h2><p>结果集对象，封装查询的结果</p><h3 id="5-1-主要方法"><a href="#5-1-主要方法" class="headerlink" title="5.1 主要方法"></a>5.1 主要方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean next()</code></td><td>游标向下移动1行，返回布尔类型，如果还有下一条记录返回true，反之false</td></tr><tr><td><code>数据类型 getXxx()</code></td><td>通过字段名或是列编号，填入参数String或是整数(1开始)，返回不同的类型。</td></tr></tbody></table><p><strong>常用数据类型转换表</strong></p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/25/jdbc_sql-1558754667060.jpg" alt="jdbc_sql"></p><h3 id="5-2-方法演示"><a href="#5-2-方法演示" class="headerlink" title="5.2 方法演示"></a>5.2 方法演示</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DQLJDBC {    public static void main(String[] args) {        ResultSet rs = null;        Connection conn = null;        Statement stmt = null;        try {            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);            conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?serverTimezone=UTC&quot;,&quot;root&quot;,&quot;123456&quot;);            stmt = conn.createStatement();            rs = stmt.executeQuery(&quot;select * from account&quot;);            &#x2F;&#x2F; 处理结果            while (rs.next()){ &#x2F;&#x2F; 循环判断游标是否是最后一行末尾                int id = rs.getInt(1); &#x2F;&#x2F; 通过列编号获取数据                String name = rs.getString(&quot;name&quot;); &#x2F;&#x2F; 通过列名获取                double balance = rs.getDouble(3); &#x2F;&#x2F; 通过列编号获取                System.out.println(id+&quot;,&quot;+name+&quot;,&quot;+balance);            }        } catch (Exception e) {            e.printStackTrace();        }finally {            if (rs!=null){                try {                    rs.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }            if (stmt!=null){                try {                    stmt.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }if (conn!=null){                try {                    conn.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }        }    }}</code></pre><h3 id="5-3-练习"><a href="#5-3-练习" class="headerlink" title="5.3 练习"></a>5.3 练习</h3><ul><li>定义一个方法：查询users表的数据将其封装为对象，然后装载集合，返回。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义存储数据的类public class Users {    private int id;    private String name;    private int age;    private String site;    &#x2F;&#x2F; 省略构造方法等}&#x2F;&#x2F; 定义方法类，实现方法public class Demo5JDBC {    public static void main(String[] args) {        List&lt;Users&gt; list = new Demo5JDBC().findAll();        System.out.println(list);    }    &#x2F;&#x2F; 创建方法，查询所有users对象，返回一个list    public List&lt;Users&gt; findAll(){        Connection conn = null;        Statement stmt = null;        ResultSet rs = null;        List&lt;Users&gt; list = null;        try {            &#x2F;&#x2F; 1. 注册驱动            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);            &#x2F;&#x2F; 2. 获取连接            conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db5?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;123456&quot;);            &#x2F;&#x2F; 3. 获取执行sql对象            stmt = conn.createStatement();            &#x2F;&#x2F; 4. 执行sql            rs = stmt.executeQuery(&quot;select * from users&quot;);            &#x2F;&#x2F; 5. 遍历结果集，封装对象，装载集合            Users us = null;            list = new ArrayList&lt;&gt;();            while (rs.next()){                &#x2F;&#x2F; 获取数据                int id = rs.getInt(&quot;id&quot;);                String name = rs.getString(&quot;name&quot;);                int age = rs.getInt(&quot;age&quot;);                String site = rs.getString(4);                &#x2F;&#x2F; 创建users对象,并赋值                us = new Users();                us.setId(id);                us.setName(name);                us.setAge(age);                us.setSite(site);                &#x2F;&#x2F; 装载集合                list.add(us);            }        } catch (Exception e) {            e.printStackTrace();        }finally {            &#x2F;&#x2F; 释放资源，rs，stmt和conn            if (rs!=null){                try {                    rs.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }            &#x2F;&#x2F; 省略其他两个，与上方法一样        }        return list;    }}</code></pre><h2 id="6-自定义数据库工具类JdbcUtils"><a href="#6-自定义数据库工具类JdbcUtils" class="headerlink" title="6. 自定义数据库工具类JdbcUtils"></a>6. 自定义数据库工具类JdbcUtils</h2><p>可以把经常用到的功能做成一个工具类，在不同的地方重用。</p><h3 id="6-1-主要方法"><a href="#6-1-主要方法" class="headerlink" title="6.1 主要方法"></a>6.1 主要方法</h3><ol><li>可以把几个字符串定义成常量：用户名，密码，URL，驱动类</li><li>得到数据库的连接：<code>getConnection()</code></li><li>关闭所有打开的资源：<code>close(Connection conn,Statement stmt,ResultSet rs)</code> 和<code>close(ResultSet rs,Statement stmt, Connection conn)</code></li></ol><h4 id="6-2-使用工具类将上一个练习优化"><a href="#6-2-使用工具类将上一个练习优化" class="headerlink" title="6.2 使用工具类将上一个练习优化"></a>6.2 使用工具类将上一个练习优化</h4><ol><li><p>定义工具类<br>在项目目录下新建一个<code>util</code>文件夹，然后新建<code>JDBCUtils.java</code>文件，编写如下内容。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; JDBC工具类public class JDBCUtils {    private static String url;    private static String user;    private static String password;    private static String driver;    &#x2F;&#x2F; 文件的读取，只需读取一次即可拿到这些值：使用静态代码块    static {        &#x2F;&#x2F; 读取资源文件，获取配置值        try {            &#x2F;&#x2F; 1. 创建Properties集合类            Properties pro = new Properties();            &#x2F;&#x2F; 获取src路径下的文件的方式--&gt;ClassLoader 类加载器,如此就可以动态的获取src的绝对路径            ClassLoader classLoader = JDBCUtils.class.getClassLoader();            URL resource = classLoader.getResource(&quot;jdbc.properties&quot;);            String path = resource.getPath();            System.out.println(path);            &#x2F;&#x2F; 2. 加载文件&#x2F;&#x2F;            pro.load(new FileReader(&quot;src&#x2F;jdbc.properties&quot;));            pro.load(new FileReader(path));            &#x2F;&#x2F; 3. 获取属性，赋值            url = pro.getProperty(&quot;url&quot;);            user = pro.getProperty(&quot;user&quot;);            password = pro.getProperty(&quot;password&quot;);            driver = pro.getProperty(&quot;driver&quot;);            &#x2F;&#x2F; 4. 注册驱动            Class.forName(driver);        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }    &#x2F;&#x2F; 获取连接    public static Connection getConnection() throws SQLException {        return DriverManager.getConnection(url,user,password);    }    &#x2F;&#x2F; 释放资源    public static void close(Statement stmt, Connection conn){        if (stmt!=null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if (conn!=null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }    &#x2F;&#x2F; 释放资源重载    public static void close(ResultSet rs,Statement stmt, Connection conn){        if (rs!=null){            try {                rs.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if (stmt!=null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if (conn!=null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }}</code></pre></li><li><p>定义配置文件<br>在项目源文件src下新建<code>jdbc.properties</code>文件。</p></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-properties">url=jdbc:mysql:&#x2F;&#x2F;&#x2F;db5?serverTimezone=UTC&amp;characterEncoding=gbkuser=rootpassword=123456driver=com.mysql.cj.jdbc.Driver</code></pre><ol start="3"><li>演示用法<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo6JDBCUtil {    public static void main(String[] args) {        List&lt;Users&gt; list = new Demo6JDBCUtil().findAll2();        System.out.println(list);    }    &#x2F;**     * 演示JDBC工具类     * @return     *&#x2F;    public List&lt;Users&gt; findAll2(){        Connection conn = null;        Statement stmt = null;        ResultSet rs = null;        List&lt;Users&gt; list = null;        try {&#x2F;&#x2F;            &#x2F;&#x2F; 1. 注册驱动&#x2F;&#x2F;            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);&#x2F;&#x2F;            &#x2F;&#x2F; 2. 获取连接&#x2F;&#x2F;            conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db5?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;123456&quot;);            conn = JDBCUtils.getConnection();            &#x2F;&#x2F; 3. 获取执行sql对象            stmt = conn.createStatement();            &#x2F;&#x2F; 4. 执行sql            rs = stmt.executeQuery(&quot;select * from users&quot;);            &#x2F;&#x2F; 5. 遍历结果集，封装对象，装载集合            Users us = null;            list = new ArrayList&lt;&gt;();            while (rs.next()){                &#x2F;&#x2F; 获取数据                int id = rs.getInt(&quot;id&quot;);                String name = rs.getString(&quot;name&quot;);                int age = rs.getInt(&quot;age&quot;);                String site = rs.getString(4);                &#x2F;&#x2F; 创建users对象,并赋值                us = new Users();                us.setId(id);                us.setName(name);                us.setAge(age);                us.setSite(site);                &#x2F;&#x2F; 装载集合                list.add(us);            }        } catch (Exception e) {            e.printStackTrace();        }finally {            JDBCUtils.close(rs,stmt,conn); &#x2F;&#x2F; 直接调用方法就可以释放资源        }        return list;    }}</code></pre></li></ol><h3 id="6-3-练习：登录案例"><a href="#6-3-练习：登录案例" class="headerlink" title="6.3 练习：登录案例"></a>6.3 练习：登录案例</h3><ol><li>创建用户表</li><li>获取用户输入</li><li>查询数据库，与数据库中数据进行匹配</li><li>返回结果</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class LoginExercise {    public static void main(String[] args) {        &#x2F;&#x2F; 获取用户输入        Scanner sc = new Scanner(System.in);        System.out.print(&quot;请输入用户名：&quot;);        String name = sc.nextLine();        System.out.print(&quot;请输入密码：&quot;);        String pwd = sc.nextLine();        if (name==null || pwd==null)            System.out.println(&quot;输入内容不能为空&quot;);        login(name,pwd);        sc.close();    }    public static void login(String name,String pwd){        Connection conn = null;        Statement stmt = null;        ResultSet rs = null;        try {            &#x2F;&#x2F; 连接数据库，判断是否存在数据            conn = JDBCUtils.getConnection();            stmt = conn.createStatement();            rs = stmt.executeQuery(&quot;select * from users where name=&#39;&quot;+name+&quot;&#39; and pwd=&#39;&quot;+pwd+&quot;&#39;&quot;);            if (rs.next()) &#x2F;&#x2F; 返回布尔值，true则存在，false则不存在                System.out.println(&quot;登录成功&quot;);            else                System.out.println(&quot;用户名或密码错误！&quot;);        } catch (Exception e) {            e.printStackTrace();        }finally {            JDBCUtils.close(rs,stmt,conn);        }    }}</code></pre><h2 id="7-PreparedStatement接口"><a href="#7-PreparedStatement接口" class="headerlink" title="7. PreparedStatement接口"></a>7. PreparedStatement接口</h2><p>表示预编译的 SQL 语句的对象。 SQL 语句被预编译并存储在 <code>PreparedStatement</code> 对象中。然后可以使用此对象多次高效地执行该语句。  </p><h3 id="7-1-SQL注入问题"><a href="#7-1-SQL注入问题" class="headerlink" title="7.1 SQL注入问题"></a>7.1 SQL注入问题</h3><p>在拼接sql时，如果有一些sql的特殊关键字参与字符串的拼接，会造成安全性问题。</p><ul><li>输入密码时，如果输入以下密码，在账户和密码不正确情况下也登录成功</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/25/SQLInject-1558754766512.jpg" alt="SQLInject"></p><ul><li>原因</li></ul><p>打印了一下查询的SQL语句：<code>select * from user where name=&#39;ehwqhwqek&#39; and pwd=&#39;a&#39; or &#39;1&#39;=&#39;1&#39;;</code>发现当and前面为假，但是or后面为真，语句实际相当于：<code>select * from user where true;</code>查询了所有记录</p><p>要解决 SQL 注入就不能让用户输入的密码和我们的 SQL 语句进行简单的字符串拼接。</p><h3 id="7-2-解决SQL注入问题"><a href="#7-2-解决SQL注入问题" class="headerlink" title="7.2 解决SQL注入问题"></a>7.2 解决SQL注入问题</h3><p>使用<code>PreparedStatement</code>对象来解决该问题</p><ul><li>预编译的SQL：参数使用?作为占位符,例：<code>select * from users where name = ? and pwd = ?</code></li><li>给？赋值方法：<code>setXxx(?的位置编号(1开始),?的值)</code></li></ul><h4 id="7-2-1-方法演示"><a href="#7-2-1-方法演示" class="headerlink" title="7.2.1 方法演示"></a>7.2.1 方法演示</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 使用prepardStatement对象解决sql注入问题public class LoginExercise2 {    public static void main(String[] args) {        &#x2F;&#x2F; 获取用户输入        Scanner sc = new Scanner(System.in);        System.out.print(&quot;请输入用户名：&quot;);        String name = sc.nextLine();        System.out.print(&quot;请输入密码：&quot;);        String pwd = sc.nextLine();        if (name==null || pwd==null)            System.out.println(&quot;输入内容不能为空&quot;);        login(name,pwd);        sc.close();    }    &#x2F;*        登录方法，使用PreparedStatement实现     *&#x2F;    public static void login(String name,String pwd){        Connection conn = null;        PreparedStatement ps = null;        ResultSet rs = null;        try {            &#x2F;&#x2F; 连接数据库，判断是否存在数据            conn = JDBCUtils.getConnection();            &#x2F;&#x2F; 定义sql语句            String sql = &quot;select * from users where name = ? and pwd = ?&quot;;            &#x2F;&#x2F; 获取执行sql对象            ps = conn.prepareStatement(sql); &#x2F;&#x2F; 将sql传入，进行预编译            &#x2F;&#x2F; 给？赋值            ps.setString(1,name);            ps.setString(2,pwd);            rs = ps.executeQuery();            if (rs.next()) &#x2F;&#x2F; 返回布尔值，true则存在，false则不存在                System.out.println(&quot;登录成功&quot;);            else                System.out.println(&quot;用户名或密码错误！&quot;);        } catch (Exception e) {            e.printStackTrace();        }finally {            JDBCUtils.close(rs,ps,conn);        }    }}</code></pre><h3 id="7-3-PreparedStatement原理"><a href="#7-3-PreparedStatement原理" class="headerlink" title="7.3 PreparedStatement原理"></a>7.3 PreparedStatement原理</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/25/PStheory-1558754821161.jpg" alt="PStheory"></p><h4 id="7-3-1-优点"><a href="#7-3-1-优点" class="headerlink" title="7.3.1  优点"></a>7.3.1  优点</h4><ol><li><code>prepareStatement()</code>会先将 SQL 语句发送给数据库预编译。<code>PreparedStatement</code> 会引用着预编译后的结果。可以多次传入不同的参数给 <code>PreparedStatement</code> 对象并执行。减少 SQL 编译次数，提高效率。</li><li>安全性更高，没有SQL输入的隐患</li><li>提高了程序的可读性</li></ol><p>后期都会使用<code>PreparedStatement</code>来完成增删改查的所有操作</p><h2 id="8-JDBC的事务操作"><a href="#8-JDBC的事务操作" class="headerlink" title="8. JDBC的事务操作"></a>8. JDBC的事务操作</h2><ul><li><p>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p></li><li><p>使用<code>Connection</code>对象来管理事务</p><ul><li>开启事务：<code>setAutoCommit(boolean autoCommit)</code>:调用该方法设置参数为fasle，即开启事务</li><li>提交事务：<code>commit()</code></li><li>回滚事务：<code>rollback()</code></li></ul></li></ul><h3 id="8-1-银行转账案例"><a href="#8-1-银行转账案例" class="headerlink" title="8.1 银行转账案例"></a>8.1 银行转账案例</h3><p>步骤分析：</p><ol><li>获取连接</li><li>开启事务</li><li>获取到PreparedStatement</li><li>使用PreparedStatement执行两次更新操作</li><li>正常情况下提交事务</li><li>出现异常回滚事务</li><li>释放资源</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class EFT {    public static void main(String[] args) {        Connection conn = null;        PreparedStatement ps1 = null;        PreparedStatement ps2 = null;        try {            &#x2F;&#x2F; 1. 获取连接            conn = JDBCUtils.getConnection();            conn.setAutoCommit(false); &#x2F;&#x2F; 将自动提交关闭，即开启事务            &#x2F;&#x2F;  定义sql，小张-500            String sql1 = &quot;update account set balance = balance - ? where name = ?&quot;;            &#x2F;&#x2F; 小李+500            String sql2 = &quot;update account set balance = balance + ? where name = ?&quot;;            &#x2F;&#x2F; 获取执行sql对象            ps1 = conn.prepareStatement(sql1);            ps2 = conn.prepareStatement(sql2);            &#x2F;&#x2F; 给?赋值,小张-500            ps1.setDouble(1,500);            ps1.setString(2,&quot;小张&quot;);            ps1.executeUpdate(); &#x2F;&#x2F; 执行更新语句            &#x2F;&#x2F; 给?赋值,小李+500            ps2.setDouble(1,500);            ps2.setString(2,&quot;小李&quot;);            ps2.executeUpdate(); &#x2F;&#x2F; 执行更新语句            &#x2F;&#x2F; 手动制造一个异常            int i = 3&#x2F;0;            &#x2F;&#x2F; 提交事务            conn.commit();            System.out.println(&quot;事务执行完毕&quot;);        } catch (Exception e) {            &#x2F;&#x2F; 事务的回滚            try {                if (conn != null)                    System.out.println(&quot;事务异常！回滚中....&quot;);                    conn.rollback();            } catch (SQLException ex) {                ex.printStackTrace();            }            e.printStackTrace();        }finally {            &#x2F;&#x2F; 释放资源            JDBCUtils.close(ps1,conn);            if (ps2!=null){                try {                    ps2.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }        }    }}</code></pre><ul><li style="list-style: none"><input type="checkbox" checked> 能够理解JDBC的概念</li><li style="list-style: none"><input type="checkbox" checked> 能够使用DriverManager类</li><li style="list-style: none"><input type="checkbox" checked> 能够使用Connection接口</li><li style="list-style: none"><input type="checkbox" checked> 能够使用Statement接口</li><li style="list-style: none"><input type="checkbox" checked> 能够使用ResultSet接口</li><li style="list-style: none"><input type="checkbox" checked> 能够说出SQL注入原因和解决方案</li><li style="list-style: none"><input type="checkbox" checked> 能够通过PreparedStatement完成增、删、改、查</li><li style="list-style: none"><input type="checkbox" checked> 能够完成PreparedStatement改造登录案例</li><li style="list-style: none"><input type="checkbox" checked> 能够完成JDBC事务操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL多表查询和事务</title>
      <link href="/DataBase/MySQL-Transaction.html"/>
      <url>/DataBase/MySQL-Transaction.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-MySQL多表查询"><a href="#1-MySQL多表查询" class="headerlink" title="1. MySQL多表查询"></a>1. MySQL多表查询</h2><p>当我们需要查询的数据在多张表时，就需要连接多张表查询，这就是多表查询。</p><a id="more"></a><h3 id="1-1-表连接查询"><a href="#1-1-表连接查询" class="headerlink" title="1.1 表连接查询"></a>1.1 表连接查询</h3><ul><li>数据准备</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">CREATE DATABASE IF NOT EXISTS `db5` CHARACTER SET gbk;-- 创建部门表CREATE TABLE dept(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(50));INSERT INTO dept(NAME) VALUES(&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);-- 创建员工表CREATE TABLE staff(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(30),gender CHAR(1), -- 性别salary DOUBLE, -- 工资join_date DATE, -- 入职日期dept_id INT,FOREIGN KEY(dept_id) REFERENCES dept(id) -- 外键);INSERT INTO staff(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1),(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2),(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2),(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3),(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);</code></pre><ul><li>多表查询的作用</li></ul><p>如果想查询孙悟空的名字和他所在的部门名字，就需要使用多表查询。</p><ul><li>多表查询的分类<ul><li>内连接：隐式内连接和显示内连接</li><li>外连接：左外连接和右外连接</li></ul></li></ul><h3 id="1-2-笛卡尔积现象"><a href="#1-2-笛卡尔积现象" class="headerlink" title="1.2 笛卡尔积现象"></a>1.2 笛卡尔积现象</h3><ul><li>笛卡尔积：有两个集合A、B，取这两个集合中元素的所有组成情况。</li></ul><p>使用<code>select * from staff,dept;</code>就会出现该现象</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/22/CartesianProduct-1558535089208.jpg" alt="title"></p><ul><li>如何消除笛卡尔积现象的影响</li></ul><p>查询结果中不是所有的数据组合都是有用的，只有<strong>员工表.dept_id=部门表.id</strong>的数据才是有用的。所有需要通过设置条件过滤掉无用数据。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">SELECT * FROM staff,dept WHERE staff.`dept_id`=dept.`id`;-- 查询员工和部门的名字SELECT staff.`name`,dept.`name` FROM staff,dept WHERE staff.`dept_id`=dept.`id`;</code></pre><h3 id="1-3-内连接"><a href="#1-3-内连接" class="headerlink" title="1.3 内连接"></a>1.3 内连接</h3><p>用左边表的记录去匹配右边表的记录，如果符合条件的则显示。如：<strong>从表.外键=主表.主键</strong></p><h4 id="1-3-1-隐式内连接"><a href="#1-3-1-隐式内连接" class="headerlink" title="1.3.1 隐式内连接"></a>1.3.1 隐式内连接</h4><ul><li>隐式内连接：不使用join关键字，条件使用where指定。</li><li>语法：<code>select 字段名 from 左表,右表 where 条件;</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 查询两张表中，所有员工表外键等于部门表主键的数据SELECT * FROM staff,dept WHERE staff.`dept_id`=dept.`id`;</code></pre><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/22/in-connection01-1558535127200.jpg" alt="title"></p><h4 id="1-3-2-显式内连接"><a href="#1-3-2-显式内连接" class="headerlink" title="1.3.2 显式内连接"></a>1.3.2 显式内连接</h4><ul><li>显式内连接：使用<strong>[inner] JOIN…ON</strong>语句, ‘[ ]’表示可省略</li><li>语法：<code>select 字段名 from 左表 [inner] join 右表 on 条件;</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 查询钢铁侠的信息，显示员工id、姓名、性别、工资和所在的部门名称SELECT s.`id`,s.`name`,s.`gender`,s.`salary`,d.`name`部门名称 FROM staff s INNER JOIN dept d ON s.`dept_id`=d.`id` AND s.`name`=&#39;钢铁侠&#39;;&#x2F;*内连接查询步骤：1. 确定查询哪些表：员工表和部门表2. 确定表连接条件：员工表.dept_id = 部门表.id 的数据才是有效的，即消除笛卡尔积现象3. 确定查询条件：查询钢铁侠的信息，员工表.name=&#39;钢铁侠&#39;4. 确定显示字段：显示钢铁侠的id、姓名、性别、工资和所在的部门名称5. 可以使用别名进行优化，如staff as s*&#x2F;</code></pre><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/22/in-connection02-1558535144642.jpg" alt="title"></p><h3 id="1-4-外连接"><a href="#1-4-外连接" class="headerlink" title="1.4 外连接"></a>1.4 外连接</h3><h4 id="1-4-1-左外连接"><a href="#1-4-1-左外连接" class="headerlink" title="1.4.1 左外连接"></a>1.4.1 左外连接</h4><p>用左边表的记录去匹配右边表的记录，如果符合条件的则显示；否则，显示 NULL</p><ul><li>语法：<code>select 字段名 fron 左表 left[outer] join 右表 on 条件;</code></li></ul><p>可以理解为：在内连接的基础上保证左表的数据全部显示(左表部门，右表员工情况下)</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 在部门表中增加一个销售部INSERT INTO dept(NAME) VALUES(&#39;销售部&#39;);-- 使用内连接查询数据SELECT * FROM dept d INNER JOIN staff s ON d.`id`=s.`dept_id`;-- 使用左外连接查询数据SELECT * FROM dept d LEFT JOIN staff s ON d.`id`=s.`dept_id`;</code></pre><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/22/LeftOuterJoin-1558535161078.jpg" alt="title"></p><p>用左表记录去匹配右表记录，当不符合条件情况下，仍会显示左表数据，但右表数据会显示为NULL。即在内连接的基础上保证左表数据全部显示。</p><h4 id="1-4-2-右外连接"><a href="#1-4-2-右外连接" class="headerlink" title="1.4.2 右外连接"></a>1.4.2 右外连接</h4><p>用右边表的记录去匹配左边表的记录，如果符合条件的则显示；否则，显示 NULL</p><ul><li>语法：<code>select 字段名 from 左表 right[outer]join 右表 on 条件;</code></li></ul><p>可以理解为：在内连接的基础上保证右表的数据全部显示</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 在员工表中增加一个员工INSERT INTO staff VALUES(NULL,&#39;蜘蛛侠&#39;,&#39;男&#39;,5880,&#39;2014-4-1&#39;,NULL);-- 使用内连接查询SELECT * FROM dept d INNER JOIN staff s ON d.`id`=s.`dept_id`; -- 右表新添加的数据将查询不到，因为dept_id值为NULL。-- 使用右外连接查询SELECT * FROM dept d RIGHT JOIN staff s ON d.`id`=s.`dept_id`; -- 在内连接基础上，保证显示右表所有数据，即使条件不满足</code></pre><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/22/RightOuterJoin-1558535183109.jpg" alt="title"></p><h2 id="2-子查询"><a href="#2-子查询" class="headerlink" title="2. 子查询"></a>2. 子查询</h2><h3 id="2-1-子查询概念"><a href="#2-1-子查询概念" class="headerlink" title="2.1 子查询概念"></a>2.1 子查询概念</h3><ol><li>一个查询的<strong>结果</strong>做为另一个查询的<strong>条件</strong></li><li>有查询的嵌套，内部的查询称为子查询</li><li>子查询要<strong>使用括号</strong></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 查询开发部中有哪些员工-- 通过两条语句查询SELECT id FROM dept WHERE NAME=&#39;开发部&#39;; -- 先获取开发部门id，1SELECT * FROM staff WHERE dept_id=1; -- 通过id去查询对应员工-- 使用子查询语句SELECT * FROM staff WHERE dept_id = (SELECT id FROM dept WHERE NAME=&#39;开发部&#39;); -- 注意子查询多行单列必须限定子查询字段列只有一个，不能使用* 或两个字段名</code></pre><h3 id="2-2-子查询结果的三种情况"><a href="#2-2-子查询结果的三种情况" class="headerlink" title="2.2 子查询结果的三种情况"></a>2.2 子查询结果的三种情况</h3><ol><li>子查询的结果是单行单列</li><li>子查询的结果是多行单列</li><li>子查询的结果是多行多列</li></ol><h4 id="2-2-1-子查询结果是一个值-单行单列-的时候"><a href="#2-2-1-子查询结果是一个值-单行单列-的时候" class="headerlink" title="2.2.1 子查询结果是一个值(单行单列)的时候"></a>2.2.1 子查询结果是一个值(单行单列)的时候</h4><ul><li>子查询结果只要是单行单列，肯定在 WHERE 后面作为条件，父查询使用：比较运算符，如：&gt; 、&lt;、&lt;&gt;、=等</li><li>语法：<code>select 查询显示字段 from 表 where 字段=(子查询);</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 查询工资最高的员工SELECT staff.`name` FROM staff WHERE salary = (SELECT MAX(salary) FROM staff);-- 查询工资小于平均工资的员工有哪些？SELECT * FROM staff WHERE salary &lt; (SELECT AVG(salary) FROM staff);</code></pre><h4 id="2-2-2-子查询结果是多行单列的时候"><a href="#2-2-2-子查询结果是多行单列的时候" class="headerlink" title="2.2.2 子查询结果是多行单列的时候"></a>2.2.2 子查询结果是多行单列的时候</h4><ul><li>子查询结果是多行单列，结果集类似于一个数组，父查询使用IN运算符</li><li>语法：<code>select 查询字段 form 表 where 字段 in (子查询);</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 查询工资大于5000的员工，来自于哪些部门的名字-- 先查询大于5000的员工所在的部门idSELECT dept_id FROM staff WHERE staff.`salary` &gt; 5000;-- 再查询这些部门id对应的部门名称,会报错SELECT NAME FROM dept WHERE id = (SELECT dept_id FROM staff WHERE salary&gt;5000); -- 错误代码： 1242 Subquery returns more than 1 row-- 使用IN运算符SELECT NAME FROM dept WHERE id IN(SELECT dept_id FROM staff WHERE salary&gt;5000);-- 查询开发部与财务部所有的员工信息-- 先查询开发部和财务部的部门idSELECT id FROM dept WHERE NAME IN (&#39;开发部&#39;,&#39;财务部&#39;);-- 通过部门id查询对应有哪些员工SELECT * FROM staff WHERE dept_id IN (SELECT id FROM dept WHERE NAME IN (&#39;开发部&#39;,&#39;财务部&#39;));</code></pre><h4 id="2-2-3-子查询结果是多行多列"><a href="#2-2-3-子查询结果是多行多列" class="headerlink" title="2.2.3 子查询结果是多行多列"></a>2.2.3 子查询结果是多行多列</h4><p>子查询结果只要是多列，肯定在 FROM 后面作为表，子查询作为表需要<strong>取别名</strong>，否则这张表没有名称则无法访问表中的字段</p><ul><li>语法：<code>select 查询字段 from (子查询) 表别名 where 条件;</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 查询出 2011 年以后入职的员工信息，包括部门名称-- 在员工表中查询 2011-1-1 以后入职的员工SELECT * FROM staff WHERE join_date &gt;=&#39;2011-1-1&#39;;-- 查询所有的部门信息，与上面的虚拟表中的信息组合，找出所有部门 id 等于的 dept_idSELECT * FROM dept d, (SELECT * FROM staff WHERE join_date&gt;=&#39;2011-1-1&#39;) e WHERE d.`id`=e.dept_id;-- 也可以使用表连接查询SELECT * FROM staff s INNER JOIN dept d ON  s.`dept_id`=d.`id` WHERE join_date&gt;=&#39;2011-1-1&#39;;SELECT * FROM staff s INNER JOIN dept d ON  s.`dept_id`=d.`id` AND join_date&gt;=&#39;2011-1-1&#39;;</code></pre><h4 id="2-2-4-子查询小结"><a href="#2-2-4-子查询小结" class="headerlink" title="2.2.4 子查询小结"></a>2.2.4 子查询小结</h4><ul><li>子查询结果只要是单列，则在where后面作为条件</li><li>子查询结果只要是多列，则在from后面作为表进行二次查询</li></ul><h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3. 事务"></a>3. 事务</h2><h3 id="3-1-事务概述及应用场景"><a href="#3-1-事务概述及应用场景" class="headerlink" title="3.1 事务概述及应用场景"></a>3.1 事务概述及应用场景</h3><ul><li><strong>概念</strong>：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</li><li>转账操作示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 创建数据表CREATE TABLE account(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(30),balance DOUBLE);-- 插入数据INSERT INTO account(NAME,balance) VALUES(&#39;小张&#39;,1000),(&#39;小李&#39;,1000);&#x2F;*模拟小张给小李转500元钱，一个转账业务操作最少要执行下面两条语句：小张账户-500小李账户+500*&#x2F;-- 小张账号-500UPDATE account SET balance = balance-500 WHERE NAME=&#39;小张&#39;;-- 小李账号+500UPDATE account SET balance = balance+500 WHERE NAME=&#39;小李&#39;;</code></pre><p>假设小张账户上-500后，服务器崩溃了。小李账户并没有+500元，如此数据就出现问题了。我们需要保证其中一条SQL语句出现问题，整个转账就算失败。因此需要使用事务。</p><h3 id="3-2-手动提交事务"><a href="#3-2-手动提交事务" class="headerlink" title="3.2 手动提交事务"></a>3.2 手动提交事务</h3><p>MySQL中可以有两种方式进行事务的操作：</p><ol><li>手动提交事务</li><li>自动提交事务</li></ol><h4 id="3-2-1-手动提交事务的SQL语句"><a href="#3-2-1-手动提交事务的SQL语句" class="headerlink" title="3.2.1 手动提交事务的SQL语句"></a>3.2.1 手动提交事务的SQL语句</h4><table><thead><tr><th>功能</th><th>SQL语句</th></tr></thead><tbody><tr><td>开启事务</td><td>start transaction; or begin;</td></tr><tr><td>提交事务</td><td>commit;</td></tr><tr><td>回滚事务</td><td>rollback;</td></tr></tbody></table><h4 id="3-2-2-手动提交事务使用过程"><a href="#3-2-2-手动提交事务使用过程" class="headerlink" title="3.2.2 手动提交事务使用过程"></a>3.2.2 手动提交事务使用过程</h4><ol><li>执行成功的情况：开启事务–&gt; 执行多条SQL语句–&gt; 成功：提交事务</li><li>执行失败的情况：开启事务–&gt; 执行多条SQL语句–&gt; 失败：事务的回滚</li></ol><h4 id="3-2-3-案例演示"><a href="#3-2-3-案例演示" class="headerlink" title="3.2.3 案例演示"></a>3.2.3 案例演示</h4><ol><li>模拟小张给小李转500元钱(成功情况)<ol><li>使用DOS控制台进入MySQL</li><li>执行以下SQL语句：1. 开启事务;  2. 小张账户-500;  3. 小李账户+500</li><li>使用SQLyog查看数据库，发现数据未改变</li><li>在控制台执行commit;提交事务</li><li>示意SQLyog查看数据库，发现数据已改变</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/transaction-1558592609612.jpg" alt="transaction"></p><ol start="2"><li>模拟小张给小李转500元钱(失败情况)，两人账户都重置为1000元。<ol><li>在控制台执行以下SQL语句：1. 开启事务;   2. 小张账户-500</li><li>使用SQLyog查看数据库，发现数据未改变</li><li>在控制台执行rollback回滚事务</li><li>使用SQLyog查看数据库，发现数据也未改变</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/transaction-error-1558592664109.jpg" alt="transaction-error"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>如果事务中SQL语句没有问题，<strong>commit提交事务</strong>，会对数据库数据进行改变。如果事务中SQL语句有问题，<strong>rollback回滚事务</strong>，会回退到开启事务时的状态。</p><h3 id="3-3-自动提交事务"><a href="#3-3-自动提交事务" class="headerlink" title="3.3 自动提交事务"></a>3.3 自动提交事务</h3><p>MySQL 默认每一条 DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执行完毕自动提交事务，MySQL 默认开始自动提交事务。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/Auto_commit-1558592689790.jpg" alt="Auto_commit"></p><h4 id="3-3-1-案例演示：自动提交事务"><a href="#3-3-1-案例演示：自动提交事务" class="headerlink" title="3.3.1 案例演示：自动提交事务"></a>3.3.1 案例演示：自动提交事务</h4><ol><li>将金额重置为1000</li><li>更新其中某一个账户</li><li>使用SQLyog查看数据库；发现数据已改变</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/demo01-1558592714256.jpg" alt="title"></p><h4 id="3-3-2-取消自动提交"><a href="#3-3-2-取消自动提交" class="headerlink" title="3.3.2 取消自动提交"></a>3.3.2 取消自动提交</h4><ul><li>查看 MySQL 是否开启自动提交事务：<code>select @@autocommit;</code> @ 表示全局变量，1表示开启，0关闭。</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/Auto_commit02-1558592732701.jpg" alt="Auto_commit02"></p><ul><li>取消自动提交事务</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/cancel_autocommit-1558592755217.jpg" alt="title"></p><ul><li>再次执行更新语句，然后使用SQLyog查看数据库，会发现数据并没有改变</li><li>在控制台执行commit提交任务</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/transaction02-1558592768439.jpg" alt="transaction02"></p><h2 id="3-4-事务原理"><a href="#3-4-事务原理" class="headerlink" title="3.4 事务原理"></a>3.4 事务原理</h2><p>事务开启之后，所有的操作都会临时保存到事务日志中，事务日志只有在得到commit命令才会同步到数据表中，其他任何情况都会情况事务日志(rollback,断开连接等)</p><h4 id="3-4-1-原理图"><a href="#3-4-1-原理图" class="headerlink" title="3.4.1 原理图"></a>3.4.1 原理图</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/theory-1558592803406.jpg" alt="theory"></p><p><strong>事务的步骤：</strong></p><ol><li>客户端连接数据库服务器，创建连接时创建此用户临时日志文件</li><li>开启事务后，所有的操作都会先写入到临时日志文件中</li><li>所有的查询操作从表中查询，但会结果日志文件加工后才返回</li><li>如果事务提交则将日志文件中的数据写入到表中，否则情况日志文件</li></ol><h3 id="3-5-回滚点"><a href="#3-5-回滚点" class="headerlink" title="3.5 回滚点"></a>3.5 回滚点</h3><p>在某些成功的操作完成之后，后续的操作有可能成功有可能失败，但是不管成功还是失败，前面操作都已经成功，可以在当前成功的位置设置一个回滚点。可以供后续失败操作返回到该位置，而不是返回所有操作，这个点称之为<strong>回滚点</strong>。</p><h4 id="3-5-1-回滚点操作语句"><a href="#3-5-1-回滚点操作语句" class="headerlink" title="3.5.1 回滚点操作语句"></a>3.5.1 回滚点操作语句</h4><table><thead><tr><th>作用</th><th>语句</th></tr></thead><tbody><tr><td>设置回滚点</td><td>savepoint 回滚点名字</td></tr><tr><td>回到回滚点</td><td>rollback to 名字</td></tr></tbody></table><h4 id="3-5-2-案例演示"><a href="#3-5-2-案例演示" class="headerlink" title="3.5.2 案例演示"></a>3.5.2 案例演示</h4><ol><li>将数据重置为1000</li><li>开启事务</li><li>让小张账户减3次钱，每次10元</li><li>设置回滚点：savepoint three_times;</li><li>让小张减4次钱，每次10元</li><li>回到回滚点：rollback to three_times;</li><li>查看结果，分析执行过程</li></ol><ul><li>小结：设置回滚点可以让我们在失败的时候回到指定回滚点，而不是回到事务开启的时候。</li></ul><h3 id="3-6-事务的隔离级别"><a href="#3-6-事务的隔离级别" class="headerlink" title="3.6 事务的隔离级别"></a>3.6 事务的隔离级别</h3><h4 id="3-6-1-事务四大特性ACID"><a href="#3-6-1-事务四大特性ACID" class="headerlink" title="3.6.1 事务四大特性ACID"></a>3.6.1 事务四大特性ACID</h4><table><thead><tr><th>事务特性</th><th>含义</th></tr></thead><tbody><tr><td>原子性(Atomicity)</td><td>每个事务都是一个整体，不可再拆分，事务中所有的SQL语句要么都执行成功，要么都失败。</td></tr><tr><td>一致性(Consistency)</td><td>事务在执行前数据库的状态与执行后数据库的状态保持一致。例：转账前两人的总金额是2000，转账后总金额也是2000</td></tr><tr><td>隔离性(Isolation)</td><td>事务与事务之间不应该相互影响，执行时保持隔离的状态</td></tr><tr><td>持久性(Durability)</td><td>一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。</td></tr></tbody></table><h4 id="3-6-2-事务的隔离级别"><a href="#3-6-2-事务的隔离级别" class="headerlink" title="3.6.2 事务的隔离级别"></a>3.6.2 事务的隔离级别</h4><p>事务在操作时的理想状态：所有的事务之间保持隔离，互不影响。因为并发操作，多个用户同时访问同一个数据，可以引发并发访问的问题</p><table><thead><tr><th>并发访问的问题</th><th>含义</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读取到了另一个事务中尚未提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务中两次读取的数据<strong>内容不一致</strong>，要求的是一个事务中多次读取时数据是一致的，这是事务update时引发的问题</td></tr><tr><td>幻读</td><td>一个事务中两次读取的数据的<strong>数量不一致</strong>，要求在一个事务多次读取的数据数量是一致的，这是insert或delete时引发的问题</td></tr></tbody></table><h4 id="3-6-3-MySQL数据库有四种隔离级别"><a href="#3-6-3-MySQL数据库有四种隔离级别" class="headerlink" title="3.6.3 MySQL数据库有四种隔离级别"></a>3.6.3 MySQL数据库有四种隔离级别</h4><p>从上往下隔离级别依次递增。“是”表示会出现这种问题，“否”表示不会出现这种问题。</p><table><thead><tr><th>级别</th><th>名字</th><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>默认隔离级别</th></tr></thead><tbody><tr><td>1</td><td>读未提交</td><td>read uncommitted</td><td>是</td><td>是</td><td>是</td><td></td></tr><tr><td>2</td><td>读已提交</td><td>read committed</td><td>否</td><td>是</td><td>是</td><td>Oracle和SQL Server</td></tr><tr><td>3</td><td>可重复读</td><td>repeatable read</td><td>否</td><td>否</td><td>是</td><td><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/isolation-1558592857953.jpg" alt="isolation"></td></tr><tr><td>4</td><td>串行化</td><td>serializable</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><blockquote><p>隔离级别越高，性能越差，安全性越高。</p></blockquote><h4 id="3-6-4-MySQL事务隔离级别相关命令"><a href="#3-6-4-MySQL事务隔离级别相关命令" class="headerlink" title="3.6.4 MySQL事务隔离级别相关命令"></a>3.6.4 MySQL事务隔离级别相关命令</h4><ul><li>查询全局事务隔离级别：<code>select @@ tx_isolation;</code></li><li>设置事务隔离级别：<code>set global transaction isolation level 级别字符串;</code> 重新登录MySQL生效。</li></ul><h4 id="3-6-5-脏读的演示"><a href="#3-6-5-脏读的演示" class="headerlink" title="3.6.5 脏读的演示"></a>3.6.5 脏读的演示</h4><p>将余额数据重置为1000元</p><ol><li>打开A窗口登录MySQL，设置全局隔离级别为最低(read uncommitted)</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/isolation-level1-1558592887521.jpg" alt="isolation-level1"></p><ol start="2"><li>打开B窗口，AB窗口都开启事务</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/AB-1558592910534.jpg" alt="AB"></p><ol start="3"><li>A窗口更新2个人的账户数据，模拟转账，未提交</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/A-update-1558592932429.jpg" alt="A-update"></p><ol start="4"><li>B窗口查询账户数据，到账了</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/B-select-1558592959485.jpg" alt="B-select"></p><ol start="5"><li>A窗口回滚：<code>rollback;</code></li><li>B窗口查询账户数据，到账的钱没了</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/B-select-2-1558592982344.jpg" alt="B-select-2"></p><p>脏读问题非常危险。比如小张向小李购买商品，小张开启事务，向小李账户转入500块钱，然后打电话给小李说钱已经转了。小李查询看钱的确到账了，发货给小张。小张收到货后回滚事务，小李再次查看钱就没了。</p><p><strong>解决脏读问题</strong>：将全局的隔离级别进行提升</p><ol><li>提高A窗口的隔离级别为read committed，并开启事务</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/isolation-level2-1558593001591.jpg" alt="isolation-level2"></p><ol start="2"><li>重新登录B窗口MySQL，进入数据库并开启事务</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/B-usedb-1558593015378.jpg" alt="B-usedb"></p><ol start="3"><li>A窗口模拟转账操作，更新两个账户数据，未提交</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/A-level2-1558593029364.jpg" alt="A-level2"></p><ol start="4"><li>B窗口查询数据，发现没有改变(没有读取到另一个事务未提交的内容)</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/B-select-level2-1558593046721.jpg" alt="B-select-level2"></p><ol start="5"><li>A窗口<code>commit;</code>提交事务，B窗口查询，发现数据改变了(另一个事务提交后的数据才能读取到)</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/A_commit_B_select-1558593059422.jpg" alt="A_commit_B_select"></p><p><strong>小结</strong>：read committed的方式可以避免脏读的发生</p><h3 id="3-6-6-不可重复读的演示"><a href="#3-6-6-不可重复读的演示" class="headerlink" title="3.6.6 不可重复读的演示"></a>3.6.6 不可重复读的演示</h3><p>将数据重置为1000</p><ol><li>开启A窗口，并设置全局隔离级别为read committed；</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/A-set-readcommitted%3B-1558593079757.jpg" alt="A-set-readcommitted"></p><ol start="2"><li>开启B窗口，B窗口开启事务并查询数据</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/B-startAndselect-1558593106316.jpg" alt="B-startAndselect"></p><ol start="3"><li>A窗口开启事务，并更新数据</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/A-update-commit-1558593126721.jpg" alt="A-update-commit"></p><ol start="4"><li>B窗口查询数据，发现两次结果不一致</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/B-select-02-1558593149558.jpg" alt="B-select-02"></p><p>两次查询输出的结果不同，无法确定哪次是对的，以哪次为准？</p><p><strong>解决不可重复读的问题</strong>：将全局隔离级别提升为：<strong>repeatable read</strong></p><p>将数据重置为1000</p><ol><li>A窗口设置隔离级别为：<strong>repeatable read</strong></li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/A_repeatable_read-1558593166460.jpg" alt="A_repeatable_read"></p><ol start="2"><li>B窗口重新登录MySQL，开启事务并查询数据</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/B_select_level3-1558593179684.jpg" alt="B_select_level3"></p><ol start="3"><li>A窗口开启事务，更新数据</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/A_update_level3-1558593195882.jpg" alt="A_update_level3"></p><ol start="4"><li>B窗口查询数据，两次查询数据一致</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/B_select_level3_02-1558593214294.jpg" alt="B_select_level3_02"></p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>同一个事务中为了保证多次查询数据一致，必须使用<strong>repeatable read</strong>隔离级别</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/level3-1558593223717.jpg" alt="level3"></p><h3 id="3-7-幻读的演示"><a href="#3-7-幻读的演示" class="headerlink" title="3.7 幻读的演示"></a>3.7 幻读的演示</h3><ul><li>幻读主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计)，发现结果不一致(标准档案一般指记录增多，记录的减少应该也算是幻读)。</li><li><p>其实对于 <code>幻读</code>, MySQL的InnoDB引擎默认的<code>RR</code>级别已经通过<code>MVCC自动帮我们解决了</code>, 所以该级别下, 也模拟不出幻读的场景; 退回到 <code>RC</code> 隔离级别的话,又容易把<code>幻读</code>和<code>不可重复读</code>搞混淆。理论上RR级别是无法解决幻读问题的，但是由于InnoDB引擎的RR级别还使用了MVCC, 所以也就避免了幻读的出现。</p></li><li><p>使用<code>隔离性</code>的最高隔离级别<code>SERIALIZABLE</code>也可以解决<code>幻读</code>, 在该隔离级别下，一个事务没有执行完，其他事务的SQL执行不了，可以挡住幻读。但该隔离级别在实际中很少使用！</p></li><li><p><a href="https://segmentfault.com/a/1190000012669504?utm_source=tag-newest" target="_blank" rel="noopener">幻读的延伸</a></p></li></ul><h2 id="4-DCL-Data-Control-Language"><a href="#4-DCL-Data-Control-Language" class="headerlink" title="4. DCL(Data Control Language)"></a>4. DCL(Data Control Language)</h2><ul><li>DDL：create/alter/drop</li><li>DML：insert/ update/delete</li><li>DQL：select/show</li><li>DCL：grant/ revoke</li></ul><p>默认使用的都是root用户，超级管理员，拥有全部的权限。但是，一个公司里面的数据库服务器上面可能同时运行着很多个项目的数据库。所以，我们应该可以根据不同的项目建立不同的用户，分配不同的权限来管理和维护数据库。</p><blockquote><p>mysqld是MySQL的主程序，服务器端。mysql是MySQL的命令行工具，客户端。</p></blockquote><h3 id="4-1-创建用户"><a href="#4-1-创建用户" class="headerlink" title="4.1 创建用户"></a>4.1 创建用户</h3><ul><li><p>语法：<code>create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;</code></p></li><li><p>关键字说明</p></li></ul><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>用户名</td><td>将创建用户名称</td></tr><tr><td>主机名</td><td>指定该用户在哪个主机上可以登录，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登录，可以使用通配符%</td></tr><tr><td>密码</td><td>该用户的登录密码，可以为空(则表示无需密码即可登录服务器)</td></tr></tbody></table><ul><li>操作示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 创建 zero 用户，只能在 localhost 这个服务器登录 mysql 服务器，密码为 123create user &#39;zero&#39;@&#39;%&#39; identified by &#39;123&#39;;-- 创建 zero2用户可以在任何电脑上登录 mysql 服务器，密码为 123CREATE USER &#39;zero2&#39;@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;-- 创建的用户名都在mysql数据库的user表中可以查看,密码经过了加密select user.`Host`,user.`User`,user.`authentication_string`PASSWORD FROM USER;</code></pre><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/23/users-1558605540361.jpg" alt="users"></p><h3 id="4-2-用户授权"><a href="#4-2-用户授权" class="headerlink" title="4.2 用户授权"></a>4.2 用户授权</h3><p>用户创建之后，什么权限都没有，需要管理员手动给用户授权</p><ul><li>语法：<code>grant 权限1,权限2...on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>关键字说明</li></ul><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>grant…on…to</td><td>授权关键字</td></tr><tr><td>权限</td><td>授予用户的权限，如CREATE、ALTER、SELECT、INSERT、UPDATE等。如果要授予所有的权限则使用ALL</td></tr><tr><td>数据库名.表名</td><td>该用户可以操作哪个数据库的哪些表。如果要授予该用户对<strong>所有数据库和表</strong>的相应操作权限则可以使用<code>*.*</code></td></tr><tr><td>‘用户名‘@’主机名’</td><td>给哪个用户授权。注意有单引号</td></tr></tbody></table><ul><li>操作示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 给 zero 用户分配对 test 这个数据库操作的权限：创建表，修改表，插入记录，更新记录，查询GRANT CREATE,ALTER,INSERT,UPDATE,SELECT ON db1.* TO &#39;zero&#39;@&#39;localhost&#39;;-- 给 zero2 用户分配所有权限，对所有数据库的所有表GRANT ALL ON *.* TO &#39;zero2&#39;@&#39;%&#39;;</code></pre><h3 id="4-3-撤销权限"><a href="#4-3-撤销权限" class="headerlink" title="4.3 撤销权限"></a>4.3 撤销权限</h3><ul><li><p>语法：<code>revoke 权限1,权限2... on 数据库.表名 from &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li><li><p>关键字</p></li></ul><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>revoke…on…from</td><td>撤销授权的关键字</td></tr><tr><td>权限</td><td>用户的权限，如 CREATE、ALTER、SELECT、INSERT、UPDATE 等，所有的权限则使用 ALL</td></tr><tr><td>数据库名.表名</td><td>对哪些数据库哪些表做操作。如果要撤销该用户对<strong>所有数据库和表</strong>的相应操作权限则可以使用<code>*.*</code></td></tr><tr><td>‘用户名‘@’主机名’</td><td>给哪个用户撤销</td></tr></tbody></table><ul><li>操作示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 撤销zero2用户对全部数据库的全部权限REVOKE ALL ON *.* FROM &#39;zero2&#39;@&#39;%&#39;;</code></pre><h3 id="4-4-查看权限"><a href="#4-4-查看权限" class="headerlink" title="4.4 查看权限"></a>4.4 查看权限</h3><ul><li>语法：<code>show grants for &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>操作示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 查看zero用户的权限SHOW GRANTS FOR &#39;zero&#39;@&#39;localhost&#39;;</code></pre><blockquote><p>usage是指连接(登录)权限，建立一个用户，就会自动授予其usage权限，无法revoke。</p></blockquote><h3 id="4-5-删除用户"><a href="#4-5-删除用户" class="headerlink" title="4.5 删除用户"></a>4.5 删除用户</h3><ul><li><p>语法：<code>drop user &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li><li><p>操作示例</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 删除zero用户DROP USER &#39;zero&#39;@&#39;localhost&#39;;</code></pre><h3 id="4-6-修改管理员密码"><a href="#4-6-修改管理员密码" class="headerlink" title="4.6 修改管理员密码"></a>4.6 修改管理员密码</h3><ul><li>语法：<code>mysqladmin -uroot -p password 新密码</code></li></ul><blockquote><p>该命令在DOS控制台执行，新密码无需加上引号。</p><p>Tips: </p><ol><li>请在DBA允许陪同下使用该命令</li><li>数据库内修改root密码需使用<code>flush privileges;</code>刷新权限才能生效</li></ol></blockquote><h3 id="4-7-修改普通用户密码"><a href="#4-7-修改普通用户密码" class="headerlink" title="4.7 修改普通用户密码"></a>4.7 修改普通用户密码</h3><ul><li>语法：<code>set password for &#39;用户名&#39;@&#39;主机名&#39;=password(&#39;newpwd&#39;);</code></li></ul><h2 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h2><ul><li style="list-style: none"><input type="checkbox" checked> 能够使用内连接进行多表查询</li><li style="list-style: none"><input type="checkbox" checked> 能够使用左外连接和右外连接进行多表查询</li><li style="list-style: none"><input type="checkbox" checked> 能够使用子查询进行多表查询</li><li style="list-style: none"><input type="checkbox" checked> 能够理解事务的概念</li><li style="list-style: none"><input type="checkbox" checked> 能够说出事务的特点</li><li style="list-style: none"><input type="checkbox" checked> 能够在MySQL中使用事务</li><li style="list-style: none"><input type="checkbox" checked> 能够理解脏读、不可重复读、幻读的概念及解决方法</li><li style="list-style: none"><input type="checkbox" checked> 能够使用DCL管理MySQL中的用户</li></ul>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;2019.5.20&#39;</title>
      <link href="/uncategorized/2019.5.20.html"/>
      <url>/uncategorized/2019.5.20.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="今日随笔-notebook"><a href="#今日随笔-notebook" class="headerlink" title="今日随笔 :notebook:"></a>今日随笔 :notebook:</h3><p>今天又是鸽子江的一天! :satisfied:</p><p>下面总结一下最近几天的问题 :mag:</p><a id="more"></a><h5 id="one-学习效率方面"><a href="#one-学习效率方面" class="headerlink" title=":one:学习效率方面"></a>:one:学习效率方面</h5><p>发现最近的学习效率有点问题，经常当天的学习内容都要拖很晚才能完成。也不知道是方法出了问题还是什么。</p><blockquote><p>学习娱乐之间要保持平衡，要有度。</p></blockquote><h5 id="two-知识点遗忘"><a href="#two-知识点遗忘" class="headerlink" title=":two: 知识点遗忘"></a>:two: 知识点遗忘</h5><p>学的一些以前的基础知识点，函数、方法什么的，如果不经常使用复习的话，很快就忘记了，应该解决一下这个问题。</p><blockquote><p> 复习以往知识点还是要提上日程</p></blockquote><h5 id="three-关于CoreJava"><a href="#three-关于CoreJava" class="headerlink" title=":three:关于CoreJava"></a>:three:关于CoreJava</h5><p>看CoreJava :book: ，给自己规定了每天看10页左右，要二个多月能看完，差不多还能接受，当然进度提高一点最好。且不能光看书，要结合书中知识点实践代码。</p><blockquote><p>在github创建一个CoreJava仓库，将所有的例子分门别类的放进去，方便以后查看。</p></blockquote><h5 id="four-今天发现的小cookie"><a href="#four-今天发现的小cookie" class="headerlink" title=":four:今天发现的小cookie"></a>:four:今天发现的小cookie</h5><p>就是Markdown语法的<strong>emoji</strong></p><p><a href="https://github.com/guodongxiaren/README/blob/master/emoji.md" target="_blank" rel="noopener">emoji参考传送门</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL查询操作</title>
      <link href="/DataBase/MySQL-Query.html"/>
      <url>/DataBase/MySQL-Query.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-DQL查询语句"><a href="#1-DQL查询语句" class="headerlink" title="1. DQL查询语句"></a>1. DQL查询语句</h2><h3 id="1-1-排序"><a href="#1-1-排序" class="headerlink" title="1.1 排序"></a>1.1 排序</h3><ul><li>语法：<code>select 字段名 from 表名 order by 字段名1 [ASC|DESC],字段名2 [ASC|DESC]...;</code></li><li>排序方式：ASC(升序,默认值)；DESC(降序)。</li></ul><a id="more"></a><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 单列排序SELECT * FROM student2 ORDER BY math; # 以math为条件升序排序，默认升序SELECT * FROM student2 ORDER BY math DESC; # 以math为条件进行降序排序# 组合排序# 查询所有数据，在数学成绩升序排序的基础上，如果数学成绩相同在以英语成绩降序排序SELECT * FROM student2 ORDER BY math ASC,english DESC;</code></pre><blockquote><p>注意：同时对多个字段进行排序，如果第1字段相等，则按第2字段排序，依次类推。</p></blockquote><h3 id="1-2-聚合函数"><a href="#1-2-聚合函数" class="headerlink" title="1.2 聚合函数"></a>1.2 聚合函数</h3><p>将一列数据作为一个整体，进行纵向的计算，返回一个结果值。</p><ol><li>count：统计个数，一般选择非空的列(主键)</li><li>max：求最大值</li><li>min：求最小值</li><li>sum：求和</li><li>avg：求平均值</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 统计学生人数SELECT COUNT(id) AS 总人数 FROM student2;# 对english列统计个数SELECT COUNT(english) FROM student2; -- 7# 对english列统计个数,如果值为NULL，替换为0SELECT COUNT(IFNULL(english,0)) FROM student2; -- 8# 查询年龄大于20岁的人数SELECT COUNT(*) FROM student2 WHERE age&gt;20;# 查询数学成绩总分SELECT SUM(math) AS 数学成绩总分 FROM student2;# 查询数学成绩平均分SELECT AVG(math) AS 数学平均分 FROM student2;# 查询数学成绩最高分SELECT MAX(math) AS 数学最高分 FROM student2;# 查询数学最低分SELECT MIN(math) AS 数学最低分 FROM student2;</code></pre><p>IFNULL(列名，默认值)：如果列名不为空，返回该列值。如果为NULL，则返回默认值。</p><blockquote><p>聚合函数的计算排除了NULL值,可以选择非空列进行计算或者使用IFNULL函数</p></blockquote><h3 id="1-3-分组"><a href="#1-3-分组" class="headerlink" title="1.3 分组"></a>1.3 分组</h3><p>分组查询是指使用<code>group by</code> 语句对查询信息进行分组，相同数据作为一组。</p><p><code>select 字段1,字段2... from 表名 group by 分组字段[HAVING 条件];</code></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 按性别进行分组，求男女生的数学平均分。SELECT sex,AVG(math) FROM student2 GROUP BY sex; # 当我们使用某个字段分组，在查询时也需要将这个字段查询出来，否则看不大数据属于哪组的&#x2F;*group by 将分组字段结果中相同内容作为一组，并且返回每组的第一条数据。单独分组没用，分组的目的就是为了统计，所以一般分组会跟聚合函数一起使用。*&#x2F;# 查询男女各有多少人SELECT sex,COUNT(*)男女各有多少人 FROM student2 GROUP BY sex; # 分组函数会先查询所有数据，按性别分组，然后统计每组人数# 查询年龄大于25岁的人，按照性别分组，统计每组人数SELECT sex,COUNT(*)年龄大于25岁人数 FROM student2 WHERE age&gt;25 GROUP BY sex;# 查询年龄大于25岁的人，按性别分组，统计每组的人数，并只显示性别人数大于 2 的数据(使用having条件控制)SELECT sex,COUNT(*)年龄大于25岁人数且人数大于2的 FROM student2 WHERE age&gt;25 GROUP BY sex HAVING COUNT(*)&gt;2; # 该SQL语句会先过滤掉年龄小于25岁的人，在按照性别分组，然后统计每组人数，最后显示性别人数大于2的数据</code></pre><h4 id="having与where的区别"><a href="#having与where的区别" class="headerlink" title="having与where的区别"></a>having与where的区别</h4><table><thead><tr><th>子句</th><th>作用</th></tr></thead><tbody><tr><td>where子句</td><td>对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据。where后面不可以使用聚合函数。</td></tr><tr><td>having子句</td><td>该子句的作用是筛选满足条件的组，即在分组之后过滤数据。having后面可以使用聚合函数。</td></tr></tbody></table><h3 id="1-4-limit语句"><a href="#1-4-limit语句" class="headerlink" title="1.4 limit语句"></a>1.4 limit语句</h3><p>limit是限制的意思，作用就是限制查询记录的条数。</p><p>语句：<code>select 字段列表 from 表名 [where子句][group by子句][limit offset(默认0),length];</code></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 查询学生表中数据，从第三条开始，显示6条。SELECT * FROM student2 LIMIT 2,6;# 使用场景：分页，一般使用在类似淘宝商品信息分页。</code></pre><h2 id="2-数据库的备份和还原"><a href="#2-数据库的备份和还原" class="headerlink" title="2. 数据库的备份和还原"></a>2. 数据库的备份和还原</h2><h3 id="2-1-备份格式"><a href="#2-1-备份格式" class="headerlink" title="2.1 备份格式"></a>2.1 备份格式</h3><p>在DOS下，使用语句：<code>mysqldump -u用户名 -p密码 数据库&gt;文件路径</code></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-powershell"># 备份db4数据库中数据到本地db4.sql文件中mysqldump -uroot -p123456 db4 &gt; C:\Java\JavaWeb\db4.sql</code></pre><h3 id="2-2-还原格式"><a href="#2-2-还原格式" class="headerlink" title="2.2 还原格式"></a>2.2 还原格式</h3><p>mysql中的命令，登录后使用：<code>use 数据库; source 导入文件的路径;</code></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">&#x2F;*还原步骤：    1. 删除db4数据库中的所有表    2. 登录mysql，选中数据库    3. 使用source 命令还原数据    4. 查看还原情况*&#x2F;use db4;source C:\Java\JavaWeb\db4.sql;</code></pre><h2 id="3-数据库表的约束"><a href="#3-数据库表的约束" class="headerlink" title="3. 数据库表的约束"></a>3. 数据库表的约束</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>对表中的数据进行限制，保证数据的正确性、有效性和完整性。一个表如果添加了约束，不正确的数据将无法插入到表中。约束在创建表的时候添加比较合适。</p><h3 id="3-2-约束种类"><a href="#3-2-约束种类" class="headerlink" title="3.2 约束种类"></a>3.2 约束种类</h3><table><thead><tr><th>约束名</th><th>约束关键字</th></tr></thead><tbody><tr><td>主键</td><td>primary key</td></tr><tr><td>唯一</td><td>unique</td></tr><tr><td>非空</td><td>not null</td></tr><tr><td>外键</td><td>foreign key</td></tr><tr><td>检查约束</td><td>check，注：mysql不支持</td></tr></tbody></table><h3 id="3-3-主键"><a href="#3-3-主键" class="headerlink" title="3.3 主键"></a>3.3 主键</h3><p>用来唯一标识数据库中的每一条记录。通常不用业务字段作为主键，而是单独给每张表设计一个id的字段，把id作为主键。</p><ul><li>主键关键字：primary key</li><li>主键特点：非空(not null)且唯一</li></ul><h4 id="创建主键"><a href="#创建主键" class="headerlink" title="创建主键"></a>创建主键</h4><ol><li>在创建表时给字段添加主键：<code>字段名 字段类型 PRIMARY KEY;</code></li><li>在已有表中添加主键：<code>alter table 表名 add primary key(字段名);</code></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 创建表时添加create table student3(id int primary key; # id设为主键    name varchar(20);    age int);# 删除主键alter table student3 drop primary key;# 在已有表中添加主键alter table student3 add primary key(id);</code></pre><h4 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h4><p>可以使用<code>auto_increment</code>将主键字段设置为自增，数据库会自动生成主键字段值。</p><h4 id="修改自增长默认起始值"><a href="#修改自增长默认起始值" class="headerlink" title="修改自增长默认起始值"></a>修改自增长默认起始值</h4><p>默认地 AUTO_INCREMENT 的开始值是 1，如果希望修改起始值,可以使用如下SQL语句。</p><ul><li>创建表时指定起始值</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">create table 表名(列名 int primary key auto_increment,)auto_increment=起始值;</code></pre><ul><li>创建表后修改起始值</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">alter table 表名 auto_increment=10;</code></pre><h4 id="delete和truncate对自增长的影响"><a href="#delete和truncate对自增长的影响" class="headerlink" title="delete和truncate对自增长的影响"></a>delete和truncate对自增长的影响</h4><ul><li>delete：删除所有的记录后，自增长没有影响。</li><li>truncate：删除后，自增长初始值重新开始了。</li></ul><h3 id="3-4-唯一约束"><a href="#3-4-唯一约束" class="headerlink" title="3.4 唯一约束"></a>3.4 唯一约束</h3><p>用以约束表中某一列不能出现重复的值</p><ul><li>语法：<code>字段名 字段类型 unique</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 创建学生表4，包含字段(id, name),name 这一列设置唯一约束,不能出现同名的学生CREATE TABLE student4(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(255) UNIQUE);# 添加学生INSERT INTO student4(NAME) VALUES(&#39;xiaohua&#39;);INSERT INTO student4(NAME) VALUES(&#39;xiaohua&#39;); # 错误代码： 1062 Duplicate entry &#39;xiaohua&#39; for key &#39;name&#39;# 测试插入nullINSERT INTO student4(NAME) VALUES(NULL); # 不会报错，因为null无数据</code></pre><h3 id="3-5-非空约束"><a href="#3-5-非空约束" class="headerlink" title="3.5 非空约束"></a>3.5 非空约束</h3><p>用于约束某一列不能为null</p><p>语法：<code>字段名 字段类型 not null</code></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 创建表学生表5, 包含字段(id,name,gender)其中 name 不能为 NULLCREATE TABLE student5(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(100) NOT NULL,gender CHAR(1));# 添加一条记录其中姓名不赋值INSERT INTO student5(NAME,gender) VALUES(NULL,&#39;man&#39;); # 错误代码： 1048 Column &#39;name&#39; cannot be null</code></pre><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>我们可以为字段指定默认值</p><p>语法：<code>字段名 字段类型 default 默认值</code></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 创建一个学生表6，包含字段(id,name,address)， 地址默认值是广州CREATE TABLE student6(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20),address VARCHAR(50) DEFAULT &#39;杭州&#39;);-- 添加一条记录,使用默认地址INSERT INTO student6(NAME,address) VALUES(&#39;xiaozhang&#39;,DEFAULT);-- 添加一条记录,不使用默认地址INSERT INTO student6(NAME,address) VALUES(&#39;xiaohua&#39;,&#39;上海&#39;);</code></pre><blockquote><p>Tips: 如果一个字段设置了非空和唯一约束，那么该字段与主键有什么区别？</p><ol><li>主键在一个表中只能有一个。</li><li>自增长只能用在主键上。</li></ol></blockquote><h3 id="3-6-外键约束"><a href="#3-6-外键约束" class="headerlink" title="3.6 外键约束"></a>3.6 外键约束</h3><p><strong>单表的缺点</strong>：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 创建一个员工表包含如下列(id, name, age, dep_name, dep_location),id 主键并自动增长,添加 5 条数据CREATE TABLE emp (    id INT PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(30),    age INT,    dep_name VARCHAR(30),    dep_location VARCHAR(30));# 添加数据INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;张三&#39;, 20, &#39;研发部&#39;, &#39;广州&#39;);INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;李四&#39;, 21, &#39;研发部&#39;, &#39;广州&#39;);INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;王五&#39;, 20, &#39;研发部&#39;, &#39;广州&#39;);INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;老王&#39;, 20, &#39;销售部&#39;, &#39;深圳&#39;);INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;大王&#39;, 22, &#39;销售部&#39;, &#39;深圳&#39;);INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;小王&#39;, 18, &#39;销售部&#39;, &#39;深圳&#39;);</code></pre><ul><li>上数据表的缺点: 一是数据冗余，二是后期可能出现的增删改问题。</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 将上述数据表分成两张表，部门表\员工表-- 创建部门表(id,dep_name,dep_location)-- 主表，一对多CREATE TABLE department(id INT PRIMARY KEY AUTO_INCREMENT,dep_name VARCHAR(20),dep_location VARCHAR(20));-- 创建员工表(id,name,age,dep_id)-- 从表,多对一CREATE TABLE employee(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20),age INT,dep_id INT -- 外键对应主表的主键);-- 添加两个部门INSERT INTO department VALUES(NULL, &#39;研发部&#39;,&#39;广州&#39;),(NULL, &#39;销售部&#39;, &#39;深圳&#39;);-- 添加员工，dep_id 表示员工所在部门INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;张三&#39;, 20, 1);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;李四&#39;, 21, 1);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;王五&#39;, 20, 1);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;老王&#39;, 20, 2);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;大王&#39;, 22, 2);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;小王&#39;, 18, 2);</code></pre><p>但是如果我们在employee的dep_id里面输入不存在的部门，数据仍然可以添加，所以要规范dep_id中的数据只能是department表中存在的id。故可以使用外键约束来解决该问题</p><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><ul><li>外键：在从表中与主表主键对应的那一列，称为外键。例上从表中的dep_id</li><li>主表：一方，用来约束别人的表</li><li>从表：多方，被别人约束的表</li><li>创建约束语法：<ul><li>新建表时增加外键：<code>[CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名)</code></li><li>已有表增加外键：<code>ALTER TABLE 从表 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主键字段名);</code></li></ul></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">DROP TABLE employee;-- 创建从表 employee 并添加外键约束 emp_depid_fk-- 多方，从表CREATE TABLE employee(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20),age INT,dep_id INT, -- 外键对应主表的主键-- 创建外键约束CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id));-- 正常添加数据INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;张三&#39;, 20, 1);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;李四&#39;, 21, 1);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;王五&#39;, 20, 1);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;老王&#39;, 20, 2);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;大王&#39;, 22, 2);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;小王&#39;, 18, 2);-- 插入数据，指定一个不存在的部门值INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;老板&#39;, 35, 6); # 错误代码： 1452 Cannot add or update a child row: a foreign key constraint fails (`db4`.`employee`, CONSTRAINT `emp_depid_fk` FOREIGN KEY (`dep_id`) REFERENCES `department` (`id`))</code></pre><h4 id="删除外键"><a href="#删除外键" class="headerlink" title="删除外键"></a>删除外键</h4><ul><li>语法：<code>ALTER TABLE 从表 drop foreign key 外键名称;</code></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 删除employee表的emp_depid_fk外键ALTER TABLE employee DROP FOREIGN KEY emp_depid_fk;-- 在 employee 表存在的情况下添加外键ALTER TABLE employee ADD CONSTRAINT emp_depid_fk FOREIGN KEY(dep_id) REFERENCES department(id);</code></pre><h4 id="外键的级联"><a href="#外键的级联" class="headerlink" title="外键的级联"></a>外键的级联</h4><ul><li>级联操作：在修改和删除主表的主键时，同时更新或删除副表的外键值，称为级联操作。</li></ul><table><thead><tr><th>级联操作语法</th><th>描述</th></tr></thead><tbody><tr><td>ON UPDATE CASCADE</td><td>级联更新，只能是创建表的时候创建级联关系。更新主表中的主键，从表中的外键列也自动同步更新</td></tr><tr><td>ON DELETE CASCADE</td><td>级联删除</td></tr></tbody></table><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">--  删除 employee 表，重新创建 employee 表，添加级联更新和级联删除DROP TABLE employee;CREATE TABLE employee(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20),age INT,dep_id INT, -- 外键对应主表的主键-- 创建外键约束CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id) ON UPDATE CASCADE ON DELETE CASCADE # 添加级联更新和级联删除);-- 再次添加数据到员工表和部门表INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;张三&#39;, 20, 1);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;李四&#39;, 21, 1);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;王五&#39;, 20, 1);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;老王&#39;, 20, 2);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;大王&#39;, 22, 2);INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;小王&#39;, 18, 2);DROP TABLE department; # Cannot delete or update a parent row: a foreign key constraint fails# 把部门表中 id 等于 1 的部门改成 id 等于 10UPDATE department SET id=10 WHERE id=1; # 1 queries executed, 1 success, 0 errors, 0 warnings-- 删除部门号是 2 的部门DELETE FROM department WHERE id=2;</code></pre><h3 id="3-7-数据约束小结"><a href="#3-7-数据约束小结" class="headerlink" title="3.7 数据约束小结"></a>3.7 数据约束小结</h3><table><thead><tr><th>约束名</th><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>主键</td><td>primary key</td><td>唯一且非空</td></tr><tr><td>默认</td><td>default</td><td>如果一列没有值，使用默认值</td></tr><tr><td>非空</td><td>not null</td><td>这一列必须有值</td></tr><tr><td>唯一</td><td>unique</td><td>这一列不能有重复值</td></tr><tr><td>外键</td><td>foreign key</td><td>主表中主键列，在从表中外键列</td></tr></tbody></table><h2 id="4-表与表之间的关系"><a href="#4-表与表之间的关系" class="headerlink" title="4. 表与表之间的关系"></a>4. 表与表之间的关系</h2><table><thead><tr><th>表与表之间的三种关系</th></tr></thead><tbody><tr><td>一对多：最常用的关系 部门和员工</td></tr><tr><td>多对多：学生选课表 和 学生表， 一门课程可以有多个学生选择，一个学生选择多门课程</td></tr><tr><td>一对一：相对使用比较少。员工表 简历表， 公民表 护照表</td></tr></tbody></table><h3 id="4-1-一对多"><a href="#4-1-一对多" class="headerlink" title="4.1 一对多"></a>4.1 一对多</h3><p>一对多(1:n) 例如：班级和学生，部门和员工，客户和订单，分类和商品</p><p>一对多建表原则: 在从表(多方)创建一个字段,字段作为外键指向主表(一方)的主键</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/20/oneToMany-1558281810598.jpg" alt="title"></p><h3 id="4-2-多对多"><a href="#4-2-多对多" class="headerlink" title="4.2 多对多"></a>4.2 多对多</h3><p>多对多(m:n) 例如：老师和学生，学生和课程，用户和角色</p><p>多对多关系建表原则: 需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主 键。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/20/ManyToMany-1558281920649.jpg" alt="title"></p><h3 id="4-3-一对一"><a href="#4-3-一对一" class="headerlink" title="4.3 一对一"></a>4.3 一对一</h3><p>一对一（1:1） 可以在任意一方添加外键指向另一方的主键。</p><p>两种建表原则：</p><ol><li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一 UNIQUE</li><li>外键是主键：主表的主键和从表的主键，形成主外键关系</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/20/OneToOne-1558282085899.jpg" alt="title"></p><h3 id="4-4-综合案例"><a href="#4-4-综合案例" class="headerlink" title="4.4 综合案例"></a>4.4 综合案例</h3><p>根据途牛网的旅游分类、旅游航线等信息设计数据库表结构</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/20/tuniu-1558320997129.jpg" alt="title"></p><h4 id="SQL语句实现"><a href="#SQL语句实现" class="headerlink" title="SQL语句实现"></a>SQL语句实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">&#x2F;*1. 创建旅游线路分类表，tab_categorycid 主键，自增cname 分类名称，唯一，*&#x2F;CREATE TABLE tab_category(cid INT PRIMARY KEY AUTO_INCREMENT,cname VARCHAR(100) UNIQUE);&#x2F;*2. 创建航线route表rid ，旅游线路主键，自增rname 旅游线路名称，非空唯一，price 价格rdate 上架时间，cid 外键*&#x2F;CREATE TABLE tab_route(rid INT PRIMARY KEY AUTO_INCREMENT,rname VARCHAR(100) UNIQUE NOT NULL,price DOUBLE,rdate DATE,cid INT,FOREIGN KEY(cid) REFERENCES tab_category(cid) -- 外键指向主表主键);&#x2F;*3. 创建用户表 tab_useruid 用户主键，自增长username 用户名长度 100，唯一，非空password 密码长度 30，非空name 真实姓名长度 100birthday 生日sex 性别，定长字符串 1telephone 手机号，字符串 11email 邮箱，字符串长度 100*&#x2F;CREATE TABLE tab_user(uid INT PRIMARY KEY AUTO_INCREMENT,username VARCHAR(100) UNIQUE NOT NULL,PASSWORD VARCHAR(30) NOT NULL,NAME VARCHAR(100),birthday DATE,sex CHAR(1) DEFAULT &#39;男&#39;,telephone VARCHAR(11),email VARCHAR(100));&#x2F;*4. 创建用户和航线的中间表，收藏表:创建收藏表 tab_favoriterid 旅游线路id,外键date 收藏时间uid 用户 id,外键rid 和 uid 不能重复,设置复合主键,同一个用户不能收藏同一个线路两次*&#x2F;CREATE TABLE tab_favorite(rid INT, -- 旅游线路idfavtime DATETIME,uid INT, -- 用户id-- 创建复合主键PRIMARY KEY(rid,uid),FOREIGN KEY(rid) REFERENCES tab_route(rid),FOREIGN KEY(uid) REFERENCES tab_user(uid));</code></pre><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/20/ExerciseCase-1558321667308.jpg" alt="title"></p><h3 id="4-5-表与表之间的关系小结"><a href="#4-5-表与表之间的关系小结" class="headerlink" title="4.5 表与表之间的关系小结"></a>4.5 表与表之间的关系小结</h3><table><thead><tr><th>表与表的关系</th><th>关系的维护</th></tr></thead><tbody><tr><td>一对多</td><td>主外键的关系</td></tr><tr><td>多对多</td><td>中间表，两个一对多</td></tr><tr><td>一对一</td><td>特殊一对多，从表中的外键设为唯一；从表的主键又是外键</td></tr></tbody></table><h2 id="6-数据库设计"><a href="#6-数据库设计" class="headerlink" title="6. 数据库设计"></a>6. 数据库设计</h2><ul><li>范式：好的数据库设计对数据的存储性能和后期的程序开发，都会产生重要的影响。建立科学的，规范的数据库就需要满足一些规则来优化数据的设计和存储，这些规则就称为范式。</li></ul><h3 id="6-1-三大范式"><a href="#6-1-三大范式" class="headerlink" title="6.1 三大范式"></a>6.1 三大范式</h3><ul><li>范式概念：设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式。各种范式呈递次规范，越高的范式数据库冗余越小。</li><li>六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</li></ul><p>满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了</p><h3 id="6-2-第一范式-1NF"><a href="#6-2-第一范式-1NF" class="headerlink" title="6.2  第一范式:1NF"></a>6.2  第一范式:1NF</h3><p>数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。简而言之，第一范式每一列不可再拆分，称为原子性。</p><h4 id="示例：班级表"><a href="#示例：班级表" class="headerlink" title="示例：班级表"></a>示例：班级表</h4><table><thead><tr><th>学号</th><th>姓名</th><th>班级</th></tr></thead><tbody><tr><td>1</td><td>小张</td><td>103班</td></tr><tr><td>2</td><td>小李</td><td>102班</td></tr><tr><td>3</td><td>小王</td><td>203班</td></tr></tbody></table><h3 id="6-3-第二范式：2NF"><a href="#6-3-第二范式：2NF" class="headerlink" title="6.3 第二范式：2NF"></a>6.3 第二范式：2NF</h3><p>在INF的前提下，非码属性必须完全依赖于码(在1NF基础上消除非主属性对主码的部分函数依赖)，即让表中的非主属性字段都<strong>完全依赖</strong>于主键。<br>所谓完全依赖是指不能存在仅依赖主键一部分的列。简而言之，第二范式就是在第一范式的基础上所有列完全依赖于主键列。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th><th>系主任</th><th>课程名称</th><th>分数</th></tr></thead><tbody><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>高等数学</td><td>95</td></tr><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>大学英语</td><td>87</td></tr><tr><td>10010</td><td>张无忌</td><td>经济系</td><td>张三丰</td><td>计算机基础</td><td>65</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>法理学</td><td>77</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>大学英语</td><td>87</td></tr><tr><td>10011</td><td>令狐冲</td><td>法律系</td><td>任我行</td><td>法律社会学</td><td>65</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>法律社会学</td><td>95</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>法理学</td><td>97</td></tr><tr><td>10012</td><td>杨过</td><td>法律系</td><td>任我行</td><td>大学英语</td><td>99</td></tr></tbody></table><ol><li>函数依赖：A–&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A。例：学号–&gt;姓名，通过学号可以确定唯一姓名值，故称姓名依赖于学号 ；(学号，课程名称) –&gt; 分数，通过学号+课程名称可以确定唯一分数值，故分数依赖于学号+课程名称。</li><li>完全函数依赖：A–&gt;B,如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。例：(学号，课程名称) –&gt; 分数，确定分数的值只能通过(学号+课程名称)属性组确定，故分数完全依赖于(学号+课程名称)。</li><li>部分函数依赖：A–&gt;B, 如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值即可。例如：(学号，课程名称) –&gt;姓名，姓名属性值可以通过学号查询，故称姓名属性值部分依赖于(学号，课程名称)属性组。</li><li>传递函数依赖：A—&gt;B, B—&gt;C, 如果通过A属性(属性组)的值，可以确定唯一的B属性值，在通过B属性值可以确定唯一C属性值，则称C传递函数依赖于A。例如：学号–&gt;系名，系名–&gt;系主任，通过学号属性值可以确定唯一系名，通过系名可以确定唯一系主任，那么就可以通过学号确定系主任，故称系主任传递依赖于学号。</li><li>码：如果在一张表中，一个属性或属性组，被其他所有属性完全依赖，则称这一属性或属性组为该表的码。例如：上表中的码为：(学号，课程名称)，通过该属性组可确定所有其他属性值，所有其他属性完全依赖于该属性组，故称为码。<ul><li>主属性：码属性组中的所有属性</li><li>非主属性：除码属性组外的属性</li></ul></li></ol><p><strong>第二范式的特点</strong>：</p><ol><li>一张表只描述一件事情。</li><li>表中的每一列都完全依赖于主键</li></ol><h3 id="6-4-第三范式：3NF"><a href="#6-4-第三范式：3NF" class="headerlink" title="6.4 第三范式：3NF"></a>6.4 第三范式：3NF</h3><p>在2NF基础上，任何非主属性不依赖于其他非主属性(在2NF基础上消除传递依赖)，即表中每一列都直接依赖于主键，而不是通过其他的列来间接依赖于主键，任何非主列不得传递依赖于主键。</p><p><strong>示例</strong>：</p><p>有如下学生信息表</p><table><thead><tr><th>学号</th><th>姓名</th><th>所在学院</th><th>学院地点</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>计算机系</td><td>杭州校区</td></tr></tbody></table><ul><li>存在传递依赖关系：学号–&gt;所在学院–&gt;学院地点</li><li>消除依赖，拆分成两张表</li></ul><p>学生表：<br>| 学号 | 姓名 | 所在学院编号(外键) |<br>| —- | —- | —————— |<br>| 1    | 小明 | 1                  |</p><p>学院表：<br>| 学院编号 | 学院地点 |<br>| ——– | ——– |<br>| 1        | 杭州校区 |</p><h3 id="6-5-三大范式总结"><a href="#6-5-三大范式总结" class="headerlink" title="6.5 三大范式总结"></a>6.5 三大范式总结</h3><table><thead><tr><th>范式</th><th>特点</th></tr></thead><tbody><tr><td>1NF</td><td>原子性：表中每列不可再拆分</td></tr><tr><td>2NF</td><td>不产生局部依赖，一张表只描述一件事情</td></tr><tr><td>3NF</td><td>不产生传递依赖，表中每一列都直接依赖于主键。而不是通过其他列间接依赖于主键。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/DataBase/MySQL-Basic.html"/>
      <url>/DataBase/MySQL-Basic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-数据库基本概念"><a href="#1-数据库基本概念" class="headerlink" title="1. 数据库基本概念"></a>1. 数据库基本概念</h2><p>数据库(DataBase)，简称DB，用于存储和管理数据的仓库。</p><p>数据库的特点：</p><ol><li>持久化存储数据。数据库其实就是一个文件系统。</li><li>方便存储和管理数据。</li><li>使用了统一的方式操作数据库。</li></ol><a id="more"></a><p><a href="http://note.youdao.com/noteshare?id=3490275e3fa4e6d37fc8bedd3794aa1f&amp;sub=7A387FC8255F4099AB24DCF98198C0E3" target="_blank" rel="noopener">安装MySQL</a></p><p><a href="http://note.youdao.com/noteshare?id=fe0558c8d90f7a4a831785455a30a8ac&amp;sub=WEB2676b40c253e961e9a2574607287e12f" target="_blank" rel="noopener">MySQL基本操作</a></p><blockquote><p>Tips：在MySQL中，数据库等于文件夹，表等于文件，数据就是数据。</p></blockquote><h3 id="2-SQL语句"><a href="#2-SQL语句" class="headerlink" title="2. SQL语句"></a>2. SQL语句</h3><p>Structured Query Language(结构化查询语句)，简称SQL。</p><p>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在异同的地方。</p><h4 id="2-1-SQL通用语法"><a href="#2-1-SQL通用语法" class="headerlink" title="2.1 SQL通用语法"></a>2.1 SQL通用语法</h4><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>可以使用空格和缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释方式：<ul><li>单行注释：– 注释内容 或 # 注释内容(MySQL特有)</li><li>多行注释：/*  注释内容  */</li></ul></li></ol><h3 id="2-2-SQL分类"><a href="#2-2-SQL分类" class="headerlink" title="2.2 SQL分类"></a>2.2 SQL分类</h3><ol><li>数据定义语言(Data Definition Language)，简称<strong>DDL</strong>。用来定义数据库对象：数据库、表、列等。关键字：create、drop、alter等。</li><li>数据操作语言(Data Manipulation Language)，简称<strong>DML</strong>。用来对数据库中表的数据进行增删改。关键字：insert、delete、update等。</li><li>数据查询语言(Data Query Language)，简称<strong>DQL</strong>。用以查询数据库中表的记录(数据)。关键字：select，where等。</li><li>数据控制语言(Data Control Language)，简称<strong>DCL</strong>。用来定义数据库的访问权限和安全级别，以及创建用户。关键字：GRANT,REVOKE等。</li></ol><h4 id="DDL：操作数据库、表"><a href="#DDL：操作数据库、表" class="headerlink" title="DDL：操作数据库、表"></a>DDL：操作数据库、表</h4><p><strong>操作数据库： CRUD</strong></p><h5 id="1-C-Create-创建"><a href="#1-C-Create-创建" class="headerlink" title="1. C(Create):创建"></a>1. C(Create):创建</h5><ul><li>创建数据库：<code>create databases 数据库名称;</code></li><li>创建数据库，判断不存在才创建：<code>create database if not exists 数据库名称;</code></li><li>创建数据库，指定字符集：<code>create database 数据库名称 character set 字符集名;</code></li><li>例：创建db4数据库，判断是否存在，并指定字符集为gbk：<code>create database if not exists db4 character set gbk;</code></li></ul><h5 id="2-R-Retrieve-查询"><a href="#2-R-Retrieve-查询" class="headerlink" title="2. R(Retrieve):查询"></a>2. R(Retrieve):查询</h5><ul><li>查询所有数据库名称：<code>show databases;</code></li><li>查询某个数据库的创建语句和字符集：<code>show create database 数据库名称;</code></li></ul><h5 id="3-U-Update-修改"><a href="#3-U-Update-修改" class="headerlink" title="3. U(Update):修改"></a>3. U(Update):修改</h5><ul><li>修改数据库的字符集:<code>alter database 数据库名称 character set 字符集名称;</code></li></ul><h5 id="4-D-Delete-删除"><a href="#4-D-Delete-删除" class="headerlink" title="4. D(Delete):删除"></a>4. D(Delete):删除</h5><ul><li>删除数据库：<code>drop database 数据库名称;</code></li><li>判断数据库存在才删除：<code>drop database if exists 数据库名称;</code></li></ul><h5 id="5-使用数据库"><a href="#5-使用数据库" class="headerlink" title="5. 使用数据库"></a>5. 使用数据库</h5><ul><li>查询当前正在使用的数据库名称：<code>select database();</code></li><li>使用数据库：<code>use 数据库名称;</code></li></ul><p><strong>操作表：CRUD</strong></p><h5 id="1-C-Create-：创建"><a href="#1-C-Create-：创建" class="headerlink" title="1. C(Create)：创建"></a>1. C(Create)：创建</h5><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">create table 表名(列名1 数据类型1,    列名2 数据类型2,    ... ...    列名n 数据类型n); # 注意：最后一列，不需要加逗号&#39;,&#39;&#x2F;*    常用数据库类型:    1. int：整数类型。例：`age int`    2. double：小数类型。例：`score double(5,2)`    3. date：日期(年月日)。例：`date yyyy-MM-dd`    4. datetime：日期(年月日时分秒)。例：`date yyyy-MM-dd HH:mm:ss`    5. timestamp：时间戳类型(年月日时分秒)。如不赋值，则默认使用当前系统时间，来自动赋值。    6. varchar：字符串类型。例：`name`*&#x2F;</code></pre><blockquote><p>Tips: 如果想复制一张表，可以使用<code>create table 表名 like 被复制表名;</code></p></blockquote><h5 id="2-R-Retrieve-：查询"><a href="#2-R-Retrieve-：查询" class="headerlink" title="2. R(Retrieve)：查询"></a>2. R(Retrieve)：查询</h5><ul><li>查询某个数据库中所有表的名称：<code>show tables;</code></li><li>查询表结构：<code>desc 表名;</code></li></ul><h5 id="3-U-Update-：修改"><a href="#3-U-Update-：修改" class="headerlink" title="3. U(Update)：修改"></a>3. U(Update)：修改</h5><ol><li>修改表名：<code>alter table 表名 rename to 新的表名;</code></li><li>修改表的字符集：<code>alter table 表名 character set 字符集名称;</code></li><li>添加一列：<code>alter table 表名 add 列名 数据类型;</code></li><li>修改列名称：<code>alter table 表名 change 列名 新列名 新数据类型;</code></li><li>修改列数据类型：<code>alter table 表名 modify 列名 新数据类型;</code></li><li>删除列：<code>alter table 表名 dorp 列名;</code></li></ol><h5 id="4-D-Delete-：删除"><a href="#4-D-Delete-：删除" class="headerlink" title="4. D(Delete)：删除"></a>4. D(Delete)：删除</h5><ul><li>删除表：<code>drop table 表名;</code></li><li>判断表存在才删除：<code>drop table if exists 表名;</code></li></ul><h4 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h4><p><strong>1. 添加数据</strong></p><ul><li>语法：<code>insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);</code></li><li>注意事项：列名和值要一一对应；如果表名后面不定义列名，则默认给所有列添加值；除了数字类型，其他类型需要使用单双引号引起来。</li></ul><p><strong>2. 删除数据</strong></p><ul><li>语法：<code>delete from 表名 [where 条件]</code></li><li>注意事项：如果不指定条件，则删除表中所有记录；如果要删除表所有记录，推荐使用<code>TRUNCATE TABLE 表名;</code></li></ul><p><strong>3. 修改数据</strong></p><ul><li>语法：<code>update 表名 set 列名1=值1,列名2=值2,...[where 条件];</code></li><li>注意：如果不加任何条件，则会将表中所有记录全部修改。</li></ul><h4 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h4><p><strong>简单查询</strong>：</p><ol><li>查询表所有行和列的数据：<code>select * from 表名;</code></li><li>查询指定列：<code>select 字段名1,字段名2,...from 表名;</code></li><li>指定列/表的别名进行查询：<code>select 字段名1 AS 别名1,字段名2 AS 别名2,... from 表名 AS 表别名;</code>  </li></ol><blockquote><p>Tips: 表使用别名一般用于多表查询操作。</p></blockquote><p><strong>清除重复值</strong>：</p><p>查询指定列并且结果不出现重复数据：<code>select distinct 字段名 from 表名;</code></p><p><strong>查询结果参与运算</strong>：</p><ol><li>某列数据和固定值运算：<code>select 列名1+固定值 from 表名;</code></li><li>某列数据和其他列数据参与运算：<code>select 列名1+列名2 from 表名;</code></li></ol><blockquote><p>注意：参与运算的必须是数值类型</p></blockquote><p>SQL语句示例：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">&#x2F;*给student表添加数学、英语成绩列，给每条记录添加对应的数学和英语成绩，查询时将数学和英语的成绩相加显示。*&#x2F;SELECT * FROM student;ALTER TABLE student ADD math INT; # 添加数学列ALTER TABLE student ADD english INT; # 添加英语列-- 两位同学添加数学英语成绩UPDATE `student` SET `math` = &#39;86&#39; , `english` = &#39;94&#39; WHERE `age` = &#39;19&#39; AND `name` = &#39;xiaoming&#39; AND `math` IS NULL AND `english` IS NULL;UPDATE `student` SET `math` = &#39;79&#39; , `english` = &#39;88&#39; WHERE `age` = &#39;18&#39; AND `name` = &#39;xiaohua&#39; AND `math` IS NULL AND `english` IS NULL;-- 给所有数学加5分SELECT math+5 FROM student;-- 查询math+english的和SELECT math+english FROM student;-- 查询总成绩，并使用别名显示SELECT *,(math+english) AS 总成绩 FROM student;</code></pre><p><strong>条件查询</strong>：</p><p>根据指定查询条件，对信息进行过滤显示，语句：<code>select 字段名 from 表名 where 条件;</code></p><ul><li>SQL语句示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql">-- 创建一个学生表，包含如下列：CREATE TABLE student2(id INT, -- 编号NAME VARCHAR(20), # 姓名age INT, -- 年龄sex VARCHAR(5), # 性别address VARCHAR(100), -- 地址math INT, # 数学english INT -- 英语);INSERT INTO student2(id,NAME,age,sex,address,math,english) VALUES(1,&#39;马云&#39;,55,&#39;男&#39;,&#39;杭州&#39;,66,78),(2,&#39;马化腾&#39;,45,&#39;女&#39;,&#39;深圳&#39;,98,87),(3,&#39;马景涛&#39;,55,&#39;男&#39;,&#39;香港&#39;,56,77),(4,&#39;柳岩&#39;,20,&#39;女&#39;,&#39;湖南&#39;,76,65),(5,&#39;柳青&#39;,20,&#39;男&#39;,&#39;湖南&#39;,86,NULL),(6,&#39;刘德华&#39;,57,&#39;男&#39;,&#39;香港&#39;,99,99),(7,&#39;马德&#39;,22,&#39;女&#39;,&#39;香港&#39;,99,99),(8,&#39;德玛西亚&#39;,18,&#39;男&#39;,&#39;南京&#39;,56,65);</code></pre><ul><li>运算符</li></ul><table><thead><tr><th>比较运算符</th><th>说明</th></tr></thead><tbody><tr><td>&gt;、&lt;、&lt;=、&gt;=、=、&lt;&gt;</td><td>&lt;&gt;在SQL中表示不等于，在sql中也可以使用!=，没有==</td></tr><tr><td>BETWEEN…AND</td><td>在一个范围之内，如：between 100 and 200 相当于条件在100到200之间。</td></tr><tr><td>IN(集合)</td><td>集合表示多个值，使用逗号分隔</td></tr><tr><td>LIKE’张%’</td><td>模糊查询</td></tr><tr><td>IS NULL</td><td>查询某一列为NULL的值，注：不能写=NULL</td></tr></tbody></table><ul><li>操作示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 查询math分数大于80分的学生SELECT * FROM student2 WHERE math&gt;80;# 查询english分数小于或等于80分的学生SELECT * FROM student2 WHERE english &lt;=80;# 查询age等于20岁的学生SELECT * FROM student2 WHERE age=20;# 查询age不等于20岁的学生，注：不等于有两种写法SELECT * FROM student2 WHERE age&lt;&gt;20;SELECT * FROM student2 WHERE age!=20;</code></pre><ul><li>逻辑运算符</li></ul><table><thead><tr><th style="text-align:left">逻辑运算符</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">and 或 &amp;&amp;</td><td>与，SQL中建议使用前者，后者不通用。</td></tr><tr><td style="text-align:left">or 或 x</td><td>或</td></tr><tr><td style="text-align:left">not 或 !</td><td>非</td></tr></tbody></table><blockquote><p> x ： <code>||</code></p></blockquote><ul><li>操作示例</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 查询age大于35且性别为男的学生SELECT * FROM student2 WHERE age&gt;35 AND sex=&#39;男&#39;;# 查询age大于35或性别为男的学生SELECT * FROM student2 WHERE age&gt;35 OR sex=&#39;男&#39;;# 查询id是1或3或5的学生SELECT * FROM student2 WHERE id=1 OR id=3 OR id=5;</code></pre><ul><li><p>in 关键字</p><p>in里面的每个数据都会作为一次条件，只要满足条件就会显示：<code>select 字段名 from 表名 where 字段 in(数据1，数据2,...);</code></p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 查询id是1或3或5的学生，使用inSELECT * FROM student2 WHERE id IN(1,3,5);# 查询id不是1或3或5的学生SELECT * FROM student2 WHERE id NOT IN(1,3,5);</code></pre><ul><li>范围查询</li></ul><p>表示从值1到值2范围，全部包含：<code>between 值1 and 值2</code></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 查询english成绩大于等于75，且小于等于90的学生SELECT * FROM student2 WHERE english BETWEEN 75 AND 90;</code></pre><ul><li>like关键字</li></ul><p>表示模糊查询:<code>select * from 表名 where 字段名 like &#39;通配符字符串;&#39;</code></p><p>通配符：<code>%,匹配任意多个字符串</code>; <code>_,匹配单个字符</code></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-sql"># 查询姓马的学生SELECT * FROM student2 WHERE NAME LIKE &#39;马%&#39;;# 查询姓名中包含&#39;德&#39;字的学生SELECT * FROM student2 WHERE NAME LIKE &#39;%德%&#39;;# 查询姓马，且姓名有两个字的学生SELECT * FROM student2 WHERE NAME LIKE &#39;马_&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit单元测试，反射和注解</title>
      <link href="/JavaBasics/reflect.html"/>
      <url>/JavaBasics/reflect.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Junit单元测试"><a href="#1-Junit单元测试" class="headerlink" title="1. Junit单元测试"></a>1. Junit单元测试</h2><h4 id="测试的分类："><a href="#测试的分类：" class="headerlink" title="测试的分类："></a>测试的分类：</h4><ol><li>黑盒测试：不需要写代码，给输入值，看输出值是否达到预期值。</li><li>白盒测试：要写代码。关注程序具体的执行流程。</li></ol><a id="more"></a><h4 id="Junit使用步骤"><a href="#Junit使用步骤" class="headerlink" title="Junit使用步骤"></a>Junit使用步骤</h4><ol><li>创建测试包(创建一个与被测试包同级的文件夹)</li><li>包内定义测试类(命名规范：被测试类名称+Test)</li><li>在测试类里面定义测试方法，如下图所示：</li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/16/Junit01-1557992450228.jpg" alt="title"></p><p><strong>参考资料</strong>：<a href="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/index.html" target="_blank" rel="noopener">Junit5基本使用</a></p><h4 id="部分断言方法"><a href="#部分断言方法" class="headerlink" title="部分断言方法"></a>部分断言方法</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/16/AssertMethod-1557993543134.jpg" alt="title"></p><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义计算类public class Calculator {    public int add(int a, int b){&#x2F;&#x2F;        int i = 3&#x2F;0;        return a - b; &#x2F;&#x2F; 故意写错，以测试accertEquals方法    }    public int sub(int a, int b){        return a - b;    }}&#x2F;&#x2F; 定义测试类import Junit.Calculator;import org.junit.jupiter.api.Test; &#x2F;&#x2F; Junit5改进后，所有方法都在jupiter.api下import org.junit.jupiter.api.Assertions; public class CalculatorTest {    @BeforeAll &#x2F;&#x2F; 一般用于资源的申请    public void init(){        System.out.println(&quot;所有测试方法执行前自动执行&quot;);    }    @AfterAll &#x2F;&#x2F; 用于资源的释放    public void close(){        System.out.println(&quot;所有测试方法结束后自动执行&quot;);    }    @Test    public void testAdd(){        Calculator c = new Calculator();        int add = c.add(1, 2);        &#x2F;&#x2F; 断言，我断言这个结果是3        Assertions.assertEquals(3,add); &#x2F;&#x2F; 不通过，报错，并显示红色    }    @Test    public void testSub(){        Calculator c = new Calculator();        int sub = c.sub(1, 2);        Assertions.assertEquals(-1,sub); &#x2F;&#x2F; 通过，显示绿色    }}</code></pre><h2 id="2-反射：框架设计的灵魂"><a href="#2-反射：框架设计的灵魂" class="headerlink" title="2. 反射：框架设计的灵魂"></a>2. 反射：框架设计的灵魂</h2><p>框架被称为半成品软件。我们可以在框架的基础上进行软件开发，简化编码。</p><p><strong>反射</strong>：将类的各个组成部分封装为其他对象，这就是反射机制</p><p>反射的好处：</p><ol><li>可以在程序运行过程中，操作这些对象。</li><li>可以解耦，提高程序的可扩展性。</li></ol><h3 id="2-1-获取Class对象的方式"><a href="#2-1-获取Class对象的方式" class="headerlink" title="2.1 获取Class对象的方式"></a>2.1 获取Class对象的方式</h3><ol><li><strong>Class.forName(“全类名”)</strong>：将字节码文件加载进内存，返回Class对象。多用于配置文件，将类名定义在配置文件中。来读取文件，加载类。</li><li><strong>类名.class</strong>：通过类名的属性class获取。多用于参数的传递。</li><li><strong>对象.getClass()</strong>：<code>getClass()</code>方法在<code>Object</code>类中定义，所以可以直接使用。多用于对象获取字节码的方式。</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ReflectDemoGetClass {    public static void main(String[] args) throws Exception {        &#x2F;&#x2F; 1.Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象。        Class cls1 = Class.forName(&quot;Demo5_16.reflect.Person&quot;);        System.out.println(cls1);        &#x2F;&#x2F; 2.类名.class：通过类名的属性class获取        Class cls2 = Person.class;        System.out.println(cls2);        &#x2F;&#x2F; 3. 对象.getClass()：`getClass()`方法在`Object`类中定义，所以可以直接使用        Class cls3 = new Person().getClass();        System.out.println(cls3);        &#x2F;&#x2F; 使用==比较对象内存地址        System.out.println(cls1 == cls2); &#x2F;&#x2F; true        System.out.println(cls2 == cls3); &#x2F;&#x2F; true    }}</code></pre><blockquote><p>Tips ：同一字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</p></blockquote><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/16/Java%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5-1558017486873.bmp" alt="Java代码在计算机中的三个阶段"></p><h3 id="2-2-Class对象的功能："><a href="#2-2-Class对象的功能：" class="headerlink" title="2.2 Class对象的功能："></a>2.2 Class对象的功能：</h3><ol><li><p>获取成员变量</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 四种方式获取成员变量Filed[] getFields() &#x2F;&#x2F; 获取所有public修饰的成员变量Filed getFiled(String name) &#x2F;&#x2F; 获取public修饰的指定名称的成员变量Field[] getDeclaredFields() &#x2F;&#x2F; 获取所有的成员变量,不考虑修饰符Filed getDeclaredField(String name) &#x2F;&#x2F; 获取指定名称的成员变量,如果不是public修饰的成员变量，可以使用暴力反射获取&#x2F;&#x2F; 示例代码如下:&#x2F;&#x2F; Person类public class Person {    private String name;    private int age;    public String a;    protected String b;    public String c;    private String d;&#x2F;&#x2F; 忽略get\set等方法    }public class ReflectDemo01 {    public static void main(String[] args) throws Exception{        &#x2F;&#x2F; 获取Person的Class对象        Class&lt;Person&gt; personClass = Person.class;        &#x2F;&#x2F; 获取成员变量        &#x2F;&#x2F; 1. Field[] getFields() 获取所有public修饰的成员变量        Field[] fields = personClass.getFields();        for (Field f:fields)            System.out.println(f); &#x2F;&#x2F; public java.lang.String reflect.Person.a        &#x2F;&#x2F; 2.Field getFiled(String name) &#x2F;&#x2F; 获取public修饰的指定名称的成员变量        Field a = personClass.getField(&quot;a&quot;);        &#x2F;&#x2F; 获取成员变量a的值        Person p = new Person();        Object value = a.get(p);        System.out.println(value); &#x2F;&#x2F; null        &#x2F;&#x2F; 设置a的值        a.set(p,&quot;小明&quot;);        System.out.println(p);        &#x2F;&#x2F; 3. Field[] getDeclaredFields() : 获取所有的成员变量,不考虑修饰符        Field[] declaredFields = personClass.getDeclaredFields();        for (Field f:declaredFields)            System.out.println(f);        &#x2F;&#x2F; 4. Filed getDeclaredField(String name) : 获取指定名称的成员变量        Field d = personClass.getDeclaredField(&quot;d&quot;);        &#x2F;&#x2F; 忽略访问权限修饰符的安全检查        d.setAccessible(true); &#x2F;&#x2F; 暴力反射        System.out.println(d.get(p)); &#x2F;&#x2F; null    }}</code></pre></li><li><p>获取构造方法</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 四种方式获取构造方法Constructor&lt;?&gt;[] getConstructors() &#x2F;&#x2F; 获取所有的public修饰的构造方法Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 获取指定的public修饰的构造方法Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 获取所有的构造方法，忽略修饰符Constructor&lt;?&gt;[] getDeclaredConstructor() &#x2F;&#x2F; 获取指定名称的构造方法，非public修饰的可使用暴力反射获取&#x2F;&#x2F; 代码举例public class ReflectDemo02 {    public static void main(String[] args) throws Exception{        &#x2F;&#x2F; 获取Person的Class对象        Class&lt;Person&gt; personClass = Person.class;        &#x2F;&#x2F; 1. Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)        &#x2F;&#x2F; 获取构造器        Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, int.class);&#x2F;&#x2F;        System.out.println(constructor); &#x2F;&#x2F; public reflect.Person(java.lang.String,int)        &#x2F;&#x2F; 使用构造器创建对象实例        Person person = constructor.newInstance(&quot;小明&quot;,22);        System.out.println(person);        &#x2F;&#x2F; 如果使用空参数构造方法创建对象，操作可以简化为如下：        Person o = personClass.newInstance(); &#x2F;&#x2F; 不推荐使用        System.out.println(o);    }}</code></pre></li><li><p>获取成员方法</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 四种方式获取成员方法Method[] getMethods() &#x2F;&#x2F; 获取所有public修饰的方法Method getMethod(String name,类&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 获取指定名称的public修饰的方法Method[] getDeclaredMethods() &#x2F;&#x2F; 获取所有的成员方法，不考虑修饰符Method getDeclaredMethod(String name,类&lt;?&gt;... parameterTypes) &#x2F;&#x2F; &#x2F;&#x2F; 获取指定名称的成员方法,如果不是public修饰的成员变量，可以使用暴力反射获取&#x2F;&#x2F; 代码示例public class ReflectDemo03 {    public static void main(String[] args) throws Exception{        &#x2F;&#x2F; 获取Person的Class对象        Class&lt;Person&gt; personClass = Person.class;        &#x2F;&#x2F; 1. Method getMethod(String name,类&lt;?&gt;... parameterTypes): 获取指定名称的public修饰的方法        Method eat = personClass.getMethod(&quot;eat&quot;);        &#x2F;&#x2F; 执行无参方法        eat.invoke(new Person());        &#x2F;&#x2F; 执行有参方法，需传递参数列表        personClass.getMethod(&quot;eat&quot;,String.class).invoke(new Person(),&quot;food&quot;);        &#x2F;&#x2F; 2. Method[] getDeclaredMethods(): 获取所有public修饰的方法        Method[] methods = personClass.getMethods();        for (Method method:methods)            System.out.println(method);        &#x2F;&#x2F; 3. Method[] getDeclaredMethods(): 获取所有的成员方法，不考虑修饰符        Method[] declaredMethods = personClass.getDeclaredMethods();        for (Method method:declaredMethods) {            System.out.println(method);            System.out.println(method.getName()); &#x2F;&#x2F; 获取方法名称        }        &#x2F;&#x2F; 获取类名称        System.out.println(personClass.getName()); &#x2F;&#x2F; reflect.Person    }}</code></pre></li><li><p>获取类名 ：<code>String getName()</code></p></li></ol><h4 id="Field：成员变量"><a href="#Field：成员变量" class="headerlink" title="Field：成员变量"></a>Field：成员变量</h4><ol><li>设置值：<code>void set(Object obj,Object value)</code></li><li>获取值：<code>get(Object obj)</code></li><li>忽略访问权限修饰符的安全检查(又称<strong>暴力反射</strong>)：<code>setAccessible(true)</code></li></ol><h4 id="Constructor：构造方法"><a href="#Constructor：构造方法" class="headerlink" title="Constructor：构造方法"></a>Constructor：构造方法</h4><p>创建对象：<code>T newInstance(Object... initargs)</code></p><blockquote><p>如果使用空参数构造方法创建对象，操作可以简化为：直接使用Class对象的newInstance方法</p></blockquote><h4 id="Method：方法对象"><a href="#Method：方法对象" class="headerlink" title="Method：方法对象"></a>Method：方法对象</h4><p>执行方法：<code>Object invoke(Object obj, Object... args)</code></p><p>获取方法名称：<code>String getName()</code></p><h3 id="2-3-练习案例"><a href="#2-3-练习案例" class="headerlink" title="2.3 练习案例"></a>2.3 练习案例</h3><p>创建一个”框架”(类)，不改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并执行其中的任意方法。</p><h4 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法</li></ol><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class MyReflectFrame {    public static void main(String[] args) throws Exception {        &#x2F;&#x2F; 可以创建任意类的对象，可以执行任意方法        &#x2F;&#x2F; 前提：不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法&#x2F;&#x2F;        new Student().sleep();        &#x2F;&#x2F; 1. 加载配置文件        &#x2F;&#x2F; 1.1 创建Properties对象        Properties pro = new Properties();        &#x2F;&#x2F; 1.2 加载配置文件，转换一个集合        &#x2F;&#x2F; 1.2.1 获取class目录下的配置文件        ClassLoader classLoader = MyReflectFrame.class.getClassLoader();&#x2F;&#x2F; 获取这个字节码文件的类加载器        InputStream is = classLoader.getResourceAsStream(&quot;D:\\IDEA_WorkSpace\\JavaWeb\\src\\Demo5_16\\pro.properties&quot;); &#x2F;&#x2F; 返回用于读取指定资源的输入流        pro.load(is); &#x2F;&#x2F; NullPointerException: inStream parameter is null!!! (后续回来解决)        &#x2F;&#x2F; 2. 获取配置文件中定义的数据        String className = pro.getProperty(&quot;className&quot;); &#x2F;&#x2F; 获取配置文件中的类名        String methodName = pro.getProperty(&quot;methodName&quot;); &#x2F;&#x2F; 获取配置文件中的方法名        &#x2F;&#x2F; 3.加载该类进内存        Class cls = Class.forName(className);        &#x2F;&#x2F; 4. 创建对象        Object obj = cls.newInstance();        &#x2F;&#x2F; 5. 获取方法对象        Method method = cls.getMethod(methodName);        &#x2F;&#x2F; 6. 执行方法        method.invoke(obj);    }}</code></pre><h2 id="3-注解"><a href="#3-注解" class="headerlink" title="3. 注解"></a>3. 注解</h2><p><strong>注解</strong>：说明程序的，给计算机看的。</p><p>注释：用文字描述程序的，给程序员看的。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>注解(Annotation)，也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p><h4 id="概念描述"><a href="#概念描述" class="headerlink" title="概念描述"></a>概念描述</h4><ul><li>JDK1.5 之后的新特性</li><li>代码级别的说明，用以说明程序的</li><li>使用注解：<code>@注解名称</code></li></ul><p><strong>作用分类</strong>：</p><ol><li>编写文档：通过代码里标识的注解生成文档[生成文档doc文档]</li><li>代码分析：通过代码里标识的注解对代码进行分析[使用反射]</li><li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查[Override]</li></ol><h3 id="3-1-JDK中预定义的一些注解"><a href="#3-1-JDK中预定义的一些注解" class="headerlink" title="3.1 JDK中预定义的一些注解"></a>3.1 JDK中预定义的一些注解</h3><ul><li><code>@Override</code>：检测被该注解标注的方法是否是继承自父类(接口)的</li><li><code>@Deprecated</code>：该注解标注的内容，表示已过时</li><li><code>@SuppressWarnings</code>：压制警告。一般传递参数all，<code>@SuppressWarnings(&quot;all&quot;)</code></li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@SuppressWarnings(&quot;all&quot;) &#x2F;&#x2F; 压制全部警告public class AnnoDemo2 {    @Override    public String toString(){        return super.toString();    }    @Deprecated    public void show1(){        &#x2F;&#x2F;有缺陷    }    public void show2(){        &#x2F;&#x2F; 优化版show2    }    public void demo(){        show1();    }}</code></pre><h3 id="3-2-自定义注解"><a href="#3-2-自定义注解" class="headerlink" title="3.2 自定义注解"></a>3.2 自定义注解</h3><p><strong>基本定义格式</strong></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public @interface 注解名称{    属性列表;}</code></pre><p>其本质<strong>就是一个接口</strong>，该接口默认继承Annotation接口<code>public interface MyAnno extends java.lang.annotation.Annotation{...}</code></p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>接口中的抽象方法被称为属性，定义属性有以下要求：</p><ol><li><p>属性的返回值类型有这些取值：基本数据类型、String、枚举、注解、以上类型的数组。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 代码示例public @interface MyAnno {    int age(); &#x2F;&#x2F; 八种基本数据类型    String name() default &quot;zhangsan&quot;; &#x2F;&#x2F; String类型    Person per(); &#x2F;&#x2F; 枚举类型    MyAnno2 anno2(); &#x2F;&#x2F; 注解类型    String[] strarr(); &#x2F;&#x2F; 以上类型数组均可}</code></pre></li><li><p>定义了属性，在使用时需给属性赋值</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 赋值示例@MyAnno(age = 12,per = Person.P1,anno2 = @MyAnno2,strarr = {&quot;a&quot;,&quot;b&quot;})public class Worker {}</code></pre></li></ol><blockquote><p>小总结：</p><ol><li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，且属性名称是value，则名称value可省略，直接写值。</li><li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可省略。</li></ol></blockquote><h4 id="元注解-用于描述注解的注解"><a href="#元注解-用于描述注解的注解" class="headerlink" title="元注解(用于描述注解的注解)"></a>元注解(用于描述注解的注解)</h4><ul><li><code>@Target</code>：描述注解能够作用的位置，默认value值有<code>ElementType</code>枚举类型，常用取值有如下三个：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li><li><code>@Retention</code>：描述注解被保留的阶段<ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到。</li></ul></li><li><code>@Documented</code>：描述注解是否被抽取到api文档中</li><li><code>@Inherited</code>：描述注解是否被子类继承</li></ul><h3 id="3-3-在程序中使用-解析-注解"><a href="#3-3-在程序中使用-解析-注解" class="headerlink" title="3.3 在程序中使用(解析)注解"></a>3.3 在程序中使用(解析)注解</h3><p>就是获取注解中定义的属性值</p><p>使用步骤：</p><ol><li>获取注解定义的位置的对象(Class，Method，Field)</li><li>获取指定的注解：<code>getAnnotation(Class)</code></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 其实就是在内存中生成了一个该注解接口的子类实现对象public class ProImpl implements Pro{    public String className(){        return &quot;Demo5_16.annotation.Demo1&quot;;    }    public String methodName(){        return &quot;show&quot;    }}</code></pre><ol start="3"><li>调用注解中的抽象方法获取配置的属性值</li></ol><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 自定义的注解Pro@Target(ElementType.TYPE) &#x2F;&#x2F; 可作用于类上@Retention(RetentionPolicy.RUNTIME) &#x2F;&#x2F; 保留在runtime阶段public @interface Pro {    String className();    String methodName();}&#x2F;&#x2F; 方法类public class Demo01 {    public void show(){        System.out.println(&quot;demo1...show....&quot;);    }}&#x2F;&#x2F; 测试类@Pro(className = &quot;Demo5_16.annotation.Demo01&quot;,methodName = &quot;show&quot;)public class MyReflectFrame {    public static void main(String[] args) throws Exception {        &#x2F;&#x2F; 可以创建任意类的对象，可以执行任意方法        &#x2F;&#x2F; 前提：不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法        &#x2F;&#x2F; 解析注解        &#x2F;&#x2F; 1.1 获取该类的字节码文件对象        Class&lt;MyReflectFrame&gt; myreflect = MyReflectFrame.class;        &#x2F;&#x2F; 2. 获取上边的注解对象(其实就是在内存中生成了一个该注解接口的子类实现对象)        Pro an = myreflect.getAnnotation(Pro.class);        &#x2F;&#x2F; 3. 调用注解对象中定义的抽象方法，获取返回值        String className = an.className();        String methodName = an.methodName();        System.out.println(className);        System.out.println(methodName);        &#x2F;&#x2F; 4. 加载该类进内存        Class cls = Class.forName(className); &#x2F;&#x2F; ClassNotFoundException: Demo5_16.annotation.Demo1 ?!!!        &#x2F;&#x2F; 5. 创建对象        Object obj = cls.newInstance();        &#x2F;&#x2F; 6. 获取方法对象        Method method = cls.getMethod(methodName);        &#x2F;&#x2F; 7. 执行方法        method.invoke(obj);    }}</code></pre><h3 id="3-4-综合案例"><a href="#3-4-综合案例" class="headerlink" title="3.4 综合案例"></a>3.4 综合案例</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义简单的计算类，使用@Check注解public class Calculator {    @Check    public void add(){        String str = null;        System.out.println(str.toString()); &#x2F;&#x2F; 会报空指针异常        System.out.println(&quot;1 + 0 =&quot; + (1 + 0));    }    @Check    public void sub(){        System.out.println(&quot;1 - 0 =&quot; + (1 - 0));    }    @Check    public void mul(){        System.out.println(&quot;1 * 0 =&quot; + (1 * 0));    }    @Check    public void div(){        System.out.println(&quot;1 &#x2F; 0 =&quot; + (1 &#x2F; 0));    }}&#x2F;&#x2F; 定义Check注解类@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Check {}&#x2F;&#x2F; 定义测试框架类TestCheck&#x2F;&#x2F; 当主方法执行后，会自动地运行被检测的所有方法(加了Check注解的方法)，判断方法是否有异常，记录到文件中public class TestCheck {    public static void main(String[] args) throws IOException {        Calculator calc = new Calculator();        &#x2F;&#x2F; 2. 获取字节码文件对象        Class cls = calc.getClass();        &#x2F;&#x2F; 3. 获取所有方法        Method[] methods = cls.getMethods();        int count = 0; &#x2F;&#x2F; 出现异常次数        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D:\\IDEA_WorkSpace\\JavaWeb\\src\\Demo5_16\\Check\\bug&quot; + System.currentTimeMillis() + &quot;txt&quot;,true));        for (Method method : methods) {            &#x2F;&#x2F; 4. 判断方法上是否有Check注解            if (method.isAnnotationPresent(Check.class)){ &#x2F;&#x2F; 判断该方法的注解对象是否为输入的注解对象，返回布尔值，true则是。                &#x2F;&#x2F; 5. 有，则执行方法                try {                    method.invoke(calc); &#x2F;&#x2F; 调用方法                } catch (Exception e) {                    &#x2F;&#x2F; 6. 捕获异常,将异常记录到文件中                    count ++;                    bw.write(method.getName() + &quot;方法出异常了&quot;); &#x2F;&#x2F; 获取方法名称                    bw.newLine();                    bw.write(&quot;异常的名称：&quot;+e.getCause());                    bw.newLine();                    bw.write(&quot;异常的原因：&quot;+e.getCause().getMessage());                    bw.newLine();                    bw.write(&quot;---------------------------&quot;);                    bw.newLine();                }            }        }        bw.write(&quot;本次测试一共出现&quot; + count + &quot;次异常&quot;);        bw.flush();        bw.close();    }}&#x2F;* 输出文件：div方法出异常了异常的名称：java.lang.ArithmeticException: &#x2F; by zero异常的原因：&#x2F; by zero---------------------------add方法出异常了异常的名称：java.lang.NullPointerException异常的原因：null---------------------------本次测试一共出现2次异常*&#x2F;</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>大多数时候，我们会使用注解，而不是自定义注解</li><li>注解给谁用？一般给编译器和解析程序(TestCheck就是解析程序)用</li><li>注解不是程序的一部分，可以理解为注解就是一个标签</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流的简单使用</title>
      <link href="/JavaBasics/stream.html"/>
      <url>/JavaBasics/stream.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Stream流"><a href="#1-Stream流" class="headerlink" title="1. Stream流"></a>1. Stream流</h2><p>说到Stream便容易想到I/O流，实际上，在Java 8中，得益于Lambda所带来的函数式编程，引入了一个<strong>全新的Stream概念</strong>，用于解决已有集合类库既有的弊端。</p><a id="more"></a><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><h4 id="传统集合的多步遍历代码"><a href="#传统集合的多步遍历代码" class="headerlink" title="传统集合的多步遍历代码"></a>传统集合的多步遍历代码</h4><p>几乎所有的集合(如<code>Collection</code>接口或<code>Map</code>接口等)都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoForEach{    public static void main(String[] agrs){        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;xiaozhang&quot;);        list.add(&quot;xiaoming&quot;);        list.add(&quot;xiaoli&quot;);        list.add(&quot;xiaowang&quot;);        for(String name:list){            System.out.println(name);        }    }}</code></pre><h4 id="循环遍历的弊端"><a href="#循环遍历的弊端" class="headerlink" title="循环遍历的弊端"></a>循环遍历的弊端</h4><p>Java 8的Lambda让我们可以更加专注于<strong>做什么</strong>(What)，而不是<strong>怎么做</strong>(How)。现在我们看一下上例代码，可以发现：</p><ul><li>for循环的语法就是“<strong>怎么做</strong>”</li><li>for循环的循环体才是”<strong>做什么</strong>“</li></ul><p>为什么使用循环？因为要进行遍历。循环是遍历的唯一方式么？遍历是指对每一个元素逐一进行处理，<strong>而并不是从第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。</p><p>试想一下，如果希望对集合中的元素进行筛选过滤：</p><ol><li>将集合A根据条件一过滤为子集B</li><li>然后在根据条件二过滤为子集C</li></ol><p>在Java 8之前的做法可能为：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoNormalFilter {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张无忌&quot;);        list.add(&quot;周芷若&quot;);        list.add(&quot;赵敏&quot;);        list.add(&quot;张强&quot;);        list.add(&quot;张三丰&quot;);        List&lt;String&gt; zhangList = new ArrayList&lt;&gt;();        for (String name:list)            if (name.startsWith(&quot;张&quot;)) &#x2F;&#x2F; startsWith:测试此字符串是否以指定的前缀开始。                zhangList.add(name);        List&lt;String&gt; shortList = new ArrayList&lt;&gt;();        for (String name:zhangList)            if (name.length() == 3)                shortList.add(name);        for (String name:shortList)            System.out.println(name);    }}</code></pre><p>上述代码含有三个循环，作用不同：</p><ol><li>首先筛选所以姓张的人；</li><li>然后筛选名字是三个字的人；</li><li>最后对筛选结果进行打印输出。</li></ol><p>每当我们需要对集合中的元素进行操作时，总是需要进行循环遍历。我们可以使用Lambda的衍生物Stream带来更加优雅的写法。</p><h4 id="Stream的更优写法"><a href="#Stream的更优写法" class="headerlink" title="Stream的更优写法"></a>Stream的更优写法</h4><p>下面来看使用Java 8的Stream API后的代码：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoStreamFilter {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;张无忌&quot;);        list.add(&quot;周芷若&quot;);        list.add(&quot;赵敏&quot;);        list.add(&quot;张强&quot;);        list.add(&quot;张三丰&quot;);        list.stream()                .filter(s -&gt; s.startsWith(&quot;张&quot;))                .filter(s -&gt; s.length() == 3)                .forEach(System.out::println);    }}</code></pre><p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p><h3 id="1-2-流式思想概述"><a href="#1-2-流式思想概述" class="headerlink" title="1.2 流式思想概述"></a>1.2 流式思想概述</h3><p><strong>注意：请暂时忘记对传统IO流的固有印象</strong>！</p><p>整体来看，流式思想类似于工厂车间的“<strong>生产流水线</strong>”</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/15/Stream01-1557888489833.jpg" alt="title"></p><p>当需要对多个元素进行操作(特别是多步操作)时，考虑到性能及便利性，我们应该首先拼好一个”模型”步骤方案，然后再按照方案去执行它。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/15/StreamModel-1557888739336.jpg" alt="title"></p><p>这张图展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种”函数模型”。图中的每一个方框都是一个”流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。</p><p>这里的<code>filter</code>、<code>map</code>、<code>skip</code>都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法<code>count</code>执行时，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。</p><blockquote><p>备注：“Stream流”其实是一个集合元素的<strong>函数模型</strong>，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p></blockquote><p>Stream(流)是一个来自数据源的元素队列</p><ul><li>元素是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算。</li><li><strong>数据源</strong>流的来源。可以是集合、数组等。</li></ul><p>和以前的Collection操作不同，Stream操作还有两个基础的特征：</p><ul><li><strong>Pipelinling</strong>：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格(fluent style)。这样做可以对操作进行优化，比如延迟执行(laziness)和短路(short-circuiting)。</li><li><strong>内部迭代</strong>：以前对集合遍历都是通过Iterator或者增强for的方式，显式的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li></ul><p>当使用一个流时，通常包括三个基本步骤：获取一个数据源(source) –&gt; 数据转换 –&gt; 执行操作获取想要的结果。每次转换原有Stream对象不变，返回一个新的Stream对象(可以有多次转换)，这就允许对其的操作可以像链条一样排列，变成一个管道。</p><h4 id="1-3-获取流"><a href="#1-3-获取流" class="headerlink" title="1.3 获取流"></a>1.3 获取流</h4><p><code>java.util.stream.Stream&lt;T&gt;</code> 是Java 8 新加入的最常用的流接口(该接口不是函数式接口)。</p><p>获取流的方式：</p><ul><li>所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取流；</li><li><code>Stream</code>接口的静态方法<code>of</code>可以获取数组对应的流。</li></ul><h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><p>首先，<code>java.util.Collection</code>接口中加入了default方法 <code>stream</code> 用来获取流，所以其所有实现类均可获取流。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoGetStream {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        Stream&lt;String&gt; stream1 = list.stream();        Set&lt;String&gt; set = new HashSet&lt;&gt;();        Stream&lt;String&gt; stream2 = set.stream();    }}</code></pre><h4 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h4><p><code>java.util.Map</code>接口不是<code>Collection</code>的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoMapGetStream {    public static void main(String[] args) {        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();        Stream&lt;String&gt; keyStream = map.keySet().stream(); &#x2F;&#x2F; 获取键流        Stream&lt;String&gt; valueStream = map.values().stream(); &#x2F;&#x2F; 获取值流        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream(); &#x2F;&#x2F; 获取键值对流    }}</code></pre><h4 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h4><p>如果使用的是数组，由于数组对象不可添加默认方法，所以<code>Stream</code>接口中提供了静态方法<code>of</code>,使用实例如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoArrGetStream {    public static void main(String[] args) {        String[] arr = {&quot;张&quot;,&quot;李&quot;,&quot;王&quot;};        Stream&lt;String&gt; stream = Stream.of(arr);    }}&#x2F;&#x2F; of方法的参数是一个可变参数，所以支持数组</code></pre><h3 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4 常用方法"></a>1.4 常用方法</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/15/StreamMethod-1557892482395.jpg" alt="title"></p><p>流模型的操作很丰富，下面介绍一些常用的API。这些方法可以被分成两种：</p><ul><li><strong>延迟方法</strong>：返回值类型仍然是<code>Stream</code>接口本身类型的方法，因此支持链式调用。(除了终结方法外，其余方法均为延迟方法)</li><li><strong>终结方法</strong>：返回值类型不再是<code>Stream</code>接口自身类型的方法，因此不再支持类似<code>StringBuilder</code>那样的链式调用。这里介绍的终结方法包括<code>count</code>和<code>forEach</code>方法。</li></ul><h4 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h4><p>​    虽然方法名字叫<code>forEach</code>，但是与for循环中的”for-each”昵称不同。方法签名如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">void forEach(Consumer&lt;? super T&gt; action);</code></pre><p>​    该方法接收一个<code>Consumer</code>接口函数，会将每一个流元素交给该函数进行处理。</p><blockquote><p>Tips: 方法名和形参列表共同组成<strong>方法签名</strong>。</p></blockquote><h4 id="复习Consumer接口"><a href="#复习Consumer接口" class="headerlink" title="复习Consumer接口"></a>复习Consumer接口</h4><p><code>java,util.function.Consumer&lt;T&gt;</code>接口是一个消费型接口。</p><p><code>Consumer</code>接口中包含抽象方法<code>void accept(T t)</code>，意为消费一个指定泛型的数据。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoStreamForEach {    public static void main(String[] args) {        Stream&lt;String&gt; stream = Stream.of(&quot;张&quot;, &quot;李&quot;, &quot;王&quot;);        stream.forEach(name-&gt; System.out.println(name));    }}</code></pre><h4 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h4><p>可以通过<code>filter</code>方法将一个流转换成另一个子集流。方法签名：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code></pre><p>该接口接收一个<code>Predicate</code>函数式接口参数作为筛选条件。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/15/StreamFilter-1557901616757.jpg" alt="title"></p><h4 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h4><p><code>java.util.stream.Predicate</code>函数式接口，其中唯一的抽象方法为<code>boolean test(T t);</code></p><p>该方法将会产生一个boolean值结果，代表指定条件是否满足。结果为true则保留元素，反之不保留。</p><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo2Filter {    public static void main(String[] args) {        Stream&lt;String&gt; stream = Stream.of(&quot;张三丰&quot;, &quot;张翠山&quot;, &quot;赵敏&quot;, &quot;周芷若&quot;, &quot;张无忌&quot;);        &#x2F;&#x2F; 对Stream流中的元素进行过滤，只要姓张的        Stream&lt;String&gt; stream2 = stream.filter(name -&gt; name.startsWith(&quot;张&quot;));        &#x2F;&#x2F; 遍历stream2流        stream2.forEach(name-&gt; System.out.println(name));    }}</code></pre><h4 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h4><p>如果需要将流中的元素映射到另一个流中，可以使用<code>map</code>方法。方法签名：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</code></pre><p>该接口需要一个<code>Function</code>函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/15/StreamMap-1557903369553.jpg" alt="title"></p><h4 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h4><p>此前我们已经学习过<code>java.util.stream.Function</code>函数式接口，其中唯一的抽象方法为：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">R apply(T t);</code></pre><p>这可以将一种T类型转换成为R类型，而这种转换的动作，就称为”映射“。</p><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的<code>map</code>方法基本使用的代码如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class StreamMap {    public static void main(String[] args) {        Stream&lt;String&gt; stream = Stream.of(&quot;10&quot;, &quot;15&quot;, &quot;17&quot;);        Stream&lt;Integer&gt; result = stream.map(str -&gt; Integer.parseInt(str));        result.forEach(str-&gt; System.out.println(str));    }}</code></pre><p>上述代码中，<code>map</code>方法的参数通过方法引用，将字符串类型转换为了int类型(并自动装箱为<code>Integer</code>类对象)。</p><h4 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h4><p>正如集合<code>Collection</code>当中的<code>size</code>方法一样，流提供<code>count</code>方法来统计元素个数</p><p>该方法返回一个long值代表元素个数。基本使用如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoStreamCount {    public static void main(String[] args) {        Stream&lt;String&gt; stream = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;);        System.out.println(stream.count()); &#x2F;&#x2F; 4    }}</code></pre><h4 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h4><p><code>limit</code>方法可以对流进行截取，只取用前n个。方法签名：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Stream&lt;T&gt; limit(long maxSize);</code></pre><p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/15/StreamLimit-1557906224811.jpg" alt="title"><br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoStreamLimit {    public static void main(String[] args) {        Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);        Stream&lt;String&gt; limit = stream.limit(3); &#x2F;&#x2F; 截取流的前两个元素        limit.forEach(s-&gt; System.out.println(s)); &#x2F;&#x2F; a,b,c    }}</code></pre></p><h4 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h4><p>如果希望跳过前几个元素，可以使用<code>skip</code>方法获取一个截取之后的新流：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Stream&lt;T&gt; skip(long n);</code></pre><p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/15/StreamSkip-1557906391858.jpg" alt="title"></p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoStreamSkip {    public static void main(String[] args) {        Stream&lt;String&gt; stream = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;);        Stream&lt;String&gt; skip = stream.skip(3);        skip.forEach(s-&gt; System.out.println(s)); &#x2F;&#x2F; 4,5,6    }}</code></pre><h4 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h4><p>如果有两个流，希望合并成为一个流，那么可以使用<code>Stream</code>接口的静态方法<code>concat</code>。方法签名：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b);</code></pre><blockquote><p>注：这是一个静态方法，与<code>java.lang.String</code>中的<code>concat</code>方法是不同的。</p></blockquote><p>代码示例</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoStreamConcat {    public static void main(String[] args) {        Stream&lt;String&gt; h = Stream.of(&quot;hello&quot;);        Stream&lt;String&gt; w = Stream.of(&quot;world!&quot;);        Stream&lt;String&gt; result = Stream.concat(h, w);        result.forEach(s-&gt; System.out.println(s));    }}</code></pre><h3 id="1-5-练习：集合元素的处理"><a href="#1-5-练习：集合元素的处理" class="headerlink" title="1.5 练习：集合元素的处理"></a>1.5 练习：集合元素的处理</h3><p>现在有两个<code>ArrayList</code>集合存储队伍当中多个成员姓名，要去使用循环依次进行以下若干步骤：</p><ol><li><p>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</p></li><li><p>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</p></li><li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li><li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li><li>将两个队伍合并为一个队伍；存储到一个新集合中。</li><li>根据姓名创建 Person 对象；存储到一个新集合中。</li><li>打印整个队伍的Person对象信息。</li></ol><p>代码实现(传统方式)</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ExerciseOldFor {    public static void main(String[] args) {        ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;();        &#x2F;&#x2F; ....        &#x2F;&#x2F;队伍2        ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;();        &#x2F;&#x2F; ....        &#x2F;&#x2F; 1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。        List&lt;String&gt; oneA = new ArrayList&lt;&gt;();        for (String name:one){            if (name.length()==3){                oneA.add(name);            }        }        &#x2F;&#x2F; 2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。        List&lt;String&gt; oneB = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 3; i++) {            oneB.add(oneA.get(i));        }        &#x2F;&#x2F; 3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。        List&lt;String&gt; twoA = new ArrayList&lt;&gt;();        for (String name:two){            if (name.startsWith(&quot;张&quot;)){                twoA.add(name);            }        }        &#x2F;&#x2F; 4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。        List&lt;String&gt; twoB = new ArrayList&lt;&gt;();        for (int i = 2; i &lt; twoA.size(); i++) {            twoB.add(twoA.get(i));        }        &#x2F;&#x2F; 5. 将两个队伍合并为一个队伍；存储到一个新集合中。        List&lt;String&gt; totalNames = new ArrayList&lt;&gt;();        totalNames.addAll(oneB);        totalNames.addAll(twoB);        &#x2F;&#x2F; 6. 根据姓名创建 Person 对象；存储到一个新集合中。        List&lt;Person&gt; personList = new ArrayList&lt;&gt;();        for (String name:totalNames){            personList.add(new Person(name));        }        &#x2F;&#x2F; 7. 打印整个队伍的Person对象信息。        for (Person p:personList){            System.out.println(p);        }    }}</code></pre><p>Stream流方式实现</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ExerciseStream {    public static void main(String[] args) {        &#x2F;&#x2F; 队伍1        ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;();        one.add(&quot;迪丽热巴&quot;);        one.add(&quot;宋远桥&quot;);        one.add(&quot;苏星河&quot;);        one.add(&quot;石破天&quot;);        one.add(&quot;石中玉&quot;);        one.add(&quot;老子&quot;);        one.add(&quot;庄子&quot;);        one.add(&quot;洪七公&quot;);        &#x2F;&#x2F;队伍2        ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;();        two.add(&quot;古力娜扎&quot;);        two.add(&quot;张无忌&quot;);        two.add(&quot;赵丽颖&quot;);        two.add(&quot;张三丰&quot;);        two.add(&quot;尼古拉斯赵四&quot;);        two.add(&quot;张天爱&quot;);        two.add(&quot;张二狗&quot;);        &#x2F;&#x2F; 1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。        Stream&lt;String&gt; threeName = one.stream().filter(n -&gt; n.length() == 3);        &#x2F;&#x2F; 2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。        Stream&lt;String&gt; firstThreePeople = threeName.limit(3);        &#x2F;&#x2F; 3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。        Stream&lt;String&gt; firstNameZhang = two.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));        &#x2F;&#x2F; 4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。        Stream&lt;String&gt; skipTwoPeople = firstNameZhang.skip(2);        &#x2F;&#x2F; 5. 将两个队伍合并为一个队伍；存储到一个新集合中。        Stream&lt;String&gt; concat = Stream.concat(firstThreePeople, skipTwoPeople);        &#x2F;&#x2F; 6. 根据姓名创建 Person 对象；存储到一个新集合中。        List&lt;Person&gt; people = new ArrayList&lt;&gt;();        concat.forEach(s -&gt; people.add(new Person(s)));        &#x2F;&#x2F; 7. 打印整个队伍的Person对象信息。        people.forEach(p-&gt; System.out.println(p));        &#x2F;&#x2F; 以上3步合并写法        Stream.concat(firstThreePeople,skipTwoPeople).map(Person::new).forEach(System.out::println);    }}</code></pre><h2 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2. 方法引用"></a>2. 方法引用</h2><p>在使用Lambda表达式时，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要写重复逻辑？</p><h3 id="2-1-冗余的Lambda场景"><a href="#2-1-冗余的Lambda场景" class="headerlink" title="2.1 冗余的Lambda场景"></a>2.1 冗余的Lambda场景</h3><p>下面是一个简单的函数式接口以便应用Lambda表达式：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface Printable{    void print(String str);}</code></pre><p>在<code>Printable</code>接口当中唯一的抽象方法<code>print</code>接收一个字符串参数，目的就是为了打印显示它。那么下面通过Lambda来实现一下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoPrintImpl {    private static void printString(String s,Printable data){        data.print(s);    }    public static void main(String[] args) {        printString(&quot;hello&quot;,s-&gt; System.out.println(s));    }}</code></pre><p>其中<code>printString</code>方法只管调用<code>Printable</code>接口的<code>print</code>方法，并不管该方法的具体实现逻辑会将字符串如何操作。而<code>main</code>方法通过Lambda表达式指定了函数式接口<code>Printable</code>的具体操作方案为：<strong>拿到一个String数据后，在控制台中输出它。</strong></p><h3 id="2-2-问题分析"><a href="#2-2-问题分析" class="headerlink" title="2.2 问题分析"></a>2.2 问题分析</h3><p>这段代码的问题在于，对字符串进行控制台打印输出的操作方案，已经有了现成的实现，那就是<code>System.out</code>对象中的<code>println(String)</code>方法。既然Lambda希望做到的事情就是调用<code>println(String)</code>方法，那何必自己手动调用呢。</p><h3 id="2-3-用方法引用改进代码"><a href="#2-3-用方法引用改进代码" class="headerlink" title="2.3 用方法引用改进代码"></a>2.3 用方法引用改进代码</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02PrintRef {    private static void printString(Printable data){        data.print(&quot;hello&quot;);    }    public static void main(String[] args) {        &#x2F;&#x2F;        printString(s-&gt; System.out.println(s));        &#x2F;*        分析：            Lambda表达式的目的，打印参数传递的字符串            把参数s，传递给了System.out对象，调用out对象中的方法println对字符串进行了输出            注意：                1. System.out对象是已经存在的                2. println方法也是已经存在的            所以我们可以使用方法引用来优化Lambda表达式            可以使用System.out方法直接引用(调用)println方法         *&#x2F;        printString(System.out::println);    }}</code></pre><p>其中双冒号<code>::</code>写法，这被称为“<strong>方法引用</strong>”，而双冒号是一种新的语法。</p><h3 id="2-4-方法引用符"><a href="#2-4-方法引用符" class="headerlink" title="2.4 方法引用符"></a>2.4 方法引用符</h3><p>双冒号<code>::</code>为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>如上例中，<code>System.out</code>对象中有一个重载的<code>println(String)</code>方法恰好就是我们所需要的。那么对于<code>printString</code>方法的函数式接口参数，对比下面两种写法，完全等效：</p><ul><li>Lambda表达式写法：<code>s -&gt; System.out.println(s);</code></li><li>方法引用写法：<code>System.out::println</code></li></ul><p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给<code>System.out.println</code>方法去处理。</p><p>第二种等效写法的语义是指：直接让<code>System.out</code>中的<code>println</code>方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</p><blockquote><p>注：Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p></blockquote><h4 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h4><p>如果使用Lambda，那么根据“<strong>可推导即可省略</strong>”的原则，无需指定参数类型，也无需指定重载形式—-它们都将被自动推导，而如果使用方法引用，也是同样可以根据上下文进行推导。</p><p>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。</p><h3 id="2-5-通过对象名引用成员方法"><a href="#2-5-通过对象名引用成员方法" class="headerlink" title="2.5 通过对象名引用成员方法"></a>2.5 通过对象名引用成员方法</h3><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class MethodRefObject {    public void printUpperCase(String str){        System.out.println(str.toUpperCase());    }}</code></pre><p>函数式接口定义不变，那么当需要使用这个<code>printUpperCase</code>成员方法来替代<code>Printable</code>接口的Lambda时，已经具有了<code>MethodRefObject</code>类的对象实例，则可以通过对象名引用成员方法，如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo04MethodRef {    private static void printString(Printable p){        p.print(&quot;hello&quot;);    }    public static void main(String[] args) {        MethodRefObject obj = new MethodRefObject();        printString(obj::printUpperCase); &#x2F;&#x2F; HELLO    }}</code></pre><h3 id="2-6-通过类名称引用静态方法"><a href="#2-6-通过类名称引用静态方法" class="headerlink" title="2.6 通过类名称引用静态方法"></a>2.6 通过类名称引用静态方法</h3><p>由于在<code>java.lang.Math</code>类中已经存在了静态方法<code>abs</code>，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@FunctionalInterfacepublic interface Calcable {int calc(int num);}</code></pre><p>两种写法调用：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo05CalcLambda {    private static void method(int num,Calcable ca){        System.out.println(ca.calc(num));    }    public static void main(String[] args) {        &#x2F;&#x2F; Lambda表达式写法        method(-10,n -&gt; Math.abs(n)); &#x2F;&#x2F; 10        &#x2F;&#x2F; 通过类名称引用静态方法        method(-10,Math::abs); &#x2F;&#x2F; 10    }}</code></pre><p>上述例子中，两种写法是完全等效的：</p><ul><li>Lambda表达式：<code>n-&gt;Math.abs(n)</code></li><li>方法引用：<code>Math::abs</code></li></ul><h3 id="2-7-通过super引用成员方法"><a href="#2-7-通过super引用成员方法" class="headerlink" title="2.7 通过super引用成员方法"></a>2.7 通过super引用成员方法</h3><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。代码示例如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 首先是函数式接口：@FunctionalInterfacepublic interface Greetable {    void greet();}&#x2F;&#x2F; 定义父类public class Human {    public void sayHello(){        System.out.println(&quot;Hello!&quot;);    }}&#x2F;&#x2F; 定义子类继承父类public class Man extends Human {    &#x2F;&#x2F; 子类重写父类sayHello方法    @Override    public void sayHello(){        System.out.println(&quot;大家好，我是Man！&quot;);    }    &#x2F;&#x2F; 定义方法method，参数传递Greetable接口    public void method(Greetable g){        g.greet();    }    public void show(){        &#x2F;&#x2F; 调用method方法，使用Lambda表达式        method(()-&gt;new Human().sayHello()); &#x2F;&#x2F; 创建父类human对象，调用父类的sayHello方法        &#x2F;&#x2F; 因为有子父类关系，所以存在一个关键字super，代表父类；所以我们可以直接使用super，调用父类的成员方法        &#x2F;&#x2F; 使用super关键字引用父类的成员方法        method(super::sayHello);    }    public static void main(String[] args) {        new Man().show(); &#x2F;&#x2F; 调用show方法    }}</code></pre><h3 id="2-8-通过this引用成员方法"><a href="#2-8-通过this引用成员方法" class="headerlink" title="2.8 通过this引用成员方法"></a>2.8 通过this引用成员方法</h3><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用<code>this::成员方法</code>的格式来使用方法引用。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义简单的函数式接口@FunctionalInterfacepublic interface Richable {    void buy();}&#x2F;&#x2F; 定义使用类public class Child {    private void buyGame(){        System.out.println(&quot;买了游戏&quot;);    }    private void computer(Richable r){        r.buy();    }    public void soHappy(){        &#x2F;&#x2F; 使用lambda表达式        computer(()-&gt;System.out.println(&quot;买了游戏&quot;))；        &#x2F;&#x2F; 使用this关键字，调用本类中已经存在的方法        computer(()-&gt;this.buyGame())        &#x2F;&#x2F; 使用方法引用        computer(this::buyGame);        &#x2F;&#x2F; 上述三种方法完全等效    }     public static void main(String[] args) {        new Child().soHappy(); &#x2F;&#x2F; 买了游戏    }}</code></pre><h3 id="2-9-类的构造器引用"><a href="#2-9-类的构造器引用" class="headerlink" title="2.9 类的构造器引用"></a>2.9 类的构造器引用</h3><p>由于构造器的名称和类名完全一样，并不固定。所以构造器引用使用<code>类名称::new</code>的格式表示。</p><p>代码示例:</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; Person类public class Person {    private String name;    public Person() {    }    public Person(String name) {        this.name = name;    }&#x2F;&#x2F; ....}&#x2F;&#x2F; 定义一个车间Person对象的函数式接口@FunctionalInterfacepublic interface PersonBuilder {    &#x2F;&#x2F; 定义一个方法，根据传递的姓名，创建Person对象返回    Person builderPerson(String name);}&#x2F;&#x2F; 类的构造器引用public class DemoBuilderPerson {    &#x2F;&#x2F; 定义一个方法，参数传递姓名和PersonBuilder接口，方法中通过姓名创建Person对象    public static void printName(String name,PersonBuilder pb){        Person person = pb.builderPerson(name);        System.out.println(person.getName());    }    public static void main(String[] args) {        &#x2F;&#x2F; 调用printName方法，方法的参数PersonBuilder接口是函数式接口，故可以使用Lambda表达式        printName(&quot;小张&quot;,name -&gt; new Person(name));        &#x2F;*            使用方法引用优化lambda表达式            构造方法new Person(String name) 已知            创建对象已知 new            就可以使用Person引用new创建对象         *&#x2F;        printName(&quot;小明&quot;,Person::new); &#x2F;&#x2F; 使用Person类的带参构造方法，通过传递的姓名创建对象    }}</code></pre><h3 id="2-10-数组的构造器引用"><a href="#2-10-数组的构造器引用" class="headerlink" title="2.10 数组的构造器引用"></a>2.10 数组的构造器引用</h3><p>数组也是<code>Object</code>的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，示例代码如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义一个创建是数组的函数式接口@FunctionalInterfacepublic interface ArrayBuilder {    &#x2F;&#x2F; 定义一个创建int类型数组的方法，参数传递数组的长度，返回创建好的int类型数组    int[] builderArray(int length);}&#x2F;&#x2F; 数组的构造器引用public class DemoArrayBuilder {    &#x2F;*        定义一个方法        方法的参数传递创建数组的长度和ArrayBuilder接口        方法内部根据传递的长度使用ArrayBuilder中的方法创建数组并返回     *&#x2F;    public static int[] createArray(int length,ArrayBuilder ab){        return ab.builderArray(length);    }    public static void main(String[] args) {        &#x2F;&#x2F; 调用createArray方法，传递数组的长度和Lambda表达式        int[] arr = createArray(10,(len)-&gt;new int[len]);        System.out.println(arr.length); &#x2F;&#x2F; 10        &#x2F;*            使用方法引用优化lambda表达式            已知创建的就是int[]数组            数组的长度也是已知的            就可以使用方法引用            int[]引用new，根据参数传递的长度来创建数组         *&#x2F;        int[] arr2 = createArray(10,int[]::new);        System.out.println(arr2.length); &#x2F;&#x2F; 10    }}</code></pre><h2 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h2><ul><li style="list-style: none"><input type="checkbox" checked> 能够理解流与集合相比的优点。让我们专注于做什么，而不是怎么做</li><li style="list-style: none"><input type="checkbox" checked> 能够理解流的延迟执行特点。Stream可以按需计算，只有当终结方法执行时，整个模型才会按照指定策略执行操作。</li><li style="list-style: none"><input type="checkbox" checked> 能够通过集合、映射或数组获取流。实现类.stream();Stream.of(数组)。</li><li style="list-style: none"><input type="checkbox" checked> 能够掌握常用的流操作。forEach,filter,map,count,limit,skip,concat</li><li style="list-style: none"><input type="checkbox" checked> 能够使用输出语句的方法引用。System.out::println？</li><li style="list-style: none"><input type="checkbox"> 能够通过4种方式使用方法引用</li><li style="list-style: none"><input type="checkbox" checked> 能够使用类和数组的构造器引用。类名称::new;数组[]::new</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式接口</title>
      <link href="/JavaBasics/function.html"/>
      <url>/JavaBasics/function.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1. 函数式接口"></a>1. 函数式接口</h2><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong>。</p><p>函数式接口，也称为SAM(Single Abstract Method interfaces)接口，即适用于函数式编程场景的接口。而java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，java中的Lambda才能顺利地进行推导。</p><a id="more"></a><blockquote><p>注：“<strong>语法糖</strong>“是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。</p></blockquote><h3 id="1-1-格式"><a href="#1-1-格式" class="headerlink" title="1.1 格式"></a>1.1 格式</h3><p>​    只要确保接口中有且仅有一个抽象方法即可：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">修饰符 interface 接口名称{    public abstract 返回值类型 方法名称(可选参数信息);    &#x2F;&#x2F; 其他非抽象方法内容}</code></pre><p>​    由于接口当中抽象方法的<code>public abstract</code>是可以省略的，所以定义一个函数式接口很简单：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface MyFun{    void MyMethod();}</code></pre><h3 id="1-2-FunctionalInterface注解"><a href="#1-2-FunctionalInterface注解" class="headerlink" title="1.2 @FunctionalInterface注解"></a>1.2 @FunctionalInterface注解</h3><p>​    与<code>@Override</code>注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：<code>@FunctionalInterface</code>。该注解可用于一个接口的定义上：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@FunctionalInterfacepublic interface MyFun{    void MyMethod();}</code></pre><p>​    一旦使用该注解来定义接口，编译器将会强制检查该接口是否确定有且仅有一个抽象方法，否则将会报错。</p><h3 id="1-3-自定义函数式接口"><a href="#1-3-自定义函数式接口" class="headerlink" title="1.3 自定义函数式接口"></a>1.3 自定义函数式接口</h3><p>对于刚刚定义好的<code>MyFun</code>函数式接口，典型使用场景就是作为方法的参数：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoFunInterface {    public static void main(String[] args) {        &#x2F;&#x2F; 使用lambda调用函数式接口中的方法        doSomething(()-&gt; System.out.println(&quot;Lambda执行了！&quot;));    }    &#x2F;&#x2F; 使用自定义的函数式接口作为方法参数    private static void doSomething(MyFun inter){        inter.MyMethod(); &#x2F;&#x2F; 调用自定义的函数式接口方法    }}</code></pre><h2 id="2-函数式编程"><a href="#2-函数式编程" class="headerlink" title="2. 函数式编程"></a>2. 函数式编程</h2><p>在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，打开了函数式编程的大门。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 函数式接口的使用：一般可以作为方法的参数和返回值类型public class Demo {    &#x2F;&#x2F; 定义一个方法，参数使用函数式接口MyFun    public static void show(MyFun myFun){        myFun.MyMethod();    }    public static void main(String[] args) {        &#x2F;&#x2F; 调用show方法，方法的参数是一个接口，所以可以传递接口的实现类对象        show(new MyFunImpl());        &#x2F;&#x2F; 调用show方法，方法的参数是一个接口,所以我们可以传递接口的匿名内部类        show(new MyFun() {            @Override            public void MyMethod() {                System.out.println(&quot;使用匿名内部类重写接口中的抽象方法&quot;);            }        });        &#x2F;&#x2F; 调用show方法，方法的参数是一个函数式接口,所以我们可以传递lambda表达式        show(()-&gt; System.out.println(&quot;使用Lambda表达式重写接口中的抽象方法&quot;));    }}&#x2F;&#x2F; result:&#x2F;*使用实现类重写MyFun接口抽象方法使用匿名内部类重写接口中的抽象方法使用Lambda表达式重写接口中的抽象方法*&#x2F;</code></pre><h3 id="2-1-Lambda的延迟执行"><a href="#2-1-Lambda的延迟执行" class="headerlink" title="2.1 Lambda的延迟执行"></a>2.1 Lambda的延迟执行</h3><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。</p><h4 id="性能浪费的日志"><a href="#性能浪费的日志" class="headerlink" title="性能浪费的日志"></a>性能浪费的日志</h4><p>注：日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。</p><p>一种典型场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件情况下进行打印输出：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02Logger {    public static void main(String[] args) {        &#x2F;&#x2F; 定义三个日志信息        String msg1 = &quot;hello&quot;;        String msg2 = &quot;world&quot;;        String msg3 = &quot;java&quot;;        &#x2F;&#x2F; 调用方法，传递日志级别和日志信息        log(1,msg1+msg2+msg3);    }    &#x2F;&#x2F; 定义一个根据日志的级别，显示日志信息的方法    private static void log(int level, String msg){        &#x2F;&#x2F; 对日志等级进行判断，如果是1级别，那么输出日志信息        if (level == 1){            System.out.println(msg);        }    }}</code></pre><p>上述代码仍存在问题：无论级别是否满足要求，作为<code>log</code>方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如级别不符合要求，那么字符串拼接操作就白做了，浪费性能。</p><blockquote><p>备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。例如：<code>LOGGER.debug(&quot;变量{}的取值为{}。&quot;, &quot;os&quot;, &quot;macOS&quot;)</code>，其中的大括号<code>{}</code>为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。</p></blockquote><h4 id="Lambda优化写法"><a href="#Lambda优化写法" class="headerlink" title="Lambda优化写法"></a>Lambda优化写法</h4><p>使用Lambda必然需要一个函数式接口：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@FunctionalInterfacepublic interface MessageInter {    String Message();}</code></pre><p>对<code>log</code>方法进行改造：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoLogLambda {    public static void main(String[] args) {        String msg1 = &quot;hello&quot;;        String msg2 = &quot;world&quot;;        String msg3 = &quot;java&quot;;        log(1,() -&gt; msg1 + msg2 + msg3);    }    private static void log(int level,MessageInter msg){        if (level == 1){            System.out.println(msg.Message()); &#x2F;&#x2F; 只有当条件满足时，才会去调用字符串拼接方法，不满足不会拼接        }    }}</code></pre><p>如此，只有当级别满足要求时，才会进行三个字符串拼接，不会造成性能浪费。</p><h4 id="证明Lambda的延迟"><a href="#证明Lambda的延迟" class="headerlink" title="证明Lambda的延迟"></a>证明Lambda的延迟</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoLoggerDelay {    private static void log(int level,MessageInter msg){        if (level == 1){            System.out.println(msg.Message());        }    }    public static void main(String[] args) {        String msg1 = &quot;hello&quot;;        String msg2 = &quot;world&quot;;        String msg3 = &quot;java&quot;;        log(2,() -&gt;{            System.out.println(&quot;满足条件Lambda执行！&quot;);            return msg1 + msg2 + msg3;        });    }}</code></pre><p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。</p><blockquote><p>实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。</p></blockquote><h3 id="2-2-使用Lambda作为参数和返回值"><a href="#2-2-使用Lambda作为参数和返回值" class="headerlink" title="2.2 使用Lambda作为参数和返回值"></a>2.2 使用Lambda作为参数和返回值</h3><p>抛开实现原理不说，Java中的Lambda表达式可以被看做是匿名内部类的替代品。如果方法的参数是一个<strong>函数式接口类型</strong>，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式接口作为方法参数。</p><p>例如<code>java.lang.Runnable</code>接口就是一个函数式接口，假设有一个<code>startThread</code>方法使用该接口作为参数，那么就可以使用Lambda进行传参。这种情况其实和<code>Thread</code>类的构造方法参数为<code>Runnable</code>没有本质区别。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 使用lambda作为方法参数public class DemoRunnable {    public static void main(String[] args) {        &#x2F;&#x2F; 调用方法，参数是接口，我们可以传递匿名内部类，实现类接口lambda等。        startThread(new Runnable() {            @Override            public void run() {                System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + &quot;线程启动了&quot;);            }        });        &#x2F;&#x2F; 调用方法，参数是一个函数式接口，我们可以传递lambda        startThread(() -&gt; System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + &quot;线程启动了&quot;));    }    &#x2F;&#x2F; 定义一个方法，方法参数使用函数式接口Runnable    public static void startThread(Runnable run){        &#x2F;&#x2F; 开启多线程        new Thread(run).start();    }}</code></pre><p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一个方法来获取一个<code>java.util.Comparator</code>接口类型的对象作为排序器时，就可以调用该方法获取。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 使用Lambda作为返回值类型public class DemoComparator {    &#x2F;&#x2F; 定义一个方法，方法返回值类型使用函数式接口Comparator    public static Comparator&lt;String&gt; getComparator(){        &#x2F;&#x2F; 方法的返回值类型是一个接口，那么我们可以返回这个接口的匿名内部类&#x2F;&#x2F;        return new Comparator&lt;String&gt;() {&#x2F;&#x2F;            @Override&#x2F;&#x2F;            public int compare(String o1, String o2) {&#x2F;&#x2F;                return o2.length() - o1.length();&#x2F;&#x2F;            }&#x2F;&#x2F;        };        &#x2F;&#x2F; 方法的返回值类型是一个函数式接口，所以我们可以返回一个Lambda表达式        return (String o1,String o2) -&gt; o2.length() - o1.length();    }    public static void main(String[] args) {        &#x2F;&#x2F; 创建一个字符串数组        String[] arr = {&quot;aaa&quot;,&quot;b&quot;,&quot;cccc&quot;,&quot;dddddd&quot;};        System.out.println(Arrays.toString(arr));        &#x2F;&#x2F; 调用Arrays中的sort方法，对字符串数组进行排序        Arrays.sort(arr,getComparator());        System.out.println(Arrays.toString(arr));    }}</code></pre><h2 id="3-常用函数式接口"><a href="#3-常用函数式接口" class="headerlink" title="3. 常用函数式接口"></a>3. 常用函数式接口</h2><p>JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在<code>java.util.function</code>包中被提供。</p><h3 id="3-1-Supplier接口"><a href="#3-1-Supplier接口" class="headerlink" title="3.1 Supplier接口"></a>3.1 Supplier接口</h3><p><code>java.util.funtion.Supplier&lt;T&gt;</code>接口仅包含一个无参的方法：<code>T get()</code>。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，也就意味着对应的Lambda表达式需要”<strong>对外提供</strong>“一个符合泛型类型的对象数据。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoSupplier {    &#x2F;&#x2F; 定义一个方法，方法的参数传递Supplier&lt;T&gt;接口，泛型执行get方法就会返回一个String    public static String getString(Supplier&lt;String&gt; sup){        return sup.get();    }    public static void main(String[] args) {        &#x2F;&#x2F; 调用getString方法，方法的参数Supplier是一个函数式接口，所以可以传递Lambda表达式        String s = getString(() -&gt; &quot;你好呀&quot;);        System.out.println(s);    }}&#x2F;&#x2F; Supplier&lt;T&gt;接口被称之为生成型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型数据</code></pre><h3 id="3-2-练习：求数组元素最大值"><a href="#3-2-练习：求数组元素最大值" class="headerlink" title="3.2 练习：求数组元素最大值"></a>3.2 练习：求数组元素最大值</h3><p>使用<code>Supplier</code>接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoMaxArray {    &#x2F;&#x2F; 定义一个方法，用于获取int类型数组中元素的最大值，方法的参数传递Supplier接口，泛型使用Integer    public static int getMax(Supplier&lt;Integer&gt; sup){        return sup.get();    }    public static void main(String[] args) {        int[] arr = {99,35,72,956,12,-3};        int maxValue = getMax(()-&gt;{            int max = arr[0];            for (int i : arr) {                if (i&gt;max)                    max = i;            }            return max;        });        System.out.println(&quot;数组中最大值元素为：&quot; + maxValue);    }}</code></pre><h3 id="3-3-Consumer接口"><a href="#3-3-Consumer接口" class="headerlink" title="3.3 Consumer接口"></a>3.3 Consumer接口</h3><p><code>java.util.function.Consumer&lt;T&gt;</code>接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。</p><h4 id="抽象方法：accept"><a href="#抽象方法：accept" class="headerlink" title="抽象方法：accept"></a>抽象方法：accept</h4><p><code>Consumer</code>接口中包含抽象方法<code>void accept(T t)</code>,意为消费一个指定泛型的数据。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoConsumer {    &#x2F;*        定义一个方法        方法的参数传递一个字符串的姓名        方法的参数传递Consumer接口，泛型使用String        可以使用Consumer接口消费字符串的姓名     *&#x2F;    public static void method(String name,Consumer&lt;String&gt; con){        con.accept(name);    }    public static void main(String[] args) {        &#x2F;&#x2F; 调用method方法，传递字符串姓名，方法的另一个参数是Consumer接口，是一个函数式接口，可以使用Lambda表达式        method(&quot;上海&quot;,(String name)-&gt;{            &#x2F;&#x2F; 对传递的字符串进行消费            &#x2F;&#x2F; 消费方式：直接输出字符串            System.out.println(name);            &#x2F;&#x2F; 消费方式：对字符串进行反转输出            String reName = new StringBuffer(name).reverse().toString();            System.out.println(reName);        });    }}&#x2F;&#x2F; result:上海海上</code></pre><h4 id="默认方法-andThen"><a href="#默认方法-andThen" class="headerlink" title="默认方法: andThen"></a>默认方法: andThen</h4><p>如果一个方法的参数和返回值全都是<code>Consumer</code>类型，那么就可以实现效果：消费数据的时候，先做一个操作，然后在做另一个操作，实现组合。而这个方法就是<code>Consumer</code>接口中的default方法<code>andThen</code>。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;*    Consumer接口的默认方法andThen    作用：需要两个Consumer接口，可以把两个Consumer接口组合到一起，在对数据进行消费    例如：      Consumer&lt;String&gt; con1      Consumer&lt;String&gt; con2      String s= &quot;hello&quot;;      con1.accept(s);      con2.accept(s);      连接两个Consumer接口，再进行消费      con1.andThen(con2).accept(s); 谁写前面谁先消费 *&#x2F;public class DemoAndThen {    private static void consumerString(String s,Consumer&lt;String&gt; one,Consumer&lt;String&gt; two){&#x2F;&#x2F;        one.accept(s);&#x2F;&#x2F;        two.accept(s);        &#x2F;&#x2F; 使用andThen方法，把两个Consumer接口连接到一起消费数据,等效于上面        one.andThen(two).accept(s);    }    public static void main(String[] args) {        &#x2F;&#x2F; 因为有两个Consumer接口，所以要传递两个Lambda进去        consumerString(&quot;Hello&quot;,                s -&gt; System.out.println(s.toUpperCase()),                s -&gt; System.out.println(s.toLowerCase()));    }}</code></pre><h3 id="3-4-练习：格式化打印信息"><a href="#3-4-练习：格式化打印信息" class="headerlink" title="3.4 练习：格式化打印信息"></a>3.4 练习：格式化打印信息</h3><p>将下面字符串数组中的信息，按照格式<code>姓名：xxx，性别：x。</code>的格式将信息打印出来。要求将打印姓名的动作作为第一个<code>Consumer</code>接口的Lambda实例，将打印性别作为第二个<code>Consumer</code>接口的Lambda实例，将两个<code>Consumer</code>接口按照顺序拼接到一起。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 字符串数组String[] arr = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;};</code></pre><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ConsumerExercise {    public static void main(String[] args) {        String[] arr = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;};        printInfo(arr,s -&gt; System.out.print(&quot;姓名：&quot;+s.split(&quot;,&quot;)[0]), &#x2F;&#x2F; 消费方式：对info进行切割，读取姓名，按照指定格式输出                  s -&gt; System.out.println(&quot;,性别：&quot;+s.split(&quot;,&quot;)[1]+&quot;。&quot;)); &#x2F;&#x2F; 对info进行切割，读取年龄，按照指定格式输出    }    private static void printInfo(String[] arr, Consumer&lt;String&gt; one, Consumer&lt;String&gt; two){        for (String info:arr)            one.andThen(two).accept(info);    }}&#x2F;* result：姓名：迪丽热巴,性别：女。姓名：古力娜扎,性别：女。姓名：马尔扎哈,性别：男。 *&#x2F;</code></pre><h3 id="3-5-Predicate接口"><a href="#3-5-Predicate接口" class="headerlink" title="3.5 Predicate接口"></a>3.5 Predicate接口</h3><p>有时我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<code>java.util.function.Predicate&lt;T&gt;</code>接口。</p><h4 id="抽象方法：test"><a href="#抽象方法：test" class="headerlink" title="抽象方法：test"></a>抽象方法：test</h4><p><code>Predicate</code>接口中包含一个抽象方法：<code>boolean test(T t)</code>。用于条件判断场景：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoPredicate {    public static boolean checkString(String s,Predicate&lt;String&gt; pre){       return pre.test(s);    }    public static void main(String[] args) {        String s = &quot;helloworld&quot;;        boolean b = checkString(s, str -&gt; str.length() &gt; 5);&#x2F;&#x2F; 对参数传递的字符串进行判断，判断字符串长度是否大于5，并把判断的结果返回        System.out.println(b);    }}</code></pre><h4 id="默认方法：and"><a href="#默认方法：and" class="headerlink" title="默认方法：and"></a>默认方法：and</h4><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个<code>Predicate</code>条件使用“与”逻辑连接起来实现“<strong>并且</strong>”的效果时，可以使用default方法<code>and</code>。</p><p>​    如果要判断一个字符串既包含大写”H”，又要包含大写”W”，示例代码如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoPredicateAnd {    public static void method(String s, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two){        boolean isValid = one.and(two).test(s);        System.out.println(&quot;字符串符合要求吗：&quot; + isValid);    }    &#x2F;*        contains(String str)            当且仅当该字符串包含str时，返回true，反之返回false     *&#x2F;    public static void main(String[] args) {        method(&quot;Helloworld&quot;,s-&gt;s.contains(&quot;H&quot;),s-&gt;s.contains(&quot;W&quot;));    }}&#x2F;&#x2F; result:false</code></pre><h4 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h4><p>与<code>and</code>类似的，默认方法<code>or</code>实现逻辑关系中的”<strong>或</strong>“。</p><p>如果希望实现逻辑”字符串包含大写H或者大写W”，那么只需要将上个例子代码<code>and</code>修改为<code>or</code>即可实现。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoPredicateAnd {    public static void method(String s, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two){        &#x2F;&#x2F; 只需修改and--&gt;or即可        boolean isValid = one.or(two).test(s);        System.out.println(&quot;字符串符合要求吗：&quot; + isValid);    }    public static void main(String[] args) {        method(&quot;Helloworld&quot;,s-&gt;s.contains(&quot;H&quot;),s-&gt;s.contains(&quot;W&quot;));    }}</code></pre><h4 id="默认方法：negate"><a href="#默认方法：negate" class="headerlink" title="默认方法：negate"></a>默认方法：negate</h4><p>“非”(取反)。源码中只是对结果boolean值进行”!”取反而已。调用方法跟<code>and</code>和<code>or</code>一样。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoPredicateNegate {    public static void method(Predicate&lt;String&gt; pre){        boolean isLong = pre.negate().test(&quot;helloworld&quot;);        System.out.println(&quot;字符串很长吗：&quot;+isLong);    }    public static void main(String[] args) {        method(s-&gt;s.length()&lt;5); &#x2F;&#x2F; true    }}</code></pre><h3 id="3-6-练习：集合信息筛选"><a href="#3-6-练习：集合信息筛选" class="headerlink" title="3.6 练习：集合信息筛选"></a>3.6 练习：集合信息筛选</h3><p>数组当中有多条”姓名+性别”格式的信息，通过<code>Predicate</code>接口的方法将符合要求的字符串筛选到集合<code>ArrayList</code>中，需同时满足以下两个条件：</p><pre><code>1. 必须为女生 2. 姓名必须是4个字</code></pre><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;数组String[] array = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; };</code></pre><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ExercisePredicate {    public static boolean FilterArray(String s, Predicate&lt;String&gt; one,Predicate&lt;String&gt; two){        return one.and(two).test(s);    }    public static void main(String[] args) {        String[] array = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; };        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();        for (String s:array){            boolean b = FilterArray(s, str -&gt; str.split(&quot;,&quot;)[0].length() == 4, str -&gt; str.contains(&quot;女&quot;));            if (b==true)                arrayList.add(s);        }        System.out.println(arrayList);    }}</code></pre><h3 id="3-7-Function接口"><a href="#3-7-Function接口" class="headerlink" title="3.7 Function接口"></a>3.7 Function接口</h3><p><code>java.util.function.Function&lt;T,R&gt;</code>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p><h4 id="抽象方法：apply"><a href="#抽象方法：apply" class="headerlink" title="抽象方法：apply"></a>抽象方法：apply</h4><p>Function接口中最主要的抽象方法为：<code>R apply(T t)</code>，根据类型T的参数获取类型R的结果。</p><p>​    使用的场景例如：将<code>String</code>类型转换为<code>Integer</code>类型。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoFunctionApply {    &#x2F;*        定义一个方法        方法的参数传递 一个字符串类型的整数        方法的参数传递以Function接口，泛型使用&lt;String,Integer&gt;        使用Function接口中的方法apply，把字符串类型的整数，转换为Integer类型的整数     *&#x2F;    public static void change(String s, Function&lt;String,Integer&gt; fun){        int in = fun.apply(s); &#x2F;&#x2F; 自动拆箱，Integer-&gt;int        System.out.println(in);    }    public static void main(String[] args) {        change(&quot;10&quot;,str-&gt;Integer.parseInt(str));    }}</code></pre><h4 id="默认方法：andThen"><a href="#默认方法：andThen" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h4><p><code>Function</code>接口中有一个默认的andThen方法，用来进行组合操作。</p><p>​    该方法同样用于“先做什么，再做什么”的场景，和<code>Consumer</code>中的<code>andThen</code>差不多</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;*分析：        转换了两次        第一次是把String类型转换为了Integer类型            所以我们可以使用Function&lt;String,Integer&gt; fun1                Integer i = fun1.apply(&quot;123&quot;)+10;        第二次是把Integer类型转换为String类型            所以我们可以使用Function&lt;Integer,String&gt; fun2                String s = fun2.apply(i);        我们可以使用andThen方法，把两次转换组合在一起使用            String s = fun1.andThen(fun2).apply(&quot;123&quot;);            fun1先调用apply方法，把字符串转换为Integer            fun2再调用apply方法，把Integer转换为字符串*&#x2F;public class DemoFunctionAndThen {    public static void MySwitch(String s, Function&lt;String,Integer&gt; fun1,Function&lt;Integer,String&gt; fun2){        String str = fun1.andThen(fun2).apply(s);        System.out.println(str); &#x2F;&#x2F; 133    }    public static void main(String[] args) {        String s = &quot;123&quot;;        MySwitch(s,str-&gt;Integer.parseInt(str)+10,i-&gt;i+&quot;&quot;);&#x2F;&#x2F; 字符串转换为整数并+10，然后再转换回字符串    }}</code></pre><h3 id="3-8-练习：自定义函数模型拼接"><a href="#3-8-练习：自定义函数模型拼接" class="headerlink" title="3.8 练习：自定义函数模型拼接"></a>3.8 练习：自定义函数模型拼接</h3><p>使用<code>Function</code>进行函数模型的拼接，按照顺序需要执行的多个函数操作如下：</p><pre><code>1. 将字符串截取数字年龄部分，得到字符串 2. 将年龄字符串转换为int类型的数字 3. 将int数字累加100，得到结果int数字</code></pre><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ExerciseFunction {    public static int change(String s, Function&lt;String,String&gt; one,Function&lt;String,Integer&gt; two,Function&lt;Integer,Integer&gt; three){        return one.andThen(two).andThen(three).apply(s);    }    public static void main(String[] args) {        String str = &quot;赵丽颖,20&quot;;        int n = change(str, s -&gt; s.split(&quot;,&quot;)[1], s -&gt; Integer.parseInt(s), i -&gt; i += 100);        System.out.println(n); &#x2F;&#x2F; 120    }}</code></pre><h2 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h2><ul><li style="list-style: none"><input type="checkbox" checked> 能够使用@FunctionalInterface注解</li><li style="list-style: none"><input type="checkbox" checked> 能够自定义无参无返回函数式接口</li><li style="list-style: none"><input type="checkbox" checked> 能够自定义有参有返回函数式接口</li><li style="list-style: none"><input type="checkbox" checked> 能够理解Lambda延迟执行的特点</li><li style="list-style: none"><input type="checkbox" checked> 能够使用Lambda作为方法的参数</li><li style="list-style: none"><input type="checkbox" checked> 能够使用Lambda作为方法的返回值</li><li style="list-style: none"><input type="checkbox" checked> 能够使用Supplier函数式接口</li><li style="list-style: none"><input type="checkbox" checked> 能够使用Consumer函数式接口</li><li style="list-style: none"><input type="checkbox" checked> 能够使用Function函数式接口</li><li style="list-style: none"><input type="checkbox" checked> 能够使用Predicate函数式接口</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/JavaBasics/network-programming.html"/>
      <url>/JavaBasics/network-programming.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-网络编程基础概念"><a href="#1-网络编程基础概念" class="headerlink" title="1. 网络编程基础概念"></a>1. 网络编程基础概念</h2><h3 id="1-1-软件结构"><a href="#1-1-软件结构" class="headerlink" title="1.1 软件结构"></a>1.1 软件结构</h3><ul><li><strong>C/S结构</strong>：全称为Client/Server结构，是指客户端和服务器结构。常见程序如QQ、迅雷等。</li><li><strong>B/S结构</strong>：全称为Brower/Server结构，是指浏览器和服务器结构。常见浏览器如谷歌、火狐等。</li></ul><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><a id="more"></a><h3 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h3><ul><li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为<strong>网络通信协议</strong>，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li><li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/13/3_tcp_ip-1557711751122.jpg" alt="title"></p><p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。</p><p><strong>链路层</strong>：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br><strong>网络层</strong>：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br><strong>传输层</strong>：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br><strong>应用层</strong>：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p><h3 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h3><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>但是在使用UDP协议传送数据时，由于UDP的<strong>面向无连接性</strong>，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p></li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/13/UDP%E9%80%9A%E4%BF%A1%E5%9B%BE%E8%A7%A3-1557712097787.bmp" alt="title"></p><p>特点：数据被限制在64KB以内，超出这个范围就不能发送了。</p><p>数据报(Datagram):网络传输的基本单位</p><ul><li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/13/4_tcp-1557712258327.jpg" alt="title"></p><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><h3 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul><li><strong>协议</strong>：计算机网络通信必须遵守的规则。</li></ul><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><ul><li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li></ul><p><strong>IP地址分类</strong></p><ul><li>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</li><li>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</li></ul><p>　　为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p><p><strong>常用命令</strong></p><ul><li><p>查看本机IP地址，在控制台输入：<code>ipconfig</code></p></li><li><p>检查网络是否连通，在控制台输入：<code>ping IP地址</code>，<code>ping 220.181.57.216</code></p></li><li><p>特殊IP地址：本机IP地址<code>127.0.0.1</code> or <code>localhost</code></p></li></ul><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h2 id="2-TCP通信程序"><a href="#2-TCP通信程序" class="headerlink" title="2. TCP通信程序"></a>2. TCP通信程序</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端(Client)与服务端(Server)。</p><p><strong>两端通信时步骤：</strong></p><ol><li>服务端程序，需要事先启动，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li></ol><p><strong>在Java中，提供了两个类用于实现TCP通信程序</strong>：</p><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li></ol><h3 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h3><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。</li></ul><blockquote><p>Tips: 回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p></blockquote><p>代码示例:</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Socket client = new Socket(&quot;127.0.0.1&quot;,8888);</code></pre><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul><li><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。<ul><li>如果此Socket具有相关联的通道，则生成的InputStream的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul></li><li><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。<ul><li>如果此Socket具有相关联的通道，则生成的OutputStream的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul></li><li><code>public void close()</code> ：关闭此套接字。<ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li></ul></li><li><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   <ul><li>任何先前写出的数据将被发送，随后终止输出流。 </li></ul></li></ul><h3 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h3><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li></ul><p>代码举例：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">ServerSocket = server = new ServerSocket(8888);</code></pre><h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><ul><li><code>public Socket accept()</code> ：监听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li></ul><h3 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h3><h4 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h4><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Socket对象，获取InputStream，读取客户端发送的数据。</li></ol><blockquote><p>到此，客户端向服务端发送数据成功。</p></blockquote><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/13/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1-1557714678758.jpg" alt="title"></p><blockquote><p>自此，服务端向客户端回写数据。</p></blockquote><ol start="6"><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Socket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。</li></ol><h4 id="客户端与服务器数据收发代码示例"><a href="#客户端与服务器数据收发代码示例" class="headerlink" title="客户端与服务器数据收发代码示例"></a>客户端与服务器数据收发代码示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 客户端实现public class ClientTCP {    public static void main(String[] args) throws IOException {        System.out.println(&quot;客户端，发送数据&quot;);        &#x2F;&#x2F; 1.1. 创建一个客户端对象Socket，构造方法绑定服务器的IP和端口号        Socket client = new Socket(&quot;localhost&quot;,8888);        &#x2F;&#x2F; 2.使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象        OutputStream os= client.getOutputStream();        &#x2F;&#x2F; 3.使用网络字节输出流对象中的方法write，给服务器发送数据        os.write(&quot;测试传输数据....&quot;.getBytes());        &#x2F;&#x2F; 4. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象        InputStream is = client.getInputStream();        &#x2F;&#x2F; 5. 使用网络字节输入流对象中的方法read，读取服务器回写的数据        byte[] b = new byte[1024];        int len = is.read(b);        System.out.println(new String(b,0,len));        &#x2F;&#x2F; 6. 释放资源        client.close();    }}&#x2F;&#x2F; 服务器端实现public class ServerTCP {    public static void main(String[] args) throws IOException {        System.out.println(&quot;服务端启动，等待客户端连接.....&quot;);        &#x2F;&#x2F; 1. 创建服务器ServerSocket对象和系统要指定的端口号        ServerSocket server = new ServerSocket(8888);        &#x2F;&#x2F; 2. 使用ServerSocket对象中的accept方法，获取请求的客户端对象Socket        Socket socket = server.accept();        &#x2F;&#x2F; 3. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象        InputStream is = socket.getInputStream();        &#x2F;&#x2F; 4. 使用网络字节输入流对象中的方法read，读取客户端发送的数据        byte[] bytes = new byte[1024];        int len = is.read(bytes);        String msg = new String(bytes,0,len);        System.out.println(msg);        &#x2F;&#x2F; 5. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象        OutputStream os = socket.getOutputStream();        &#x2F;&#x2F; 6. 使用网络字节输出流对象中的方法write，给客户端回写数据        os.write(&quot;服务端已接收到数据....&quot;.getBytes());        &#x2F;&#x2F; 7. 释放资源        server.close();        socket.close();    }}</code></pre><h2 id="3-文件传输案例"><a href="#3-文件传输案例" class="headerlink" title="3. 文件传输案例"></a>3. 文件传输案例</h2><h3 id="3-1-案例分析"><a href="#3-1-案例分析" class="headerlink" title="3.1 案例分析"></a>3.1 案例分析</h3><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/13/6_upload-1557733549763.jpg" alt="title"></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 客户端public class FileUpload_Client {    public static void main(String[] args) throws IOException {        System.out.println(&quot;客户端开始发送文件...&quot;);        &#x2F;&#x2F; 1. 创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源        FileInputStream fis = new FileInputStream(&quot;C:\\Users\\14908\\Desktop\\upload.jpg&quot;);        &#x2F;&#x2F; 2. 创建一个客户端Socket对象，构造方法中绑定服务器IP和端口号        Socket client = new Socket(&quot;localhost&quot;,8888);        &#x2F;&#x2F; 3. 使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象        OutputStream os = client.getOutputStream();        &#x2F;&#x2F; 4. 使用本地字节输入流FileInputStream对象中的方法read，读取本地文件        byte[] b = new byte[1024];        int len;        while ((len = fis.read(b)) != -1){            &#x2F;&#x2F; 5. 使用网络字节输出流OutputStream对象中的write方法，把读取的文件上传到服务器            os.write(b,0,len);        }        &#x2F;*            解决阻塞问题：上传完文件，给服务器写一个结束标记            void shutdownOutPut() 禁用此套接字的输出流            对于TCP套接字，任何此前写入的数据都将被发送，并且后跟TCP的正常连接终止序列         *&#x2F;        client.shutdownOutput();        &#x2F;&#x2F; 6. 使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象        InputStream is = client.getInputStream();        &#x2F;&#x2F; 7. 使用网络字节输入流流InputStream对象中的方法read，读取服务器回写的数据        while (((len = is.read(b))!=-1)){            System.out.println(new String(b,0,len));        }        &#x2F;&#x2F; 8. 释放资源(FileInputStream,Socket)        fis.close();        client.close();    }}&#x2F;&#x2F; 服务器端public class FileUpload_Server {    public static void main(String[] args) throws IOException {        System.out.println(&quot;服务器启动，等待连接...&quot;);        &#x2F;&#x2F; 1. 创建一个本地字节输出流FileOutputStream对象，构造方法中绑定目的地        FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_13\\download.jpg&quot;);        &#x2F;&#x2F; 2. 创建一个服务端ServerSocket对象，构造方法中绑定侦听的端口号        ServerSocket server = new ServerSocket(8888);        &#x2F;&#x2F; 3. 使用ServerSocket对象的accept方法，接收客户端的socket对象        Socket socket = server.accept();        &#x2F;&#x2F; 4. 使用socket中的方法getInputStream，获取网络字节输入流InputStream对象        InputStream is = socket.getInputStream();        byte[] bytes = new byte[1024];        &#x2F;&#x2F; 5. 使用网络字节输入流InputStream对象中的read方法，读取客户端传输过来的数据        int len;        while ((len = is.read(bytes)) != -1){            &#x2F;&#x2F; 6. 使用本地字节输出流FileOutputStream对象中的方法write，将文件写出到硬盘            fos.write(bytes,0,len);            fos.flush();        }        &#x2F;&#x2F; 7. 使用socket中的方法getOutputStream，获取网络字节输出流对象，使用write方法回写数据        socket.getOutputStream().write(&quot;上传成功!&quot;.getBytes());        &#x2F;&#x2F; 8. 释放资源        fos.close();        socket.close();        server.close();    }}</code></pre><h4 id="文件上传优化"><a href="#文件上传优化" class="headerlink" title="文件上传优化"></a>文件上传优化</h4><ol><li><p><strong>文件名写死问题</strong></p><p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，可以使用系统时间优化文件名称，保证文件名称唯一。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_13\\&quot;+System.currentTimeMillis()+&quot;.jpg&quot;);</code></pre></li></ol><ol start="2"><li><p><strong>服务器端循环接收的问题</strong></p><p>服务器端应该保持运行，持续接收来自不同用户的文件，使用循环改进即可。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   &#x2F;&#x2F; 每次接收新的连接，创建一个Socket   while(true){       Socket socket = server.accept();       .....   }</code></pre></li></ol><ol start="3"><li><p><strong>效率问题</strong></p><p>服务端在接收大文件时，可能要耗费更多的时间，此时不能接收其他用户上传的文件，所以使用多线程技术优化。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">   while(true){       Socket socket = server.accept();       &#x2F;&#x2F; 新的socket交给子线程处理       new Thread(() -&gt; {           &#x2F;&#x2F; 处理文件保存代码       }).start();   }</code></pre></li></ol><h4 id="优化代码实现"><a href="#优化代码实现" class="headerlink" title="优化代码实现"></a>优化代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 客户端public class FileUpload_Client {    public static void main(String[] args) throws IOException {        System.out.println(&quot;客户端开始发送文件...&quot;);        &#x2F;&#x2F; 1. 创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源        FileInputStream fis = new FileInputStream(&quot;C:\\Users\\14908\\Desktop\\upload.jpg&quot;);        &#x2F;&#x2F; 2. 创建一个客户端Socket对象，构造方法中绑定服务器IP和端口号        Socket client = new Socket(&quot;localhost&quot;,8888);        &#x2F;&#x2F; 3. 使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象        OutputStream os = client.getOutputStream();        &#x2F;&#x2F; 4. 使用本地字节输入流FileInputStream对象中的方法read，读取本地文件        byte[] b = new byte[1024];        int len;        while ((len = fis.read(b)) != -1){            &#x2F;&#x2F; 5. 使用网络字节输出流OutputStream对象中的write方法，把读取的文件上传到服务器            os.write(b,0,len);        }        &#x2F;*            解决阻塞问题：上传完文件，给服务器写一个结束标记            void shutdownOutPut() 禁用此套接字的输出流            对于TCP套接字，任何此前写入的数据都将被发送，并且后跟TCP的正常连接终止序列         *&#x2F;        client.shutdownOutput();        &#x2F;&#x2F; 6. 使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象        InputStream is = client.getInputStream();        &#x2F;&#x2F; 7. 使用网络字节输入流流InputStream对象中的方法read，读取服务器回写的数据        while (((len = is.read(b))!=-1)){            System.out.println(new String(b,0,len));        }        &#x2F;&#x2F; 8. 释放资源(FileInputStream,Socket)        fis.close();        client.close();    }}&#x2F;&#x2F; 服务器端public class FileUpload_Server {    public static void main(String[] args) throws IOException {        System.out.println(&quot;服务器启动，等待连接...&quot;);        &#x2F;&#x2F; 2. 创建一个服务端ServerSocket对象，构造方法中绑定侦听的端口号        ServerSocket server = new ServerSocket(8888);        &#x2F;&#x2F; 3. 使用ServerSocket对象的accept方法，接收客户端的socket对象        while (true) { &#x2F;&#x2F; 循环接收socket对象            Socket socket = server.accept();            new Thread(() -&gt; { &#x2F;&#x2F; 线程优化多用户访问                try{                    &#x2F;&#x2F; 4. 使用socket中的方法getInputStream，获取网络字节输入流InputStream对象                    InputStream is = socket.getInputStream();                    &#x2F;&#x2F; 1. 创建一个本地字节输出流FileOutputStream对象，构造方法中绑定目的地                    FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_13\\&quot;+System.currentTimeMillis()+&quot;.jpg&quot;);                    byte[] bytes = new byte[1024];                    &#x2F;&#x2F; 5. 使用网络字节输入流InputStream对象中的read方法，读取客户端传输过来的数据                    int len;                    while ((len = is.read(bytes)) != -1) {                        &#x2F;&#x2F; 6. 使用本地字节输出流FileOutputStream对象中的方法write，将文件写出到硬盘                        fos.write(bytes, 0, len);                        fos.flush();                    }                    &#x2F;&#x2F; 7. 使用socket中的方法getOutputStream，获取网络字节输出流对象，使用write方法回写数据                    socket.getOutputStream().write(&quot;上传成功!&quot;.getBytes());                    &#x2F;&#x2F; 8. 释放资源                    fos.close();                    socket.close();                }catch (IOException e) {                    e.printStackTrace();                }            }).start();        }        &#x2F;&#x2F; 服务器就不用关闭了&#x2F;&#x2F;        server.close();    }}</code></pre><h3 id="3-2-模拟B-S服务器"><a href="#3-2-模拟B-S服务器" class="headerlink" title="3.2 模拟B\S服务器"></a>3.2 模拟B\S服务器</h3><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;*    BS版本TCP服务器 *&#x2F;public class BServer {    public static void main(String[] args) throws IOException {        ServerSocket server = new ServerSocket(8088);        &#x2F;*            浏览器解析服务器回写的html页面，页面中如果有图片，那么浏览器就会单独开启一个线程，读取服务器的图片            我们需要让服务器一直处于监听状态，客户端请求一次，服务器端回写一次。         *&#x2F;        while (true){            Socket socket = server.accept();            new Thread(()-&gt;{                try{                    InputStream is = socket.getInputStream(); &#x2F;&#x2F; 网络字节输入流                    &#x2F;&#x2F; 把is网络字节输入流对象，转换为字符缓冲输入流                    BufferedReader br = new BufferedReader(new InputStreamReader(is));                    &#x2F;&#x2F; 把客户端请求信息的第一行读取出来                    String line = br.readLine();                    System.out.println(line); &#x2F;&#x2F; 输出请求的路径                    &#x2F;&#x2F; 把读取的信息以空格进行分离，只要中间部分                    String[] arr = line.split(&quot; &quot;);                    &#x2F;&#x2F; 把路径前面的&#x2F;去除,获取Demo5_13\web\index.html                    String htmlpath = arr[1].substring(1);                    &#x2F;&#x2F; 创建一个本地字节输入流，构造方法中绑定要读取的html路径                    FileInputStream fis = new FileInputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\&quot;+htmlpath);                    &#x2F;&#x2F; 使用Socket中的getOutputStream方法，获取网络字节输出流对象                    OutputStream os = socket.getOutputStream();                    &#x2F;&#x2F; 写入html协议响应头，固定写法                    os.write(&quot;HTTP&#x2F;1.1 200 OK\r\n&quot;.getBytes());                    os.write(&quot;Content-Type:text&#x2F;html\r\n&quot;.getBytes());                    &#x2F;&#x2F;必须写入空行，否则浏览器不解析                    os.write(&quot;\r\n&quot;.getBytes());                    &#x2F;&#x2F; 一读一写复制文件，把服务器读取的html文件回写到客户端                    int len;                    byte[] bytes = new byte[1024];                    while ((len = fis.read(bytes)) != -1) {                        os.write(bytes,0,len);                    }                    &#x2F;&#x2F; 释放资源                    fis.close();                    socket.close();                }catch (IOException E){                    E.printStackTrace();                }            }).start();        }        &#x2F;&#x2F;server.close();    }}</code></pre><h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><ul><li style="list-style: none"><input type="checkbox" checked> 能够辨别UDP和TCP协议特点。无连接和有连接，传输数据安全和传输效率高</li><li style="list-style: none"><input type="checkbox" checked> 能够说出TCP协议下两个常用类名称。Socket，ServerSocket。</li><li style="list-style: none"><input type="checkbox" checked> 能够编写TCP协议下字符串数据传输程序。OutputStream.write(“hello”.getBytes());</li><li style="list-style: none"><input type="checkbox" checked> 能够理解TCP协议下文件上传案例。本地字节输入流读取数据，通过网络字节输出流发送到服务器，服务器通过网络字节输入流循环读取数据，使用本地字节输入流写出到硬盘中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓冲流、转换流、序列化流、打印流</title>
      <link href="/JavaBasics/io.html"/>
      <url>/JavaBasics/io.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-缓冲流"><a href="#1-缓冲流" class="headerlink" title="1. 缓冲流"></a>1. 缓冲流</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><a id="more"></a><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><h3 id="1-1-字节缓冲流"><a href="#1-1-字节缓冲流" class="headerlink" title="1.1 字节缓冲流"></a>1.1 字节缓冲流</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li></ul><h4 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h4><p>缓冲流读写方法与基本流是一致的，通过复制大文件(560MB)，来测试一下效率。</p><ol><li>基本流代码</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class BufferedDemo01 {    public static void main(String[] args) {        long start = System.currentTimeMillis(); &#x2F;&#x2F; 记录开始时间        &#x2F;&#x2F; 创建流对象        try(            FileInputStream fis = new FileInputStream(&quot;D:\\chrome\\IdeaInstall.exe&quot;);            FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\copy.exe&quot;);        ){            &#x2F;&#x2F;读写数据            int b;            while ((b = fis.read())!=-1){                fos.write(b);            }        }catch (IOException e) {            e.printStackTrace();        }        long end = System.currentTimeMillis();&#x2F;&#x2F; 记录结束时间        System.out.println(&quot;普通流复制560MB所需时间：&quot;+(end-start)+&quot;毫秒&quot;);    }}&#x2F;&#x2F; result: long long time</code></pre><ol start="2"><li>缓冲流代码</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ButteredDemo02 {    public static void main(String[] args) {        long start = System.currentTimeMillis(); &#x2F;&#x2F; 记录开始时间        try(&#x2F;&#x2F; 创建缓冲流对象            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;D:\\chrome\\IdeaInstall.exe&quot;));            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\copy2.exe&quot;))        ){            &#x2F;&#x2F;读写数据            int b;            while ((b = bis.read())!=-1){                bos.write(b);            }        } catch (IOException e) {            e.printStackTrace();        }        long end = System.currentTimeMillis(); &#x2F;&#x2F; 记录结束时间        System.out.println(&quot;缓冲流复制560MB所需时间：&quot;+(end-start)+&quot;毫秒&quot;);    }}&#x2F;&#x2F; result：缓冲流复制560MB所需时间：40171毫秒</code></pre><ol start="3"><li>使用数组优化</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ButteredDemo02 {    public static void main(String[] args) {        long start = System.currentTimeMillis(); &#x2F;&#x2F; 记录开始时间        try(&#x2F;&#x2F; 创建缓冲流对象            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;D:\\chrome\\IdeaInstall.exe&quot;));            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\copy2.exe&quot;))        ){            &#x2F;&#x2F;读写数据            int len;            byte[] bytes = new byte[8*1024]; &#x2F;&#x2F; 使用数组对象优化            while ((len = bis.read(bytes))!=-1){                bos.write(bytes,0,len);  &#x2F;&#x2F; 只写入有效字节数据            }        } catch (IOException e) {            e.printStackTrace();        }        long end = System.currentTimeMillis(); &#x2F;&#x2F; 记录结束时间        System.out.println(&quot;缓冲流使用数组复制560MB所需时间：&quot;+(end-start)+&quot;毫秒&quot;);    }}&#x2F;&#x2F; result:缓冲流使用数组复制560MB所需时间：2847毫秒</code></pre><h3 id="1-2-字符缓冲流"><a href="#1-2-字符缓冲流" class="headerlink" title="1.2 字符缓冲流"></a>1.2 字符缓冲流</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个新的字符缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的字符缓冲输出流。</li></ul><h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><p>字符缓冲流的基本方法与普通字符流调用方式一致，但它具备特有的方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li></ul><p><code>readLine</code>方法演示：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class BufferedReaderDemo01 {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 创建流对象        BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\read.txt&quot;));        &#x2F;&#x2F; 定义字符串，保存读取的一行文字        String line;        &#x2F;&#x2F; 循环读取，直到读取到null        while ((line = br.readLine())!=null){            System.out.print(line);            System.out.println(&quot;，&quot;);        }        br.close(); &#x2F;&#x2F; 释放资源    }}</code></pre><p><code>newLine</code>方法演示：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class BufferedWriterDemo02 {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 创建流对象        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\out.txt&quot;));        &#x2F;&#x2F; 写出数据        bw.write(&quot;你好&quot;);        bw.newLine(); &#x2F;&#x2F; 写出换行        bw.write(&quot;世界&quot;);        bw.newLine();        bw.close();    }}&#x2F;&#x2F; result:你好世界</code></pre><h3 id="1-3-练习：文本排序"><a href="#1-3-练习：文本排序" class="headerlink" title="1.3 练习：文本排序"></a>1.3 练习：文本排序</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</code></pre><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><ol><li>逐行读取文本信息。</li><li>解析文本信息到集合中。</li><li>遍历集合，按顺序，写出文本信息。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class BufferedExercise {    public static void main(String[] args) {        &#x2F;&#x2F; 创建map集合，保存文本数据，键为序号，值为文字        HashMap&lt;String,String&gt; lineMap = new HashMap&lt;&gt;();        &#x2F;&#x2F; 创建流对象        try(                BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\出师表.txt&quot;));                BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\sort.txt&quot;))        ){            &#x2F;&#x2F; 循环读取数据，解析存入map中            String line;            while((line = br.readLine())!=null){                &#x2F;&#x2F; 解析文本                String[] split = line.split(&quot;\\.&quot;); &#x2F;&#x2F; 以&quot;.&quot;作为分隔符，将一行分为序号和文字两部分                lineMap.put(split[0],split[1]);&#x2F;&#x2F; 序号为键，文字为值，存入集合中            }            &#x2F;&#x2F; 遍历map集合            for (int i = 1; i &lt;= lineMap.size(); i++) {                String key = String.valueOf(i); &#x2F;&#x2F; 获取键名为i的键                &#x2F;&#x2F; 获取map中的文本                String value = lineMap.get(key); &#x2F;&#x2F; 获取键名为key的对应值                &#x2F;&#x2F; 拼接字符串，并写出                bw.write(key + &quot;.&quot; + value);                bw.newLine(); &#x2F;&#x2F; 写出换行            }        }catch (IOException e){            e.printStackTrace();        }    }}</code></pre><h2 id="2-转换流"><a href="#2-转换流" class="headerlink" title="2. 转换流"></a>2. 转换流</h2><h3 id="2-1-字符编码和字符集"><a href="#2-1-字符编码和字符集" class="headerlink" title="2.1 字符编码和字符集"></a>2.1 字符编码和字符集</h3><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p><p><strong>编码</strong>:字符(能看懂的)–字节(看不懂的)</p><p><strong>解码</strong>:字节(看不懂的)–&gt;字符(能看懂的)</p><ul><li><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</li></ul><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><ul><li><strong>字符集 <code>Charset</code></strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p><img src="https://i.loli.net/2019/05/10/5cd540cb5cccd.jpg" alt=""></p><p>当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li></ul><ul><li><strong>ISO-8859-1字符集</strong>：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><strong>GBxxx字符集</strong>：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode字符集</strong> ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><h3 id="2-2-编码引出的问题"><a href="#2-2-编码引出的问题" class="headerlink" title="2.2 编码引出的问题"></a>2.2 编码引出的问题</h3><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><h3 id="2-3-InputStreamReader类"><a href="#2-3-InputStreamReader类" class="headerlink" title="2.3 InputStreamReader类"></a>2.3 InputStreamReader类</h3><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。`</li></ul><h4 id="指定编码读取Demo"><a href="#指定编码读取Demo" class="headerlink" title="指定编码读取Demo"></a>指定编码读取Demo</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ReaderDemo {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 定义文件路径        String FilePath = &quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\file_gbk.txt&quot;;        &#x2F;&#x2F; 创建流对象，默认UTF8编码        InputStreamReader isr = new InputStreamReader(new FileInputStream(FilePath));        &#x2F;&#x2F; 创建流对象，指定GBK编码        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FilePath),&quot;GBK&quot;);        &#x2F;&#x2F; 定义变量，保存字符        int read;        &#x2F;&#x2F; 使用默认编码字符流读取，乱码        while ((read = isr.read())!=-1){            System.out.print((char)read); &#x2F;&#x2F; ��Һ�        }        isr.close();        &#x2F;&#x2F; 使用指定GBK编码字符流读取        while ((read = isr2.read())!=-1){            System.out.println((char)read); &#x2F;&#x2F; 大家好        }        isr2.close();    }}</code></pre><h3 id="2-4-OutPutStreamWriter类"><a href="#2-4-OutPutStreamWriter类" class="headerlink" title="2.4 OutPutStreamWriter类"></a>2.4 OutPutStreamWriter类</h3><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><h4 id="指定编码写出Demo"><a href="#指定编码写出Demo" class="headerlink" title="指定编码写出Demo"></a>指定编码写出Demo</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class OutPutDemo {    public static void main(String[] args) throws IOException {        String FilePath = &quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\&quot;;        &#x2F;&#x2F; 创建流对象，默认UTF8编码        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FilePath + &quot;out2.txt&quot;));        &#x2F;&#x2F; 写出数据        osw.write(&quot;你好&quot;); &#x2F;&#x2F; 保存为6个字节        osw.close();        &#x2F;&#x2F; 创建流对象，指定GBK编码        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FilePath + &quot;out3.txt&quot;),&quot;GBK&quot;);        &#x2F;&#x2F; 写出数据        osw2.write(&quot;你好&quot;); &#x2F;&#x2F; 保存为4个字节        osw2.close();    }}</code></pre><h4 id="转换流图解"><a href="#转换流图解" class="headerlink" title="转换流图解"></a>转换流图解</h4><p><strong>转换流是字节与字符间的桥梁！</strong></p><p><img src="https://i.loli.net/2019/05/10/5cd56e55421e2.jpg" alt=""></p><h3 id="2-5-练习：转换文件编码"><a href="#2-5-练习：转换文件编码" class="headerlink" title="2.5 练习：转换文件编码"></a>2.5 练习：转换文件编码</h3><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p><h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><ol><li>指定GBK编码的转换流，读取文本文件。</li><li>使用UTF-8编码的转换流，写出文本文件。</li></ol><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class CodeSwitchDemo {    public static void main(String[] args) {        try( &#x2F;&#x2F; 1. 指定GBK编码的转换流，读取文本文件。             InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\file_gbk.txt&quot;),&quot;GBK&quot;);             OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\codeswitch.txt&quot;)) &#x2F;&#x2F; 默认就是utf8        ){            &#x2F;&#x2F; 读取文件            char[] chars = new char[1024]; &#x2F;&#x2F; 定义字符数组            int len;            while ((len = isr.read(chars))!=-1){ &#x2F;&#x2F; 使用字符数组优化读取                osw.write(chars,0,len); &#x2F;&#x2F; 写出            }        }catch (IOException e){            e.printStackTrace();        }    }}</code></pre><h2 id="3-序列化"><a href="#3-序列化" class="headerlink" title="3. 序列化"></a>3. 序列化</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： </p><p><img src="https://i.loli.net/2019/05/10/5cd575db8ecac.jpg" alt=""></p><h3 id="3-1-ObjectOutputStream类"><a href="#3-1-ObjectOutputStream类" class="headerlink" title="3.1 ObjectOutputStream类"></a>3.1 ObjectOutputStream类</h3><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public ObjectOutputStream(OutputStream out)</code>：创建一个指定<code>OutputStream</code>的<code>ObjectOutputStream</code>。</li></ul><h4 id="对象序列化操作-写对象操作"><a href="#对象序列化操作-写对象操作" class="headerlink" title="对象序列化操作(写对象操作)"></a>对象序列化操作(写对象操作)</h4><ol><li>一个对象要想序列化，必须满足两个条件</li></ol><ul><li>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Employee implements java.io.Serializable {    public String name;    public String address;    public transient int age; &#x2F;&#x2F; transient瞬态修饰成员,不会被序列化    public void addressCheck() {      System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);    }}</code></pre><ol start="2"><li>写出对象方法</li></ol><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 测试类&#x2F;*java.io.ObjectOutputStream extends OutputStream    ObjectOutputStream: 对象序列化流    作用：把对象以流的方式写入到文件中保存    构造方法：        ObjectOutputStream(OutputStream out): 创建写入指定OutputStream的ObjectOutputStream        参数：OutputStream out：字节输出流    特有成员方法：        void writeObject(Object obj):将指定对象写入ObjectOutputStream*&#x2F;public class Demo01ObjectOutputStream {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 1. 创建ObjectOutputStream，构造方法中传递字节输出流        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\person.txt&quot;));        &#x2F;&#x2F; 2. 使用ObjectOutputStream对象中的方法writeObject()，把对象写入到文件中        oos.writeObject(new Person(&quot;小张&quot;,11));        &#x2F;&#x2F; 3. 释放资源        oos.close();    }}&#x2F;&#x2F; Person类&#x2F;*    序列化和反序列化时，会抛出NotSerializableException(没有序列化异常)    类通过实现 Java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其进行任何状态序列化或反序列化。    Serializable接口也叫标记型接口        要进行序列化和反序列化的类必须实现Serializable接口，就会给类添加一个标记        当我们进行序列化和反序列化时，就会检测该类是否有这个标记            有：就可以进行序列化和反序列化操作            无：就会抛出NotSerializableException异常 *&#x2F;public class Person implements Serializable {    private String name;    private int age;    public Person() {    }    &#x2F;&#x2F; 省略get&#x2F;set等方法}</code></pre><h3 id="3-2-ObjectInputStream类"><a href="#3-2-ObjectInputStream类" class="headerlink" title="3.2 ObjectInputStream类"></a>3.2 ObjectInputStream类</h3><p><code>ObjectInputStream</code>反序列化流，将之前使用<code>ObjectOutputStream</code>序列化的原始数据恢复为对象。 </p><h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定<code>InputStream</code>的<code>ObjectInputStream</code>。</li></ul><h4 id="反序列化操作1-读对象操作"><a href="#反序列化操作1-读对象操作" class="headerlink" title="反序列化操作1(读对象操作)"></a>反序列化操作1(读对象操作)</h4><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象。</li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;*java.io.ObjectInputStream extends InputStream    ObjectInputStream:对象的反序列化流    作用：把文件中保存的对象，以流的方式读取出来使用    构造方法：        ObjectInputStream(InputStream in)：创建从指定InputStream中读取的ObjectInputStream        参数：InputStream in：字节输入流    特有成员方法：        Object readObject(): 从ObjectInputStream 读取对象*&#x2F;public class Demo01InputStream {    public static void main(String[] args) throws IOException, ClassNotFoundException {        &#x2F;&#x2F; 1. 创建ObjectInputStream对象，构造方法中传递字节输入流        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\person.txt&quot;));        &#x2F;&#x2F; 2. 使用ObjectInputStream对象的方法readObject() 读取保存对象的文件        Object obj = ois.readObject();       &#x2F;*       readObject()方法声明抛出了ClassNotFoundException(class文件找不到异常)            当不存在对象的class文件时抛出此异常            反序列化前提：                1. 类必须实现Serializable                2. 必须存在类对应的class文件       *&#x2F;        &#x2F;&#x2F; 3. 释放资源        ois.close();        &#x2F;&#x2F; 4. 使用读取出来的对象        System.out.println(obj); &#x2F;&#x2F; Person{name=&#39;小张&#39;, age=11}    }}</code></pre><blockquote><p>Tips:   <strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p></blockquote><h4 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a>反序列化操作2</h4><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法 </li></ul><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。</p><p><code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Person implements Serializable {    private static final long serialVersionUID = 1L; &#x2F;&#x2F; 加入固定序列版本号    private String name;    public int age;    &#x2F;&#x2F; 省略构造方法，get&#x2F;set等}</code></pre><h3 id="3-3-练习：序列化集合"><a href="#3-3-练习：序列化集合" class="headerlink" title="3.3 练习：序列化集合"></a>3.3 练习：序列化集合</h3><ol><li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li><li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li></ol><h4 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h4><ol><li>把若干学生对象 ，保存到集合中。</li><li>把集合序列化。</li><li>反序列化读取时，只需要读取一次，转换为集合类型。</li><li>遍历集合，可以打印所有的学生信息</li></ol><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 序列化操作public class StudentSerializableDemo {    public static void main(String[] args) throws IOException {    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\students.txt&quot;));    ArrayList&lt;Person&gt; arrayList = new ArrayList&lt;&gt;();    arrayList.add(new Person(&quot;xiaoming&quot;,12));    arrayList.add(new Person(&quot;xiaohua&quot;,17));    arrayList.add(new Person(&quot;xiaoli&quot;,15));    oos.writeObject(arrayList);    oos.close();}}&#x2F;&#x2F; 反序列化操作public class StudentDemo2 {    public static void main(String[] args) throws IOException, ClassNotFoundException {        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\students.txt&quot;));        &#x2F;&#x2F; 读取，强转为ArrayList类型        ArrayList&lt;Person&gt; stuobj = (ArrayList&lt;Person&gt;) ois.readObject();        &#x2F;&#x2F; 遍历打印        for (Person p:stuobj){            System.out.println(p);        }        ois.close();    }}</code></pre><h2 id="4-打印流"><a href="#4-打印流" class="headerlink" title="4. 打印流"></a>4. 打印流</h2><p>我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><h3 id="4-1-PringStream类"><a href="#4-1-PringStream类" class="headerlink" title="4.1 PringStream类"></a>4.1 PringStream类</h3><h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public PrintStream(String fileName)</code>： 使用指定的文件名创建一个新的打印流。</li></ul><h4 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h4><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以改变它的流向。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class PrintDemo {    public static void main(String[] args) throws FileNotFoundException {        System.out.println(97);        &#x2F;&#x2F; 创建打印流，指定文件名称        PrintStream ps = new PrintStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_10\\print.txt&quot;);        &#x2F;&#x2F; 设置系统的打印流向，输出到print.txt中        System.setOut(ps);        &#x2F;&#x2F; 调用系统打印里，就会在print.txt中输出97        System.out.println(97);    }}</code></pre><h3 id="今日目标"><a href="#今日目标" class="headerlink" title="今日目标"></a>今日目标</h3><ul><li style="list-style: none"><input type="checkbox" checked> 能够使用字节缓冲流读取数据到程序。FileInputStream</li><li style="list-style: none"><input type="checkbox" checked> 能够使用字节缓冲流写出数据到文件。FileOutPutStream</li><li style="list-style: none"><input type="checkbox" checked> 能够明确字符缓冲流的作用和基本用法。FileReader，FileWriter</li><li style="list-style: none"><input type="checkbox" checked> 能够使用缓冲流的特殊功能。数组优化</li><li style="list-style: none"><input type="checkbox" checked> 能够阐述编码表的意义</li><li style="list-style: none"><input type="checkbox" checked> 能够使用转换流读取指定编码的文本文件。 InputStreamReader</li><li style="list-style: none"><input type="checkbox" checked> 能够使用转换流写入指定编码的文本文件。 OutputStreamWriter</li><li style="list-style: none"><input type="checkbox" checked> 能够说出打印流的特点。 可以改变打印流向，输出到文件中</li><li style="list-style: none"><input type="checkbox" checked> 能够使用序列化流写出对象到文件。ObjectOutputStream</li><li style="list-style: none"><input type="checkbox" checked> 能够使用反序列化流读取文件到程序中。ObjectInputStream</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的字节流和字符流</title>
      <link href="/JavaBasics/io-stream.html"/>
      <url>/JavaBasics/io-stream.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-IO概述"><a href="#1-IO概述" class="headerlink" title="1. IO概述"></a>1. IO概述</h2><p>我们把数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p><p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出(写入)</strong>数据。</p><a id="more"></a><h3 id="1-1-IO的分类"><a href="#1-1-IO的分类" class="headerlink" title="1.1 IO的分类"></a>1.1 IO的分类</h3><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h3 id="1-2-顶级父类"><a href="#1-2-顶级父类" class="headerlink" title="1.2 顶级父类"></a>1.2 顶级父类</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/06/IO%E7%88%B6%E7%B1%BB-1557156293866.jpg" alt="title"></p><h2 id="2-字节流"><a href="#2-字节流" class="headerlink" title="2. 字节流"></a>2. 字节流</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p><h3 id="2-1-字节输出流-OutputStream"><a href="#2-1-字节输出流-OutputStream" class="headerlink" title="2.1 字节输出流[OutputStream]"></a>2.1 字节输出流[OutputStream]</h3><p><code>java.io.OutputStream</code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><blockquote><p>Tips: close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h3 id="2-2-FileOutputStream类"><a href="#2-2-FileOutputStream类" class="headerlink" title="2.2 FileOutputStream类"></a>2.2 FileOutputStream类</h3><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。<br><code>java.io.FileOutputStream</code>类是文件输出流，用于将数据写出到文件。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称路径写入文件。</li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p><ul><li>构造举例，代码如下：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FileOutPutDemo01 {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 使用File对象创建流对象        File file = new File(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\a.txt&quot;);        FileOutputStream fos = new FileOutputStream(file);        &#x2F;&#x2F; 使用文件名称路径创建流对象        FileOutputStream fos2 = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\b.txt&quot;);    }}</code></pre></li></ul><h4 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h4><ol><li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FOSWrite {    public static void main(String[] args) throws IOException {        FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo&quot; +                &quot;\\Demo5_6\\fos.txt&quot;);        &#x2F;&#x2F; 写入数据        fos.write(97);        fos.write(98);        fos.write(99);        &#x2F;&#x2F; 关闭        fos.close();    }}&#x2F;&#x2F; result:abc</code></pre></li></ol><blockquote><p>Tips: </p><pre><code>1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。</code></pre></blockquote><ol start="2"><li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FOSWriteDemo02 {    public static void main(String[] args) throws IOException {        FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo&quot; +                &quot;\\Demo5_6\\fos2.txt&quot;);        &#x2F;&#x2F; 将字符串转换为字节数组        byte[] bytes = &quot;测试写入&quot;.getBytes();        &#x2F;&#x2F; 写出字节数组数据        fos.write(bytes); &#x2F;&#x2F; 测试写入        fos.close();    }}</code></pre></li></ol><ol start="3"><li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FosWriteDemo03 {    public static void main(String[] args) throws IOException {        FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\fos3.txt&quot;);        byte[] bytes = &quot;abcdef&quot;.getBytes(); &#x2F;&#x2F; 字符串转换为字节数组        fos.write(bytes,2,2); &#x2F;&#x2F; result：cd        fos.close();    }}</code></pre></li></ol><h4 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h4><ul><li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><p>以上两个构造方法，参数中都需要传入一个boolean类型的值，true表示追加数据，false表示清空原有数据。代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FOSAppendWrite {    public static void main(String[] args) throws IOException {        FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo&quot; +                &quot;\\Demo5_6\\fos2.txt&quot;,true); &#x2F;&#x2F; 创建流对象，设置数据追加        fos.write(&quot;，测试追加。&quot;.getBytes()); &#x2F;&#x2F; result = 测试写入，测试追加。        fos.close();    }}</code></pre></p><h4 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h4><p>Windows中换行符号是<code>\r\n</code>。以下代码示例具体使用：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FOSWriteDemo04 {    public static void main(String[] args) throws IOException {        FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\c.txt&quot;);        byte[] words = {97,98,99,100,101}; &#x2F;&#x2F; abcde        for (byte i:words){            fos.write(i);            fos.write(&quot;\r\n&quot;.getBytes()); &#x2F;&#x2F; 写出一个换行，将换行符号转为数组写出        }        fos.close();    }}&#x2F;*result:abcde *&#x2F;</code></pre></p><blockquote><p>Tips：</p><ul><li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li></ul></li></ul></blockquote><h3 id="2-3-字节输入流-InputStream"><a href="#2-3-字节输入流-InputStream" class="headerlink" title="2.3 字节输入流[InputStream]"></a>2.3 字节输入流[InputStream]</h3><p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li></ul><h3 id="2-4-FileInputStream类"><a href="#2-4-FileInputStream类" class="headerlink" title="2.4 FileInputStream类"></a>2.4 FileInputStream类</h3><p><code>java.io.FileInputStream</code>类是文件输入流，从文件中读取字节。</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p><ul><li>代码示例如下：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FileInputStreamDemo01 {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 使用File对象创建流对象        FileInputStream fis = new FileInputStream(new File(&quot;Demo5_6\\fos2.txt&quot;));        &#x2F;&#x2F; 使用文件名创建流对象        FileInputStream fis2 = new FileInputStream(&quot;Demo5_6\\fos.txt&quot;);    }}</code></pre></li></ul><h4 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h4><ol><li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码演示如下：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FISRead {    public static void main(String[] args) throws IOException {        FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\read.txt&quot;);        byte[] bytes = {97,98,99,100,101};        for (byte b:bytes){            fos.write(b);            fos.write(&quot;\n&quot;.getBytes());        }        fos.close();        &#x2F;&#x2F; 创建字节输入流对象，指向文件        FileInputStream fis = new FileInputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\read.txt&quot;);int b;        while ((b = fis.read())!=-1){ &#x2F;&#x2F; 判断从数据中读取的值不等于-1            System.out.println((char)b); &#x2F;&#x2F; byte字节型转换为char字符型        }        fis.close();    }}</code></pre></li></ol><blockquote><p>Tips:虽然读取了一个字节，但是会自动提示为int类型。操作完毕后，一定要close()。</p></blockquote><ol start="2"><li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FISReadDemo02 {    public static void main(String[] args) throws IOException {        FileInputStream fis = new FileInputStream(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\read.txt&quot;);        int len; &#x2F;&#x2F; 定义变量，作为有效个数        byte[] bytes = new byte[2]; &#x2F;&#x2F; 定义字节数组，作为放字节数据的容器，存储2个字节        while ((len = fis.read(bytes))!=-1){ &#x2F;&#x2F; 这样每次可以读取2个字节            System.out.println(new String(bytes,0,len)); &#x2F;&#x2F; 每次读取后，将数组变成字符串打印        }        fis.close();    }}</code></pre></li></ol><h3 id="2-5-字节流练习：图片复制"><a href="#2-5-字节流练习：图片复制" class="headerlink" title="2.5 字节流练习：图片复制"></a>2.5 字节流练习：图片复制</h3><h4 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/05/07/2_copy-1557212320372.jpg" alt="title"></p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class CopyImg {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 创建流对象，指定数据源        FileInputStream fis = new FileInputStream(&quot;C:\\Users\\14908\\Desktop\\Java\\img\\2_copy.jpg&quot;);        &#x2F;&#x2F; 指定目的地        FileOutputStream fos = new FileOutputStream(&quot;D:\\IDEA_WorkSpace\\Demo&quot; +                &quot;\\Demo5_6\\copy.jpg&quot;);        &#x2F;&#x2F; 定义长度        int len;        &#x2F;&#x2F; 定义数组        byte[] b = new byte[1024];        &#x2F;&#x2F; 循环读取        while ((len = fis.read(b))!=-1){            fos.write(b,0,len);        }        fos.close();        fis.close();    }}</code></pre><blockquote><p>Tips：<br>    流的关闭原则：先开后关，后开先关。</p></blockquote><h2 id="3-字符流"><a href="#3-字符流" class="headerlink" title="3. 字符流"></a>3. 字符流</h2><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><h3 id="3-1-字符输入流-Reader"><a href="#3-1-字符输入流-Reader" class="headerlink" title="3.1 字符输入流[Reader]"></a>3.1 字符输入流[Reader]</h3><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li><li><code>public int read()</code>： 从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><h3 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h3><p><code>java.io.FileReader</code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><blockquote><p>Tips:</p><pre><code>1. 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表(IDEA中是UTF-8)2. 字节缓冲区：一个字节数组，用来临时存储字节数据</code></pre></blockquote><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。<br><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。</p><p>代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FileReaderDemo throws IOException{public static void main(String[] args){&#x2F;&#x2F; 使用File对象创建流对象FileReader fr = new FileReader(new File(&quot;Demo5_6\\a.txt&quot;))；&#x2F;&#x2F; 使用文件名称创建流对象FileReader fr2 = new FileReader(&quot;Demo5_6\\a.txt&quot;)；}}</code></pre></p><h4 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h4><ol><li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码演示如下：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FRReadDemo01 {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\d.txt&quot;);        int w;        while ((w = fr.read())!=-1){            System.out.print((char)w);        }        fr.close();    }}</code></pre></li></ol><blockquote><p>Tips：虽然读取了一个字符，但是会自动提升为int类型。</p></blockquote><ol start="2"><li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码演示如下：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FRReadDemo02 {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\d.txt&quot;);        int len;        char[] cbuf = new char[2]; &#x2F;&#x2F; 定义字符数组，作为放字符数据的容器        while ((len = fr.read(cbuf))!=-1){            System.out.print(new String(cbuf,0,len)); &#x2F;&#x2F; 转换为字符串输出        }        fr.close();    }}</code></pre></li></ol><h3 id="3-3-字符输出流-Writer"><a href="#3-3-字符输出流-Writer" class="headerlink" title="3.3 字符输出流[Writer]"></a>3.3 字符输出流[Writer]</h3><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf)</code>写入字符数组。 </li><li><code>abstract  void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li><li><code>void write(String str)</code>写入字符串。 </li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush()</code>刷新该流的缓冲。  </li><li><code>void close()</code> 关闭此流，但要先刷新它。 </li></ul><h3 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h3><p><code>java.io.FileWriter</code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。 </li></ul><h4 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h4><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FWWrite {    public static void main(String[] args) throws IOException {        FileWriter fw = new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\fw.txt&quot;);        &#x2F;&#x2F; 写出数据        fw.write(97);        fw.write(&#39;b&#39;);        fw.write(&#39;c&#39;);        fw.write(30000);        fw.close();        &#x2F;&#x2F; result: abc田    }}</code></pre></p><blockquote><p>Tips:</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li><li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li></ol></blockquote><h4 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h4><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close</code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><p>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FWWriteDemo02 {    public static void main(String[] args) throws IOException {        FileWriter fw = new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\fw02.txt&quot;);        &#x2F;&#x2F; 写出数据,通过flush        fw.write(&#39;刷&#39;);        fw.flush();        fw.write(&#39;新&#39;);        fw.flush();        &#x2F;&#x2F; 写出数据，通过close        fw.write(&#39;关&#39;);        fw.close();        fw.write(&#39;闭&#39;); &#x2F;&#x2F; [报错] java.io.IOException: Stream closed        fw.close();    }}</code></pre></p><blockquote><p>Tips：即使使用了flush方法写出了数据，操作到最后还是要调用close方法，释放系统资源。</p></blockquote><h4 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h4><ol><li><p><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，实例如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FWCharWrite {    public static void main(String[] args) throws IOException {        FileWriter fw = new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\fw03.txt&quot;);        char[] chars = &quot;测试写出字符数组&quot;.toCharArray(); &#x2F;&#x2F; 将字符串转换为字符数组        fw.write(chars); &#x2F;&#x2F; 测试写出字符数组        fw.write(chars,4,2); &#x2F;&#x2F; 写出从索引2开始的2个字节，即&quot;字符&quot;2字        fw.close();    }}                                                              </code></pre></li><li><p><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，示例如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FWWriteString {    public static void main(String[] args) throws IOException {        FileWriter fw = new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\fw04.txt&quot;);        fw.write(&quot;测试字符串写出&quot;); &#x2F;&#x2F; 测试字符串写出        fw.write(&quot;测试写出指定字符&quot;,2,2); &#x2F;&#x2F; 写出        fw.close();    }}</code></pre></li></ol><ol start="3"><li><strong>续写和换行</strong>：操作类似于FileOutputStream。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FWWriteString {    public static void main(String[] args) throws IOException {        FileWriter fw = new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\fw04.txt&quot;);        fw.write(&quot;测试字符串写出&quot;); &#x2F;&#x2F; 测试字符串写出        fw.write(&quot;\r\n&quot;); &#x2F;&#x2F; 写出换行符        fw.write(&quot;测试写出指定字符&quot;,2,2); &#x2F;&#x2F; 写出        fw.close();    }}</code></pre></li></ol><h2 id="4-IO异常的处理"><a href="#4-IO异常的处理" class="headerlink" title="4. IO异常的处理"></a>4. IO异常的处理</h2><h3 id="JDK7前的处理"><a href="#JDK7前的处理" class="headerlink" title="JDK7前的处理"></a>JDK7前的处理</h3><p>之前的练习中，一直把异常直接抛出，实际开发中建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class HandleException01 {    public static void main(String[] args) {        &#x2F;&#x2F; 声明一个Fw对象，指向空        FileWriter fw = null;        try {            &#x2F;&#x2F; 创建一个流对象，将fw指向该对象            fw = new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\fw05.txt&quot;);            &#x2F;&#x2F; 写出数据            fw.write(&quot;异常的处理测试&quot;);        } catch (IOException e) {            e.printStackTrace();        }finally{            try{                if (fw != null){                    fw.close();                }            }catch (IOException e){                e.printStackTrace();            }        }    }}</code></pre></p><h3 id="JDK7的处理"><a href="#JDK7的处理" class="headerlink" title="JDK7的处理"></a>JDK7的处理</h3><p>可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。<br>格式：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">try(创建流对象语句，如多个，使用&#39;;&#39;隔开){&#x2F;&#x2F; 读写语句}catch(IOException e){e.printStackTrace();}</code></pre></p><p>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FWJDK7Dispose {    public static void main(String[] args) {        try(FileWriter fw = new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\fw06.txt&quot;);){            fw.write(&quot;测试JDK7后优化的try...catch&quot;);        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre></p><h3 id="JDK9的改进"><a href="#JDK9的改进" class="headerlink" title="JDK9的改进"></a>JDK9的改进</h3><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，格式如下。<br>改进前格式：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 被final修饰的对象final Resource resource1 = new Resource(&quot;resource1&quot;);&#x2F;&#x2F; 普通对象Resource resource2 = new Resource(&quot;resource2&quot;);&#x2F;&#x2F; 引入方式：创建新的变量保存try (Resource r1 = resource1;     Resource r2 = resource2) {     &#x2F;&#x2F; 使用对象}</code></pre></p><p>改进后的格式：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 被final修饰的对象final Resource resource1 = new Resource(&quot;resource1&quot;);&#x2F;&#x2F; 普通对象Resource resource2 = new Resource(&quot;resource2&quot;);&#x2F;&#x2F; 引入方式：直接引入try (resource1; resource2) {     &#x2F;&#x2F; 使用对象}</code></pre></p><p>改进后的代码实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class TryDemo {    public static void main(String[] args) throws IOException{        final FileReader fr = new FileReader(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\read.txt&quot;);        FileWriter fw = new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\out.txt&quot;);        try(fr;fw){            int b;            while ((b = fr.read())!=-1){                fw.write(b);            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre></p><h2 id="5-属性集"><a href="#5-属性集" class="headerlink" title="5. 属性集"></a>5. 属性集</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p><code>java.util.Properties</code> 继承于<code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p><h3 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h3><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>public Properties()</code> :创建一个空的属性列表。</p><h4 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h4><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li><li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值，返回搜索到的值</li><li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：返回所有键名称的集合。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ProDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 创建属性集对象        Properties pt = new Properties();        &#x2F;&#x2F; 添加键值对元素        pt.setProperty(&quot;小梦&quot;,&quot;168&quot;);        pt.setProperty(&quot;小明&quot;,&quot;175&quot;);        pt.setProperty(&quot;小张&quot;,&quot;178&quot;);        &#x2F;&#x2F; 打印属性集对象        System.out.println(pt);        &#x2F;&#x2F; 通过键获取值        Set&lt;String&gt; set = pt.stringPropertyNames(); &#x2F;&#x2F; 获取所以键，放入集合中        for (String key:set){            System.out.println(key+&quot;--&gt;&quot;+pt.getProperty(key));        }    }}&#x2F;&#x2F; result{小明=175, 小张=178, 小梦=168}小明--&gt;175小张--&gt;178小梦--&gt;168</code></pre></li></ul><h4 id="store方法"><a href="#store方法" class="headerlink" title="store方法"></a>store方法</h4><p><code>Properties</code>集合中的方法<code>store</code>；用于把集合中的临时数据，持久化写入到硬盘中存储。</p><ul><li><strong>构造方法</strong><ul><li>void store(OutPutStream out,String comments); 字节输出流，不能写入中文</li><li>void store(Write write,String comments); 字符输出流，可以写中文</li><li>String comments: 注释，用来解释说明保存的文件是做什么的，不能中文注释</li></ul></li></ul><p>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ProDemo02 {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 1. 创建Properties集合对象，添加数据        Properties pro = new Properties();        pro.setProperty(&quot;小明&quot;,&quot;177&quot;);        pro.setProperty(&quot;小立&quot;,&quot;181&quot;);        pro.setProperty(&quot;小化&quot;,&quot;173&quot;);        &#x2F;&#x2F; 2. 创建字节输出流&#x2F;字符输出流对象，绑定输出目的地。        FileWriter fw = new FileWriter(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\prop.txt&quot;);        &#x2F;&#x2F; 3. 使用Properties集合中的方法store，把集合中的临时数据，写入到硬盘中        pro.store(fw,&quot;save data&quot;);        &#x2F;&#x2F; 4. 释放资源        fw.close();        &#x2F;*        prop.txt            #save data            #Tue May 07 20:47:14 CST 2019            小明=177            小立=181            小化=173         *&#x2F;    }}</code></pre></p><h4 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h4><p>可以使用<code>Properties</code>集合中的方法<code>load</code>，把硬盘中保存的文件(键值对形式的)，读取到集合中使用。</p><ul><li><p><strong>构造方法</strong>：</p><ul><li>void load(InputStream inStream); 字节输入流，不能读取含有中文的键值对</li><li>void load(Reader reader); 字符输入流，可以读取中文</li></ul></li><li><p><strong>注意</strong>：</p><ol><li>存储键值对的文件中，键与值的默认连接符号可以使用=，空格(其他符号)，一般使用=</li><li>存储键值对的文件中，可以使用# 做注释，注释的内容不会被读取</li><li>存储键值对的文件中，键值默认都是字符串，不需要再加引号</li></ol></li></ul><p>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ProLoadMethod {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 1. 创建Properties集合对象        Properties pro = new Properties();        &#x2F;&#x2F; 2. 使用Properties集合对象中的load方法来读取保存键值对的文件        pro.load(new FileReader(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_6\\prop.txt&quot;));        &#x2F;&#x2F; 3.遍历Properties集合        Set&lt;String&gt; set = pro.stringPropertyNames();        for (String key:set){            System.out.println(key + &quot;--&gt;&quot; + pro.getProperty(key));        }    }}</code></pre></p><h2 id="今日总结："><a href="#今日总结：" class="headerlink" title="今日总结："></a>今日总结：</h2><ol><li>IO的概述</li><li>IO的分类：根据数据流向：输入流和输出流，根据数据类型：字节流和字符流。</li><li>字节输出流<code>OutPutStream</code>类的子类<code>FileFileOutputStream</code>类构造方法创建流对象的方式</li><li><code>FileFileOutputStream</code>类的基本方法<code>write</code>的三种使用方式</li><li>数据的追加续写：<code>FileFileOutputStream</code>类的第二个参数布尔值，true追加，false清空。</li><li>关于换行符的写入</li><li>字节输入流<code>InputStream</code>类的子类<code>FileInputStream</code>类</li><li><code>FileInputStream</code>类构造方法创建流对象的方式</li><li><code>FileInputStream</code>类的基本方法<code>read</code>的2种使用方式，读取字节和读取字节数组。</li><li>字符输入流<code>Reader</code>类的子类<code>FileReader</code>类</li><li><code>FileReader</code>类构造方法创建流对象的方式</li><li>读取字符数据的两种方式，读取字符和读取字符数据</li><li>字符输出流<code>Write</code>类的子类<code>FileWrite</code>类构造方法创建流对象的方式</li><li>使用<code>write</code>写出数据的方法：写出字符、写出字符数组写出字符串</li><li>关闭<code>close()</code>和刷新<code>flush</code>方法</li><li>IO异常处理的优化方案</li><li>属性集的概述和使用</li><li><code>Properties</code>类的构造方法创建流对象</li><li>基本存储方法:<code>setProperty()</code>,<code>getProperty()</code>,<code>stringPropertyNames()</code></li><li>读取<code>load()</code>和写入<code>store()</code>方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中File类和递归</title>
      <link href="/JavaBasics/file-recursion.html"/>
      <url>/JavaBasics/file-recursion.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><a id="more"></a><h3 id="1-1-构造方法"><a href="#1-1-构造方法" class="headerlink" title="1.1 构造方法"></a>1.1 构造方法</h3><ul><li><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li><li><code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。</li></ul><p>代码举例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoFileClass {    public static void main(String[] args) {        &#x2F;&#x2F; 通过文件绝对路径        String pathname = &quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5\\testfile.txt&quot;;        File file1 = new File(pathname);&#x2F;&#x2F;        System.out.println(file1);        &#x2F;&#x2F; 通过父路径和子路径字符串        String parent = &quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5&quot;;        String child = &quot;testfile.txt&quot;;        File file2 = new File(parent,child);&#x2F;&#x2F;        System.out.println(file2);        &#x2F;&#x2F; 通过父级File对象和子路径字符串        File parentDir = new File(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5&quot;);        File file3 = new File(parentDir,child);        System.out.println(file3);    }}</code></pre></p><blockquote><p>一个File对象代表硬盘中实际存在的一个文件或者目录；无论该路径下是否存在文件或者目录，都不影响File对象的创建。</p></blockquote><h3 id="1-2-常用方法"><a href="#1-2-常用方法" class="headerlink" title="1.2 常用方法"></a>1.2 常用方法</h3><h4 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h4><ul><li><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。</li><li><code>public String getPath()</code> ：将此File转换为路径名字符串。 </li><li><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </li><li><code>public long length()</code>  ：返回由此File表示的文件的长度。 </li></ul><p>实例代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class GetFileDemo {    public static void main(String[] args) {        File file = new File(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5\\testfile.txt&quot;);        System.out.println(&quot;文件绝对路径:&quot; + file.getAbsolutePath());        System.out.println(&quot;文件构造路径:&quot; + file.getPath());        System.out.println(&quot;文件名称:&quot; + file.getName());        System.out.println(&quot;文件长度:&quot; + file.length()+&quot;字节&quot;);        File fileDir = new File(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5&quot;);        System.out.println(&quot;目录绝对路径：&quot; + fileDir.getAbsolutePath());        System.out.println(&quot;目录构造路径：&quot; + fileDir.getPath());        System.out.println(&quot;目录名称：&quot; + fileDir.getName());        System.out.println(&quot;目录长度：&quot; + fileDir.length());    }}&#x2F;&#x2F; 上述输出结果：文件绝对路径:D:\IDEA_WorkSpace\Demo\Demo5_5\testfile.txt文件构造路径:D:\IDEA_WorkSpace\Demo\Demo5_5\testfile.txt文件名称:testfile.txt文件长度:32字节目录绝对路径：D:\IDEA_WorkSpace\Demo\Demo5_5目录构造路径：D:\IDEA_WorkSpace\Demo\Demo5_5目录名称：Demo5_5目录长度：4096</code></pre></p><blockquote><p>API中说明：length(), 表示文件的长度。但是File对象表示目录，则返回值未指定。</p></blockquote><h4 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h4><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FilePath {    public static void main(String[] args) {        System.out.println(new File(&quot;D:\\IDEA_WorkSpace\\Demo\\&quot; +                &quot;Demo5_5\\testfile.txt&quot;).getAbsolutePath());        System.out.println(new File(&quot;testfile.txt&quot;).getAbsolutePath());    }}&#x2F;&#x2F; output resultD:\IDEA_WorkSpace\Demo\Demo5_5\testfile.txtD:\IDEA_WorkSpace\testfile.txt</code></pre></li></ul><h4 id="判定功能的方法"><a href="#判定功能的方法" class="headerlink" title="判定功能的方法"></a>判定功能的方法</h4><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li></ul><p>示例代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FileIs {    public static void main(String[] args) {        File file = new File(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5\\testfile.txt&quot;);        File dir = new File(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5&quot;);        &#x2F;&#x2F; 判断是否存在文件或者目录,返回布尔值        System.out.println(file.exists()); &#x2F;&#x2F; true        System.out.println(dir.exists()); &#x2F;&#x2F; trueSystem.out.println(new File(&quot;A:\\testDir&quot;).exists()); &#x2F;&#x2F; false        &#x2F;&#x2F; 判断是文件还是目录&#x2F;&#x2F;        System.out.println(&quot;is file?: &quot; + file.isFile()); &#x2F;&#x2F; true&#x2F;&#x2F;        System.out.println(&quot;is file?: &quot; + dir.isFile()); &#x2F;&#x2F; false&#x2F;&#x2F;        System.out.println(&quot;is directory?: &quot; + file.isDirectory()); &#x2F;&#x2F; false&#x2F;&#x2F;        System.out.println(&quot;is directory?: &quot; + dir.isDirectory()); &#x2F;&#x2F; true        Judge(file);         Judge(dir);    }    public static void Judge(File file){        if (file.isFile())            System.out.println(file + &quot;  是文件&quot;);        if (file.isDirectory())            System.out.println(file + &quot;  是目录&quot;);    }}</code></pre></p><h4 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h4><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FileCreDel{    final static String rootpath = &quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5\\&quot;;    public static void main (String[] args) throws IOException {        System.out.println(&quot;创建文件:1\n创建文件夹：2\n删除文件或文件夹：3\n退出：4&quot;);        Scanner sc = new Scanner(System.in);        while (true) {            int pattern = sc.nextInt();            switch (pattern) {                case 1:                    System.out.println(&quot;输入需要创建的文件名:&quot;);                    CreFile(sc.next());                    break;                case 2:                    System.out.println(&quot;输入需要创建的文件夹名:&quot;);                    MkDir(sc.next());                    break;                case 3:                    System.out.println(&quot;输入需要删除的文件或文件夹名称:&quot;);                    Del(sc.next());                    break;                case 4:                    System.exit(0);            }        }    }    public static void CreFile(String name) throws IOException {        File file = new File(rootpath + name);        if (file.exists() == false) {            file.createNewFile();            System.out.println(name + &quot;文件创建成功&quot;);        } else{            System.out.println(name + &quot;文件已经存在，创建失败！&quot;);        }    }    public static void MkDir(String name) throws IOException{        File dir = new File(rootpath + name);        if (dir.exists() == false){            dir.mkdirs();            System.out.println(name + &quot;文件夹创建成功&quot;);        }else{            System.out.println(name + &quot;文件夹已存在，创建失败！&quot;);        }    }    public static void Del(String name){        if (new File(rootpath + name).delete() == true){            System.out.println(&quot;删除成功！&quot;);        }else {            System.out.println(&quot;删除失败，文件或文件夹不存在！&quot;);        }    }}</code></pre></p><blockquote><p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p></blockquote><h3 id="1-3-目录的遍历"><a href="#1-3-目录的遍历" class="headerlink" title="1.3 目录的遍历"></a>1.3 目录的遍历</h3><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FileFor {    public static void main(String[] args) {        File dir = new File(&quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5\\&quot;);        &#x2F;&#x2F; 获取当前目录下的文件以及文件夹的名称。        String[] names = dir.list();        for(String name:names){            System.out.println(name);        }        &#x2F;&#x2F; 获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息。        File[] files = dir.listFiles();        for (File file:files){            System.out.println(file);        }    }}</code></pre></li></ul><blockquote><p>Tips:调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p></blockquote><h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ul><li><strong>递归</strong>：指在当前方法内调用自己的这种现象。</li><li><strong>递归的分类:</strong><ul><li>递归分为两种，直接递归和间接递归。</li><li>直接递归称为方法自身调用自己。</li><li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li></ul></li><li><strong>注意事项</strong>：<ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li><li>构造方法,禁止递归。</li></ul></li></ul><h3 id="2-2-递归累加求和"><a href="#2-2-递归累加求和" class="headerlink" title="2.2 递归累加求和"></a>2.2 递归累加求和</h3><h4 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1~n的和"></a>计算1~n的和</h4><p><strong>分析</strong>：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p><p>实例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoRecursion02 {    public static void main(String[] args) {        int num = 5;        System.out.println(getSum(num));    }    public static int getSum(int num){        if (num == 1)            return 1;        return num+getSum(--num); &#x2F;&#x2F; 为什么num--会报错？ num--：num先参与运算，在减一，这样传递过去的一直是5，故--num才行，先自减1在参与运算。    }}</code></pre></p><h3 id="2-3-递归求阶乘"><a href="#2-3-递归求阶乘" class="headerlink" title="2.3 递归求阶乘"></a>2.3 递归求阶乘</h3><ul><li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1 </code></pre></li></ul><p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">推理得出：n! = n * (n-1)!</code></pre></p><p>代码实现如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoRecursion03 {    public static void main(String[] args) {        int n = 5;        System.out.println(n + &quot;的阶乘为：&quot; + getValue(n));    }    public static int getValue(int n){        if (n == 1)            return 1;        return n * getValue(--n);    }}</code></pre></p><h3 id="2-4-递归打印多级目录"><a href="#2-4-递归打印多级目录" class="headerlink" title="2.4 递归打印多级目录"></a>2.4 递归打印多级目录</h3><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p><p>示例代码：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class RecursionPrintDir {    public static void main(String[] args) {        File dir = new File(&quot;D:\\IDEA_WorkSpace\\Demo\\&quot;);        printDir(dir);    }    public static void printDir(File dir){        File[] files = dir.listFiles(); &#x2F;&#x2F; 获取文件或目录file对象        for (File file:files){            if (file.isFile()){                System.out.println(&quot;文件名：&quot; + file.getAbsolutePath()); &#x2F;&#x2F;如果是文件则打印绝对路径            }else{                System.out.println(&quot;目录：&quot; + file.getAbsolutePath());                printDir(file); &#x2F;&#x2F; 继续遍历，调用printdir，形成递归            }        }    }}</code></pre></p><h2 id="3-综合案例"><a href="#3-综合案例" class="headerlink" title="3. 综合案例"></a>3. 综合案例</h2><h3 id="3-1-文件搜索"><a href="#3-1-文件搜索" class="headerlink" title="3.1 文件搜索"></a>3.1 文件搜索</h3><p>输入文件名称，输出文件路径<br><strong>分析</strong>：</p><ol><li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li><li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li></ol><p>代码实现：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class SearchFile {    static String rootpath = &quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5\\&quot;;&#x2F;&#x2F;    final static String filename = &quot;FileFor.java&quot;;    public static void main(String[] args) {        System.out.println(&quot;输入你要搜索的文件名：&quot;);        searchfile(new File(rootpath),new Scanner(System.in).next());    }    public static void searchfile(File dir,String filename){        File[] files = dir.listFiles();        for (File file:files){            if(file.isFile()){                if (file.getName().equals(filename) == true){                    System.out.println(file.getAbsolutePath());                }            }else{                searchfile(file,filename);            }        }    }}</code></pre></p><blockquote><p>注意：==和equals的区别！！！</p></blockquote><h3 id="3-2-文件过滤器的优化"><a href="#3-2-文件过滤器的优化" class="headerlink" title="3.2 文件过滤器的优化"></a>3.2 文件过滤器的优化</h3><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p><p><code>boolean accept(File pathname)</code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p><p><strong>分析</strong>：</p><ol><li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li><li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol><li>要么是.java文件。</li><li>要么是目录，用于继续遍历。</li></ol></li><li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li></ol><p>代码实现：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoFileFilter {    static String rootpath = &quot;D:\\IDEA_WorkSpace\\Demo\\Demo5_5\\&quot;;    public static void main(String[] args) {        printDir(new File(rootpath));    }    public static void printDir(File dir){        &#x2F;&#x2F; 匿名内部类方式,创建过滤器子类对象        File[] files = dir.listFiles(new FileFilter() {            @Override            public boolean accept(File pathname) {                return pathname.getName().endsWith(&quot;.java&quot;)||pathname.isDirectory();&#x2F;&#x2F; 过滤掉除了.java文件和目录以外的所有东西            }        });        &#x2F;&#x2F; 循环打印过滤后的数据        for (File file:files){            if (file.isFile()){                System.out.println(&quot;文件名：&quot;+file.getAbsolutePath());            }else{                printDir(file);            }        }    }}</code></pre></p><h3 id="3-3-Lambda优化"><a href="#3-3-Lambda优化" class="headerlink" title="3.3 Lambda优化"></a>3.3 Lambda优化</h3><p>代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static void printDir2(File dir){        File[] files = dir.listFiles(f-&gt;{return f.getName().endsWith(&quot;.java&quot;) || f.isDirectory();});        for (File file:files){            if (file.isFile()){                System.out.println(&quot;文件名：&quot;+file.getAbsolutePath());            }else{                printDir2(file);            }        }    }</code></pre></p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><ol><li>Java中的File类</li><li>文件和目录的创建和删除操作</li><li>File类的一些方法</li><li>递归的概念以及使用<br><strong>遇到的问题</strong>：</li><li>==与equals的区别，使用过程中的注意事项</li><li>Lambda表达式还不熟练</li><li>时间管理</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的线程池与Lambda表达式</title>
      <link href="/JavaBasics/threadPool-Lambda.html"/>
      <url>/JavaBasics/threadPool-Lambda.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-等待唤醒机制"><a href="#1-等待唤醒机制" class="headerlink" title="1. 等待唤醒机制"></a>1. 等待唤醒机制</h2><p><strong>概念</strong>：多个线程在处理同一个资源，但处理的动作(线程的任务)却不相同。</p><p>比如：线程A用来生产包子，线程B用来吃包子，包子可以理解为同一资源。线程A与线程B的处理动作，一个是生产，一个是消费。那么线程A与线程B之间就存在线程通信问题。</p><a id="more"></a><p><strong>为什么要处理线程间通信：</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><h3 id="1-1-等待唤醒机制"><a href="#1-1-等待唤醒机制" class="headerlink" title="1.1 等待唤醒机制"></a>1.1 等待唤醒机制</h3><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>就是在一个线程进行了规定操作后，就进入等待状态<strong>wait()</strong>， 等待其他线程执行完他们的指定代码过后 再将其唤醒<strong>notify()</strong> ;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait/notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题，使用的3个方法含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不在持有锁，所以它需要再次尝试获取锁(可能会面临其他线程的竞争),成功后才能在当初调用wait方法之后的地方恢复执行。</p></blockquote><blockquote><p>总结：如果能获取锁，线程就从waiting状态变成Runnable状态；否则，从wait set出来，又会进入entry set，线程就从waiting状态变成了Blocked状态。</p></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol><h3 id="1-2-生成者与消费者问题"><a href="#1-2-生成者与消费者问题" class="headerlink" title="1.2 生成者与消费者问题"></a>1.2 生成者与消费者问题</h3><p>等待唤醒机制其实就是经典的”生产者与消费者”的问题。</p><p>拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p><p>包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。</p><p>代码实例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 资源类public class Baozi {    &#x2F;&#x2F; 设置包子的属性    String pier; &#x2F;&#x2F; 皮    String xianer; &#x2F;&#x2F; 陷    boolean flag = false; &#x2F;&#x2F; 包子的状态：有就true，没有就false}&#x2F;&#x2F; 生产者类public class BaoZiPu extends Thread{ &#x2F;&#x2F; 生成者(包子铺)类：是一个线程类，可以继承Thread    &#x2F;&#x2F; 1.需要在成员位置创建一个包子变量    private Baozi bz;    &#x2F;&#x2F; 2.使用带参构造方法，为包子变量赋值    public BaoZiPu(String name, Baozi bz){        super(name);        this.bz = bz;    }    &#x2F;&#x2F; 设置线程任务(run)：生成包子    &#x2F;*    包子铺线程和包子线程关系---&gt;通信(互斥)        必须使用同步技术保证两个线程只能有一个在执行        锁对象必须保持唯一，可以使用包子对象作为锁对象        包子铺类和吃货的类就需要把包子对象作为参数传递进来            1.需要在成员位置创建一个包子变量            2.使用带参构造方法，为包子变量赋值     *&#x2F;    @Override    public void run(){        int count = 0;        &#x2F;&#x2F; 造包子        while (true){             &#x2F;&#x2F; 必须使用同步技术保证两个线程只能有一个在执行            synchronized (bz) {                if (bz.flag == true) { &#x2F;&#x2F; 对包子状态进行判断                    try {                        bz.wait(); &#x2F;&#x2F; true：有包子,包子铺调用wait方法进入等待状态                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                &#x2F;&#x2F; 没有包子，包子铺生产包子                System.out.println(&quot;包子铺开始做包子&quot;);                if (count % 2 == 0) {                    bz.pier = &quot;面皮&quot;;                    bz.xianer = &quot;五花肉&quot;;                } else {                    bz.pier = &quot;薄皮&quot;;                    bz.xianer = &quot;韭菜鸡蛋&quot;;                }                count++;                try {                    Thread.sleep(5000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                &#x2F;&#x2F; 包子铺生成好了包子                bz.flag = true; &#x2F;&#x2F; 修改包子的状态为true                System.out.println(&quot;包子造好了：&quot; + bz.pier + bz.xianer+&quot;,吃货来吃吧!&quot;);                bz.notify(); &#x2F;&#x2F; 唤醒吃货线程，起来吃包子了            }        }    }}&#x2F;&#x2F; 消费者类public class BaoZiPu extends Thread{ &#x2F;&#x2F; 生成者(包子铺)类：是一个线程类，可以继承Thread    &#x2F;&#x2F; 1.需要在成员位置创建一个包子变量    private Baozi bz;    &#x2F;&#x2F; 2.使用带参构造方法，为包子变量赋值    public BaoZiPu(String name, Baozi bz){        super(name);        this.bz = bz;    }    &#x2F;&#x2F; 设置线程任务(run)：生成包子    &#x2F;*    包子铺线程和包子线程关系---&gt;通信(互斥)        必须使用同步技术保证两个线程只能有一个在执行        锁对象必须保持唯一，可以使用包子对象作为锁对象        包子铺类和吃货的类就需要把包子对象作为参数传递进来            1.需要在成员位置创建一个包子变量            2.使用带参构造方法，为包子变量赋值     *&#x2F;    @Override    public void run(){        int count = 0;        &#x2F;&#x2F; 造包子        while (true){             &#x2F;&#x2F; 必须使用同步技术保证两个线程只能有一个在执行            synchronized (bz) {                if (bz.flag == true) { &#x2F;&#x2F; 对包子状态进行判断                    try {                        bz.wait(); &#x2F;&#x2F; true：有包子,包子铺调用wait方法进入等待状态                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                &#x2F;&#x2F; 没有包子，包子铺生产包子                System.out.println(&quot;包子铺开始做包子&quot;);                if (count % 2 == 0) {                    bz.pier = &quot;面皮&quot;;                    bz.xianer = &quot;五花肉&quot;;                } else {                    bz.pier = &quot;薄皮&quot;;                    bz.xianer = &quot;韭菜鸡蛋&quot;;                }                count++;                try {                    Thread.sleep(5000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                &#x2F;&#x2F; 包子铺生成好了包子                bz.flag = true; &#x2F;&#x2F; 修改包子的状态为true                System.out.println(&quot;包子造好了：&quot; + bz.pier + bz.xianer+&quot;,吃货来吃吧!&quot;);                bz.notify(); &#x2F;&#x2F; 唤醒吃货线程，起来吃包子了            }        }    }}&#x2F;&#x2F; 测试类public class TestDemo {    public static void main(String[] args) {        Baozi bz = new Baozi(); &#x2F;&#x2F; 创建包子对象        new BaoZiPu(&quot;包子铺&quot;,bz).start(); &#x2F;&#x2F; 创建包子铺线程，开启，生产包子        new Chihuo(&quot;吃货&quot;,bz).start(); &#x2F;&#x2F; 创建吃货线程，开启，吃包子    }}</code></pre></p><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h2><h3 id="2-1-线程池思想概述"><a href="#2-1-线程池思想概述" class="headerlink" title="2.1 线程池思想概述"></a>2.1 线程池思想概述</h3><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p><p>在Java中可以通过线程池来达到这样的效果。下面就详细讲解一下Java的线程池。</p><h3 id="2-2-线程池概念"><a href="#2-2-线程池概念" class="headerlink" title="2.2 线程池概念"></a>2.2 线程池概念</h3><ul><li><strong>线程池</strong>：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。<br>下图描述线程池的工作原理：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86-1556526310665.bmp" alt="title"></li></ul><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li></ol><h3 id="2-3-线程池的使用"><a href="#2-3-线程池的使用" class="headerlink" title="2.3 线程池的使用"></a>2.3 线程池的使用</h3><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的,因此<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int n Threads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>使用线程池对象的方法如下：</p><ul><li><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</li></ul><blockquote><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></blockquote><p>使用线程池中线程对象的步骤：</p><ol><li>创建线程池对象。</li><li>创建Runnable接口子类对象。(task)</li><li>提交Runnable接口子类对象。(take task)</li><li>关闭线程池(一般不做)。</li></ol><p>Runnable实现类实例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 实现类public class MyRunnable implements Runnable{    @Override    public void run() {        System.out.println(&quot;我要一个教练&quot;);        try{            Thread.sleep(2000);        }catch(InterruptedException e){            e.printStackTrace();        }        System.out.println(&quot;教练来了：&quot;+Thread.currentThread().getName());        System.out.println(&quot;教我游泳,教完后，教练回到了游泳池&quot;);    }}&#x2F;&#x2F; 线程池测试类public class ThreadPoolDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 创建线程池对象        ExecutorService service = Executors.newFixedThreadPool(2); &#x2F;&#x2F; 创建了包含2个线程对象的线程池        &#x2F;&#x2F; 创建Runnable实例对象        MyRunnable r = new MyRunnable();&#x2F;&#x2F;        new Thread(r).start(); &#x2F;&#x2F; 使用传统方式，自己创建线程对象        service.submit(r); &#x2F;&#x2F; 从线程池中获取线程对象，然后会自动调用MyRunnable中的run()        service.submit(r); &#x2F;&#x2F; 再次获取一个线程对象        service.submit(r); &#x2F;&#x2F; again        &#x2F;*            注意：submit方法调用结束后，程序并没终止，是因为线程池控制了线程的关闭            将使用完的线程又归还到了线程池中         *&#x2F;        service.shutdown();    }}</code></pre></p><h2 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3. Lambda表达式"></a>3. Lambda表达式</h2><h3 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h3><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong></p><p>面向对象的思想:做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情。</p><p>函数式编程思想:只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p><h3 id="3-2-冗余的Runnable代码"><a href="#3-2-冗余的Runnable代码" class="headerlink" title="3.2 冗余的Runnable代码"></a>3.2 冗余的Runnable代码</h3><h4 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h4><p>当需要启动一个线程去完成任务是，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使<code>java.lang.Thread</code>类来启动该线程。如下所示：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo01Runnable {public static void main(String[] args) {    &#x2F;&#x2F; 匿名内部类Runnable task = new Runnable() {@Overridepublic void run() { &#x2F;&#x2F; 覆盖重写抽象方法System.out.println(&quot;多线程任务具体执行内容！&quot;);}};new Thread(task).start(); &#x2F;&#x2F; 启动线程}}</code></pre></p><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li><li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li><li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h3 id="3-3-编程思想转换"><a href="#3-3-编程思想转换" class="headerlink" title="3.3 编程思想转换"></a>3.3 编程思想转换</h3><h4 id="专注于具体做什么，而不是这么做"><a href="#专注于具体做什么，而不是这么做" class="headerlink" title="专注于具体做什么，而不是这么做"></a>专注于具体做什么，而不是这么做</h4><p>很多时候我们为了做具体的事情而不得不创建了一个匿名内部类对象来完成，这是非必要的。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。</p><p><strong>传递一段代码</strong> –这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><p>2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p><h3 id="3-4-体验Lambda的更优写法"><a href="#3-4-体验Lambda的更优写法" class="headerlink" title="3.4 体验Lambda的更优写法"></a>3.4 体验Lambda的更优写法</h3><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoLambdaRunnable {    public static void main(String[] args) {        new Thread(() -&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); &#x2F;&#x2F; 启动线程    }}</code></pre></p><p>这段代码同上一段执行效果完全一样。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p><h3 id="3-5-回顾匿名内部类"><a href="#3-5-回顾匿名内部类" class="headerlink" title="3.5 回顾匿名内部类"></a>3.5 回顾匿名内部类</h3><h4 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h4><p>要启动一个线程，需要创建一<code>Thread</code>类的对象调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p><ul><li><code>public Thread(Runnable target)</code><br>为了获取<code>Runnable</code>接口的实现对象，还要为该接口定义一个实现类<code>RunnableImpl</code>：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class RunnableImpl implements Runnable{    @Override    public void run(){System.out.println(&quot;多线程任务执行！&quot;)    }}</code></pre></li></ul><p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ThreadInitParam{    public static void main(String[] args){Runnable task = new RunnableImpl();new Thread(task).start();    }}</code></pre></p><h4 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h4><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ThreadNameless {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(&quot;多线程任务执行！&quot;);            }        }).start();    }}</code></pre></p><h4 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h4><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p><ul><li><code>public abstract void run();</code><br>即制定了一种做事情的方案（其实就是一个函数）：</li></ul><ul><li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li><li><strong>无返回值</strong>：该方案不产生任何结果。</li><li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li></ul><p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">() -&gt; System.out.println(&quot;多线程任务执行！&quot;)</code></pre></p><ul><li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li><li>中间的一个箭头代表将前面的参数传递给后面的代码；</li><li>后面的输出语句即业务逻辑代码。</li></ul><h3 id="3-6-Lambda标准格式"><a href="#3-6-Lambda标准格式" class="headerlink" title="3.6 Lambda标准格式"></a>3.6 Lambda标准格式</h3><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码<br>Lambda表达式的<strong>标准格式</strong>为：(参数类型 参数名称) -&gt; { 代码语句 }<br>格式说明：</li><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul><h3 id="3-7-Lambda的参数和返回值"><a href="#3-7-Lambda的参数和返回值" class="headerlink" title="3.7 Lambda的参数和返回值"></a>3.7 Lambda的参数和返回值</h3><p>// Todo 使用数组存储多个Person对象。</p><p>// Todo 对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序。</p><p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p><ul><li><code>public abstract int compare(T o1, T o2);</code></li></ul><p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Person{    private String name;    private int age;    &#x2F;&#x2F; 省略构造器、toString方法与Getter Setter }</code></pre></p><h4 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h4><p>使用传统代码对<code>Person[]</code>数组进行排序<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoComparator {    public static void main(String[] args) {        &#x2F;&#x2F; 创建一个Person数组        Person[] array = {                new Person(&quot;xiaom&quot;,13),                new Person(&quot;xiaoz&quot;,17),                new Person(&quot;xiaol&quot;,15)};        &#x2F;&#x2F; Comparator接口的实例（使用了匿名内部类）重写了compare方法，制定了&quot;按照年龄从小到大升序(前-后)&quot;的排序规则。        Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() {            @Override            public int compare(Person o1, Person o2) {                return o1.getAge() - o2.getAge();            }        };        Arrays.sort(array,comp); &#x2F;&#x2F; 第二个参数为排序规则，即Comparator接口实例        for(Person person:array){            System.out.println(person);        }    }}</code></pre></p><h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><ul><li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li><li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li><li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>实际上，<strong>只有参数和方法体才是关键</strong>。</li></ul><h4 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoComparatorLambda {    public static void main(String[] args) {        &#x2F;&#x2F; 创建一个Person数组        Person[] array = {                new Person(&quot;xiaom&quot;,13),                new Person(&quot;xiaoz&quot;,17),                new Person(&quot;xiaol&quot;,15)};        Arrays.sort(array,(Person a,Person b) -&gt; {return a.getAge() - b.getAge();});        for(Person person:array){            System.out.println(person);        }    }}</code></pre><h3 id="3-8-练习"><a href="#3-8-练习" class="headerlink" title="3.8 练习"></a>3.8 练习</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义接口类public interface Calculator {    public abstract int calc(int a,int b);}&#x2F;&#x2F; 定义测试类public class DemoInvokeCalc {    public static void main(String[] args) {        &#x2F;&#x2F; 使用匿名内部类实现        invokeCalc(10, 20, new Calculator() {            @Override            public int calc(int a, int b) {                return a + b;            }        });        &#x2F;&#x2F; TODO 请在此使用Lambda[标准格式]调用invokeCalc方法来计算120+130的结果        invokeCalc(120,130,(int a,int b)-&gt; {return a+b;}); &#x2F;&#x2F; 使用Lambda表达式实现invokeCalc(20,30,(a, b) -&gt; a + b); &#x2F;&#x2F; Lambda表达式省略格式写法    }    private static void invokeCalc(int a,int b,Calculator calculator){&#x2F;&#x2F; 三个参数，2个int类型整数，1个接口        int result = calculator.calc(a, b);        System.out.println(&quot;结果是：&quot;+result);    }}</code></pre></p><h3 id="3-9-Lambda省略格式"><a href="#3-9-Lambda省略格式" class="headerlink" title="3.9 Lambda省略格式"></a>3.9 Lambda省略格式</h3><h4 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h4><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static void main(String[] args){invokeCalc(120,130,(a,b)-&gt;a+b);}</code></pre></p><h4 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h4><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><h3 id="3-10-Lambda的使用前提"><a href="#3-10-Lambda的使用前提" class="headerlink" title="3.10 Lambda的使用前提"></a>3.10 Lambda的使用前提</h3><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的线程详解和同步方法</title>
      <link href="/JavaBasics/thread.html"/>
      <url>/JavaBasics/thread.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h2><p>线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p><a id="more"></a><h3 id="1-1-多线程原理"><a href="#1-1-多线程原理" class="headerlink" title="1.1 多线程原理"></a>1.1 多线程原理</h3><p>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义线程类public class MyThread extends Thread{    &#x2F;&#x2F; 定义指定线程名称的构造方法    public MyThread(String name) {        &#x2F;&#x2F; 调用父类的String参数的构造方法，指定线程的名称        super(name);     }    &#x2F;&#x2F; 重写run方法，完成该线程的执行逻辑    @Override    public void run(){        for(int i = 0;i &lt; 10;i++){            System.out.println(getName()+&quot;正在执行第&quot;+i+&quot;次&quot;);&#x2F;&#x2F; getName获取当前线程名称        }    }}&#x2F;&#x2F; 测试类public class TestThread {    public static void main(String[] args) {        &#x2F;&#x2F; 创建线程对象        MyThread mt = new MyThread(&quot;小强&quot;);        &#x2F;&#x2F; 启动线程        mt.start();        &#x2F;&#x2F; 在主方法中执行for循环        for(int i = 0;i &lt; 10;i++){            System.out.println(&quot;旺财&quot;+i);        }    }}</code></pre></p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E7%BA%BF%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE-1556453011478.png" alt="title"></p><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的<br>start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p><p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E6%A0%88%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE-1556454114513.bmp" alt="title"></p><p>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p><h3 id="1-2-Thread类"><a href="#1-2-Thread类" class="headerlink" title="1.2 Thread类"></a>1.2 Thread类</h3><p><code>java.lang.Thread</code>类中定义了有关线程的一些方法:</p><p><strong>构造方法</strong>：</p><ul><li><code>public Thread()</code> ：分配一个新的线程对象。</li><li><code>public Thread(String name)</code> :分配一个指定名字的新的线程对象。</li><li><code>public Thread(Runnable target)</code> :分配一个带有指定目标新的线程对象。</li><li><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。</li></ul><p><strong>常用方法</strong>:</p><ul><li><code>public String getName()</code>:获取当前线程名称。</li><li><code>public void start()</code>:导致此线程开始执行; Java虚拟机调用此线程的run方法。</li><li><code>public void run()</code>:此线程要执行的任务在此处定义代码。</li><li><code>public static void sleep(long millis)</code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li><li><code>public static Thread currentThread()</code>:返回对当前正在执行的线程对象的引用</li></ul><h3 id="1-3-创建线程方式二"><a href="#1-3-创建线程方式二" class="headerlink" title="1.3 创建线程方式二"></a>1.3 创建线程方式二</h3><p>采用 <code>java.lang.Runnable</code> 也是非常常见的一种，我们只需要重写run方法即可。<br>步骤如下：</p><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。</li><li>调用线程对象的start()方法来启动线程。</li></ol><p>代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 实现类public class MyRunnable implements Runnable{    @Override    public void run() { &#x2F;&#x2F; 重写run方法        for (int i = 0;i &lt; 10; i++){            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);        }    }}&#x2F;&#x2F; 测试类public class RunnableDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 创建类对象，线程任务对象        MyRunnable mr = new MyRunnable();        &#x2F;&#x2F; 创建线程对象        Thread r = new Thread(mr,&quot;小强&quot;);        r.start();        for (int i = 0;i &lt; 10;i++){            System.out.println(&quot;旺财&quot;+i);        }    }}</code></pre></p><p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程<br>代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p><p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread<br>对象的start()方法来运行多线程代码。</p><p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，<strong>熟悉Thread类的API</strong>是进行多线程编程的基础。</p><blockquote><p>Tips::Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。<br>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p></blockquote><h3 id="1-4-Thread和Runnable的区别"><a href="#1-4-Thread和Runnable的区别" class="headerlink" title="1.4 Thread和Runnable的区别"></a>1.4 Thread和Runnable的区别</h3><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p><p><strong>实现Runnable接口创建多线程程序的好处：</strong></p><ol><li>适合多个相同的程序代码的线程去共享同一个资源。</li><li>可以避免java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类</li></ol><blockquote><p>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p></blockquote><h3 id="1-5-匿名内部类方法实现线程的创建"><a href="#1-5-匿名内部类方法实现线程的创建" class="headerlink" title="1.5    匿名内部类方法实现线程的创建"></a>1.5    匿名内部类方法实现线程的创建</h3><p>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</p><p>使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class NoNameInnerClassThread {    public static void main(String[] args) {        Runnable r = new Runnable() {            @Override            public void run() {                for(int i = 0;i&lt;10;i++){                    System.out.println(&quot;小张&quot;+i);                }            }        };        new Thread(r).start();        for (int i = 0; i &lt; 10; i++) {            System.out.println(&quot;小李&quot;+i);        }    }}</code></pre></p><h2 id="2-线程安全"><a href="#2-线程安全" class="headerlink" title="2. 线程安全"></a>2. 线程安全</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>举例演示线程的安全问题：<br>电影院要卖票，模拟电影院的卖票过程。假设要播放的电影是“复联4”，本次电影的座位共100个(本场电影只能卖100张票)。</p><p>我们模拟电影院的售票窗口，实现多个窗口同时卖“复联4”这场电影票(多个窗口一起卖这100张票)</p><p>需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟</p><p>代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 实现类public class Ticket implements Runnable{    private int ticket = 100;    &#x2F;&#x2F; 执行卖票流程    @Override    public void run() {        &#x2F;&#x2F; 每个窗口的卖票操作        while (true){            if (ticket&gt;0){                try{                    Thread.sleep(100);                }catch (InterruptedException e){                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName()+&quot;正在卖&quot;+ticket--);            }        }    }}&#x2F;&#x2F; 测试类public class TicketDemo {    public static void main(String[] args) {        Ticket tk = new Ticket(); &#x2F;&#x2F; 创建线程任务对象        &#x2F;&#x2F; 创建3个窗口对象        Thread t1 = new Thread(tk,&quot;窗口1&quot;);        Thread t2 = new Thread(tk,&quot;窗口2&quot;);        Thread t3 = new Thread(tk,&quot;窗口3&quot;);        &#x2F;&#x2F; 同时进行卖票操作        t1.start();        t2.start();        t3.start();    }}</code></pre></p><p>结果有一部分会出现如下情况：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-1556459958932.jpg" alt="title"><br><br>发现程序出现了两个问题：</p><ol><li>有部分相同的票数被卖了两回。</li><li>不存在的票，比如0票与-1票，是不存在的。</li></ol><p>这种几个窗口(线程)票数不同步了，这种问题称为线程不安全。</p><blockquote><p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作,一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></blockquote><h3 id="2-1-线程同步"><a href="#2-1-线程同步" class="headerlink" title="2.1 线程同步"></a>2.1 线程同步</h3><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。<br>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制<br>(synchronized)来解决。<br>根据案例简述：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-txt">窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</code></pre></p><p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。<br>有三种方式完成同步操作：</p><ol><li>同步代码块。</li><li>同步方法。</li><li>锁机制。</li></ol><h3 id="2-2-同步代码块"><a href="#2-2-同步代码块" class="headerlink" title="2.2 同步代码块"></a>2.2 同步代码块</h3><ul><li><strong>同步代码块</strong>：<code>synchronized</code>关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。格式：<code>synchronized</code>(同步锁){需要同步操作的代码}</li></ul><p><strong>同步锁：</strong><br>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁。</p><ol><li>锁对象 可以是任意类型。</li><li>多个线程对象 要使用同一把锁。</li></ol><blockquote><p>注意：    在任何时候候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着<br>(BLOCKED)。</p></blockquote><p>使用同步代码块解决线程同步问题实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Ticket implements Runnable{    private int ticket = 100;    Object lock = new Object(); &#x2F;&#x2F; 创建锁对象    &#x2F;&#x2F; 执行卖票流程    @Override    public void run() {        &#x2F;&#x2F; 每个窗口的卖票操作        while (true){            synchronized (lock) { &#x2F;&#x2F; 加锁                if (ticket &gt; 0) {                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + &quot;正在卖&quot; + ticket--);                }else{                    break;                }            }        }    }}&#x2F;&#x2F; 当使用了同步代码块后，上述的线程的安全问题就解决了。</code></pre></p><h3 id="2-3-同步方法"><a href="#2-3-同步方法" class="headerlink" title="2.3 同步方法"></a>2.3 同步方法</h3><ul><li><strong>同步方法</strong>：使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。格式：<code>public synchroized void method(){可能会产生线程问题的代码}</code></li></ul><blockquote><p>同步锁是谁？对于非static方法，同步锁就是this。对于static方法，使用当前方法所在类的字节码对象(类名.class)</p></blockquote><p>使用同步方法解决线程安全问题代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Ticket implements Runnable{    private int ticket = 100;    Object lock = new Object(); &#x2F;&#x2F; 创建锁对象    &#x2F;&#x2F; 执行卖票流程    @Override    public void run() {        &#x2F;&#x2F; 每个窗口的卖票操作        while (true){            sellTicket();            if (ticket==0)                break;        }    }    public synchronized void sellTicket(){ &#x2F;&#x2F; 使用synchronized修饰方法&#x2F;&#x2F; 卖票操作        if (ticket &gt; 0) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;正在卖&quot; + ticket--);        }    }}</code></pre></p><h3 id="2-4-Lock锁"><a href="#2-4-Lock锁" class="headerlink" title="2.4 Lock锁"></a>2.4 Lock锁</h3><p><code>java.util.concurrent.locks.Lock</code>机制提供了比<strong>synchronized</strong>代码块和<strong>synchronized</strong>方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</p><p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p><ul><li><code>public void lock()</code> :加同步锁。</li><li><code>public void unlock()</code> :释放同步锁。</li></ul><p>使用Lock锁解决线程安全问题代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Ticket implements Runnable{    private int ticket = 100;    Lock lock = new ReentrantLock();    &#x2F;&#x2F; 执行卖票流程    @Override    public void run() {        &#x2F;&#x2F; 每个窗口的卖票操作        while (true){            lock.lock(); &#x2F;&#x2F; 上锁            if (ticket &gt; 0) {                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName() + &quot;正在卖&quot; + ticket--);            }            lock.unlock(); &#x2F;&#x2F; 解锁            if (ticket == 0)                break;        }    }}</code></pre></p><h2 id="3-线程状态"><a href="#3-线程状态" class="headerlink" title="3, 线程状态"></a>3, 线程状态</h2><h3 id="3-1线程状态概述"><a href="#3-1线程状态概述" class="headerlink" title="3.1线程状态概述"></a>3.1线程状态概述</h3><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，<br>有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态：</p><p>这里先列出各个线程状态发生的条件，下面对每种状态进行详细解析：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/6%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81-1556462102520.jpg" alt="title"></p><h3 id="3-2-Timed-Waiting-计时等待"><a href="#3-2-Timed-Waiting-计时等待" class="headerlink" title="3.2 Timed Waiting(计时等待)"></a>3.2 Timed Waiting(计时等待)</h3><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。</p><p>在前面写的卖票案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就<br>强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。</p><p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等<br>待)，以下通过案例加深理解。</p><p><strong>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串</strong><br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class TimeWaitingDemo extends Thread{    public void run(){        for (int i = 0; i &lt; 100; i++) {            if (i%10==0)                System.out.println(&quot;------&quot;+i);            System.out.print(i);            try {                Thread.sleep(1000);                System.out.print(&quot;线程睡眠1s！\n&quot;);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args){        new TimeWaitingDemo().start();    }}</code></pre></p><p>sleep方法的使用还是很简单的,需要注意下面几点：</p><ol><li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协<br>作关系。</li><li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠</li><li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</li></ol><p>Timed Waiting 线程状态图：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85-1556463087958.png" alt="title"></p><h3 id="3-3-BLOCKED-锁阻塞"><a href="#3-3-BLOCKED-锁阻塞" class="headerlink" title="3.3 BLOCKED(锁阻塞)"></a>3.3 BLOCKED(锁阻塞)</h3><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。</p><p>在学完同步机制后，这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获<br>取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p><p>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，如下图示：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E9%94%81%E9%98%BB%E5%A1%9E-1556463246524.png" alt="title"></p><h3 id="3-4-Wating-无限等待"><a href="#3-4-Wating-无限等待" class="headerlink" title="3.4 Wating(无限等待)"></a>3.4 Wating(无限等待)</h3><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。<br>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class WaitingDemo {    public static Object obj = new Object();    public static void main(String[] args){        &#x2F;&#x2F; 演示waiting        new Thread(new Runnable() { &#x2F;&#x2F; 匿名内部类            @Override            public void run() {                while (true){                    synchronized (obj){                        try {                            System.out.println(Thread.currentThread().getName()+&quot;=== 获取到锁对&quot; +                                    &quot;象，调用wait方法，进入waiting状态，释放锁对象&quot;);                            obj.wait();&#x2F;&#x2F; 进入无限等待状态&#x2F;&#x2F;                            obj.wait(5); &#x2F;&#x2F; 5s后自动醒来                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                        System.out.println(Thread.currentThread().getName()+&quot;=== 从waiting状态&quot; +                                &quot;醒来，获取到锁对象，继续执行&quot;);                    }                }            }        },&quot;等待线程&quot;).start();        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(Thread.currentThread().getName()+&quot;------- 等待3秒&quot;);                try {                    Thread.sleep(3000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                synchronized (obj){                    System.out.println(Thread.currentThread().getName()+&quot;------ 获取到锁对象&quot; +                            &quot;，调用notify方法，释放锁对象&quot;);                    obj.notify(); &#x2F;&#x2F; 释放锁对象                }            }        },&quot;唤醒线程&quot;).start();    }}&#x2F;&#x2F; 输出结果：等待线程=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象唤醒线程------- 等待3秒唤醒线程------ 获取到锁对象，调用notify方法，释放锁对象等待线程=== 从waiting状态醒来，获取到锁对象，继续执行等待线程=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象.....阻塞等待中</code></pre></p><p>通过上述案例可以发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的<br>Object.notify()方法 或 Object.notifyAll()方法。</p><p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，<br>多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞<br>争，但更多时候你们更多是一起合作以完成某些任务。</p><p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入<br>了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了<br>notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入<br>Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85-1556464661325.png" alt="title"></p><h3 id="3-5-补充知识点"><a href="#3-5-补充知识点" class="headerlink" title="3.5 补充知识点"></a>3.5 补充知识点</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/28/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE-1556464693106.png" alt="title"></p><p>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，<br>比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。<br>这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是<br>如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两<br>得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒<br>计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p><h3 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h3><ol><li>多线程原理解析</li><li>Thread类构造方法和常用方法的使用</li><li>Runnable类的使用</li><li>线程安全问题</li><li>线程同步的三种方法</li><li>线程六种状态概述</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的异常处理和进程线程概念</title>
      <link href="/JavaBasics/Throwable.html"/>
      <url>/JavaBasics/Throwable.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h2><ul><li><strong>异常</strong>：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li></ul><p>在Java等面向对象的编程语言中，异常本身是一个类，产出异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p><blockquote><p>异常指的不是语法错误，语法错误是不会编译通过的。</p></blockquote><a id="more"></a><h3 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h3><p>异常机制就是帮助我们找到程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>和<code>java.lang.Exception</code>，平常所说的异常指的是<code>java.lang.Exception</code><br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/27/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB-1556336090373.png" alt="title"></p><p><strong>Throwable体系</strong></p><ul><li><strong>Error</strong>：严重错误Error，无法通过处理的错误，只能事先避免。好比绝症。</li><li><strong>Exception</strong>：表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。类似感冒之类的。</li></ul><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p><p><em>包含了异常的类型，异常的原因，还有异常出现的位置，在开发和调试阶段，都得使用printStackTrace。</em></p></li><li><p><code>public String getMessage()</code>:获取发生异常的原因。</p><p><em>提示给用户的时候，就提示错误原因。</em></p></li><li><p><code>public String toString()</code>: 获取异常的类型和异常描述信息(不用)。</p></li></ul><p><strong><em>出现异常后，可以把异常的简单类名，复制到API中去查询。</em></strong></p><h3 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h3><p>一般的异常指的就是Exception，因为这类异常一旦出现，我们就需要对代码进行更正，修复程序。</p><p><strong>异常的分类</strong>：根据在编译时期还是运行时期去检查异常</p><ul><li><strong>编译时期的异常</strong>： checked异常。在编译时期，就会检查，如果没有处理异常，则编译失败。</li><li><strong>运行时期异常</strong>：runtime异常。在运行时期，检查异常，在编译时期，运行异常不会编译器检测(不会报错)。</li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/27/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB-1556346151127.png" alt="title"></p><h3 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4 异常的产生过程解析"></a>1.4 异常的产生过程解析</h3><p>运行下面程序，程序会产生义工数组索引越界异常<code>ArrayIndexOutOfBoundsException</code>。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 工具类public class ArrayTools {    &#x2F;&#x2F; 对给定的数组通过给定的索引获取元素    public static int getElement(int[] arr, int index){        int element = arr[index];        return element;    }}&#x2F;&#x2F; 测试类public class ExceptionDemo {    public static void main(String[] args) {        int[] arr = {34,12,67};        int num = ArrayTools.getElement(arr,4);        System.out.println(&quot;num=&quot;+num);        System.out.println(&quot;over&quot;);    }}</code></pre></p><p>上述程序执行过程图解：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/27/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B-1556347566816.png" alt="title"></p><h2 id="2-异常的处理"><a href="#2-异常的处理" class="headerlink" title="2. 异常的处理"></a>2. 异常的处理</h2><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p><h3 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1 抛出异常throw"></a>2.1 抛出异常throw</h3><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在Java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。具体操作如下：</p><ol><li>创建一个异常对象，封装一些提示信息。</li><li><p>通过关键字thro将这个异常对象告知给调用者。throw异常对象。</p><p> throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p></li></ol><p><strong>使用格式：</strong> <code>throw new 异常类名(参数)</code></p><p>  例如：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">throw new NullPointerException(&quot;要访问的arr数组不存在&quot;);throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;)</code></pre></p><p>以下为程序实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ThrowDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 创建一个数组        int[] arr = {2,4,35,2};        &#x2F;&#x2F; 根据索引找对应的元素        int index = 4;        int element = getElement(arr,index);        System.out.println(element);        System.out.println(&quot;over&quot;);    }    &#x2F;&#x2F; 根据 索引找到数组中对应的元素    public static int getElement(int[] arr,int index){        &#x2F;&#x2F; 判断 索引是否越界        if(index&lt;0 || index &gt; arr.length-1){            &#x2F;*                判断条件如果满足，当执行完throw抛出异常对象后，方法已无法继续运算。                这时就会结束当前方法的执行，并将异常告知给调用者。这时就需通过异常来解决。             *&#x2F;            throw new ArrayIndexOutOfBoundsException(&quot;小老弟，索引越界了！！！&quot;);        }        int element = arr[index];        return element;    }}</code></pre></p><blockquote><p>注意：如果产生了问题，throw就会将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p><p>那么对于调用者来说，有两种方式处理，一种是进行捕获处理，另一种就是继续将问题声明出去，使用throws声明处理。</p></blockquote><h3 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h3><p>我们学习过一个类Objects， 里面有提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p><ul><li><code>public static &lt;T&gt; requireNonNull(T obj)</code>:查看指定引用对象不是null。</li></ul><p>查看源码可以发现这里对null对象进行了抛出异常操作。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static &lt;T&gt; T requireNonNull(T obj) {        if (obj == null)            throw new NullPointerException();        return obj;    }</code></pre></p><h3 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3 声明异常throws"></a>2.3 声明异常throws</h3><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理，那么必须通过throws进行声明，让调用者去处理。<br>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常)。</p><p><strong>声明异常格式：</strong><code>修饰符 返回值类型 方法名(参数) throws 异常类名1，异常类名2...{  }</code></p><p>代码实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ThrowDemo02 {    public static void main(String[] args) throws IOException{        read(&quot;a.txt&quot;);    }    &#x2F;&#x2F; 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明    &#x2F;&#x2F; 假如该方法可能有多种异常情况产生，那么throws后面可以写多个异常类，用逗号隔开。    public static void read(String path) throws FileNotFoundException, IOException {        if(!path.equals(&quot;a.txt&quot;)) &#x2F;&#x2F; 如果不是a.txt这个字符串            throw new FileNotFoundException(&quot;文件不存在&quot;); &#x2F;&#x2F; 则生成一个异常类返回给调用者        if(!path.equals(&quot;b.txt&quot;))            throw new IOException();    }}</code></pre></p><h3 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4 捕获异常try…catch"></a>2.4 捕获异常try…catch</h3><p>如果异常出现的话，会立即终止程序，所以我们得处理异常：</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><p><strong>try-catch</strong>的方式就是捕获异常。</p><ul><li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p>捕获异常语法如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">try{    编写可能会出现异常的代码}catch(异常类型 e){    处理异常的代码    &#x2F;&#x2F; 记录日志&#x2F;打印异常信息&#x2F;继续抛出异常}</code></pre></p><p><strong>try：</strong> 该代码块中编写可能产生异常的代码。<br><strong>catch：</strong> 用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><blockquote><p>注意：try和catch都不能单独使用，必须一起用。</p></blockquote><p>代码实例:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class TryCatchDemo {    public static void main(String[] args) {        try{ &#x2F;&#x2F; 当产生异常时，必须有处理方式，要么捕获，要么声明。            read(&quot;b.txt&quot;);        }catch (FileNotFoundException e){ &#x2F;&#x2F; try中抛出的是什么异常，在括号中就定义什么异常            System.out.println(e);        }        System.out.println(&quot;over&quot;);    }    public static void read(String path) throws FileNotFoundException{        if(!path.equals(&quot;a.txt&quot;))            throw new FileNotFoundException(&quot;文件不存在&quot;);    }}</code></pre></p><p>如何获取异常信息：</p><p>Throwable类中定义了一些查看方法:</p><ul><li><p><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li><li><p><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</p><p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em><br>​ </p><h3 id="2-4-finally代码块"><a href="#2-4-finally代码块" class="headerlink" title="2.4 finally代码块"></a>2.4 finally代码块</h3></li></ul><p><strong>finally</strong>：当遇到某些代码是无论是否发生异常，都要执行的，那么可以放在finally代码块中，在finally代码块中存放的代码都是一定会被执行的。</p><p>有哪些时候的代码必须最终执行？当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p><p>语法：try…catch….finally:自身需要处理异常,最终还得关闭资源。</p><blockquote><p>注意：finally不能单独使用。</p></blockquote><p>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FinallyDemo {    public static void main(String[] args) {        try{            read(&quot;a.txt&quot;);        }catch (FileNotFoundException e){            &#x2F;&#x2F;捕获编译期报错信息，在运行期抛出去。            throw  new RuntimeException(e);        }finally {            System.out.println(&quot;这里的代码必定执行&quot;);        }        System.out.println(&quot;over&quot;);    }    &#x2F;&#x2F; 因为我们当前的read方法中有异常，所以编译期会报错。    public static void read(String path) throws FileNotFoundException{        if(!path.equals(&quot;a.txt&quot;))            throw new FileNotFoundException(&quot;文件不存在&quot;);    }}</code></pre></p><blockquote><p>当只有在try或者catch中调用退出JVM的相关方法时，finally才不会执行，否则必定执行。</p></blockquote><h3 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5 异常注意事项"></a>2.5 异常注意事项</h3><ul><li><p>多个异常使用捕获又该如何处理呢？</p><ol><li>多个异常分别处理。</li><li>多个异常一次捕获，多次处理。</li><li>多个异常一次捕获一次处理。</li></ol></li></ul><p>一般使用一次捕获多次处理方式，格式如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">try{    编写可能会出现异常的代码}catch(异常类型A e){ 当try中出现A类型异常时，就用该catch来捕获。处理异常代码}catch(异常类型B e){当try中出现B类型异常时，就用该catch来捕获。处理异常代码}</code></pre></p><blockquote><p>注意：这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p></blockquote><ul><li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p></li><li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p></li><li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p></li><li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p></li></ul><h2 id="3-自定义异常"><a href="#3-自定义异常" class="headerlink" title="3. 自定义异常"></a>3. 自定义异常</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p><strong>为什么需要自定义异常类:</strong></p><p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p><p>在上述示例中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题。我们就需要自己定义异常。</p><p><strong>什么是自定义异常类:</strong></p><p>在开发中根据自己业务的异常情况来定义的异常类。</p><p><strong>异常类如何定义:</strong></p><ol><li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li><li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li></ol><h3 id="3-2-自定义异常的练习"><a href="#3-2-自定义异常的练习" class="headerlink" title="3.2 自定义异常的练习"></a>3.2 自定义异常的练习</h3><p>模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p><p>代码实例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 首先定义一个登录异常类RegisterException:public class RegisterException extends Exception{    public RegisterException() { &#x2F;&#x2F; 空参构造    }    public RegisterException(String message){        super(message); &#x2F;&#x2F; @param message 表示异常提示    }}&#x2F;&#x2F; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。public class TestDemo {    &#x2F;&#x2F; 模拟数据库中已存在的账号    private static String[] names = {&quot;xiaowang&quot;,&quot;xiaozhang&quot;,&quot;xiaoming&quot;};    public static void main(String[] args) {        &#x2F;&#x2F; 调用方法        try{            &#x2F;&#x2F; 可能出现异常的代码块            checkUsername(&quot;xiaowang&quot;);            System.out.println(&quot;注册成功&quot;);        }catch(RegisterException e){            e.printStackTrace();        } catch (LoginException e) {            e.printStackTrace();        }    }    public static boolean checkUsername(String uname) throws LoginException, RegisterException {        for(String name:names){            if(name.equals(uname))                throw new RegisterException(&quot;亲&quot;+name+&quot;已经被注册了！&quot;);        }        return true;    }}</code></pre></p><h2 id="4-多线程"><a href="#4-多线程" class="headerlink" title="4. 多线程"></a>4. 多线程</h2><h3 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h3><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/27/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91-1556377430817.bmp" alt="title"></li></ul><p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p><blockquote><p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p></blockquote><h3 id="4-2-线程与进程"><a href="#4-2-线程与进程" class="headerlink" title="4.2 线程与进程"></a>4.2 线程与进程</h3><ul><li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。</p></li></ul><p>打开任务管理器，可以查看当前任务的进程：</p><p><strong>进程</strong> <br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/27/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5-1556377763628.png" alt="title"></p><p><strong>线程</strong> <br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/27/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5-1556377846601.png" alt="title"></p><p><strong>线程调度:</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p></li><li><p>抢占式调度</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p><ul><li>设置线程的优先级<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/27/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7-1556377952137.bmp" alt="title"></li><li><p>抢占式调度详解</p><p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着”.</p><p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/27/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6-1556378070170.bmp" alt="title"></p></li></ul></li></ul><h3 id="4-3-创建线程类"><a href="#4-3-创建线程类" class="headerlink" title="4.3 创建线程类"></a>4.3 创建线程类</h3><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>代码实例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 自定义线程类public class MyThread extends Thread{    &#x2F;&#x2F; 定义指定线程名称的构造方法    public MyThread(String name) {        &#x2F;&#x2F; 调用父类的String参数的构造方法，指定线程的名称        super(name);    }    &#x2F;&#x2F; 重写run方法，完成该线程的执行逻辑    @Override    public void run(){        for(int i = 0;i &lt; 10;i++){            System.out.println(getName()+&quot;正在执行第&quot;+i+&quot;次&quot;);        }    }}&#x2F;&#x2F; 测试类public class TestThread {    public static void main(String[] args) {        &#x2F;&#x2F; 创建线程对象        MyThread mt = new MyThread(&quot;新的线程！&quot;);        &#x2F;&#x2F; 启动线程        mt.start();        &#x2F;&#x2F; 在主方法中执行for循环        for(int i = 0;i &lt; 10;i++){            System.out.println(&quot;main线程&quot;+i);        }    }}</code></pre></p><h3 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h3><ol><li>Java中的异常体系</li><li>异常处理5个关键字：try、catch、finally、throw、throws</li><li>异常处理的使用方法</li><li>自定义异常类</li><li>并发与并行的概念</li><li>进程线程的概念</li><li>线程调度的各种方式</li><li>Java中的线程类Thread，以及基本使用方式</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map集合和Debug跟踪</title>
      <link href="/JavaBasics/Map.html"/>
      <url>/JavaBasics/Map.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Map集合"><a href="#1-Map集合" class="headerlink" title="1. Map集合"></a>1. Map集合</h2><p>生活中我们常会看到一种集合：IP地址与主机名，身份证号与个人等，这种一一对应的关系，叫做映射。Java中的<code>java.util.Map</code>接口是专门用来存放这种映射关系的集合类。</p><a id="more"></a><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/26/Collection%E4%B8%8EMap-1556257061416.bmp" alt="title"></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的。每个元素由键值对组成，通过键可以找对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h3 id="1-2-Map常用子类"><a href="#1-2-Map常用子类" class="headerlink" title="1.2 Map常用子类"></a>1.2 Map常用子类</h3><p>Map有多个子类，这里主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li><strong>HashMap&lt;K,V&gt;</strong>：存储数据采用的哈希表结构，元素的存取顺序不一致。由于要保证键的唯一、不重复，需要重写键的hashCode()和equals()方法。</li><li><strong>LinkedHashMap</strong>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证键的唯一性，需要重写键的hashCode和equals方法。</li></ul><blockquote><p>Tips:Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，需为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可不同。</p></blockquote><h3 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3 Map接口中的常用方法"></a>1.3 Map接口中的常用方法</h3><p>Map接口中定义了多种方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p>Map接口的方法示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class MapDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 创建Map对象        HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();        &#x2F;&#x2F; put(键,值)添加元素        System.out.println(map.put(&quot;小明&quot;,15)); &#x2F;&#x2F; 如果添加的元素对键名没有在集合中，会返回一个null，并添加元素        System.out.println(map.put(&quot;小明&quot;,11)); &#x2F;&#x2F; 如果添加的元素对键名在集合中存在，则返回该键对应的值，然后替换为新值        map.put(&quot;小张&quot;,18);        map.put(&quot;李小&quot;,16);        System.out.println(map); &#x2F;&#x2F; {小明=15, 小张=18, 李小=16}        &#x2F;&#x2F; remove(键名)删除指定元素        System.out.println(map.remove(&quot;李小&quot;));        System.out.println(map); &#x2F;&#x2F; {小明=15, 小张=18}        &#x2F;&#x2F; 通过键名查询对应的值        System.out.println(map.get(&quot;小明&quot;)); &#x2F;&#x2F; 15        System.out.println(map.get(&quot;小张&quot;)); &#x2F;&#x2F; 18    }}</code></pre></p><blockquote><p>Tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则表示没有这个键值对，返回null，并把指定键值添加到集合中。</p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值，并把指定键所对应的值，替换为新值。</p></blockquote><h3 id="1-4-Map集合遍历键找值的方式"><a href="#1-4-Map集合遍历键找值的方式" class="headerlink" title="1.4 Map集合遍历键找值的方式"></a>1.4 Map集合遍历键找值的方式</h3><p>遍历方式：即通过元素中的键名，获取键所对应的值。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoGetValue {    public static void main(String[] args) {        HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();        map.put(&quot;小明&quot;,16);        map.put(&quot;小李&quot;,19);        map.put(&quot;小张&quot;,17);        map.put(&quot;小德&quot;,12);        &#x2F;&#x2F; 获取所以键，存储到set集合中        Set&lt;String&gt; keys = map.keySet();        for(String key:keys){            System.out.println(key+&quot;的年龄是：&quot;+map.get(key)+&quot;岁&quot;);        }    }}</code></pre></p><h3 id="1-5-Entry键值对对象"><a href="#1-5-Entry键值对对象" class="headerlink" title="1.5 Entry键值对对象"></a>1.5 Entry键值对对象</h3><p>Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，在Map中是一一对应关系，这一对对象又称做Map中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们遍历Map集合时，就可以从每一个键值对(Entry)对象中获取对应的键与对应的值。</p><p>Entry同样提供了获取对应键和对应值的方法：</p><ul><li><code>public K getKey()</code>: 获取Entry对象中的键。</li><li><code>public V getValue()</code>:获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所以Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>:获取Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h3 id="1-6-Map集合遍历键值对方式"><a href="#1-6-Map集合遍历键值对方式" class="headerlink" title="1.6 Map集合遍历键值对方式"></a>1.6 Map集合遍历键值对方式</h3><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。<br>操作步骤：</p><ol><li>获取Map集合中，所以键值对(Entry)对象，以Set集合形式返回。方法提示：<code>entrySet()</code>。</li><li>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li><li>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>   <!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class EntryDemo {    public static void main(String[] args) {        HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;();        map.put(&quot;小米&quot;,32);        map.put(&quot;小花&quot;,25);        map.put(&quot;小马&quot;,52);        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrys = map.entrySet();        for (Map.Entry&lt;String,Integer&gt; entry:entrys){            String key = entry.getKey();            int value = entry.getValue();            System.out.println(key+&quot;的年龄是:&quot;+value+&quot;岁&quot;);        }    }}</code></pre></li></ol><blockquote><p>Tips: Map集合不能直接使用迭代器或foreach进行遍历。但是转Set之后就可以使用了。</p></blockquote><h3 id="1-7-HashMap存储自定义类型键值"><a href="#1-7-HashMap存储自定义类型键值" class="headerlink" title="1.7 HashMap存储自定义类型键值"></a>1.7 HashMap存储自定义类型键值</h3><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 学生类public class Student {    private String name;    private int age;&#x2F;&#x2F; ... 省略get&#x2F;set方法，初始化构造方法等}&#x2F;&#x2F; 测试类public class HashMapTest {    public static void main(String[] args) {        &#x2F;&#x2F; 创建HashMap集合对象        Map&lt;Student, String&gt; map = new HashMap&lt;&gt;();        map.put(new Student(&quot;张三&quot;,25),&quot;上海&quot;);        map.put(new Student(&quot;李四&quot;,28),&quot;北京&quot;);        map.put(new Student(&quot;王五&quot;,20),&quot;广州&quot;);        map.put(new Student(&quot;赵六&quot;,19),&quot;深圳&quot;);        map.put(new Student(&quot;孙钱&quot;,24),&quot;杭州&quot;);        &#x2F;&#x2F; 取出元素        Set&lt;Student&gt; keys = map.keySet(); &#x2F;&#x2F; 获取所以键名放入set中        for (Student key:keys){            System.out.println(key.toString() + &quot;.....&quot; + map.get(key)); &#x2F;&#x2F; 注意Student类要重写toString方法        }    }}</code></pre></p><h3 id="1-8-LinkedHashMap"><a href="#1-8-LinkedHashMap" class="headerlink" title="1.8 LinkedHashMap"></a>1.8 LinkedHashMap</h3><p>HashMap可以保证成对元素唯一性，且查询速度很快，可存入的顺序是无序的，如果要保证有序，可以使用<code>HashMap</code>下的一个子类<code>LinkedHashMap</code>，它是链表和哈希表组成的一个数据存储结构。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class LinkedHashMapDemo {    public static void main(String[] args) {        LinkedHashMap&lt;String,Integer&gt; linkMap = new LinkedHashMap&lt;&gt;();        linkMap.put(&quot;小米&quot;,11);        linkMap.put(&quot;小花&quot;,15);        linkMap.put(&quot;小中&quot;,19);        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrys = linkMap.entrySet();        for(Map.Entry&lt;String,Integer&gt; entry:entrys){            System.out.println(entry.getKey() + &quot;的年龄是：&quot; + entry.getValue() + &quot;岁&quot;);        }    }}&#x2F;&#x2F; 如此就保证了存入元素的有序性</code></pre></p><h3 id="1-9-Map集合练习"><a href="#1-9-Map集合练习" class="headerlink" title="1.9 Map集合练习"></a>1.9 Map集合练习</h3><p>计算一个字符串中每个字符出现次数。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class MapTest {    public static void main(String[] args) {        System.out.println(&quot;请输入一个字符串:&quot;);        String line = new Scanner(System.in).nextLine();        findChar(line);    }    public static void findChar(String line){        &#x2F;&#x2F; 创建一个集合，存储字符及出现次数        HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();        for(int i = 0;i &lt; line.length();i++){            char c = line.charAt(i); &#x2F;&#x2F; 返回指定索引处字符            if(!map.containsKey(c)){ &#x2F;&#x2F; 判断字符 是否在键集中,不在则执行下面语句                map.put(c,1); &#x2F;&#x2F; 第一次出现，添加该字符，并计数1            }else{ &#x2F;&#x2F; 则说明字符键名在键集中了，就是出现过                Integer count = map.get(c); &#x2F;&#x2F; 获取前一次值                map.put(c,++count); &#x2F;&#x2F; 再次存入，并更新值            }        }        System.out.println(map);    }}</code></pre></p><h2 id="2-知识点补充"><a href="#2-知识点补充" class="headerlink" title="2. 知识点补充"></a>2. 知识点补充</h2><h3 id="2-1-JDK9对集合添加的优化"><a href="#2-1-JDK9对集合添加的优化" class="headerlink" title="2.1 JDK9对集合添加的优化"></a>2.1 JDK9对集合添加的优化</h3><p>Java 9，添加了几种集合工厂方法，更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class JDK9NewMethod {    public static void main(String[] args) {        Set&lt;String&gt; str = Set.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);&#x2F;&#x2F;        str1.add(&quot;d&quot;); &#x2F;&#x2F; 这里使用add方法，编译不会报错，执行会报错，因为是不可变集合。        System.out.println(str);        List&lt;String&gt; list = List.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);        System.out.println(list);        Map&lt;String,Integer&gt; map = Map.of(&quot;a&quot;,1,&quot;b&quot;,2);        System.out.println(map);    }}</code></pre></p><p>注意事项：</p><blockquote><ol><li>of()方法只是Map,List,Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，如HashSet，ArrayList等。<br>2.返回的集合是不可变的。</li></ol></blockquote><h3 id="2-2-Debug跟踪"><a href="#2-2-Debug跟踪" class="headerlink" title="2.2 Debug跟踪"></a>2.2 Debug跟踪</h3><h4 id="使用IDEA的断点调试功能，查看程序的运行过程"><a href="#使用IDEA的断点调试功能，查看程序的运行过程" class="headerlink" title="使用IDEA的断点调试功能，查看程序的运行过程"></a>使用IDEA的断点调试功能，查看程序的运行过程</h4><p>下图为调试窗口基本功能。<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/26/debug%E8%B0%83%E8%AF%95%E7%AA%97%E5%8F%A3%E5%8A%9F%E8%83%BD%E7%AE%80%E8%BF%B0-1556287135342.png" alt="title"></p><h2 id="3-斗地主Map实现"><a href="#3-斗地主Map实现" class="headerlink" title="3. 斗地主Map实现"></a>3. 斗地主Map实现</h2><h3 id="需求分析："><a href="#需求分析：" class="headerlink" title="需求分析："></a>需求分析：</h3><ol><li>准备牌：<br>完成数字与纸牌的映射关系：<br>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</li><li>洗牌：<br>通过数字完成洗牌发牌</li><li>发牌：<br>将每个人以及底牌设计为ArrayList<string>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。<br>存放的过程中要求数字大小与斗地主规则的大小对应。<br>将代表不同纸牌的数字分配给不同的玩家与底牌。</string></li><li>看牌：<br>通过Map集合找到对应字符展示。<br>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/26/04_%E6%96%97%E5%9C%B0%E4%B8%BB%E6%A1%88%E4%BE%8B%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-1556289337309.bmp" alt="title"><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Poker {    public static void main(String[] args) {        &#x2F;&#x2F; 准备牌        List&lt;String&gt; colors = List.of(&quot;♥&quot;,&quot;♦&quot;,&quot;♠&quot;,&quot;♣&quot;);        List&lt;String&gt; numbers = List.of(&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;);        HashMap&lt;Integer,String&gt; pokerMap = new HashMap&lt;&gt;();        int cardID = 0;        for (String color:colors){            for (String num:numbers){                pokerMap.put(cardID,color+num);                cardID++;            }        }        pokerMap.put(52,&quot;小☺&quot;);        pokerMap.put(53,&quot;大☠&quot;);&#x2F;&#x2F;        System.out.println(pokerMap);        ArrayList&lt;Integer&gt; cardKeys = new ArrayList&lt;&gt;();        cardKeys.addAll(pokerMap.keySet());&#x2F;&#x2F; 获取map的键名集合，并转换为List集合，方便打乱。        &#x2F;&#x2F; 打乱顺序，洗牌        Collections.shuffle(cardKeys); &#x2F;&#x2F; 牌编号集合        &#x2F;&#x2F; 创建3个玩家集合和底牌集合。        ArrayList&lt;String&gt; bottomCard = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 底牌        ArrayList&lt;String&gt; player1 = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 玩家1        ArrayList&lt;String&gt; player2 = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 玩家2        ArrayList&lt;String&gt; player3 = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 玩家3        &#x2F;&#x2F; 发牌的编号        for (int i = 0;i &lt; cardKeys.size();i++){            if (i &gt;= 51){                bottomCard.add(pokerMap.get(cardKeys.get(i))); &#x2F;&#x2F; 根据牌编号，获取对应在牌盒中的牌，放入底牌            }else if (i % 3 == 0){                player1.add(pokerMap.get(cardKeys.get(i))); &#x2F;&#x2F; 根据牌编号，获取对应在牌盒中的牌，放入玩家1手中            }else if (i % 3 == 1){                player2.add(pokerMap.get(cardKeys.get(i))); &#x2F;&#x2F; 根据牌编号，获取对应在牌盒中的牌，放入玩家2手中            }else{                player3.add(pokerMap.get(cardKeys.get(i))); &#x2F;&#x2F; 根据牌编号，获取对应在牌盒中的牌，放入玩家3手中            }        }        &#x2F;&#x2F; 根据花色排序，后续可改进为根据数字排序        Collections.sort(bottomCard);        Collections.sort(player1);        Collections.sort(player2);        Collections.sort(player3);        &#x2F;&#x2F; 看牌        System.out.println(player1);        System.out.println(player2);        System.out.println(player3);        System.out.println(bottomCard);    }}</code></pre></li></ol><h3 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h3><ol><li>Map集合中的子类和常用方法</li><li>Debug跟踪的使用</li><li>使用Map实现斗地主案例</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构概述和List/Set集合</title>
      <link href="/JavaBasics/set.html"/>
      <url>/JavaBasics/set.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h2><h3 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h3><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。下面分别了解一下：</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><strong>栈</strong>：<strong>stack</strong>，又称堆栈，它是运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表；又被称为后进先出(Last In First Out)的线性表，简称LIFO结构。</li></ul><a id="more"></a><p>简单的说：采用该结构的集合，对元素的存取有以下特点：</p><ul><li>先进后出(即，先存进去的元素，要在后它存进去的元素依次取出后，才能取出该元素)。</li><li>栈的入口、出口都是栈的顶端位置。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E5%A0%86%E6%A0%88-1556160250265.png" alt="title"></li><li><strong>压栈</strong>：就是存元素。即、把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即、把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li><strong>队列</strong>：<strong>queue</strong>，简称队，它同堆栈一样，也是一种运算受限的线性表，只允许在一端进行插入操作，而在另一端进行删除操作的线性表，又被称为先进先出(First In First Out)的线性表，简称FIFO结构。<br>采用该结构的集合，对元素的存取有如下特点：</li><li>先进先出(即，先存进去的元素，会比后它进来的元素先出去)。</li><li>队列的入口、出口各占一侧。如下图示：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E9%98%9F%E5%88%97%E5%9B%BE-1556161254994.bmp" alt="title"></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组</strong>：<strong>Array</strong>是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。<br>数据结构特点：<br></li><li><p>查找元素快：通过索引，可以快速访问指定位置的元素<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB-1556161542860.png" alt="title"></p></li><li><p>增删元素慢</p><ul><li><strong>指定索引位置增加元素</strong>： 需要创建一个新数组，将指定新元素存储在指定索引位置，在把原数组元素根据索引，复制到新数组对应索引的位置。如下图：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0-1556161717343.png" alt="title"></li><li><strong>指定索引位置删除元素</strong>：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引位置，原数组中指定索引位置元素不复制到新数组中。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4-1556161853599.png" alt="title"></li></ul></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><strong>链表</strong>：<strong>linked list</strong>由一系列结点node(链表中每一个元素称为结点)组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域(每一个节点包含指向下一个节点的指针)。链表结构有单向链表与双向链表，这里介绍的是单向链表。<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9-1556162344765.png" alt="title"><br><br>采用该数据结构的集合，对元素的存取有如下的特点：</li><li>多个结点之间，通过地址进行连接。例如多个人手拉手，每个人使用自己的右手拉住下一个人的左手，依次类推，这样多个人就连在一起了。<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84-1556162662545.png" alt="title"><br></li><li>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。</li><li>增删元素快：只需修改连接下个元素的地址即可。<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9-1556163144732.png" alt="title"><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9-1556163150767.bmp" alt="title"></li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul><li><strong>二叉树</strong>:<strong>binary tree</strong>,是每个节点不超过2的有序<strong>树(tree)</strong>。即每个节点最多只有两个分支(不存在分支度大于2的节点)的数结构。通常分支被称作”左子树”和”右子树”。二叉树的分支具有左右次序，不能颠倒。<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E4%BA%8C%E5%8F%89%E6%A0%91-1556164470030.bmp" alt="title"><br>二叉树有一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也意味着，树的键值仍然有序的。<br>红黑树的约束：</li></ul><ol><li>节点可以是红色的或者黑色的</li><li>根节点是黑色的</li><li>叶子节点(特指空节点)是黑色的</li><li>每个红色节点的子节点都是黑色的</li><li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同<br>红黑树特点：速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍<br><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md" target="_blank" rel="noopener">红黑树详解</a></li></ol><h2 id="2-List集合"><a href="#2-List集合" class="headerlink" title="2. List集合"></a>2. List集合</h2><h3 id="2-1-List接口"><a href="#2-1-List接口" class="headerlink" title="2.1 List接口"></a>2.1 List接口</h3><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特定就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33.那么集合中，元素的存储就是按照11、22、33的顺序完成的。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素(与数组的索引是一个道理)</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><h3 id="2-2-List接口中常用的方法"><a href="#2-2-List接口中常用的方法" class="headerlink" title="2.2 List接口中常用的方法"></a>2.2 List接口中常用的方法</h3><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法。</p><ul><li><code>public void add(int index, E element)</code>:将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>: 返回集合中指定位置的元素</li><li><code>public E remove(int index)</code>:移除列表中指定位置的元素，返回的是被移除的元素</li><li><code>public E set(int index,E element)</code>:用指定元素替换集合中指定位置的元素，返回值是更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关的，代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.ArrayList;import java.util.List;public class Demo01List {    public static void main(String[] args) {        &#x2F;&#x2F; 创建List集合对象        List&lt;String&gt; list =  new ArrayList&lt;String&gt;();        &#x2F;&#x2F;往 尾部添加 元素        list.add(&quot;小米&quot;);        list.add(&quot;小天&quot;);        list.add(&quot;小风&quot;);        System.out.println(list);  &#x2F;&#x2F; [小米, 小天, 小风]        &#x2F;&#x2F; add(int index,String s) 往指定位置添加元素        list.add(1,&quot;小洪&quot;);        System.out.println(list); &#x2F;&#x2F; [小米, 小洪, 小天, 小风]        &#x2F;&#x2F; remove(int index) 删除指定位置元素，返回被删除元素        System.out.println(&quot;删除索引位置为2的元素&quot;+list.remove(2)); &#x2F;&#x2F; 删除索引位置为2的元素小天        &#x2F;&#x2F; set(int index, String s) 将指定位置的元素进行替换(修改)        System.out.println(list.set(1,&quot;小华&quot;)); &#x2F;&#x2F; 返回的是被替换的元素， 小洪        for (int i = 0; i &lt; list.size(); i++) {            System.out.println(list.get(i)); &#x2F;&#x2F; get(int index) 获取指定索引位置的元素        }    }}</code></pre></p><h2 id="3-List的子类"><a href="#3-List的子类" class="headerlink" title="3. List的子类"></a>3. List的子类</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，因日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是常用的集合。</p><h3 id="3-1-LinkedList集合"><a href="#3-1-LinkedList集合" class="headerlink" title="3.1 LinkedList集合"></a>3.1 LinkedList集合</h3><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，如下图就是一个双向链表。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-1556175171141.png" alt="title"></p></blockquote><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法了解即可：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用的。方法演示：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.LinkedList;public class Demo02LinkedList {    public static void main(String[] args) {        LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();        list.addFirst(0);        list.addLast(1);        list.addLast(2);        list.addLast(3);        System.out.println(list); &#x2F;&#x2F; [0,1,2,3]        System.out.println(&quot;返回此列表第一个元素:&quot;+list.getFirst()); &#x2F;&#x2F; 0        System.out.println(&quot;返回此列表最后一个元素:&quot;+list.getLast()); &#x2F;&#x2F; 3        System.out.println(&quot;删除第一个元素并返回它:&quot;+list.removeFirst()); &#x2F;&#x2F; 0        System.out.println(&quot;删除最后一个元素并返回它:&quot;+list.removeLast()); &#x2F;&#x2F; 3        System.out.println(list.pop()); &#x2F;&#x2F; 弹出，就是移除元素,栈在列表左侧        list.push(3);        System.out.println(list);        System.out.println(list.isEmpty()); &#x2F;&#x2F; 判断列表是否为空，空则返回true    }}</code></pre></p><h2 id="4-Set接口"><a href="#4-Set接口" class="headerlink" title="4. Set接口"></a>4. Set接口</h2><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对该接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且有规则保证存入元素不出现重复。</p><p><code>Set</code>集合有多个子类，这里主要介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p><blockquote><p>Tips：Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h3 id="4-1-HashSet集合介绍"><a href="#4-1-HashSet集合介绍" class="headerlink" title="4.1 HashSet集合介绍"></a>4.1 HashSet集合介绍</h3><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它存储的元素是不可重复的，并且元素都是无序的。它的底层实现其实是一个<code>java.util.HashMap</code>支持。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖与：<code>hashCode</code>与<code>equals</code>方法。以下代码示意使用Set集合存储：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.HashSet;public class Demo03HashSet {    public static void main(String[] args) {        &#x2F;&#x2F; 创建 Set集合        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();        &#x2F;&#x2F; 添加元素        set.add(new String(&quot;cba&quot;));        set.add(&quot;abc&quot;);        set.add(&quot;bac&quot;);        set.add(&quot;cba&quot;);        &#x2F;&#x2F; 遍历        for (String s:set){            System.out.println(s); &#x2F;&#x2F; cba,abc,bac 自动去重了        }    }}</code></pre></p><h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h4><p>hashCode方法返回对象的哈希值<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;*    哈希值：是一个十进制的整数，由系统随机给出(就是对象的地址值，是一个逻辑地址，不是数据实际存储的物理地址)    在Object类有一个方法，可以获取对象的哈希值    int hashCode() 返回该对象的哈希码值    hashCode()方法的源码：        public native int hashCode();        native:代办该方法调用的是本地操作系统的方法。 *&#x2F;public class DemoHashCode {    public static void main(String[] args) {        &#x2F;&#x2F; Person类继承了Object类，所以可以使用Object类的hashCode方法        Person p1 = new Person();        System.out.println(p1.hashCode()); &#x2F;&#x2F; 1072408673        System.out.println(new Person().hashCode()); &#x2F;&#x2F; 1531448569        System.out.println(&quot;abc&quot;.hashCode()); &#x2F;&#x2F; 96354        &#x2F;&#x2F; 以下两个为特殊情况，内容不同hash值相同        System.out.println(&quot;重地&quot;.hashCode()); &#x2F;&#x2F; 1179395        System.out.println(&quot;通话&quot;.hashCode()); &#x2F;&#x2F; 1179395    }}</code></pre></p><p>Set集合去重原理：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/Set%E5%8E%BB%E9%87%8D%E5%8E%9F%E7%90%86-1556188205465.png" alt="title"></p><h3 id="4-2-HashSet集合存储数据的结构-哈希表"><a href="#4-2-HashSet集合存储数据的结构-哈希表" class="headerlink" title="4.2 HashSet集合存储数据的结构(哈希表)"></a>4.2 HashSet集合存储数据的结构(哈希表)</h3><h4 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h4><p>在JDK 1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过Key值依次查找的效率较低。而JDK 1.8中，哈希表存储采用数组+链表+红黑树实现，而链表长度超过阈值(8)时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树(JDK1.8增加了红黑树部分)实现的，如下图示。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E5%93%88%E5%B8%8C%E8%A1%A8-1556182995014.png" alt="title"><br>哈希表存储流程图：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/25/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE-1556183133856.png" alt="title"></p><p>JDK1.8引入红黑树大程度优化了HashMap性能，而保证HashSet集合元素的唯一是根据对象的hashCode和equals方法决定的。如果我们往集合中存放自定义的对象，那么为了保证其唯一，就必须重写hashCode和equals方法建立当前对象的比较方式。</p><h3 id="4-3-HashSet存储自定义类型元素"><a href="#4-3-HashSet存储自定义类型元素" class="headerlink" title="4.3 HashSet存储自定义类型元素"></a>4.3 HashSet存储自定义类型元素</h3><p>给HashSet存放自定义类型的元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashCode集合中对象的唯一性。以下代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.HashSet;&#x2F;*    HashSet存储自定义类型元素    set集合保存元素唯一：        存储的元素(String,Integer,....student,Person),必须重写hashCode方法和equals方法    要求：        同名同年龄的人，视为同一人，只能存储一次 *&#x2F;public class Demo04MyHashSet {    public static void main(String[] args) {        &#x2F;&#x2F; 创建hashSet集合，存储Person        HashSet&lt;Person&gt; set = new HashSet&lt;&gt;();        Person p1 = new Person(&quot;小米&quot;,11);        Person p2 = new Person(&quot;小米&quot;,11);        Person p3 = new Person(&quot;小米&quot;,12);        System.out.println(p1.hashCode()); &#x2F;&#x2F; 1072408673        System.out.println(p2.hashCode()); &#x2F;&#x2F; 1531448569        &#x2F;&#x2F; 因为hashcode值不一样，所以认为是不同元素，没有起到去重效果。        System.out.println(p1==p2); &#x2F;&#x2F; false 比较对象地址值不同，也认定是两个不同元素        System.out.println(p1.equals(p2));        set.add(p1);        set.add(p2);        set.add(p3);        System.out.println(set);    }}</code></pre></p><h3 id="4-4-LinkedHashSet"><a href="#4-4-LinkedHashSet" class="headerlink" title="4.4 LinkedHashSet"></a>4.4 LinkedHashSet</h3><p>HashSet可以保证元素唯一，可是元素存放进去是没有顺序的，如果要保证允许，可以使用HashSet的一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。<br>示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Iterator;import java.util.LinkedHashSet;import java.util.Set;public class DemoLinkedHashSet {    public static void main(String[] args) {        Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;();        set.add(&quot;aaa&quot;);        set.add(&quot;ccc&quot;);        set.add(&quot;bbb&quot;);        set.add(&quot;ddd&quot;);        for(String s:set){            System.out.println(s);        }    }}</code></pre></p><h3 id="4-5-可变参数"><a href="#4-5-可变参数" class="headerlink" title="4.5 可变参数"></a>4.5 可变参数</h3><p>如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">修饰符 返回值类型 方法名(参数类型... 形参名){ }</code></pre><p><strong>…</strong>用在参数上，我们称之为可变参数，这个写法完全等价与</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">修饰符 返回值类型 方法名(参数类型[] 形参名){ }</code></pre><p>后面的这种定义，在调用时必须传递数组，而前者可以直接传递数据。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单方便之处),直接将数组中的元素作为实际参数进行传递。其实是编译成的class文件，先将这些元素封装到一个数组中，再进行传递。这些动作在编译.class文件时，就自动完成了。<br>代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ChangeArgs {    public static void main(String[] args) {        int[] arr = {1,3,65,491,5};        int sum = getSum(arr);        System.out.println(sum);        int sum2 = getSum(6,7,2,63,737); &#x2F;&#x2F; 使用了可变参数写法，可以传递多个数据        System.out.println(sum2);    }    &#x2F;&#x2F; 原始写法&#x2F;&#x2F;    public static int getSum(int[] arr){&#x2F;&#x2F;        int sum = 0;&#x2F;&#x2F;        for(int a : arr){&#x2F;&#x2F;            sum += a;&#x2F;&#x2F;        }&#x2F;&#x2F;&#x2F;&#x2F;        return sum;&#x2F;&#x2F;    }    &#x2F;&#x2F; 使用可变参数写法    public static int getSum(int... arr){        int sum = 0;        for (int a:arr){            sum += a;        }        return sum;    }}</code></pre></p><h2 id="5-Collections"><a href="#5-Collections" class="headerlink" title="5. Collections"></a>5. Collections</h2><h3 id="5-1-常用功能"><a href="#5-1-常用功能" class="headerlink" title="5.1 常用功能"></a>5.1 常用功能</h3><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoCollections {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        &#x2F;&#x2F; 原写法&#x2F;&#x2F;        list.add(1);&#x2F;&#x2F;        list.add(2);&#x2F;&#x2F;        list.add(43);&#x2F;&#x2F;        list.add(675);        &#x2F;&#x2F; 使用工具类添加元素        Collections.addAll(list,64,267,1242,5);        System.out.println(list); &#x2F;&#x2F; [64, 267, 1242, 5]        &#x2F;&#x2F; 排序        Collections.sort(list);        System.out.println(list); &#x2F;&#x2F; [5, 64, 267, 1242]    }}</code></pre></p><h3 id="5-2-Comparator比较器"><a href="#5-2-Comparator比较器" class="headerlink" title="5.2 Comparator比较器"></a>5.2 Comparator比较器</h3><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p><p>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02 {    public static void main(String[] args) {        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;cba&quot;);        list.add(&quot;aba&quot;);        list.add(&quot;sba&quot;);        list.add(&quot;nba&quot;);        &#x2F;&#x2F;排序方法        Collections.sort(list);        System.out.println(list); &#x2F;&#x2F; [aba, cba, nba, sba]    }}</code></pre></p><p>排序方式，简单的就是比较两个对象之间的大小，在Java中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><p>我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { }</code></pre><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，如果要实现一些别的操作，可以使用<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成。这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p><ul><li><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</li></ul><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p></blockquote><blockquote><p>如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）</p></blockquote><blockquote><p>如果要按照降序排序，则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo03 {    public static void main(String[] args) {        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;cba&quot;);        list.add(&quot;aba&quot;);        list.add(&quot;sba&quot;);        list.add(&quot;nba&quot;);        &#x2F;&#x2F;排序方法  按照第一个单词的降序        Collections.sort(list, new Comparator&lt;String&gt;() {            @Override            public int compare(String o1, String o2) {                return o2.charAt(0) - o1.charAt(0);            }        });        System.out.println(list); &#x2F;&#x2F; [sba, nba, cba, aba]    }}</code></pre><h3 id="5-3-简述Comparable和Comparator两个接口的区别。"><a href="#5-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="5.3 简述Comparable和Comparator两个接口的区别。"></a>5.3 简述Comparable和Comparator两个接口的区别。</h3><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><h3 id="5-4-Exercise"><a href="#5-4-Exercise" class="headerlink" title="5.4 Exercise"></a>5.4 Exercise</h3><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; Student类public class Student implements Comparable&lt;Student&gt;{    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    @Override    public String toString() {        return &quot;Student{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }    public void setName(String name) {        this.name = name;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int compareTo(Student o) {        return this.age-o.age; &#x2F;&#x2F; 升序    }}&#x2F;&#x2F; 测试类public class Demo04 {    public static void main(String[] args) {        ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();        list.add(new Student(&quot;小明&quot;,11));        list.add(new Student(&quot;小李&quot;,14));        list.add(new Student(&quot;小张&quot;,17));        list.add(new Student(&quot;小化&quot;,16));        &#x2F;&#x2F; 升序操作        Collections.sort(list);&#x2F;&#x2F; 报错，要求 该list中元素类型  必须实现比较器Comparable接口        for (Student sd:list){            System.out.println(sd);        }    }}</code></pre></p><p>必须实现Comparable接口，重写compareTo方法，才能进行升序操作。</p><h3 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h3><ol><li>基本数据结构简述</li><li>List集合的相关操作方法</li><li>LinkedList集合的方法</li><li>Set，HashSet，LinkedHashSet等集合的使用方法，自定义元素等</li><li>哈希表定义</li><li>可变参数的使用</li><li>Collections工具类的使用方法</li><li>Comparator比较器</li><li>Comparable和Comparator两个接口的区别</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collection集合和泛型</title>
      <link href="/JavaBasics/collection.html"/>
      <url>/JavaBasics/collection.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Collection集合"><a href="#1-Collection集合" class="headerlink" title="1. Collection集合"></a>1. Collection集合</h2><ul><li><strong>集合</strong>:集合是java中提供的一种容器，可以用来存储多个数据。<br>集合和数组的区别</li><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致。当对象多的时候，使用集合进行存储。</li></ul><a id="more"></a><h2 id="1-1-集合框架"><a href="#1-1-集合框架" class="headerlink" title="1.1 集合框架"></a>1.1 集合框架</h2><p>JavaSE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分成两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collction</code>集合，后续学习<code>Map</code>集合。</p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。<br>如图描述集合类的继承体系：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/24/01_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D-1556083479913.bmp" alt="title"></li></ul><h2 id="1-2-Collection常用功能"><a href="#1-2-Collection常用功能" class="headerlink" title="1.2 Collection常用功能"></a>1.2 Collection常用功能</h2><p>Coollection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。<br>代码示例：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.ArrayList;import java.util.Collection;public class DemoCollection {    public static void main(String[] args) {        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); &#x2F;&#x2F; 创建集合对象，多态写法        &#x2F;&#x2F; 使用添加功能，add(String s)；        coll.add(&quot;小米&quot;);        coll.add(&quot;小洪&quot;);        coll.add(&quot;小丽&quot;);        System.out.println(coll); &#x2F;&#x2F; [小米, 小洪, 小丽]        &#x2F;&#x2F; 使用判断功能 contains(String s);        System.out.println(coll.contains(&quot;小张&quot;)); &#x2F;&#x2F; false        System.out.println(coll.contains(&quot;小米&quot;)); &#x2F;&#x2F; true        System.out.println(coll.size()); &#x2F;&#x2F; 返回集合中元素个数        System.out.println(coll.remove(&quot;小洪&quot;));        System.out.println(coll);        Object[] obj = coll.toArray(); &#x2F;&#x2F; 转换成一个Object数组        for (int i = 0; i &lt; obj.length; i++) {            System.out.println(obj[i]);        }        coll.clear(); &#x2F;&#x2F; 清空集合        System.out.println(coll.isEmpty()); &#x2F;&#x2F; 判断集合是否为空    }}</code></pre></li></ul><h2 id="2-Iterator迭代器"><a href="#2-Iterator迭代器" class="headerlink" title="2. Iterator迭代器"></a>2. Iterator迭代器</h2><h3 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h3><p><code>java.util.Iterator</code>接口主要用于迭代访问<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><ul><li><code>public Iterator iterator()</code>:获取集合对应的迭代器，用来遍历集合中的元素。</li><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有就把这个元素取出来，然后继续判断。直到把集合中所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口常用的方法如下：</p><ul><li><code>public E next()</code>: 返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>: 如果仍有元素可以迭代，则返回true。<blockquote><p>E ：代表泛型的意思，指的是迭代出元素的数据类型</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoIterator {    public static void main(String[] args) {        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();        &#x2F;&#x2F; 添加元素        coll.add(&quot;盖伦&quot;);        coll.add(&quot;艾希&quot;);        coll.add(&quot;剑圣&quot;);        Iterator&lt;String&gt; it = coll.iterator(); &#x2F;&#x2F; 每个集合对象都有自己的迭代器。        while (it.hasNext()){&#x2F;&#x2F;判断是否仍然有迭代元素            System.out.println(it.next()); &#x2F;&#x2F; 获取迭代出的元素        }    }}</code></pre></blockquote></li></ul><h3 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h3><p>上面的案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用it集合的iterator()方法获取迭代器对象，然后使用hasNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出来，反之则说明达到了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。如下图例演示Iterator对象迭代元素的过程：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/24/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3-1556091723158.png" alt="title"></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h3 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h3><p>增强for循环(也称for each循环)是JDK 1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。内部原理是一个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。格式如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">for(元素数据类型 变量：Collection集合or数组){    &#x2F;&#x2F; 操作代码}</code></pre></p><p>它能用于遍历Collection和数组。通常只进行遍历元素，不能在遍历过程中对集合进行增删操作。</p><h4 id="遍历示例"><a href="#遍历示例" class="headerlink" title="遍历示例"></a>遍历示例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.ArrayList;import java.util.Collection;public class DemoSuperFor {    public static void main(String[] args) {        int[] arr = {3,4,5,6,7};        for(int a:arr){&#x2F;&#x2F; a代表数组中的每个元素            System.out.println(a);        }&#x2F;&#x2F; 进行元素遍历        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();        coll.add(&quot;蛮王&quot;);        coll.add(&quot;剑圣&quot;);        coll.add(&quot;赵信&quot;);        &#x2F;&#x2F; 使用增强for遍历        for(String s:coll){ &#x2F;&#x2F; 变量s代表被遍历到的集合园            System.out.println(s);        }    }}</code></pre><blockquote><p>Tips:增强for循环必须有被遍历的目标。且目标只能是Collection或是数组。新式for仅仅用作遍历操作出现。</p></blockquote><h2 id="3-泛型"><a href="#3-泛型" class="headerlink" title="3. 泛型"></a>3. 泛型</h2><p>集合中是可以存放任意对象的，只要把对象存储集合后，那么这时它们都会被提升成Object类型。当我们在取出每一个对象并进行相应操作时，必须采用类型转换。</p><p>观察一下代码：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoGeneric {    public static void main(String[] args) {        Collection coll = new ArrayList();        coll.add(&quot;abc&quot;);        coll.add(&quot;itcast&quot;);        coll.add(5); &#x2F;&#x2F; 由于集合没有做泛型限定，任何类型都可以存放        Iterator it = coll.iterator();        while (it.hasNext()){            System.out.println(((String)it.next()).length());        }    }}</code></pre></p><p>当程序运行到最后时会抛出<strong>java.lang.ClassCastException</strong>错误。因为集合中有一个int类型存在，所以发生了类型转换异常。Collection虽然可以存储各种对象，但实际上通常只存储同一类型对象。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>Tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Objec类型。</p></blockquote><h3 id="3-1-使用泛型的好处"><a href="#3-1-使用泛型的好处" class="headerlink" title="3.1 使用泛型的好处"></a>3.1 使用泛型的好处</h3><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class DemoGeneric02 {    public static void main(String[] args) {        Collection&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;abc&quot;);        list.add(&quot;itcast&quot;);        &#x2F;&#x2F;list.add(5); &#x2F;&#x2F; 编译不通过，类型不同        Iterator&lt;String&gt; it = list.iterator();        while(it.hasNext()){            String str = it.next(); &#x2F;&#x2F; 当使用了Iterator&lt;String&gt;控制元素类型后，就不用强转了。            System.out.println(str.length());        }    }}</code></pre></p><blockquote><p>Tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看作数据类型。</p></blockquote><h3 id="3-2-泛型的定义与使用"><a href="#3-2-泛型的定义与使用" class="headerlink" title="3.2 泛型的定义与使用"></a>3.2 泛型的定义与使用</h3><p>在集合中会大量使用到泛型，这里来完整地学习泛型知识。<br><br>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h4 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h4><p>定义格式：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">修饰符 class 类名&lt;代表泛型的变量&gt;{ }</code></pre></p><p>例如，API中的ArrayList集合：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">class ArrayList&lt;E&gt;{    public boolean add(E e){ }    public E get(int index){ }}</code></pre></p><p><strong>在创建对象的时候确定泛型</strong><br>例如：<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>以下举例自定义泛型类<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoTestE {    public static void main(String[] args) {        &#x2F;&#x2F; 创建一个泛型为String的类        DemoE&lt;String&gt; mye = new DemoE&lt;String&gt;();        &#x2F;&#x2F; 调用set方法        mye.setMvp(&quot;我是一个字符串&quot;);        &#x2F;&#x2F; 调用get方法        String str = mye.getMvp();        System.out.println(str);        &#x2F;&#x2F; 创建一个泛型为Integer的类        DemoE&lt;Integer&gt; my2 = new DemoE&lt;&gt;();        my2.setMvp(123);        System.out.println(my2.getMvp());    }}</code></pre></p><h4 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h4><p>格式： <code>修饰符&lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ }</code><br>代码举例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 自定义一个含有泛型的方法public class MyGenericMethod {    public &lt;MVP&gt; void show(MVP mvp){        System.out.println(mvp.getClass()); &#x2F;&#x2F; 获取当前类对象    }    public &lt;MVP&gt; MVP show2(MVP mvp){        return mvp;    }}&#x2F;&#x2F; 使用该类方法，任意输入数据类型public class GenericMethodDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 创建对象        MyGenericMethod mgm = new MyGenericMethod();        &#x2F;&#x2F; 调用方法        mgm.show(&quot;aaa&quot;);        mgm.show(123);        mgm.show(&#39;A&#39;);        mgm.show(1.30);    }}</code></pre></p><h4 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h4><p>格式：<code>修饰符 interface名称&lt;代表泛型的变量&gt;{ }</code><br>使用方法基本和类的一致，代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 含有泛型的接口类public interface MyGenericInterface&lt;E&gt; {    public abstract void add(E e);    public abstract E getE();}&#x2F;&#x2F; 使用格式1： 定义类时确定泛型的类型public class MyGenericInterfaceImpl implements MyGenericInterface&lt;String&gt; {    @Override    public void add(String e){        System.out.println(&quot;接口使用泛型&quot;);    }    @Override    public String getE(){        return null;    }}&#x2F;&#x2F; 此时，泛型E的是就是String类型&#x2F;&#x2F; 使用格式2：始终不确定泛型的类型，直到创建对象时，确定泛型的类型public class MyImpl2&lt;E&gt; implements MyGenericInterface&lt;E&gt;{    @Override    public void add(E e) {        System.out.println(&quot;在创建对象时会确认泛型的类型&quot;);    }    @Override    public E getE() {        return null;    }}&#x2F;&#x2F; 测试public class GenericTest {    public static void main(String[] args) {        MyImpl2&lt;String&gt; my = new MyImpl2&lt;String&gt;(); &#x2F;&#x2F; 在创建对象时指定泛型类型        my.add(&quot;aa&quot;);        MyImpl2&lt;Integer&gt; my2 = new MyImpl2&lt;Integer&gt;();         my2.add(1);    }}</code></pre></p><h3 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4 泛型通配符"></a>3.4 泛型通配符</h3><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符的基本使用"><a href="#通配符的基本使用" class="headerlink" title="通配符的基本使用"></a>通配符的基本使用</h4><p>泛型的通配符：不知道使用什么类型来接收时，可以使用？(？表示未知通配符)。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.ArrayList;import java.util.Collection;public class TestWildCard {    public static void main(String[] args) {        Collection&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();        list.add(123);        getElement(list); &#x2F;&#x2F; 可以接受任意类型数据        Collection&lt;String&gt; str = new ArrayList&lt;String&gt;();        str.add(&quot;str&quot;);        getElement(str);    }    public static void getElement(Collection&lt;?&gt; coll){ &#x2F;&#x2F; 不知道会传入什么类型数据，可以用？        System.out.println(coll);    }}</code></pre><blockquote><p>Tips:泛型不存在继承关系，例如Collection<object> list = new ArrayList<string>();这种是错误的。</string></object></p></blockquote><h4 id="通配符高级使用–受限泛型"><a href="#通配符高级使用–受限泛型" class="headerlink" title="通配符高级使用–受限泛型"></a>通配符高级使用–受限泛型</h4><p>前面设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在Java的泛型中可以指定一个泛型<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>：<code>类型名称&lt;？extends类&gt;对象名称</code></li><li><strong>意义</strong>：<code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>:<code>类型名称&lt;?super类&gt;对象名称</code></li><li><strong>意义</strong>：<code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object，String类，Number类，Integer类，其中Number是Integer的父类。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;*泛型的上限限定：? extends E 代表使用的泛型只能是E类型的子类&#x2F;本身泛型的下线限定：? super E   代表使用的泛型只能是E类型的父类&#x2F;本身 *&#x2F;import java.util.ArrayList;import java.util.Collection;public class Demo01 {    public static void main(String[] args) {        Collection&lt;Integer&gt; ints = new ArrayList&lt;&gt;();        Collection&lt;String&gt; str = new ArrayList&lt;&gt;();        Collection&lt;Number&gt; num = new ArrayList&lt;&gt;();        Collection&lt;Object&gt; obj = new ArrayList&lt;&gt;();        getElement1(ints);        getElement1(str); &#x2F;&#x2F; 报错 不是Number子类或本身        getElement1(num);        getElement1(obj); &#x2F;&#x2F; 报错 是Number父类，不符合        getElement2(ints); &#x2F;&#x2F; 报错        getElement2(str); &#x2F;&#x2F; 报错        getElement2(num);        getElement2(obj);        &#x2F;*            类与类之间的继承关系            Integer extends Number extends Object            String extends Object         *&#x2F;    }    &#x2F;&#x2F; 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类    public static void getElement1(Collection&lt;? extends Number&gt; coll){}    &#x2F;&#x2F; 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类    public static void getElement2(Collection&lt;? super Number&gt; coll){}}</code></pre><h2 id="4-综合案例"><a href="#4-综合案例" class="headerlink" title="4 综合案例"></a>4 综合案例</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：使用54张牌打乱顺序，三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留底牌。</p><h3 id="4-1-案例分析"><a href="#4-1-案例分析" class="headerlink" title="4.1 案例分析"></a>4.1 案例分析</h3><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<string>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collection类的shuffle方法进行随机排序。</string></p></li><li><p>发牌</p><p>将每个人以底牌设计为ArrayList<string>，将最后3张牌直接存于底牌，剩余牌通过对3取模依次发牌。</string></p></li><li><p>看牌</p><p>直接打印每个集合。</p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.ArrayList;        import java.util.Collections;&#x2F;*1. 准备牌：54张牌，存到一个集合中   特殊牌：大小王   其余52张牌：     定义一个数组&#x2F;集合，存储4种花色     定义一个数组&#x2F;集合，存储13个序号:2AKQJ....3   循环嵌套遍历两个数组&#x2F;集合，组装52张牌2. 洗牌    使用集合工具类Collection的方法    static void shuffle(List&lt;?&gt; list) 使用指定的随机源对指定列表进行置换    会随机打乱集合中的元素顺序。3. 发牌    要求：1人17张牌，剩余3张作为底牌，1人以张轮流发牌，集合索引(0-53)%3    定义4个集合，存储3位玩家的牌和底牌    索引%2，有两值(0,1) 0%2=0,1%2=1,2%2=0,3%2=1    索引%3，有三值(0,1,2) 0%3=0,1%3=1,2%3=2,3%3=04. 看牌    直接打印集合即可。 *&#x2F;public class Poker {    public static void main(String[] args) {        ArrayList&lt;String&gt; flowerColor = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 花色        ArrayList&lt;String&gt; cardNumber = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 牌数字        ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 牌盒        &#x2F;&#x2F; 添加花色        flowerColor.add(&quot;♥&quot;);        flowerColor.add(&quot;♦&quot;);        flowerColor.add(&quot;♠&quot;);        flowerColor.add(&quot;♣&quot;);        &#x2F;&#x2F; 添加牌数字        for (int i = 2; i &lt;= 10; i++) {            cardNumber.add(i + &quot;&quot;); &#x2F;&#x2F; 将int数字字符串化        }        cardNumber.add(&quot;J&quot;);        cardNumber.add(&quot;Q&quot;);        cardNumber.add(&quot;K&quot;);        cardNumber.add(&quot;A&quot;);        &#x2F;&#x2F; 组装牌        for (String color:flowerColor){            for(String numbers:cardNumber){                pokerBox.add(color+numbers);&#x2F;&#x2F;                System.out.println(color+numbers);            }        }        &#x2F;&#x2F; 大小王        pokerBox.add(&quot;小☺&quot;);        pokerBox.add(&quot;大☠&quot;);&#x2F;&#x2F;        System.out.println(pokerBox);        &#x2F;&#x2F; Collection类的shuffle方法进行随机排序。        Collections.shuffle(pokerBox);        &#x2F;&#x2F; 创建玩家集合和底牌集合        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();        &#x2F;&#x2F; 遍历牌盒        for (int i = 0; i &lt; pokerBox.size(); i++) {            String card = pokerBox.get(i); &#x2F;&#x2F; 获取一张牌            &#x2F;&#x2F; 留三张底牌，放入底牌盒中            if(i &gt;= 51){                dipai.add(card);            }else{                if(i%3==0){                    player1.add(card);                }else if(i%3==1){                    player2.add(card);                }else {                    player3.add(card);                }            }        }        System.out.println(player1);        System.out.println(player2);        System.out.println(player3);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的Object类和常用API</title>
      <link href="/JavaBasics/Object-api.html"/>
      <url>/JavaBasics/Object-api.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1. Object类"></a>1. Object类</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找到的父类就是Object。<br>根据JDK源码及Object类的API文档，Object类中包含的方法有11个。本章主要学习其中的2个：</p><ul><li><code>public String toString()</code>; 返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>:指示其他某个对象是否与此对象”相等”。</li></ul><a id="more"></a><h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><p>toString方法返回该对象的字符串表示，其实返回的字符串内容就是对象的类型+@+内存地址值。<code>Person@3feba861</code><br>由于该方法返回的是内存地址，所以一般要重写它以获取对象属性。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Person {    private String name;    private int age;    @Override    public String toString() { &#x2F;&#x2F; 重写toString方法        return &quot;Person{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }省略get&#x2F;set}</code></pre></p><p>在IntelliJ IDEA中，可以使用快捷键<code>ALT+Insert</code>,点击<code>toString()</code>选项，自动生成该方法。</p><h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><ul><li><code>public boolean equals(Object obj)</code>:比较两个对象是否“相等”，返回布尔值。<h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3>如果没有覆盖重写equals方法，那么object类默认进行<code>==</code>运算符的对象地址比较，只要不同就返回false。</li></ul><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，可以重写equals方法。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">@Override    public boolean equals(Object o) {        if (this == o) return true;        &#x2F;&#x2F; 如果o不等于空并且o不等于Person类型，返回false。 getClass() != o.getClass()  使用反射技术，判断o是否是Person类型， 等效于 obj instanceof Person        if (o == null || getClass() != o.getClass()) return false;        &#x2F;&#x2F; 向下转型        Person person = (Person) o;        &#x2F;* Object.equals(Object a, Object b); equals方法重载解析：        Objects.equals(name, person.name); &#x2F;&#x2F; 传入两个对象参数        public static boolean equals(Object a, Object b) {               &#x2F;&#x2F; 判断a==b 或者 a不等于空，并且a与b的内存地址相同才返回true，反之false            return (a == b) || (a != null &amp;&amp; a.equals(b));        }         *&#x2F;        return age == person.age &amp;&amp; Objects.equals(name, person.name);    }</code></pre></p><p>使用快捷键<code>ALT+Insert</code>可以自动生成该代码。</p><h2 id="1-4-Oebjects类"><a href="#1-4-Oebjects类" class="headerlink" title="1.4 Oebjects类"></a>1.4 Oebjects类</h2><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方来操作对象，它由一些静态的实用方法组成，这些方法是null-save(空指针安全的)或null-tolerant(容忍空指针的),用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象时，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Objects a,Objects b)</code>:判断两个对象是否相等。<br>源码解析：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">    Object.equals(Object a, Object b); &#x2F;&#x2F; 对传入的两个对象进行比较，可防止空指针异常。    Objects.equals(name, person.name); &#x2F;&#x2F; 传入两个对象参数    public static boolean equals(Object a, Object b) {           &#x2F;&#x2F; 判断a==b 或者 a不等于空，并且a与b的内存地址相同,才能返回true，反之false。        return (a == b) || (a != null &amp;&amp; a.equals(b)); }</code></pre></li></ul><h2 id="2-日期时间类"><a href="#2-日期时间类" class="headerlink" title="2. 日期时间类"></a>2. 日期时间类</h2><h3 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h3><p><code>java.util.Date</code>类表示特点的瞬间，精确到毫秒。<br>Date中拥有多个构造方法，部分已过时，其中有未过时的构造方法可以把毫秒值转成日期对象。</p><ul><li><code>public Date()</code>:分配Date对象并初始化此对象，以表示分配它的时间(精确到毫秒)。获取当前系统的日期和时间。</li><li><code>public Date(long date)</code>:传递毫秒值，把毫秒值转换为Date日期，以表示自从标准基准时间(称为”历元(epoch)”，即1970年1月1日00:00:00 GMT)以来的指定毫秒数。</li></ul><ul><li><code>public long getTime()</code>：把日期对象转换成对应的时间毫秒值。<blockquote><p>Tips:由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></blockquote></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Date;public class Demo01Date {    public static void main(String[] args) {        System.out.println(&quot;当前系统时间&quot;+new Date());        System.out.println(&quot;将传入的毫秒值转换为日期时间格式&quot;+new Date(0L)); &#x2F;&#x2F; Tue Apr 23 20:39:00 CST 2019        System.out.print(&quot;把日期转换为毫秒值&quot;+new Date().getTime()); &#x2F;&#x2F; 相当于System.currenTimeMillis()方法    }}</code></pre><blockquote><p>Tips:在使用println方法时，会自动调用Date类中的toString方法。Date类重写了toString方法，所以结果为指定格式的字符串。</p></blockquote><h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code>是日期/时间格式子类的抽象类，通过这个类可以帮我们完成日期和文本之间的转换，也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li>格式化：按照指定的格式，从Date对象转换为String对象。</li><li>解析：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一默认(格式)来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>:用指定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。</li></ul><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用格式规则为：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/23/pattern%E6%A0%BC%E5%BC%8F-1556026542510.png" alt="title"></p><blockquote><p>更详细的格式规则，可参考SimpleDateFormat类的API文档。<br>创建一个SimpleDateFormat对象代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo03DateFormat {    public static void main(String[] args) {        DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    }}</code></pre></p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>public String format(Date date)</code>:将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>:将字符串解析为Date对象。</li></ul><h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用DateFormat类中的方法format，将日期格式化为文本，使用步骤如下。</p><ol><li>创建SimpleDateFormat对象，构造方法中传入指定模式</li><li>调用SimpleDateFormat对象中的方法format，按照构造方法中的模式，把Date日期格式转换为符合格式的字符串<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">    &#x2F;&#x2F; 1. 创建SimpleDateFormat对象，构造方法中传入指定模式    DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    &#x2F;&#x2F; 2. 调用SimpleDateFormat对象中的方法format    String a = format.format(new Date());    System.out.println(a);  &#x2F;&#x2F; 2019-04-23 22:04:11</code></pre></li></ol><h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用DateFormat类中的方法parse，把文本解析为日期，使用步骤如下：</p><ol><li>创建SimpleDateFormat对象，构造方法中传入指定模式</li><li>调用SimpleDateFormat对象中的方法parse，把符合构造方法中模式的字符串，解析为Date日期</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">DateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);Date date = sdf.parse(&quot;1996-06-03 11:45:03&quot;);System.out.println(date);&#x2F;*注意：public Date parse(String source) throws ParseExceptionparse方法声明了一个异常叫ParseException,如果字符串和构造方法的模式不一致，那么程序就会抛出异常。调用了一个抛出异常的方法，就必须处理这个异常，要么throws继续抛出这个异常，要么try catch自己处理。*&#x2F;</code></pre><h2 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h2><p>使用日期时间相关API，计算一个人出生了多少天<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;public class Demo02Test {    public static void main(String[] args) throws ParseException {        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入你的出生日期，格式：年-月-日&quot;);        String Birthday = sc.next();        long CurrentTime = new Date().getTime(); &#x2F;&#x2F; 现在时间        DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); &#x2F;&#x2F; 设置时间格式        long liveTime = CurrentTime - format.parse(Birthday).getTime(); &#x2F;&#x2F; 使用parse把文本解析为日期格式在转换为毫秒值&#x2F;&#x2F;        System.out.println(liveTime);        System.out.println(&quot;出生了&quot;+liveTime&#x2F;1000&#x2F;60&#x2F;60&#x2F;24+&quot;天&quot;); &#x2F;&#x2F; liveTime&#x2F;1000&#x2F;60&#x2F;60&#x2F;24 把毫秒值转换为天    }}</code></pre></p><h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calenday为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：<br>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>:使用默认时区和语言环境获取一个日历。<br>示例代码：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Calendar;public class Demo04Calendar {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance(); &#x2F;&#x2F; 多态    }}</code></pre></li></ul><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>:返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>:将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field,int amount)</code>:根据日历规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>:返回一个表示此Calendar时间值的Date对象,返回从历元到现在的毫秒偏移量。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/23/Calendar%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F-1556029579519.png" alt="title"></p><h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，演示代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Calendar;public class Demo04Calendar {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance(); &#x2F;&#x2F; 多态        int year = cal.get(Calendar.YEAR); &#x2F;&#x2F; 获取当前年份        int month = cal.get(Calendar.MONTH)+1; &#x2F;&#x2F;因为国外月份是0~11，我们是1~12.        int day = cal.get(Calendar.DAY_OF_MONTH); &#x2F;&#x2F; 当前天数&#x2F;&#x2F;        System.out.println(day);&#x2F;&#x2F;        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;号&quot;);        cal.set(Calendar.YEAR,2020); &#x2F;&#x2F;自定义日期        cal.set(Calendar.MONTH,06);        cal.set(Calendar.DAY_OF_MONTH,03);        int year1 = cal.get(Calendar.YEAR);        int month1 = cal.get(Calendar.MONTH);        int day1 = cal.get(Calendar.DAY_OF_MONTH);        System.out.println(year1+&quot;年&quot;+month1+&quot;月&quot;+day1+&quot;号&quot;);    }}</code></pre></p><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为整数则加上偏移量，负数则减去偏移量，演示代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Calendar;public class Demo05CalendarAddMethod {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        int year = cal.get(Calendar.YEAR);        int month = cal.get(Calendar.MONTH)+1;        int day = cal.get(Calendar.DAY_OF_MONTH);        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;号&quot;);        &#x2F;&#x2F; 使用add方法        cal.add(Calendar.YEAR,1); &#x2F;&#x2F; 当前年份+1        cal.add(Calendar.MONTH,2);        cal.add(Calendar.DAY_OF_MONTH,-20); &#x2F;&#x2F; 天数-20天        int year1 = cal.get(Calendar.YEAR);        int month1 = cal.get(Calendar.MONTH)+1;        int day1 = cal.get(Calendar.DAY_OF_MONTH);        System.out.println(year1+&quot;年&quot;+month1+&quot;月&quot;+day1+&quot;号&quot;);    }}</code></pre></p><h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Calendar;import java.util.Date;public class Demo06CalendarGetTime {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        Date date = cal.getTime(); &#x2F;&#x2F; 获取的是Date对象        System.out.println(date); &#x2F;&#x2F; Tue Apr 23 22:52:25 CST 2019    }}</code></pre></p><h2 id="3-System类"><a href="#3-System类" class="headerlink" title="3. System类"></a>3. System类</h2><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或者系统级操作，常用方法有：</p><ul><li><code>public static long currentTimeMillis()</code>:返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src,int srcPos,Object dest, int destPos, int length)</code>:将数组中指定的数据拷贝到另一个数组中。</li></ul><h3 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h3><p>currentTimeMillis方法获取的是当前系统时间与1970年01月01日00:00(计算机元年)之间的毫秒差值。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo07CurrentTime {    public static void main(String[] args) {        System.out.println(System.currentTimeMillis());    }}</code></pre></p><h3 id="小练习1"><a href="#小练习1" class="headerlink" title="小练习1"></a>小练习1</h3><p>计算for循环打印数字1~9999所需的时间(毫秒)。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo08SystemTest {    public static void main(String[] args) {        long CurrentTime = System.currentTimeMillis();        for(int i = 1;i &lt; 10000;i++){            System.out.println(i);        }        System.out.println(&quot;打印1~9999花费&quot;+(System.currentTimeMillis() - CurrentTime)+&quot;毫秒&quot;);    }}</code></pre></p><h3 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h3><p>该方法将数组指定数据拷贝到另一个数组中，数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/23/arratcopy%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89-1556031999370.png" alt="title"></p><h3 id="小练习2"><a href="#小练习2" class="headerlink" title="小练习2"></a>小练习2</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上。<br>复制元素前：src[1,2,3,4,5]，dest[6,7,8,9,10]<br>复制元素后：src[1,2,3,4,5], dest[1,2,3,9,10]<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">arraycopy(源数组，源数组索引起始位置，目标数组，目标数组索引起始位置，复制元素个数) *&#x2F;public class Demo09SystemArrayCopy {    public static void main(String[] args) {        int[] src = {1,2,3,4,5};        int[] dest = {6,7,8,9,10};        System.arraycopy(src,0,dest,0,3);        for (int i = 0; i &lt; dest.length; i++) {            System.out.print(dest[i]+&quot;,&quot;); &#x2F;&#x2F; 123910        }    }}</code></pre></p><h2 id="4-StringBuilder类"><a href="#4-StringBuilder类" class="headerlink" title="4. StringBuilder类"></a>4. StringBuilder类</h2><h3 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h3><p>由于String类的对象内容不可变，所以每当进行字符串拼接时，都会在内存中创建一新的对象。<br>字符串是常量，它们的值在创建后不能被更改。如果字符串进行拼接操作，每次拼接时都会创建一个新的String对象，耗时又浪费空间。可以使用<code>java.lang.StringBuilder</code>类。</p><h3 id="4-2-StringBuilder类概述"><a href="#4-2-StringBuilder类概述" class="headerlink" title="4.2 StringBuilder类概述"></a>4.2 StringBuilder类概述</h3><p>StringBuilder又称为可变字符序列,它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。<br>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/23/01_StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86-1556033213070.bmp" alt="title"></p><h3 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h3><p>常用的构造方法有2个：</p><ul><li><code>public StringBuilder()</code>:构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>:构造一个容器同时将一个字符串添加进去。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo10StringBuilder {    public static void main(String[] args) {        StringBuilder strb = new StringBuilder(); &#x2F;&#x2F; 创建一个空容器对象        StringBuilder strb2 = new StringBuilder(&quot;Hello&quot;); &#x2F;&#x2F; 带参构造方法    }}</code></pre></li></ul><h3 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h3><p>StringBuilder中常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h4 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h4><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo10StringBuilder {    public static void main(String[] args) {        StringBuilder builder = new StringBuilder(); &#x2F;&#x2F; 创建一个空容器对象        StringBuilder result = builder.append(&quot;hello&quot;); &#x2F;&#x2F;向容器中添加一个字符串类型        System.out.println(builder); &#x2F;&#x2F; hello        System.out.println(result); &#x2F;&#x2F; hello        if(builder == result){            System.out.println(&quot;它们是同一个容器对象&quot;);        }        &#x2F;&#x2F; 可以添加任意类型,且可以往容器中连续放入        builder.append(100).append(true).append(10.0).append(&#39;A&#39;);        System.out.println(builder); &#x2F;&#x2F; hello100true10.0A&#x2F;*如果在开发中，遇到调用一个对象后，返回一个对象的情况，可以使用返回的对象继续调用方法。如上情况，可以把它们连在一起，这叫做链式编程。*&#x2F;    }}</code></pre></p><h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h4><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo11StringToString {    public static void main(String[] args) {        StringBuilder builder = new StringBuilder(&quot;hello&quot;).append(&quot;world&quot;);        String str = builder.toString(); &#x2F;&#x2F; 将builder容器转换为字符串类型。        System.out.println(str);            }}</code></pre></p><h2 id="5-包装类"><a href="#5-包装类" class="headerlink" title="5. 包装类"></a>5. 包装类</h2><p>Java提供了两个类型系统，基本类型与引用类型。使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/23/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E5%8C%85%E8%A3%85%E7%B1%BB-1556034717119.png" alt="title"></p><h3 id="5-1-装箱与拆箱"><a href="#5-1-装箱与拆箱" class="headerlink" title="5.1 装箱与拆箱"></a>5.1 装箱与拆箱</h3><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱” 与 “拆箱”：</p><ul><li><strong>装箱</strong>:从基本类型转换为对应的包装类对象。</li><li><strong>拆箱</strong>:从包装类对象转换为对应的基本类型。</li></ul><p>用Integer与int为例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo12PackClass {    public static void main(String[] args) {        &#x2F;&#x2F; 基本数值 --&gt; 包装对象        Integer i = new Integer(4); &#x2F;&#x2F; 使用构造方法        Integer iii = Integer.valueOf(4); &#x2F;&#x2F; &#x2F;使用包装类中的valueOf方法        &#x2F;&#x2F; 包装对象 --&gt; 基本数值        int num = i.intValue();    }}</code></pre></p><h3 id="5-2-自动装箱与自动拆箱"><a href="#5-2-自动装箱与自动拆箱" class="headerlink" title="5.2 自动装箱与自动拆箱"></a>5.2 自动装箱与自动拆箱</h3><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5开始，基本类型与包装类的装箱、拆箱动作可以自动完成。示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">Integer i = 4;&#x2F;&#x2F;自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;&#x2F;&#x2F;等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;&#x2F;&#x2F;加法运算完成后，再次装箱，把基本数值转成对象。</code></pre></p><h3 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h3><h4 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h4><p>基本类型转换String总共有三种方法，这里只讲解最简单一种方式：基本类型直接与””连接即可，如34+””。</p><h4 id="String转换成对应的基本类型"><a href="#String转换成对应的基本类型" class="headerlink" title="String转换成对应的基本类型"></a>String转换成对应的基本类型</h4><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><blockquote><p>如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的final关键字及内部类</title>
      <link href="/JavaBasics/final-innerClass.html"/>
      <url>/JavaBasics/final-innerClass.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-final关键字"><a href="#1-final关键字" class="headerlink" title="1. final关键字"></a>1. final关键字</h2><p>继承中子类可以在父类的继承上改写父类内容，比如方法重写。但如果我们随意的继承API中提供的类，改写其内容，显示不合适。为了避免这种随意改写的起来，Java提供了final关键字，用于修改不可改变内容。</p><a id="more"></a><ul><li>final：不可改变。可用于修饰类、方法和变量。<ul><li>类：被修改的类，不能被继承。</li><li>方法：被修饰的方法，不能被重写。</li><li>变量：被修饰的变量，不能被重新赋值。</li></ul></li></ul><h3 id="1-1-使用方式"><a href="#1-1-使用方式" class="headerlink" title="1.1 使用方式"></a>1.1 使用方式</h3><ul><li>修饰类：final class 类名{}</li><li>修饰方法：修饰符 final 返回值类型 方法名(参数列表){方法体}</li><li>修饰变量有以下三种情况：<ul><li>局部变量–基本类型：基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。</li><li>局部变量–引用类型：引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部成员变量值的修改。</li><li>成员变量：成员变量涉及到初始化的问题，初始化方式有两种，显式初始化和构造方法初始化。</li></ul></li></ul><p>代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class FinalDemo01 {    public static void main(String[] args) {        &#x2F;&#x2F; 1. 以下示意局部变量基本类型使用final关键字修饰。        final int a; &#x2F;&#x2F; 使用final修饰，声明变量。        a = 10; &#x2F;&#x2F; 第一次赋值，编译通过&#x2F;&#x2F;        a = 20; &#x2F;&#x2F; 第二次赋值，报错。        final int b = 10; &#x2F;&#x2F; 申明变量同时直接赋值，使用final修饰&#x2F;&#x2F;        b = 20; &#x2F;&#x2F; 报错,不可重新赋值        for(int i = 0; i &lt; 10;i++){            final int c = i;            System.out.print(c);        }        &#x2F;&#x2F; 2. 以下示例局部变量引用类型使用final关键字修饰。        final TestFinal tf = new TestFinal(&quot;张三&quot;,11); &#x2F;&#x2F; 创建一个测试对象。&#x2F;&#x2F;        tf = new TestFinal(); &#x2F;&#x2F; 新创建一个对象，把tf指向该对象。报错，使用final修饰后无法改变地址值。    }}&#x2F;&#x2F; 成员变量initializepublic class TestFinal {    &#x2F;&#x2F; 创建类时直接初始化，并用final修饰。&#x2F;*    final String USERNAME = &quot;张山&quot;;    private int age;*&#x2F;    final String USERNAME;    private int age;    &#x2F;&#x2F; 使用构造方法initialize    public TestFinal(String USERNAME, int age) {        this.USERNAME = USERNAME;        this.age = age;    }}</code></pre></p><h2 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2. 权限修饰符"></a>2. 权限修饰符</h2><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。</p><ul><li>public：公共的</li><li>protected：受保护的</li><li>default：默认的</li><li>private：私有的</li></ul><h3 id="2-1-不同权限的访问能力"><a href="#2-1-不同权限的访问能力" class="headerlink" title="2.1 不同权限的访问能力"></a>2.1 不同权限的访问能力</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/22/Java%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90-1555902457643.png" alt="title"><br><br>public具有最大权限。private则是最小权限。<br>故编写代码时，如果没有特殊的考虑，应该这样使用权限：</p><ul><li>成员变量使用private，隐藏细节。</li><li>构造方法使用public，方便创建对象。</li><li>成员方法使用public，方便调用方法。</li><li>不加权限修饰符的，其访问能力与default修饰符相同。</li></ul><h2 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3. 内部类"></a>3. 内部类</h2><p>如果一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。</p><h3 id="成员内部类：定义在类中方法外的类。"><a href="#成员内部类：定义在类中方法外的类。" class="headerlink" title="成员内部类：定义在类中方法外的类。"></a>成员内部类：定义在类中<strong>方法外</strong>的类。</h3><p>在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类Car中包含发动机类Engine，这个Engine类就可以使用内部类来描述，定义在成员位置。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">class Car{ &#x2F;&#x2F;外部类 ...    class Engine{ &#x2F;&#x2F;成员内部类...    }}</code></pre></p><ul><li>内部类可以直接访问外部类的成员，包括私有成员。</li><li>访问重名的成员变量，使用格式：外部类名称.this.外部类成员变量名<br>如何使用成员内部类？两种方式：</li></ul><ol><li>间接方式：在外部类的方法中，使用内部类；然后通过调用外部类方法来间接调用内部类。</li><li>直接方式：[外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();]</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 成员内部类示例public class Body { &#x2F;&#x2F; 内部类    public class Heart{ &#x2F;&#x2F; 成员内部类        &#x2F;&#x2F; 内部类方法        public void beat(){            System.out.println(&quot;心脏跳动：砰砰砰！&quot;);            System.out.println(&quot;我叫：&quot; + name); &#x2F;&#x2F; 内部类可以直接访问外部类成员变量        }    }    private String name; &#x2F;&#x2F; 外部类成员变量    &#x2F;&#x2F; 外部类方法    public void methodBody(){        System.out.println(&quot;外部类的方法&quot;);        new Heart().beat(); &#x2F;&#x2F; 匿名对象    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}&#x2F;&#x2F; 成员内部类示例测试类public class InnerClassDemo02 {    public static void main(String[] args) {        Body body = new Body();        body.methodBody(); &#x2F;&#x2F; 间接通过外部类方法访问内部类        System.out.println(&quot;下面使用直接访问方式访问内部类&quot;);        Body.Heart heart = new Body().new Heart();        heart.beat();    }}&#x2F;&#x2F; 访问重名的成员变量示例public class Other {    int num = 10; &#x2F;&#x2F; 外部类的成员变量    public class Inner{        int num = 20; &#x2F;&#x2F; 内部类的成员变量        public void methodInner(){            int num = 30; &#x2F;&#x2F; 内部类方法的局部变量            System.out.println(num); &#x2F;&#x2F; 局部变量，就近原则            System.out.println(this.num); &#x2F;&#x2F; 内部类成员变量            System.out.println(Other.this.num); &#x2F;&#x2F; 外部类成员变量        }    }}&#x2F;&#x2F; 访问重名的成员变量示例测试类public class InnerClassDemo03 {    public static void main(String[] args) {        Other.Inner obj = new Other().new Inner();        obj.methodInner();    }}</code></pre><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>如果一个类是定义在一个<strong>方法内部</strong>的，那么这就是一个局部内部类<br>“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 局部内部类public class Outer {    public void methodOuter(){        class Inner{ &#x2F;&#x2F; 局部内部类            int num = 10;            public void methodInner(){                System.out.println(num);            }        }        Inner inner = new Inner(); &#x2F;&#x2F; 创建局部内部类对象        inner.methodInner(); &#x2F;&#x2F; 调用内部类方法,将打印10    }}&#x2F;&#x2F; 测试类public class DemoMain {    public static void main(String[] args) {        Outer outer = new Outer();        outer.methodOuter();    }}</code></pre></p><p>小结类的权限修饰符：<br>public &gt; protected &gt; (default) &gt; private<br>定义一个类时，权限修饰符规则：</p><ol><li>外部类：public / (default)</li><li>成员内部类：public / protected / (default) / private</li><li>局部内部类：什么都不能写</li></ol><p>注意事项：<br>局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是[有效的final的]<br>备注：从Java 8+开始，只要局部变量属实不变，那么final关键字可省略<br>原因：</p><ol><li>new出来的对象在堆内存中。</li><li>局部变量是跟着方法走的，在栈内存当中。</li><li>方法运行结束之后，立即出栈，局部变量就会立即消失。</li><li>但new出来的对象会在堆中持续存在，直到垃圾回收消失。</li></ol><h3 id="匿名内部类-重点"><a href="#匿名内部类-重点" class="headerlink" title="匿名内部类(重点)"></a>匿名内部类(重点)</h3><ul><li>匿名内部类：是内部类的简化写法。它本质是一个<strong>带具体实现的父类或者父接口的匿名</strong>的子类对象。<br>开发中，最常用的内部类就是匿名内部类。以接口为例，当使用一个接口时，得做如下几步操作：</li></ul><ol><li>定义子类</li><li>重写接口中的方法</li><li>创建子类对象</li><li>调用重写后的方法<br>我们最终的目的只是为了调用方法，那么该如何简化。匿名内部类就可以处理这种情况。</li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 接口类public interface MyInterface {    void method();    void method2();}&#x2F;*匿名内部类的定义格式：接口名称 对象名 = new 接口名称(){    &#x2F;&#x2F; 覆盖重写所有抽象方法}对格式 “new 接口名称() {...}” 进行解析：1. new代表创建对象的动作2. 接口名称就是匿名内部类需要实现哪个接口3. {...} 这是匿名内部类的内容另外还有注意几点问题：1. 匿名内部类，在创建对象时，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。2. 匿名对象，在[调用方法]时，只能调用唯一一次，如果希望同一对象调用多次方法，那么必须给对象起名。3. 匿名内部类是省略了[实现类&#x2F;子类名称]，但匿名对象是省略了[对象名称]。匿名内部类和匿名对象不是一回事！ *&#x2F;&#x2F;&#x2F; 主方法测试类public class DemoMain {    public static void main(String[] args) {        &#x2F;&#x2F; 使用匿名内部类        MyInterface obj = new MyInterface() {            @Override            public void method() {                System.out.println(&quot;使用匿名内部类实现了方法1！&quot;);            }            @Override            public void method2() {                System.out.println(&quot;匿名内部类实现方法2&quot;);            }        };        obj.method();        obj.method2();        &#x2F;&#x2F; 使用了匿名内部类，而且省略了对象名称，也是匿名对象        new MyInterface(){            @Override            public void method() {                System.out.println(&quot;使用匿名对象方式，该内部类方法只能调用一次&quot;);            }            @Override            public void method2() {            }        }.method(); &#x2F;&#x2F; 因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象才能二次调用。    }}</code></pre><h2 id="4-引用类型用法总结"><a href="#4-引用类型用法总结" class="headerlink" title="4. 引用类型用法总结"></a>4. 引用类型用法总结</h2><p>实际开发中，引用类型的使用非常重要且普遍。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么引用类型也是可以的。</p><h3 id="4-1-class作为成员变量"><a href="#4-1-class作为成员变量" class="headerlink" title="4.1 class作为成员变量"></a>4.1 class作为成员变量</h3><p>具体代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义一个英雄类public class Hero {    private String name; &#x2F;&#x2F; 名称    private int blood;  &#x2F;&#x2F; 生命值    private Weapon weapon; &#x2F;&#x2F; 添加武器属性    public Hero() {    }    public Hero(String name, int blood, Weapon weapon) {        this.name = name;        this.blood = blood;        this.weapon = weapon;    }    public void attack(){        System.out.println(name+&quot;使用了&quot;+weapon.getName()+&quot;攻击敌方&quot;);    }... 省略get&#x2F;set方法}&#x2F;&#x2F; 定义一个武器类public class Weapon {    private String name; &#x2F;&#x2F; 武器名称    public Weapon(String name) {        this.name = name;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}&#x2F;&#x2F; 测试类public class DemoMain {    public static void main(String[] args) {        &#x2F;&#x2F; 创建英雄对象        Hero hero = new Hero();        &#x2F;&#x2F; 创建武器对象        Weapon wp = new Weapon(&quot;霜之哀伤&quot;);        hero.setName(&quot;伊利丹&quot;); &#x2F;&#x2F; 设置英雄名字        hero.setWeapon(wp); &#x2F;&#x2F; 将武器交给英雄        hero.attack(); &#x2F;&#x2F; 攻击    }}</code></pre></p><h3 id="4-2-interface作为方法参数和返回值类型"><a href="#4-2-interface作为方法参数和返回值类型" class="headerlink" title="4.2 interface作为方法参数和返回值类型"></a>4.2 interface作为方法参数和返回值类型</h3><p>以下示意接口作为方法参数：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 接口类public interface Skill {    void use(); &#x2F;&#x2F; 释放技能}&#x2F;&#x2F; 实现类 public class SkillImpl implements Skill {    @Override    public void use() {        System.out.println(&quot;biubiubiu&quot;);    }}&#x2F;&#x2F; 英雄类public class Hero {    private String name; &#x2F;&#x2F; 英雄名称    private Skill skill; &#x2F;&#x2F; 英雄技能    public Hero() {    }    public Hero(String name, Skill skill) {        this.name = name;        this.skill = skill;    }    public void attack(){        System.out.println(&quot;我叫&quot;+name+&quot;，开始释放技能：&quot;);        skill.use(); &#x2F;&#x2F;调用接口中的抽象方法        System.out.println(&quot;释放技能完成。&quot;);    }....省略get&#x2F;set方法}&#x2F;&#x2F; 测试类public class DemoGame {    public static void main(String[] args) {        Hero hero = new Hero();        hero.setName(&quot;艾希&quot;); &#x2F;&#x2F; 设置英雄名称        &#x2F;&#x2F; 设置英雄技能        &#x2F;&#x2F; 使用实现类作为参数传递&#x2F;&#x2F;        hero.setSkill(new SkillImpl());&#x2F;&#x2F;        hero.attack();        &#x2F;&#x2F; 使用匿名内部类作为参数&#x2F;&#x2F;        Skill skill = new Skill() {&#x2F;&#x2F;            @Override&#x2F;&#x2F;            public void use() {&#x2F;&#x2F;                System.out.println(&quot;pia~~pia~~pia~~&quot;);&#x2F;&#x2F;            }&#x2F;&#x2F;        };        &#x2F;&#x2F; 使用匿名内部类和匿名对象        hero.setSkill(new Skill() {            @Override            public void use() {                System.out.println(&quot;da~da~da~&quot;);            }        });        hero.attack();    }}</code></pre></p><p>以下示例接口作为方法的返回值类型<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class DemoInterface {    public static void main(String[] args) {        &#x2F;&#x2F; 左边是接口名称，右边是实现类名称，这就是多态写法        List&lt;String&gt; list = new ArrayList&lt;&gt;(); &#x2F;&#x2F;         List&lt;String&gt; result = addNames(list);        for (int i = 0; i &lt; result.size(); i++) {            System.out.println(result.get(i));        }    }    public static List&lt;String&gt; addNumbers(List&lt;String&gt; list){        list.add(&quot;1&quot;);        list.add(&quot;2&quot;);        list.add(&quot;3&quot;);        return list;    }}&#x2F;&#x2F; 用一个接口或是自定义类作为方法的参数或者返回值都是可以的</code></pre></p><h3 id="5-综合案例–发红包-界面版"><a href="#5-综合案例–发红包-界面版" class="headerlink" title="5. 综合案例–发红包[界面版]"></a>5. 综合案例–发红包[界面版]</h3><p>完整代码见：<a href="https://github.com/zero6996/JavaDemo/tree/master/Demo4_22/DemoRedPacket" target="_blank" rel="noopener">SendRedPacket</a></p><p>手气红包算法思路解析：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/22/%E6%89%8B%E6%B0%94%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E8%A7%A3%E6%9E%90-1555941568465.png" alt="title"></p><h3 id="案例总结"><a href="#案例总结" class="headerlink" title="案例总结"></a>案例总结</h3><p>通过发红包案例，你都学到了什么？请思考如下问题：</p><ol><li>基础语法，你是否清晰？</li><li>一些基本的类的方法，你是否能够调用</li><li>案例中哪里体现了继承，继承的作用是什么？</li><li>接口作为参数，如何使用？</li><li>接口作为成员变量，如何使用?</li><li>如何简化接口的使用方式？</li></ol><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><ol><li>使用final关键字修饰类、方法和变量。</li><li>Java中的权限修饰符。</li><li>成员内部类、局部内部类、匿名内部类、匿名对象的基本使用格式。</li><li>引用类型作为参数，返回值类型的使用方式。</li><li>综合案例发红包代码理解。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java三大特性之多态</title>
      <link href="/JavaBasics/polymorphic.html"/>
      <url>/JavaBasics/polymorphic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-接口"><a href="#1-接口" class="headerlink" title="1. 接口"></a>1. 接口</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是<strong>封装了方法</strong>，包含抽象方法，默认方法和静态方法，私有方法。</p><a id="more"></a><p>接口的定义，它与定义类方式相似，但是使用interface关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。<br>接口的使用，它不能创建对象，但是可以被实现(implements，类似于被继承)。一个实现接口的类(可以看做是接口的子类),需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p><h3 id="1-2-定义格式"><a href="#1-2-定义格式" class="headerlink" title="1.2 定义格式"></a>1.2 定义格式</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/21/%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F-1555818337838.png" alt="title"></p><h4 id="含有抽象方法"><a href="#含有抽象方法" class="headerlink" title="含有抽象方法"></a>含有抽象方法</h4><ul><li>抽象方法：使用abstract关键字修饰，可以省略，没有方法体。该方法供子类实现使用。<br>代码如下：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface InterFaceName{    public abstract void method();}</code></pre></li></ul><h4 id="含有默认方法和静态方法"><a href="#含有默认方法和静态方法" class="headerlink" title="含有默认方法和静态方法"></a>含有默认方法和静态方法</h4><ul><li>默认方法：使用default修饰，不可省略，供子类调用或者子类重写。</li><li>静态方法：使用static修饰，供接口直接调用。</li></ul><p>代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface InterFaceName{    public default void method(){&#x2F;&#x2F; 执行语句    }    public static void method2(){&#x2F;&#x2F; 执行语句    }}</code></pre></p><h4 id="含有私有方法和私有静态方法"><a href="#含有私有方法和私有静态方法" class="headerlink" title="含有私有方法和私有静态方法"></a>含有私有方法和私有静态方法</h4><ul><li>私有方法：使用private修饰，供接口中的默认方法或者静态方法调用。</li></ul><p>代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface InterFaceName{    private void method(){    &#x2F;&#x2F; 执行语句    }}</code></pre></p><h3 id="1-3-基本的实现"><a href="#1-3-基本的实现" class="headerlink" title="1.3 基本的实现"></a>1.3 基本的实现</h3><p>类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相似，只是关键字不同，实现使用implements关键字。</p><p>非抽象子类实现接口：</p><ol><li>必须重写接口中所有抽象方法。</li><li>继承了接口的默认方法，即可以直接调用，也可以重写。<br>格式如下：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/21/%E6%8E%A5%E5%8F%A3%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F-1555826716777.png" alt="title"></li></ol><p>代码示例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义接口类public interface LiveAble {    &#x2F;&#x2F; 定义抽象方法    public abstract void eat();    public abstract void sleep();}&#x2F;&#x2F; 定义实现类public class Animal implements LiveAble{    @Override    public void eat(){        System.out.println(&quot;吃东西&quot;);    }    @Override    public void sleep(){        System.out.println(&quot;睡觉&quot;);    }}&#x2F;&#x2F; 定义测试类public class InterfaceDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 创建子类对象        Animal a = new Animal();        a.eat();        a.sleep();    }}</code></pre></p><h4 id="默认方法的使用"><a href="#默认方法的使用" class="headerlink" title="默认方法的使用"></a>默认方法的使用</h4><p>可以继承，可以重写，但只能通过实现类的对象来调用。接口当中的默认方法，可以解决接口升级的问题。</p><ol><li>实现类可以继承接口类的默认方法，也可以自己重写默认方法。</li></ol><p>代码示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义接口类public interface LiveAble {    &#x2F;&#x2F; 定义抽象方法    public abstract void eat();    public abstract void sleep();    public default void fly(){ &#x2F;&#x2F; 定义默认方法        System.out.println(&quot;飞行&quot;);    }}&#x2F;&#x2F; 定义实现类public class Animal implements LiveAble{    @Override    public void fly(){ &#x2F;&#x2F; 重写接口中的默认方法，也可以不重写，继承接口类中的默认方法        System.out.println(&quot;自由自在的飞！&quot;);    }}&#x2F;&#x2F; 定义测试类public class InterfaceDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 创建子类对象        Animal a = new Animal();        a.eat();        a.sleep();        a.fly(); &#x2F;&#x2F; 如果实现类没有重写默认方法，则执行的是继承自接口类的默认方法，重写则执行实现类重写后的方法    }}</code></pre></p><h4 id="静态方法的使用"><a href="#静态方法的使用" class="headerlink" title="静态方法的使用"></a>静态方法的使用</h4><p>静态与.class文件相关，只能使用接口名调用，不能通过实现类的类名或者实现类的对象调用</p><p>示例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 接口类public interface LiveAble {    public static void run(){        System.out.println(&quot;这是静态方法，只能通过接口类调用&quot;);    }}&#x2F;&#x2F; 实现类无法继承或重写接口类静态方法&#x2F;&#x2F; 测试类public class InterfaceDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 创建子类对象        Animal a = new Animal();&#x2F;&#x2F; a.run(); 报错，无法通过实现类调用静态方法        LiveAble.run(); &#x2F;&#x2F; 接口类的静态方法只能通过接口类来调用    }}</code></pre></p><h4 id="私有方法的使用"><a href="#私有方法的使用" class="headerlink" title="私有方法的使用"></a>私有方法的使用</h4><ul><li>私有方法：只有默认方法可以调用</li><li>私有静态方法：默认方法和静态方法可以调用。<br>如果一个接口中有多个默认方法且方法中有代码重复内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。私有方法是对默认方法和静态方法的辅助。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public interface LiveAble {    default void func(){func1();func2();    }    private void func1(){System.out.println(&quot;跑起来~~~&quot;);    }    private void func2(){System.out.println(&quot;跑起来~~~&quot;);    }}</code></pre></li></ul><h4 id="接口的常量定义和使用"><a href="#接口的常量定义和使用" class="headerlink" title="接口的常量定义和使用"></a>接口的常量定义和使用</h4><p>接口当中也可可以定义”成员变量”，但是必须使用public static final三个关键字进行修饰。可以认为就是接口的[常量]。<br>格式：public static final 数据类型 常量名称 = 数据值; 一旦使用final关键字进行修饰，说明不可改变。<br>注意事项：</p><ol><li>接口中的常量，可以省略public static final。</li><li>接口中的常量，必须进行赋值，不能不赋值。</li><li>接口中常量的名称规则：使用完全大写的字母，单词间用下划线进行分隔。</li></ol><h3 id="接口内容小结"><a href="#接口内容小结" class="headerlink" title="接口内容小结"></a>接口内容小结</h3><p>在Java 9+版本中，接口的内容可以有：</p><ul><li>成员变量其实是常量。<ul><li>格式：[public] [sttaic] [final] 数据类型 常量名称 = 数据值; </li><li>注意：常量必须进行赋值，且一旦赋值不能改变。常量名称完全大写，用下划线分隔。</li></ul></li><li>接口中最重要的就是抽象方法。<ul><li>格式：[public] [abstract] 返回值类型 方法名称(参数列表);</li><li>注意：实现类必须覆盖重写接口的所有抽象方法，除非实现类是抽象类。</li></ul></li><li>从Java 8开始，接口里允许定义默认方法。<ul><li>格式：[public] default 返回值类型 方法名称(参数列表){方法体}</li><li>注意：默认方法也可以被覆盖重写</li></ul></li><li>从Java 8开始，接口里允许定义静态方法。<ul><li>格式：[public] static 返回值类型 方法名称(参数列表){方法体}</li><li>注意：应该通过接口名称进行调用，无法通过实现类对象调用接口静态方法。</li></ul></li><li>从Java 9开始，接口里允许定义私有方法。<ul><li>普通私有方法：private 返回值类型 方法名称(参数列表){方法体}</li><li>静态私有方法：private static 返回值类型 方法名称(参数列表){方法体}</li><li>注意：private方法只要接口自己才能调用，无法被实现类或者别人使用。</li></ul></li></ul><h3 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h3><p>在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。<br>格式如下：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/21/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E5%AE%9E%E7%8E%B0%E6%A0%BC%E5%BC%8F-1555836946283.png" alt="title"><br><br>使用接口的时候，需注意：</p><ol><li>接口是没有静态代码块或者构造方法的。</li><li>一个类的直接父类是唯一的，但是一个类可以同时实现多个接口的。<br>格式：<br>public class MyIntfaceImpl implements MyInterfaceA,MyInterfaceB{<br> // 覆盖重写所有抽象方法<br>}</li><li>如果实现类实现的多个接口中，存在重复的抽象方法，只需覆盖重写一次即可。</li><li>如果实现类没有覆盖重写所以接口的所有抽象方法，那么实现类必须是抽象类。</li><li>如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</li><li>一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，子类优先用父类当中的方法。</li></ol><h3 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h3><p>一个接口能继承另一个或者多个接口。接口的继承使用extends关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名，那么子接口需要重写一次。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 父接口Apublic interface MyInterfaceA {    public abstract void methodA();    public abstract void methodCommon();    public default void methodDefault(){        System.out.println(&quot;接口A默认方法&quot;);    }}&#x2F;&#x2F; 父接口Bpublic interface MyInterfaceB {    public abstract void methodB();    public abstract void methodCommon();    public default void methodDefault(){        System.out.println(&quot;接口B默认方法&quot;);    }}&#x2F;&#x2F; 子接口public interface MyInterface extends MyInterfaceA,MyInterfaceB{    public abstract void method();    @Override    default void methodDefault() { &#x2F;&#x2F; 重写父接口的默认方法    }}</code></pre></p><ol><li>类与类之间是单继承的。直接父类只有一个</li><li>类与接口之间是多实现的。一个类可以实现多个接口。</li><li>接口与接口之间是多继承的。</li></ol><p>注意事项：</p><ol><li>多个父接口当中的抽象方法如果重复，没关系</li><li>多个父接口中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，[而且带着default关键字</li></ol><h2 id="2-多态"><a href="#2-多态" class="headerlink" title="2.多态"></a>2.多态</h2><ul><li>多态：是指同一行为，具有多个不同表现形式。</li></ul><h3 id="2-1多态的体现"><a href="#2-1多态的体现" class="headerlink" title="2.1多态的体现"></a>2.1多态的体现</h3><p>多态的体现格式：父类名称 对象名 = new 子类名称();<br>代码中体现多态性，其实就是一句话：父类引用指向子类对象</p><h4 id="成员变量在多态中的规则"><a href="#成员变量在多态中的规则" class="headerlink" title="成员变量在多态中的规则"></a>成员变量在多态中的规则</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 父类public class Fu {    int num = 10;    public void showNum(){        System.out.println(num);    }}&#x2F;&#x2F; 子类public class Zi extends Fu {    int num = 20;    @Override    public void showNum(){        System.out.println(num);    }}&#x2F;&#x2F; 测试类public class DemoMulti01 {    public static void main(String[] args) {        Fu obj = new Zi();        System.out.println(obj.num); &#x2F;&#x2F; 直接访问成员变量时，左边是谁就先访问谁的        &#x2F;&#x2F; 子类没有覆盖重写，就是父：10        &#x2F;&#x2F; 子类如果覆盖重写，就是子：20        obj.showNum();    }}</code></pre><p>注意事项：</p><ol><li>直接通过对象名称访问成员变量：看等号左边是谁优先访问谁，没有则向上查找。</li><li>间接通过成员方法来访问成员变量：看该方法属于谁优先访问谁，没有则向上找。</li></ol><h4 id="多态中成员方法的使用特点"><a href="#多态中成员方法的使用特点" class="headerlink" title="多态中成员方法的使用特点"></a>多态中成员方法的使用特点</h4><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 父类public class Fu {    int num = 10;    public void showNum(){        System.out.println(num);    }    public void method(){        System.out.println(&quot;父类方法&quot;);    }    public void methodFu(){        System.out.println(&quot;父类特有方法&quot;);    }}&#x2F;&#x2F; 子类public class Zi extends Fu {    int num = 20;    @Override    public void showNum(){        System.out.println(num);    }    @Override    public void method(){        System.out.println(&quot;子类方法&quot;);    }    public void methodZi(){        System.out.println(&quot;子类特有方法&quot;);    }}&#x2F;&#x2F; 测试类&#x2F;*在多态的代码中，成员方法的访问规则是：    看new的是谁，就优先用谁，没有则向上找。成员方法口诀：编译看左边，运行看右边。对比一下：成员变量：编译看左边，运行还看左边。成员方法：编译看左边，运行看右边。 *&#x2F;public class Demo02MultiMethod {    public static void main(String[] args) {            Fu obj = new Zi(); &#x2F;&#x2F; 多态            &#x2F;&#x2F; 运行看右边：左边是Fu，Fu有method方法，所以编译通过，但是运行时看右边是Zi，故运行子类方法。            obj.method(); &#x2F;&#x2F; 父子都有，优先用子            &#x2F;&#x2F; 运行看右：左边是Fu，Fu有methodFu方法，编译通过，但运行是看右Zi，子类没有该方法，就向上找到父类，然后执行。            obj.methodFu(); &#x2F;&#x2F; 子类没有，向上找到父类有            &#x2F;&#x2F; 编译看左边：左边是Fu，Fu中没有methodZi方法，所以编译报错。            &#x2F;&#x2F; obj.methodZi(); 错误写法！    }}</code></pre></p><h3 id="2-2-多态的好处"><a href="#2-2-多态的好处" class="headerlink" title="2.2 多态的好处"></a>2.2 多态的好处</h3><p>可以使程序编写的更简单，并且有良好的扩展性。</p><h3 id="2-3-引用类型转换"><a href="#2-3-引用类型转换" class="headerlink" title="2.3 引用类型转换"></a>2.3 引用类型转换</h3><p>多态的转型分为向上转型和向下转型两种：</p><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><ul><li>概述：多态本身就子类类型向父类类型向上转换的过程，这个过程是默认的。</li><li>使用格式：父类名称 变量名 = new 子类类型(); 如 Animal a = new Cat();</li><li>含义：右侧创建一个子类对象，把它当做父类来看待使用。如上创建了一只猫，当做动物看待，没问题。</li><li>注意事项：向上转型一定是安全的，从小范围转向了大范围，从小范围的猫，向上转换成为更大范围的动物。</li><li>类似于：double num = 100; // 正确， int–&gt; double， 自动类型转换。</li></ul><h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><ul><li>概述：父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li><li>格式：子类名称 对象名 = (子类名称)父类对象；如 Cat cat = (Cat)a;</li><li>含义：将父类对象，[还原]成为本来的子类对象。</li></ul><p>注意事项：</p><ol><li>必须保证对象本来创建的时候，就是猫，才能向下转型成为猫。</li><li>如果对象创建时本来就不是猫，现在非要向下转型为猫，会报错ClassCastException</li><li>类似于： int num = (int)10.0; // 可以   int num = (int)10.5 //不可以，精度损失。</li></ol><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验。<br>格式：变量名 instanceof 数据类型; 如果变量属于该数据类型，返回true，反之返回false。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 父类public abstract class Animal {    public abstract void eat();}&#x2F;&#x2F; 子类1public class Cat extends Animal{    @Override    public void eat() {        System.out.println(&quot;猫吃鱼&quot;);    }    public void jump(){        System.out.println(&quot;猫跳跳&quot;);    }}&#x2F;&#x2F; 子类2public class Dog extends Animal{    @Override    public void eat() {        System.out.println(&quot;狗吃shit&quot;);    }    public void watchHouse(){        System.out.println(&quot;看家&quot;);    }}&#x2F;&#x2F; 测试类public class MainMethod {    public static void main(String[] args) {        Animal animal = new Dog();        animal.eat();        getAnimal(new Cat());    }    public static void getAnimal(Animal animal){        if(animal instanceof Dog){            Dog dog = (Dog)animal;            dog.watchHouse();        }        if(animal instanceof Cat){            Cat cat = (Cat)animal;            cat.jump();        }    }}</code></pre></p><h2 id="3-接口多态的综合案例"><a href="#3-接口多态的综合案例" class="headerlink" title="3. 接口多态的综合案例"></a>3. 接口多态的综合案例</h2><p>定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。</p><h3 id="3-1-案例分析"><a href="#3-1-案例分析" class="headerlink" title="3.1 案例分析"></a>3.1 案例分析</h3><p>进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘</p><ul><li>USB接口，包含开启功能、关闭功能</li><li>笔记本类，包含运行功能、关机功能、使用USB设备功能</li><li>鼠标类，要实现USB接口，并具备点击的方法</li><li>键盘类，要实现USB接口，具备敲击的方法</li></ul><p>具体代码实现如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 接口类public interface USB {    public abstract void open(); &#x2F;&#x2F; 打开设备    public abstract void close(); &#x2F;&#x2F; 关闭设备}&#x2F;&#x2F; 笔记本类public class Laptop {    public void powerOn(){        System.out.println(&quot;笔记本电脑开机&quot;);    }    public void powerOff(){        System.out.println(&quot;笔记本电脑关机&quot;);    }    &#x2F;&#x2F; 使用USB设备的方法，使用接口作为方法参数    public void usbDevice(USB usb){        usb.open();        if(usb instanceof Mouse){            Mouse mouse = (Mouse)usb; &#x2F;&#x2F; 向下转型            mouse.click();        }else if (usb instanceof Keyboard){            Keyboard keyboard = (Keyboard)usb;            keyboard.click();        }        usb.close();    }}&#x2F;&#x2F; 鼠标类&#x2F;&#x2F; 鼠标就是一个USB设备public class Mouse implements USB{    @Override    public void open() {        System.out.println(&quot;打开鼠标&quot;);    }    @Override    public void close() {        System.out.println(&quot;关闭鼠标&quot;);    }    public void click(){        System.out.println(&quot;鼠标点击&quot;);    }}&#x2F;&#x2F; 键盘类&#x2F;&#x2F; 键盘也是一个USB设备public class Keyboard implements USB{    @Override    public void open() {        System.out.println(&quot;打开键盘&quot;);    }    @Override    public void close() {        System.out.println(&quot;关闭键盘&quot;);    }    public void click(){        System.out.println(&quot;键盘输入&quot;);    }}&#x2F;&#x2F; 测试类public class DemoMain {    public static void main(String[] args) {        &#x2F;&#x2F; 首先创建一个电脑        Laptop laptop = new Laptop();        laptop.powerOn();        &#x2F;&#x2F; 准备一个鼠标,供电脑使用        USB usbMouse = new Mouse(); &#x2F;&#x2F; 首先向上转型        laptop.usbDevice(usbMouse);        &#x2F;&#x2F; 创建一个USB键盘        Keyboard keyboard = new Keyboard(); &#x2F;&#x2F;没有使用多态写法        &#x2F;&#x2F; 方法参数是USB类型，传递进去的是实现类对象        laptop.usbDevice(keyboard); &#x2F;&#x2F; 正确写法！ 自动发生了向上转型！        laptop.powerOff();    }}</code></pre></p><p>该案例主要练习对接口的基本使用，对象的上下转型以及接口作为对象参数的使用。</p><h3 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h3><ol><li>接口的概述以及定义格式，以及实现接口的格式。interface关键字，implements关键字</li><li>接口中的抽象方法，默认方法和静态方法，私有方法和私有静态方法的各自使用特点。</li><li>接口中成员方法，成员变量的特点。</li><li>接口的多继承。</li><li>多态的概念以及前提。</li><li>多态中的向上向下转型格式以及实际使用方法。</li><li>instanceof关键字。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三大特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java三大特性之继承</title>
      <link href="/JavaBasics/extend.html"/>
      <url>/JavaBasics/extend.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。其中，多个类可以称为子类，单独那个类称为父类、超类或者基类。</p><a id="more"></a><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h3><ul><li>定义：继承就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</li><li>优点：提高了代码的复用性，类与类之间产生了关系，是多态的前提。</li></ul><h3 id="1-1-继承的格式"><a href="#1-1-继承的格式" class="headerlink" title="1.1 继承的格式"></a>1.1 继承的格式</h3><p>通过extends关键字，可以声明一个子类继承另外一个父类，实例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;定义父类public class Employee {    String name;    public void work(){        System.out.println(&quot;努力工作&quot;);    }}&#x2F;&#x2F; 定义子类继承父类class Teacher extends Employee{    public void printName(){        System.out.println(&quot;name:&quot; + name);    }}&#x2F;&#x2F; 测试public class Demo01Extends {    public static void main(String[] args) {        Teacher t = new Teacher();        t.name = &quot;小明&quot;;        t.printName();        t.work();    }}</code></pre></p><h3 id="1-2-继承后的成员变量"><a href="#1-2-继承后的成员变量" class="headerlink" title="1.2 继承后的成员变量"></a>1.2 继承后的成员变量</h3><ul><li>如果子类父类中成员变量未重名，访问没有影响。</li><li>如果成员变量有重名的，访问会有影响，需要使用super关键字修饰父类成员变量。实例如下：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02Super {    public static void main(String[] args) {        Zi z = new Zi();        z.show();    }}class Fu{    int num = 5;}class Zi extends Fu{    int num = 6;    public void show(){        &#x2F;&#x2F; 访问父类中的num        System.out.println(&quot;父类num：&quot; + super.num); &#x2F;&#x2F;使用super关键字即可访问父类成员变量        &#x2F;&#x2F;访问子类中的num        System.out.println(&quot;子类num：&quot; + this.num);    }}</code></pre></li></ul><p>注意：</p><ol><li>父类中的成员变量是非私有时，子类可以直接访问。若父类成员变量私有了，子类是不能直接访问的，可以通过父类设置的getxxx/setxxx方法间接访问。</li></ol><h3 id="1-3-继承后的成员方法。"><a href="#1-3-继承后的成员方法。" class="headerlink" title="1.3 继承后的成员方法。"></a>1.3 继承后的成员方法。</h3><ol><li>如果子类父类中成员方法不重名，这时调用是没有影响的。对象在调用方法时，会现在子类寻找对应方法，若子类存在就执行子类中的方法，若子类不存在该方法就会执行父类中对应的方法。</li><li>如果子类父类中成员方法重名，这时访问会造成一种特殊情况，叫做方法重写。</li><li>重写(Override)：子类中出现与父类一模一样的方法时(返回值类型，方法名和参数列表都相同)，会出现覆盖效果，也称为覆盖或者覆写。声明不变，重新实现。</li></ol><h4 id="重写的应用"><a href="#重写的应用" class="headerlink" title="重写的应用"></a>重写的应用</h4><p>子类可以根据需要，定义属于自己的行为。即沿袭了父类的功能名称，有根据子类需要重新实现父类方法，从而进行扩展。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 父类public class Phone {    public void call(){        System.out.println(&quot;打电话&quot;);    }    public void sendMessage(){        System.out.println(&quot;发短信&quot;);    }    public void showNum(){        System.out.println(&quot;来电显示号码&quot;);    }}&#x2F;&#x2F; 子类继承父类，并重写父类方法，扩展自己功能public class NewPhone extends Phone{    public void showNum(){        super.showNum();        System.out.println(&quot;来电显示姓名&quot;);        System.out.println(&quot;来电显示头像&quot;);    }}&#x2F;&#x2F; 实例类public class Demo04Extends {    public static void main(String[] args) {        NewPhone ph = new NewPhone();        ph.call();        ph.sendMessage();        ph.showNum();    }}</code></pre></p><p>方法覆盖重写的注意事项：</p><ol><li>必须保证父子类之间方法的名称相同，参数列表也相同。<br>@Override:写在方法前面,检测是否是有效的正确覆盖重写，可选</li><li>子类方法的返回值必须小于等于父类方法的返回值范围。<br>扩展：java.lang.Object类是所有类的公共最高父类(祖宗类),String是Object的子类。</li><li>子类方法的权限必须大于等于父类方法的权限修饰符。<br>扩展：public &gt; protected &gt; (default) &gt; private 注：(default)不是关键字default，而是什么都不写，留空。</li></ol><h3 id="1-4-继承关系中构造方法的访问特点"><a href="#1-4-继承关系中构造方法的访问特点" class="headerlink" title="1.4 继承关系中构造方法的访问特点"></a>1.4 继承关系中构造方法的访问特点</h3><ol><li>子类构造方法当中有一个默认隐含的”super()” 调用，所以一定是先调用父类构造，后执行的子类构造。</li><li>子类构造可以通过super关键字来调用父类重载构造</li><li>super的父类构造调用，必须是子类构造方法的第一个语句。子类构造不能调用多次super构造。<br>小结：子类必须调用父类构造方法，不写则赠送super(); 写了则用写的super调用，super有且只能有一个，还必须是第一个。</li></ol><h3 id="1-5-super和this关键字用法小结"><a href="#1-5-super和this关键字用法小结" class="headerlink" title="1.5 super和this关键字用法小结"></a>1.5 super和this关键字用法小结</h3><p>super关键字三种用法：</p><ol><li>在子类的成员方法中，访问父类的成员变量。super.父类成员变量;</li><li>在子类的成员方法中，访问父类的成员方法。super.父类成员方法();</li><li>在子类的构造方法中，访问父类的构造方法。super();<br>this关键字三种用法：</li><li>在本类的成员方法中，访问本类的成员变量。this.本类成员变量;</li><li>在本类的成员方法中，访问本类的另一个成员方法。this.本类成员方法();</li><li>在本类的构造方法中，访问本类的另一个构造方法。this(…);<br>注意：<br>A. this(…) 调用也必须是构造方法的第一个语句，且唯一一个。<br>B. super和this两种构造调用，不能同时使用。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Zi extends Fu{    int num = 20;    public Zi(){        this(8); &#x2F;&#x2F; 本类的无参构造，调用本类的有参构造    }    public Zi(int n){    }    public void showNum(){        int num = 10;        System.out.println(num); &#x2F;&#x2F; 局部变量        System.out.println(this.num); &#x2F;&#x2F; 本类成员变量        System.out.println(super.num); &#x2F;&#x2F;  父类成员变量    }    public void methodA(){        System.out.println(&quot;AAA&quot;);    }    public void methodB(){        this.methodA(); &#x2F;&#x2F; 调用本类成员方法        System.out.println(&quot;BBB&quot;);    }}</code></pre></li></ol><p>super和this内存图<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/20/super%26this%E5%86%85%E5%AD%98%E5%9B%BE-1555741452451.png" alt="title"></p><h3 id="1-6-Java继承的三个特点"><a href="#1-6-Java继承的三个特点" class="headerlink" title="1.6 Java继承的三个特点"></a>1.6 Java继承的三个特点</h3><ol><li>Java语言只支持单继承，一个类的直接父类只能有唯一个</li><li>Java支持多层继承(继承体系)</li><li>子类和父类是一种相对的概念</li></ol><h2 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2. 抽象类"></a>2. 抽象类</h2><p>父类中的方法，被它的子类覆盖重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为<strong>抽象方法</strong>。Java语法规定，包含抽象方法的类就是<strong>抽象类</strong>。</p><ul><li>抽象方法：没有方法体的方法。</li><li>抽象类：包含抽象方法的类。</li></ul><h3 id="2-1-abstract使用格式"><a href="#2-1-abstract使用格式" class="headerlink" title="2.1 abstract使用格式"></a>2.1 abstract使用格式</h3><h3 id="2-2-抽象方法"><a href="#2-2-抽象方法" class="headerlink" title="2.2 抽象方法"></a>2.2 抽象方法</h3><ul><li>使用abstract关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</li><li>定义格式：修饰符 abstract 返回值类型 方法名(参数列表);</li><li>代码示例：public abstract void run();<h3 id="2-3-抽象类"><a href="#2-3-抽象类" class="headerlink" title="2.3 抽象类"></a>2.3 抽象类</h3><ul><li>如果一个类包含抽象方法，那么该类必须是抽象类。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">定义格式：abstract class 类名称{...}代码示例：public abstract class Animal{ &#x2F;&#x2F; 抽象类    public abstract void run(); &#x2F;&#x2F; 抽象方法}</code></pre></li></ul></li></ul><h3 id="2-4-抽象的使用"><a href="#2-4-抽象的使用" class="headerlink" title="2.4 抽象的使用"></a>2.4 抽象的使用</h3><ol><li>不能使用new来直接创建抽象类对象。</li><li>必须用一个子类来继承抽象父类。</li><li>子类必须覆盖重写抽象父类当中所有的抽象方法。覆盖重写(实现方法)：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</li><li>创建子类对象进行使用。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 抽象类public abstract class Animal {    public abstract void eat(); &#x2F;&#x2F; 抽象方法}&#x2F;&#x2F; 子类继承抽象类public class Cat extends Animal{    @Override    public void eat(){ &#x2F;&#x2F; 重写抽象方法，并补上大括号和具体实现        System.out.println(&quot;猫吃鱼&quot;);    }}&#x2F;&#x2F; 实例public class DemoMain {    public static void main(String[] args) {        Cat cat = new Cat(); &#x2F;&#x2F; 创建子类对象        cat.eat(); &#x2F;&#x2F; 调用方法    }}</code></pre></li></ol><h3 id="2-5-注意事项"><a href="#2-5-注意事项" class="headerlink" title="2.5 注意事项"></a>2.5 注意事项</h3><p>关于抽象类的使用，注意事项总结：</p><ol><li>抽象类不能创建对象。只能创建其非抽象子类的对象。原因：抽象类的抽象方法没有具体方法体，没有意义</li><li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。因为子类的构造方法中，有默认的super(); 会调用父类构造方法。</li><li>抽象类中，不一定包含抽象方法，但有抽象方法的类必定是抽象类。未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</li><li>抽象类的子类，必须重写父类中所有的抽象方法，否则会报错。除非该子类也是抽象类。</li></ol><h2 id="3-继承的综合案例"><a href="#3-继承的综合案例" class="headerlink" title="3. 继承的综合案例"></a>3. 继承的综合案例</h2><p>群主发普通红包。某群有多名成员，群主发红包。规则：</p><ol><li>群主有一笔金额，从群主余额扣除，平均分为n份，让成员领取。</li><li>成员领取红包后，保存到成员余额中。<br>根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。</li></ol><h3 id="分析案例"><a href="#分析案例" class="headerlink" title="分析案例"></a>分析案例</h3><p>根据描述分析，得出如下继承体系：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/20/%E5%8F%91%E7%BA%A2%E5%8C%85%E6%A1%88%E4%BE%8B%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB-1555750639750.png" alt="title"><br><br>代码实现：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F; 定义父类Userspublic class Users {    private String name;    private double money;    public Users() {    }    public Users(String name, double money) {        this.name = name;        this.money = money;    }    public void show(){        System.out.println(&quot;我叫&quot;+name+&quot;，我有&quot;+money+&quot;块钱&quot;);    }    ... ...省略get&#x2F;set方法}&#x2F;&#x2F; 定义群主类&#x2F;&#x2F; 群主类public class Manager extends Users{    public Manager(){ &#x2F;&#x2F; 无参构造方法    }    public Manager(String name, double money) { &#x2F;&#x2F; 全参构造方法        super(name, money); &#x2F;&#x2F; 调用了父类的构造方法，并初始化值    }    &#x2F;&#x2F; 定义群主发红包方法，参数为发红包金额和份数    public ArrayList&lt;Double&gt; send(double totalMoney, int count){        &#x2F;&#x2F; 首先需要一个集合，用来存储若干个红包的金额        ArrayList&lt;Double&gt; redList = new ArrayList&lt;&gt;();        &#x2F;&#x2F;首先看一下群主有多少钱        double leftMoney = super.getMoney(); &#x2F;&#x2F; 群主当前余额        if(totalMoney &gt; leftMoney){            System.out.println(&quot;余额不足&quot;);            return redList; &#x2F;&#x2F; 返回空集合        }        &#x2F;&#x2F;扣钱，其实就是重置余额        super.setMoney(leftMoney - totalMoney);        &#x2F;&#x2F;发红包需平均拆分为count份        double avg = (int)totalMoney &#x2F; count; &#x2F;&#x2F; int化后丢失精度,如何把零头单独拿出来？        double mod = totalMoney - avg * count;&#x2F;&#x2F;余数，也就是甩下的零头        &#x2F;&#x2F; 除不来的零头，包在最后一个红包里        &#x2F;&#x2F; 下面把红包一个一个放到集合中        for (int i = 0; i &lt; count - 1; i++) {            redList.add(avg);        }        double last = avg + mod; &#x2F;&#x2F;最后一个红包        redList.add(last);        return redList; &#x2F;&#x2F; 返回的是一个红包数组集合    }}&#x2F;&#x2F;定义群员类&#x2F;&#x2F; 成员类public class Member extends Users{    public Member(){    }    public Member(String name, double money) {        super(name, money);}    public void receive(ArrayList&lt;Double&gt; list){        &#x2F;&#x2F; 从多个红包当中随机抽取一个，给我自己。        &#x2F;&#x2F; 随机获取一个集和当中的索引编号        int index = new Random().nextInt(list.size());        &#x2F;&#x2F; 根据索引，从集合中删除，并且得到被删除的红包值，给自己钱        double delta = list.remove(index);        &#x2F;&#x2F; 成员查看一下自己的余额        double money = super.getMoney();        &#x2F;&#x2F; 将得到的红包金额加入自己的余额        super.setMoney(delta + money);    }}&#x2F;&#x2F; 定义主方法实例public class MainRedPacket {    public static void main(String[] args) {        Manager manager = new Manager(&quot;群主&quot;,100.765);        Member one = new Member(&quot;成员A&quot;,0);        Member two = new Member(&quot;成员B&quot;,0);        Member three = new Member(&quot;成员C&quot;,0);        manager.show();        one.show();        two.show();        three.show();        System.out.println(&quot;===================&quot;);        ArrayList&lt;Double&gt; redList = manager.send(55.687,3);        one.receive(redList);        two.receive(redList);        three.receive(redList);        manager.show();        one.show();        two.show();        three.show();    }}</code></pre></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Java继承的概念，特点</li><li>extends关键字的使用</li><li>继承后成员变量成员方法构造方法的访问特点</li><li>方法的覆盖重写</li><li>super和this关键字的使用</li><li>抽象类，抽象方法的概念</li><li>abstract关键字的使用</li><li>综合案例练习</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三大特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的常用工具类</title>
      <link href="/JavaBasics/tool-classs.html"/>
      <url>/JavaBasics/tool-classs.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-String类概述"><a href="#1-String类概述" class="headerlink" title="1. String类概述"></a>1. String类概述</h2><p>java.lang.String 类代表字符串。Java程序中所有的字符串文字都可以被看作是实现此类的实例。<br><br>类String中包括用于检查各个字符串的方法，比如用于比较字符串、搜索字符串、提取子字符串以及创建具有翻译为大写或者小写的所有字符的字符串副本。</p><a id="more"></a><h3 id="1-1-字符串的特点"><a href="#1-1-字符串的特点" class="headerlink" title="1.1 字符串的特点"></a>1.1 字符串的特点</h3><ol><li>字符串的内容永不可变。</li><li>因为不可变，所以字符串是可以共享的</li><li>字符串效果上相当于是char[]字符数组，但底层原理是byte[]字节数组。</li></ol><h3 id="1-2-创建字符串的常见3-1种方式"><a href="#1-2-创建字符串的常见3-1种方式" class="headerlink" title="1.2 创建字符串的常见3+1种方式"></a>1.2 创建字符串的常见3+1种方式</h3><h4 id="三种构造方法"><a href="#三种构造方法" class="headerlink" title="三种构造方法"></a>三种构造方法</h4><ol><li>public String(): 创建一个空白字符串，不含有任何内容。</li><li>public String(char[] array)：根据字符数组的内容，来创建对应的字符串。</li><li>public String(byte[] array): 根据字节数组的内容，来创建对应的字符串。<h4 id="一种直接创建："><a href="#一种直接创建：" class="headerlink" title="一种直接创建："></a>一种直接创建：</h4><code>String str = &quot;Hello&quot;;</code></li></ol><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02StringTwo {    public static void main(String[] args) {        String str1 = &quot;abc&quot;;        String str2 = &quot;abc&quot;;        char[] charArray = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;};        String str3 = new String(charArray);    }}</code></pre><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E5%9B%BE-1555640143003.png" alt="title"></p><h3 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h3><h4 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h4><ul><li><p>public boolean equals(Object Obj):参数可以是任何对象，只有参数是一个字符串且内容相同时返回true，反之false。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo03StringEquals {    public static void main(String[] args) {        String str1 = &quot;Hello&quot;;        String str2 = &quot;Hello&quot;;        char[] charArray = {&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;};        String str3 = new String(charArray);        System.out.println(str1.equals(str2));        System.out.println(str2.equals(str3));        System.out.println(str3.equals(&quot;Hello&quot;));        System.out.println(&quot;Hello&quot;.equals(str3));        String str4 = null;        System.out.println(&quot;abc&quot;.equals(str4)); &#x2F;&#x2F; false 推荐写法    System.out.println(str4.equals(&quot;abc&quot;)); &#x2F;&#x2F; 报错，NullPointerException    }}注意事项：1. 任何对象都能用Object进行接收。2. equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果是一样的。3. 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。&lt;br&gt;推荐：&quot;abc&quot;.equals(str),不推荐:str.equals(&quot;abc&quot;)。</code></pre></li><li><p>public boolean equalsIgnoreCase(String anotherString):将此字符串与指定对象进行比较，忽略大小写。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/19/equalsIgnoreCase-1555643567275.png" alt="title"></p></li></ul><h4 id="String当中与获取相关的常用方法"><a href="#String当中与获取相关的常用方法" class="headerlink" title="String当中与获取相关的常用方法"></a>String当中与获取相关的常用方法</h4><ul><li>public int lenght(); 获取字符串当中含有的字符个数，拿到字符串长度。</li><li>public String concat(String str); 将指定的字符串连接到该字符串的末尾。</li><li>public char charAt(int index); 获取指定索引位置的单个字符。</li><li>public int indexOf(String str); 查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。</li></ul><p>举例代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo04StringGet {    public static void main(String[] args) {        int length = &quot;abcdefghijklmnobqrstuvwxyz&quot;.length();        System.out.println(&quot;字符串长度为：&quot; + length);        &#x2F;&#x2F;拼接字符串        String str1 = &quot;Hello&quot;;        String str2 = &quot;World&quot;;        String str3 = str1.concat(str2);        System.out.println(str1); &#x2F;&#x2F; Hello        System.out.println(str2); &#x2F;&#x2F; World        System.out.println(str3); &#x2F;&#x2F; HelloWorld        System.out.println(&quot;Hello&quot;.charAt(0)); &#x2F;&#x2F; H        String str4 = str3;        System.out.println(str4.indexOf(&quot;llo&quot;)); &#x2F;&#x2F;返回索引位置，即2    }}</code></pre></p><ul><li>public String substring(int index):截取从参数位置一直到字符串末尾，返回新字符串</li><li>public String substring(int begin,int end):截取从begin开始，一直到end结束，中间的字符串。[begin,end)，包含左边，不包含右边。</li></ul><p>举例代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo05SubString {    public static void main(String[] args) {        String str1 = &quot;HelloWorld&quot;;        System.out.println(str1.substring(5)); &#x2F;&#x2F; 返回World        System.out.println(str1.substring(4,7)); &#x2F;&#x2F; owo , 4~6不含7    }}</code></pre></p><h4 id="String当中与转换相关的常用方法"><a href="#String当中与转换相关的常用方法" class="headerlink" title="String当中与转换相关的常用方法"></a>String当中与转换相关的常用方法</h4><ul><li>public char[] toCharArray(); 将当前字符串拆分成为字符数组作为返回值。</li><li>public byte[] getBytes(); 获取当前字符串底层的字节数组。</li><li>public String replace(CharSequence oldString, CharSequence newString);将所有出现的老字符串替换为新的字符串，返回替换后的结果新字符串。</li></ul><p>例子：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo06StringConvert {    public static void main(String[] args) {        char[] chars = &quot;Hello&quot;.toCharArray();        System.out.println(chars); &#x2F;&#x2F; Hello        System.out.println(chars[0]); &#x2F;&#x2F; H        System.out.println(chars.length); &#x2F;&#x2F; 5        System.out.println(&quot;=========================&quot;);        String str = &quot;abc&quot;;        byte[] bytes = str.getBytes();        System.out.println(bytes); &#x2F;&#x2F;指向内存地址中abc对应的byte值        System.out.println(bytes[0]); &#x2F;&#x2F; [0] = 97,[1] = 98,[2] = 99        String str2 = &quot;你怎么回事小老弟，会不会玩啊，fuck&quot;;        System.out.println(str2.replace(&quot;fuck&quot;,&quot;儒雅随和&quot;));    }}Tips：CharSequence意思是说可以接受字符串类型。是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中。</code></pre></p><h4 id="String中分割字符串的方法"><a href="#String中分割字符串的方法" class="headerlink" title="String中分割字符串的方法"></a>String中分割字符串的方法</h4><p>public String[] split(String regex); 按照参数的规则，将字符串切分为若干部分。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo07StringSplit {    public static void main(String[] args) {        String str1 = &quot;a,b,c&quot;;        String[] array1 = str1.split(&quot;,&quot;);        for(int i = 0;i&lt;array1.length;i++){            System.out.println(array1[i]);        }        String str2 = &quot;a b c&quot;;        String[] array2 = str2.split(&quot; &quot;);        for(int i=0;i&lt;array2.length;i++){            System.out.println(array2[i]);        }        String str3 = &quot;XXX.YYY.ZZZ&quot;;        String[] array3 = str3.split(&quot;\\.&quot;); &#x2F;&#x2F;注意转义        for (int i=0;i&lt;array3.length;i++){            System.out.print(array3[i]);        }    }}</code></pre></p><h4 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h4><p>拼接字符串练习，输入数组{1,2,3}，返回[1#2#3]。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">public class Demo08StringExercise {    public static void main(String[] args) {        int[] arr = {1,2,3,4};        System.out.println(arrayToString(arr));    }    public static String arrayToString(int[] arr){        String str = &quot;[&quot;;        for (int i=0;i&lt;arr.length;i++){            if(i != arr.length-1){                str += (arr[i]+&quot;#&quot;);            }else{                str += (arr[i]+&quot;]&quot;);            }        }        return str;    }}</code></pre></p><p>统计字符个数：键盘录入一个字符，统计字符串中大小写字母及数字字符个数<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Scanner;&#x2F;*键盘输入一个字符串，统计其中各种字符出现次数，返回次数。字符种类：大写字母，小写字母，数字，其他 *&#x2F;public class Demo09StringExercise02 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入字符串：&quot;);        String input = sc.next(); &#x2F;&#x2F; 获取键盘输入的字符串        System.out.println(stringCount(input));    }    public static String stringCount(String input){        int countUpper = 0;        int countLower = 0;        int countNumber = 0;        int countOther = 0;        char[] chars = input.toCharArray();        for(int i = 0;i &lt; chars.length;i++){            char ch = chars[i]; &#x2F;&#x2F; 单个字符，底层表示为byte[]数值            if(ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;){                countUpper++;            }else if (ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;){                countLower++;            }else if (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;){                countNumber++;            }else{                countOther++;            }        }        return &quot;大写字母：&quot;+countUpper+&quot;\n小写字母：&quot;+countLower+&quot;\n数字:&quot;+countNumber+&quot;\n其他类型：&quot;+countOther;    }}</code></pre></p><h2 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2. static关键字"></a>2. static关键字</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>关于static关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就不可以靠创建对象来调用了。</p><h3 id="2-2定义和使用格式"><a href="#2-2定义和使用格式" class="headerlink" title="2.2定义和使用格式"></a>2.2定义和使用格式</h3><p>当static修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类对象的情况下对类变量进行操作。</p><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><ul><li>类变量：使用static关键字修饰的成员变量。格式：static 数据类型 变量名。</li></ul><p>实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;定义学生类public class Student {    private int sid; &#x2F;&#x2F;学号    private String name;    private int age;    static String room;    public static int idCount = 0; &#x2F;&#x2F;自动分配学号    public Student() {        this.sid = ++idCount;    }    public Student(String name, int age) {        this.name = name;        this.age = age;        this.sid = ++idCount;    }......省略get&#x2F;set方法}&#x2F;&#x2F;实例使用public class Demo10Class {    public static void main(String[] args) {        Student stu = new Student(&quot;法师&quot;,11);        stu.room = &quot;101号教室&quot;;        System.out.println(&quot;姓名：&quot;+stu.getName()+&quot;,年龄:&quot;+stu.getAge()+&quot;岁,教室：&quot;+stu.getRoom()+&quot;,学号：&quot;+stu.getSid());        Student stu2 = new Student(&quot;盗贼&quot;,15);        System.out.println(&quot;姓名：&quot;+stu2.getName()+&quot;,年龄:&quot;+stu2.getAge()+&quot;岁,教室：&quot;+stu2.getRoom()+&quot;,学号：&quot;+stu2.getSid());    }}</code></pre></p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>当static修饰成员方法时，该方法称为类方法。静态方法在声明中有static，建议使用类名来调用，而不需要创建类的对象。</p><ul><li>类方法：使用static关键字修饰的成员方法，一般称为静态方法。<br>格式如下：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/19/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-1555663220471.png" alt="title"></li></ul><p>实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;MyClasspublic class MyClass {    int num; &#x2F;&#x2F; 成员变量    static int numStatic; &#x2F;&#x2F;静态变量    public void method(){        System.out.println(&quot;这是一个成员方法！&quot;);        System.out.println(num); &#x2F;&#x2F;成员方法可以访问成员变量        System.out.println(numStatic); &#x2F;&#x2F; 成员方法可以访问静态变量    }    public static void methodStatic(){        System.out.print(&quot;这是一个静态方法！&quot;);        System.out.println(numStatic); &#x2F;&#x2F;静态方法可以访问静态变量        &#x2F;&#x2F;System.out.println(num); &#x2F;&#x2F;静态方法无法访问成员变量    }}&#x2F;&#x2F;实例类public class Demo01StaticMethod {    public static void main(String[] args) {        MyClass obj = new MyClass(); &#x2F;&#x2F; 首先创建对象        obj.method(); &#x2F;&#x2F; 才能使用没有static关键字的内容        &#x2F;&#x2F;对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。        obj.methodStatic(); &#x2F;&#x2F; 不推荐写法，编译器编译时会自动优化为下面方法。        MyClass.methodStatic(); &#x2F;&#x2F; 推荐写法，类名称.静态方法。        &#x2F;&#x2F; 对于本类当中的静态方法，可以省略名称        myMethod();        Demo01StaticMethod.myMethod(); &#x2F;&#x2F; 完全等效于上面    }    public static void myMethod(){        System.out.println(&quot;自己的方法!&quot;);    }}</code></pre></p><ul><li>静态方法调用总结：<ul><li>静态方法可以直接访问类变量和静态方法。</li><li>静态方法不能直接访问普通成员变量或成员方法。原因：因为在内存中是[先]有的静态内容，[后]有的非静态内容,”前人不知后事，后人尽知前史”。</li><li>静态方法中，不能使用this关键字。</li><li>无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。静态变量：类名称.静态变量；静态方法：类名称.静态方法();</li></ul></li></ul><h4 id="2-3-静态原理图解"><a href="#2-3-静态原理图解" class="headerlink" title="2.3 静态原理图解"></a>2.3 静态原理图解</h4><p>static修饰的内容：</p><ul><li>是随着类的加载而加载的，且只加载一次。</li><li>存储于一块固定的内存区域(静态区),所以，可以直接被类名调用。</li><li>它优先于对象存在，所以，可以被所有对象共享。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/19/static%E5%86%85%E5%AD%98%E5%9B%BE-1555683796541.png" alt="title"></li></ul><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul><li>静态代码块：定义在成员位置，使用static修饰的代码块{}。<ul><li>位置：类中方法外。</li><li>执行：随着类的加载而执行且只执行一次，优先于main方法和构造方法的执行。</li></ul></li><li>格式：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/19/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97-1555684497323.png" alt="title"></li><li>作用：用来一次性地对静态成员变量进行赋值。</li></ul><h2 id="3-Arrays类"><a href="#3-Arrays类" class="headerlink" title="3. Arrays类"></a>3. Arrays类</h2><p>java.util.Arrays此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。</p><h3 id="3-1-操作数组的方法"><a href="#3-1-操作数组的方法" class="headerlink" title="3.1 操作数组的方法"></a>3.1 操作数组的方法</h3><ul><li>public static String toString(int[] a): 返回指定数组内容的字符串表示形式。</li><li>public static void sort(int[] a): 对指定的int型数组按数字升序进行排序。</li></ul><p>举例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Arrays;public class Demo03Arrays {    public static void main(String[] args) {        int[] arr = {1,3,54,86,37,28};        System.out.println(arr); &#x2F;&#x2F; 打印数组内存地址        String str = Arrays.toString(arr); &#x2F;&#x2F;将指定数组内容变成字符串返回。        System.out.println(str);        int[] arr2 = {2,5,3,8,4,9,1};        Arrays.sort(arr2); &#x2F;&#x2F; 升序排序        System.out.println(Arrays.toString(arr2)); &#x2F;&#x2F; [1, 2, 3, 4, 5, 8, 9]    }}</code></pre></p><h4 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h4><p>对一个随机字符串进行升序排序，然后倒序输出<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Arrays;public class Demo04ArraysExercise {    public static void main(String[] args) {        String str = &quot;ehiaroaklcmbzhywqiem&quot;;        char[] chars = str.toCharArray();        Arrays.sort(chars); &#x2F;&#x2F; 对字符串进行升序排序        System.out.println(chars);        for (int i = chars.length - 1; i &gt;= 0; i--) { &#x2F;&#x2F;快捷键:[chars.forr] , 对chars对象进行倒序遍历; [fori],正序遍历            System.out.print(chars[i]);        }    }}</code></pre></p><h2 id="4-Math类"><a href="#4-Math类" class="headerlink" title="4. Math类"></a>4. Math类</h2><p>java.lang.Math类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，里面提供了大量的静态方法，完成与数学运算的操作。</p><h3 id="4-1-基本运算的方法"><a href="#4-1-基本运算的方法" class="headerlink" title="4.1 基本运算的方法"></a>4.1 基本运算的方法</h3><ul><li>public static double abs(double num): 返回绝对值。</li><li>public static double ceil(double num): 向上取整。</li><li>public static double floor(double num): 向下取整。</li><li>public static double round(double num): 四舍五入。</li></ul><p>实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo05Math {    public static void main(String[] args) {        System.out.println(&quot;以下示例abs用法&quot;);        System.out.println(Math.abs(3.14)); &#x2F;&#x2F; 3.14        System.out.println(Math.abs(-2.5)); &#x2F;&#x2F; 2.5        System.out.println(Math.abs(0)); &#x2F;&#x2F; 0        System.out.println(&quot;以下示例ceil用法&quot;);        System.out.println(Math.ceil(3.9)); &#x2F;&#x2F; 4.0        System.out.println(Math.ceil(3.1)); &#x2F;&#x2F; 4.0        System.out.println(Math.ceil(3.0)); &#x2F;&#x2F; 3.0        System.out.println(&quot;以下示例floor用法&quot;);        System.out.println(Math.floor(30.9)); &#x2F;&#x2F; 30.0        System.out.println(Math.floor(30.1)); &#x2F;&#x2F; 30.0        System.out.println(Math.floor(31.0)); &#x2F;&#x2F; 31.0        System.out.println(&quot;以下示例round用法&quot;);        System.out.println(Math.round(20.4)); &#x2F;&#x2F;20        System.out.println(Math.round(20.5)); &#x2F;&#x2F;21        System.out.println(&quot;圆周率：&quot; + Math.PI);    }}</code></pre></p><h4 id="小练习-2"><a href="#小练习-2" class="headerlink" title="小练习"></a>小练习</h4><p>请使用 Math 相关的API，计算在 -10.8 到 5.9 之间，绝对值大于 6 或者小于 2.1 的整数有多少个？<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo06mathExercise {    public static void main(String[] args) {        double min = -10.8;        double max = 5.9;        int num = 0;        for (int i = (int)min; i &lt; max; i++) {            int abs = Math.abs(i); &#x2F;&#x2F; 绝对值化            if(abs &gt; 6 || abs &lt;2.1){                num++;            }        }        System.out.println(num);    }}</code></pre></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="字符串类及常用方法API"><a href="#字符串类及常用方法API" class="headerlink" title="字符串类及常用方法API"></a>字符串类及常用方法API</h3><ol><li>public String(): 创建一个空白字符串，不含有任何内容。</li><li>public String(char[] array)：根据字符数组的内容，来创建对应的字符串。</li><li>public String(byte[] array): 根据字节数组的内容，来创建对应的字符串</li><li>public boolean equals(Object Obj):参数可以是任何对象，只有参数是一个字符串且内容相同时返回true，反之false。</li><li>public boolean equalsIgnoreCase(String anotherString):将此字符串与指定对象进行比较，忽略大小写。</li><li>public int lenght(); 获取字符串当中含有的字符个数，拿到字符串长度。</li><li>public String concat(String str); 将指定的字符串连接到该字符串的末尾。</li><li>public char charAt(int index); 获取指定索引位置的单个字符。</li><li>public int indexOf(String str); 查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。</li><li>public String substring(int index):截取从参数位置一直到字符串末尾，返回新字符串。</li><li>public String substring(int begin,int end):截取从begin开始，一直到end结束，中间的字符串。[begin,end)，包含左边，不包含右边。</li><li>public char[] toCharArray(); 将当前字符串拆分成为字符数组作为返回值。</li><li>public byte[] getBytes(); 获取当前字符串底层的字节数组。</li><li>public String replace(CharSequence oldString, CharSequence newString);将所有出现的老字符串替换为新的字符串，返回替换后的结果新字符串。</li><li>public String[] split(String regex); 按照参数的规则，将字符串切分为若干部分。</li></ol><h3 id="static关键字及常用方法"><a href="#static关键字及常用方法" class="headerlink" title="static关键字及常用方法"></a>static关键字及常用方法</h3><ol><li>类变量：使用static关键字修饰的成员变量。格式：static 数据类型 变量名；</li><li>类方法：使用static关键字修饰的成员方法，一般称为静态方法。</li></ol><h3 id="Arrays类操作数组的常用方法"><a href="#Arrays类操作数组的常用方法" class="headerlink" title="Arrays类操作数组的常用方法"></a>Arrays类操作数组的常用方法</h3><ol><li>public static String toString(int[] a): 返回指定数组内容的字符串表示形式。</li><li>public static void sort(int[] a): 对指定的int型数组按数字升序进行排序。</li></ol><h3 id="Math类常用方法"><a href="#Math类常用方法" class="headerlink" title="Math类常用方法"></a>Math类常用方法</h3><ol><li>public static double abs(double num): 返回绝对值。</li><li>public static double ceil(double num): 向上取整。</li><li>public static double floor(double num): 向下取整。</li><li>public static double round(double num): 四舍五入。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API概述</title>
      <link href="/JavaBasics/api.html"/>
      <url>/JavaBasics/api.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>API(Application Programming Interface)，应用程序编程接口。Java API是一本API字典，是JDK中提供给我们使用类的说明文档。这些类将底层的代码实现封装了起来，我们不用关心类是如何实现的，只需学习这些类如何使用即可。</p><a id="more"></a><h3 id="API使用步骤"><a href="#API使用步骤" class="headerlink" title="API使用步骤"></a>API使用步骤</h3><ol><li>打开帮助文档。</li><li>点击显示，找到索引，看到输入框。</li><li>输入你要查询的类名。</li><li>看包。java.lang下的类不需要导包，其他都要import</li><li>看类的解释和说明。</li><li>学习构造方法。</li><li>使用成员方法。</li></ol><h2 id="2-Scanner类"><a href="#2-Scanner类" class="headerlink" title="2. Scanner类"></a>2. Scanner类</h2><h3 id="2-1-什么是Scanner类？"><a href="#2-1-什么是Scanner类？" class="headerlink" title="2.1 什么是Scanner类？"></a>2.1 什么是Scanner类？</h3><p>一个可以解析基本类型和字符串的简单文本扫描器。如下代码能够使用户从System.in中获取数据：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/18/Scanner-1555573837528.png" alt="title"><br><br>System.in系统输入指的是通过键盘录入数据。</p><h3 id="2-2-引用类型使用步骤"><a href="#2-2-引用类型使用步骤" class="headerlink" title="2.2 引用类型使用步骤"></a>2.2 引用类型使用步骤</h3><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。格式：import 包名.类名;</p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>使用该类的构造方法，创建一个该类的对象。格式：数据类型 变量名 = new 数据类型(参数列表);</p><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>调用该类的成员方法，完成指定功能。格式：变量名.方法名();</p><h3 id="2-3-Scanner使用步骤"><a href="#2-3-Scanner使用步骤" class="headerlink" title="2.3 Scanner使用步骤"></a>2.3 Scanner使用步骤</h3><ul><li>java.util.Scanner:该类需要import导入后使用。</li><li>public Scanner(InputStream source):构造一个新的Scanner，它生成的值是从指定的输入流扫描的。</li><li>public int nextInt():将输入信息的下一个标记扫描为一个int值。</li></ul><p>举例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Scanner;public class Demo03ScannerMax {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int Max = 0;        for(int i = 1;i &lt; 4;i++){            System.out.println(&quot;请输入第&quot; + i + &quot;个数字：&quot;);            int temp = sc.nextInt();            if(temp &gt; Max){                Max = temp;            }        }        System.out.println(&quot;最大数是：&quot; + Max);    }}</code></pre></p><h3 id="2-4-匿名对象"><a href="#2-4-匿名对象" class="headerlink" title="2.4 匿名对象"></a>2.4 匿名对象</h3><p>匿名对象就是创建对象时，只有创建对象的语句，却没有把对象地址赋值给某个变量。没有变量名的对象就是匿名对象。</p><ul><li>格式：new 类名(参数列表);<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4></li></ul><ol><li>创建匿名对象直接调用方法，没有变量名。举例：new Scanner(System.in).nextInt();</li><li>一旦调用两次方法，就是创建了两个对象，语句执行完毕即对象销毁。</li><li>匿名对象可以作为方法的参数和返回值。<h4 id="作为参数："><a href="#作为参数：" class="headerlink" title="作为参数："></a>作为参数：</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">class Test {    public static void main(String[] args) {        &#x2F;&#x2F; 普通方式        Scanner sc = new Scanner(System.in);input(sc); &#x2F;&#x2F;匿名对象作为方法接收的参数input(new Scanner(System.in));    }    public static void input(Scanner sc){System.out.println(sc);    }}</code></pre></li></ol><h4 id="作为返回值："><a href="#作为返回值：" class="headerlink" title="作为返回值："></a>作为返回值：</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static Scanner getScanner(){        return new Scanner(System.in);    }</code></pre><h2 id="3-Random类"><a href="#3-Random类" class="headerlink" title="3. Random类"></a>3. Random类</h2><h3 id="3-1-什么是Random类"><a href="#3-1-什么是Random类" class="headerlink" title="3.1 什么是Random类"></a>3.1 什么是Random类</h3><p>此类的实例用于生产伪随机数。如下代码使用户能够得到一个随机数：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/18/Random-1555577504861.png" alt="title"></p><h3 id="3-2-Random使用三步骤"><a href="#3-2-Random使用三步骤" class="headerlink" title="3.2 Random使用三步骤"></a>3.2 Random使用三步骤</h3><ol><li>导包：import java.util.Random;</li><li>创建:Random r = new Random();</li><li>使用:获取一个随机的int数字(范围是int所有范围，有正负两种),int num = r.nextInt();</li></ol><p>举例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo05Random {    public static void main(String[] args) {        int a = 0;        while(a &lt; 100){            System.out.println(&quot;随机数是：&quot; + new Random().nextInt());            a++;        }    }}</code></pre></p><p>获取一个随机的int数字(参数代表了范围，左闭右开区间):int num = r.nextInt(3)实际含义是：[0,3),也就是0~2。</p><h4 id="猜数字小游戏"><a href="#猜数字小游戏" class="headerlink" title="猜数字小游戏"></a>猜数字小游戏</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.Random;import java.util.Scanner;public class Demo06guessNumber {    public static void main(String[] args) {        int number = new Random().nextInt(100) + 1;        int count = 0;        while (true){            System.out.println(&quot;请输入你要猜的数字(1-100)：&quot;);            int guessNumber = new Scanner(System.in).nextInt();            if(guessNumber &gt; number){                System.out.println(&quot;You enter number is big , again! &quot;);            }else if(guessNumber &lt; number){                System.out.println(&quot;You enter number is small , again!&quot;);            }else{                System.out.println(&quot;Bin1go！你使用了&quot; + count + &quot;次。&quot;);                break;            }            count++;        }    }}</code></pre><h2 id="3-ArrayList类"><a href="#3-ArrayList类" class="headerlink" title="3. ArrayList类"></a>3. ArrayList类</h2><h3 id="3-1-什么是ArrayList类？"><a href="#3-1-什么是ArrayList类？" class="headerlink" title="3.1 什么是ArrayList类？"></a>3.1 什么是ArrayList类？</h3><p>java.util.ArrayList是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。Array中可不断添加元素，其大小也自动增长。</p><h3 id="3-2-ArrayList使用步骤"><a href="#3-2-ArrayList使用步骤" class="headerlink" title="3.2 ArrayList使用步骤"></a>3.2 ArrayList使用步骤</h3><ul><li>java.util.ArrayList<e>:该类需要import导入后使用。<br><br><e>,表示一种指定的数据类型，叫做泛型。E，取自Element(元素)的首字母。在出现E的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。</e></e></li><li>基本格式：ArrayList<string> list = new ArrayList<string>();JDK7以后，右边泛型的尖括号可以留空，但&lt;&gt;仍要写。ArrayList<string> list = new ArrayList&lt;&gt;();<h3 id="3-3-常用方法和遍历"><a href="#3-3-常用方法和遍历" class="headerlink" title="3.3 常用方法和遍历"></a>3.3 常用方法和遍历</h3>对于元素的操作，基本体现在增、删、查。常用方法如下：</string></string></string></li><li>public boolean add(E e);向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。</li><li>public E get(int index);从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。</li><li>public E remove(int index);从集合中删除元素，参数是索引，返回值就是被删除的元素。</li><li>public int size();获取集合的尺寸长度，返回值是集合中包含的元素个数。</li></ul><h3 id="3-4-存储基本数据类型"><a href="#3-4-存储基本数据类型" class="headerlink" title="3.4 存储基本数据类型"></a>3.4 存储基本数据类型</h3><p>ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似<int>不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据，&lt;&gt;中的数据类型，必须转换后才能编写。转换写法如下：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/18/%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%8C%85%E8%A3%85%E7%B1%BB-1555590027103.png" alt="title"><br><br>可以发现，只有Integer和Character需要特殊记忆，其他基本类型只是首字母大写即可。那么存储基本类型数据，代码如下：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/18/Integer%E4%BD%BF%E7%94%A8%E8%B7%9D%E7%A6%BB-1555590228509.png" alt="title"><br></int></p><h4 id="自定义格式打印集合内容"><a href="#自定义格式打印集合内容" class="headerlink" title="自定义格式打印集合内容"></a>自定义格式打印集合内容</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.ArrayList;public class DemoPrintArrayList {    public static void main(String[] args) {        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;盗贼&quot;);        list.add(&quot;法师&quot;);        list.add(&quot;术士&quot;);        list.add(&quot;战士&quot;);        print(list);    }    public static void print(ArrayList&lt;String&gt; list){        System.out.print(&quot;{&quot;);        for (int i = 0;i &lt; list.size();i++){            if (i != list.size()-1){                System.out.print(list.get(i)+ &quot;@&quot;);            }else {                System.out.print( list.get(i)+ &quot;}&quot;);            }        }    }}</code></pre><h4 id="定义获取偶数元素集合方法"><a href="#定义获取偶数元素集合方法" class="headerlink" title="定义获取偶数元素集合方法"></a>定义获取偶数元素集合方法</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.util.ArrayList;import java.util.Random;&#x2F;*定义获取所有偶数元素集合的方法(ArrayList类型作为返回值) *&#x2F;public class DemoGetEvenNumber {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for(int i = 0;i &lt; 20;i++){            list.add(new Random().nextInt(1000)+1);        }        System.out.println(list);        System.out.print(getEvenNumber(list));    }    public static ArrayList&lt;Integer&gt; getEvenNumber(ArrayList&lt;Integer&gt; list){        ArrayList&lt;Integer&gt; Even = new ArrayList&lt;&gt;();        for(int i = 0;i &lt; list.size();i++){            if(list.get(i) %2 == 0){                Even.add(list.get(i));            }        }        return Even;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类和对象</title>
      <link href="/JavaBasics/class-object.html"/>
      <url>/JavaBasics/class-object.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-面向对象思想"><a href="#1-面向对象思想" class="headerlink" title="1. 面向对象思想"></a>1. 面向对象思想</h2><h3 id="1-1-面向对象思想概述"><a href="#1-1-面向对象思想概述" class="headerlink" title="1.1 面向对象思想概述"></a>1.1 面向对象思想概述</h3><p>Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计，开发计算机程序。这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p><a id="more"></a><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li>洗衣服：<ul><li>面向过程：把衣服脱下来–&gt;找一个盆–&gt;放点洗衣粉–&gt;加点水–&gt;浸泡10分钟–&gt;揉一揉–&gt;清洗衣服–&gt;拧干–&gt;晾起来</li><li>面向对象：把衣服脱下来–&gt;打开全自动洗衣机–&gt;放衣服–&gt;开启洗衣机–&gt;晾起来</li></ul></li><li>区别：<ul><li>面向过程：强调步骤</li><li>面向对象：强调对象，这里对象指洗衣机<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。面向对象的语言中，包含了三大基本特征，即封装、继承和多态。</li></ul></li></ul><h3 id="1-2-类和对象"><a href="#1-2-类和对象" class="headerlink" title="1.2 类和对象"></a>1.2 类和对象</h3><h4 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a>什么是类？</h4><ul><li>类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</li><li>属性：就是该类事物的状态信息</li><li>行为：就是该类事物能够做什么事</li><li>举例：小猫。属性：名字，颜色，年龄，体重。行为：走，跳，叫，吃。<h4 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h4></li><li>对象：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为。</li><li>现实中，一类事物(猫类)的一个实例:一只小猫。</li><li>举例：一只小猫。属性：tom，5kg，2years，yellow。行为：反复横跳，喵喵叫，吃饭。<h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4></li><li>类是对一类事物的描述，是抽象的。</li><li>对象是一类事物的实例，是具体的，实际存在的。</li><li>类是对象的模板，对象是类的实体。</li></ul><h3 id="1-3-类的定义"><a href="#1-3-类的定义" class="headerlink" title="1.3 类的定义"></a>1.3 类的定义</h3><h4 id="事物与类的对比"><a href="#事物与类的对比" class="headerlink" title="事物与类的对比"></a>事物与类的对比</h4><p>现实世界的一类事物：</p><ul><li>属性：事物的状态信息。</li><li>行为：事物能够做什么。<br>Java中用class描述事物也是如此：</li><li>成员变量：对应事物的属性。</li><li>成员方法：对应事物的行为。<h4 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h4><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/%E7%B1%BB%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F-1555469808569.png" alt="title"></li><li>定义类：就是定义类的成员，包括成员变量和成员方法。</li><li>成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。</li><li>成员方法：和以前定义方法几乎一样的。只不过把static去掉。<br><br>举例：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Student {    &#x2F;&#x2F;成员变量;    String name; &#x2F;&#x2F; 姓名    int age; &#x2F;&#x2F;年龄    &#x2F;&#x2F;成员方法    public void eat(){        System.out.println(&quot;吃饭饭&quot;);    }    public void sleep(){        System.out.println(&quot;睡觉觉&quot;);    }    public void study() {        System.out.println(&quot;学习&quot;);    }}</code></pre></li></ul><h3 id="1-4-对象的使用"><a href="#1-4-对象的使用" class="headerlink" title="1.4 对象的使用"></a>1.4 对象的使用</h3><h4 id="对象的使用格式"><a href="#对象的使用格式" class="headerlink" title="对象的使用格式"></a>对象的使用格式</h4><ul><li>使用步骤1，导包：也就是指出需要使用的类，在什么位置，同一包下可省略导包步骤。<br>import 包名称.类名称;<br>import com.zero.demo.demo03_Class.Student;</li><li>步骤2，创建对象：类名 对象名 = new 类名();</li><li>步骤3，使用对象访问类中成员:<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98-1555470287058.png" alt="title"></li></ul><p>举例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo03Student {    public static void main(String[] args){        Student stu = new Student();        System.out.println(stu.name = &quot;校长&quot;);        System.out.println(stu.age = 55);        stu.eat();        stu.sleep();        stu.study();    }}</code></pre></p><p>注意：如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样。</p><h4 id="成员变量的默认值"><a href="#成员变量的默认值" class="headerlink" title="成员变量的默认值"></a>成员变量的默认值</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E5%80%BC-1555471157001.png" alt="title"></p><h3 id="1-5-对象内存图"><a href="#1-5-对象内存图" class="headerlink" title="1.5 对象内存图"></a>1.5 对象内存图</h3><p>一个对象，调用一个方法内存图：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE-1555472618000.png" alt="title"><br>两个对象，调用一个方法内存图：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/two%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE-1555482190913.png" alt="title"><br>两个引用指向同一个对象的内存图：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E5%AF%B9%E8%B1%A1-1555482832109.png" alt="title"><br>使用对象类型作为方法的参数：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-1555484961711.png" alt="title"></p><h3 id="1-6-成员变量和局部变量的区别"><a href="#1-6-成员变量和局部变量的区别" class="headerlink" title="1.6 成员变量和局部变量的区别"></a>1.6 成员变量和局部变量的区别</h3><p>变量根据定义位置的不同，变量有不同的名字</p><ul><li>在类中的位置不同<em>重点</em><ul><li>成员变量：类中，方法外</li><li>局部变量：方法中或者方法声明上(形参)</li></ul></li><li>作用范围不一样<em>重点</em><ul><li>成员变量：类中</li><li>局部变量：方法中</li></ul></li><li>初始化值的不同<em>重点</em><ul><li>成员变量：有默认值</li><li>局部变量：无默认值。必须先定义，赋值，才能使用。</li></ul></li><li>在内存中的位置不同(了解)<ul><li>成员变量：堆内存</li><li>局部变量：栈内存</li></ul></li><li>生命周期不同(了解)<ul><li>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</li><li>局部变量：随着方法进栈而诞生，随着方法出栈而消失<h2 id="2-三大特征之一：封装"><a href="#2-三大特征之一：封装" class="headerlink" title="2. 三大特征之一：封装"></a>2. 三大特征之一：封装</h2><h3 id="2-1-封装概述"><a href="#2-1-封装概述" class="headerlink" title="2.1 封装概述"></a>2.1 封装概述</h3>面向对象编程语言是对象客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4>将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。<h3 id="2-2-封装的步骤"><a href="#2-2-封装的步骤" class="headerlink" title="2.2 封装的步骤"></a>2.2 封装的步骤</h3></li></ul></li></ul><ol><li>使用private关键字来修饰成员变量。</li><li>对需要访问的成员变量，提供对应的一对getxxx方法、setxxx方法。</li></ol><h3 id="2-3-封装的操作–private关键字"><a href="#2-3-封装的操作–private关键字" class="headerlink" title="2.3 封装的操作–private关键字"></a>2.3 封装的操作–private关键字</h3><h5 id="private的含义"><a href="#private的含义" class="headerlink" title="private的含义"></a>private的含义</h5><ol><li>private是一个权限修饰符，代表最小权限。</li><li>可以修饰成员变量和成员方法。</li><li>被private修饰后的成员变量和成员方法，只能在本类中才能访问。<h4 id="private的使用格式"><a href="#private的使用格式" class="headerlink" title="private的使用格式"></a>private的使用格式</h4><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/private%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F-1555489770741.png" alt="title"></li></ol><p>举例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Student {private String name; &#x2F;&#x2F; 使用private修饰成员变量private int age;}&#x2F;&#x2F; 定义getxxx方法和setxxx方法，提供对外接口public class Student {    private String name;    private int age;    public void setName(String n) {name = n;}    public String getName() {return name;}    public void setAge(int a) {age = a;}    public int getAge() {return age;}}</code></pre></p><h3 id="2-4-封装优化–this关键字"><a href="#2-4-封装优化–this关键字" class="headerlink" title="2.4 封装优化–this关键字"></a>2.4 封装优化–this关键字</h3><p>如果方法形参和成员变量名一致，会导致成员变量赋值失败。 这是由于形参变量名与成员变量名重名，导致成员变量名被隐藏，方法中的变量名，无法访问到成员变量，从而赋值失败。我们需使用this关键字，来解决这个重名问题。</p><h4 id="this的含义"><a href="#this的含义" class="headerlink" title="this的含义"></a>this的含义</h4><p>this代表所在类的当前对象的引用(地址值)，即对象自己的引用。</p><ul><li>使用格式：this.成员变量名;</li></ul><p>举例:</p><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/this%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96-1555491440061.png" alt="title"></p><h3 id="2-5-封装优化–构造方法"><a href="#2-5-封装优化–构造方法" class="headerlink" title="2.5 封装优化–构造方法"></a>2.5 封装优化–构造方法</h3><p>当一个对象被创建时，构造方法用来初始化该对象，给对象的成员变量赋初始值。</p><h4 id="构造方法的定义格式"><a href="#构造方法的定义格式" class="headerlink" title="构造方法的定义格式"></a>构造方法的定义格式</h4><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F-1555491533588.png" alt="title"><br><br>构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，也不需要void。举例如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Student {    private String name;    private int age;    &#x2F;&#x2F; 无参数构造方法    public Student() {}    &#x2F;&#x2F; 有参数构造方法    public Student(String name,int age) {this.name = name;this.age = age;}}</code></pre></p><p>注意事项：</p><ol><li>构造方法的名称必须和所在的类名称完全一模一样。</li><li>构造方法不要写返回值类型，连void都不写。</li><li>构造方法不能return一个具体的返回值。</li><li>如果没有编写任何构造方法，那么编译器会默认生成一个，没有参数，方法体也为空。public Student(){}；</li><li>一般编写了至少一个构造方法，那么编译器将不再生成。</li></ol><h3 id="2-6-标准代码–JavaBean"><a href="#2-6-标准代码–JavaBean" class="headerlink" title="2.6 标准代码–JavaBean"></a>2.6 标准代码–JavaBean</h3><p>JavaBean是Java语言编写类的一种标志规范。符合JavaBean的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的set和get方法。所以一个标准类通常要拥有下面四个组成部分：</p><ol><li>所有的成员变量都要使用private关键字修饰。</li><li>为每个成员变量编写一对getxxx/setxxx方法。</li><li>编写一个无参数的构造方法。</li><li>编写一个全参数的构造方法。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class ClassName{    &#x2F;&#x2F;成员变量    &#x2F;&#x2F;构造方法    &#x2F;&#x2F;无参构造方法【必须】    &#x2F;&#x2F;有参构造方法【建议】    &#x2F;&#x2F;成员方法    &#x2F;&#x2F;getXxx()    &#x2F;&#x2F;setXxx()}</code></pre></li></ol><p>编写符合JavaBean规范的类，以学生类为例，标准代码如下：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class JavaBeanStudent {    private String name;    private  int age;    public JavaBeanStudent() {    }    public JavaBeanStudent(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre></p><p>以上代码可以通过Code-&gt;Generate功能自动生成：<br><br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/17/JavaBean%20%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90-1555493892266.png" alt="title"></p>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组</title>
      <link href="/JavaBasics/array.html"/>
      <url>/JavaBasics/array.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><ul><li>数组的基本概念：数组就是存储数据长度固定的容器，包装多个数据的数据类型要一致。</li><li>容器：是将多个数据存储在一起，每个数据称为该容器的元素。</li><li>数组的特点：<ul><li>数组是一种引用数据类型。</li><li>数组当中的多个数据，类型必须统一。</li><li>数组的长度在程序运行期间不可改变。</li></ul></li></ul><a id="more"></a><h2 id="1-数组的定义和访问"><a href="#1-数组的定义和访问" class="headerlink" title="1. 数组的定义和访问"></a>1. 数组的定义和访问</h2><h3 id="1-1-数组的定义"><a href="#1-1-数组的定义" class="headerlink" title="1.1 数组的定义"></a>1.1 数组的定义</h3><ul><li>数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。</li><li>两种常见的初始化方式：<ul><li>动态初始化（指定长度）</li><li>静态初始化（指定内容）</li></ul></li><li>动态初始化格式：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/16/%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-1555383964746.png" alt="title"></li><li>数组定义格式详解：<ul><li>数组存储的数据类型：创建的数组容器可以存储什么数据类型。</li><li>[]:表示数组。</li><li>数组的名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</li><li>new：关键字，创建数组使用的关键字。</li><li>数组存储的数据类型：创建的数组容器可以存储什么数据类型。</li><li>[长度]：数组的长度，表示数组容器中可以存储多少个元素。</li><li>注意：数组有定长特性，长度一旦指定，不可更改。类似你买一个水杯，买了一个1升的水杯，总容量就是1升，不多不少。</li></ul></li><li><p>举例：定义可以存储3个整数的数组容器，代码如下：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">int[] arr = new int[3];</code></pre></li><li><p>静态初始化标准格式：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/16/%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-1555384404508.png" alt="title"></p></li><li><p>举例：定义存储1,2,3,4,5整数的数组容器。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">int[] arr = new int[]{1,2,3,4,5};</code></pre></li><li><p>静态初始化省略格式：</p></li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/16/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15553845603050-1555384614682.png" alt="title"></p><ul><li>举例：定义存储1,2，3整数的数组容器：<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">int[] arr = {1,2,3};</code></pre></li></ul><p>注意：</p><ol><li>静态初始化没有直接指定长度，但仍然会自动推算得到长度。</li><li>静态初始化标准格式可以拆分为两个步骤。</li><li>动态初始化也可以拆分成为两个步骤。</li><li>静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。</li><li>不确定数组当中具体内容，使用动态初始化；确认了具体内容，用静态初始化。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;静态初始化的标准格式拆分：int[] arrayA;arrayA = new int[]{1,2,3};&#x2F;&#x2F;动态初始化的拆分步骤：int[] arrayB;arrayB = new intp[3];</code></pre></li></ol><h3 id="1-2-数组的访问"><a href="#1-2-数组的访问" class="headerlink" title="1.2 数组的访问"></a>1.2 数组的访问</h3><ul><li>索引：每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引(index),可以通过数组的索引访问到数组中的元素。</li><li>格式：数组名[索引]</li><li><p>数组长度属性：每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度，语句为：数据名.length。属性length的执行结果是数组的长度，int类型结果。由此可以推断出，数组的最大索引值为数组名.length-1。</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02ArrayUse {    public static void main(String[] agrs){        int[] arr = new int[]{1,2,3,4,5};        System.out.println(arr.length);        System.out.println(arr[arr.length-1]);    }}</code></pre></li><li><p>索引访问数组中的元素：</p><ul><li>数组名[索引]=数组，为数组中的元素赋值</li><li>变量=数组名[索引]，获取数组中的元素</li></ul></li></ul><h2 id="2-数组原理内存图"><a href="#2-数组原理内存图" class="headerlink" title="2. 数组原理内存图"></a>2. 数组原理内存图</h2><h3 id="2-1-内存概述"><a href="#2-1-内存概述" class="headerlink" title="2.1 内存概述"></a>2.1 内存概述</h3><p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。<br>Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p><h3 id="2-1-Java虚拟机的内存划分"><a href="#2-1-Java虚拟机的内存划分" class="headerlink" title="2.1 Java虚拟机的内存划分"></a>2.1 Java虚拟机的内存划分</h3><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p><ul><li>JVM的内存划分：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/16/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86-1555393728931.png" alt="title"></li></ul><p>Java内存需划分为5个部分：</p><ol><li>==栈(Stack)==：存放的都是方法中的局部变量。方法运行时使用的内存。<ul><li>局部变量：方法的参数，或者是方法{}内部的变量</li><li>作用域：一旦超出作用域，立刻从栈内存当中消失。</li></ul></li><li>==堆(Heap)==：凡是new出来的东西，都在堆当中。存储对象或数组。    <ul><li>堆内存里面的东西都有一个地址值：16进制</li><li>堆内存里面的数据，都有默认值。规则：</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%BB%98%E8%AE%A4%E5%80%BC-1555394445700.png" alt="title"></p><ol start="3"><li>==方法区(Method Area)==：存储.class相关信息，包含方法的信息。</li><li>本地方法栈(Native Method Stack)：与操作系统相关。</li><li>寄存器(pc Register)：与CPU相关。</li></ol><h3 id="2-2-数据在内存中的存储"><a href="#2-2-数据在内存中的存储" class="headerlink" title="2.2 数据在内存中的存储"></a>2.2 数据在内存中的存储</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02ArrayOne {    public static void main(String[] args){        int[] arr = new int[3];        System.out.println(arr); &#x2F;&#x2F; [I@5f184fc6    }}</code></pre><p>以上方法执行，输出结果是[I@5f184fc6。这个是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的内存地址。<br><br>一个数组内存图：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/16/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE%E8%AF%A6%E8%A7%A3-1555396483239.png" alt="title"><br>两个数组内存图：<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/16/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE-1555397156716.png" alt="title"></p><h2 id="3-数组的常见操作"><a href="#3-数组的常见操作" class="headerlink" title="3. 数组的常见操作"></a>3. 数组的常见操作</h2><h3 id="3-1-数组越界异常"><a href="#3-1-数组越界异常" class="headerlink" title="3.1 数组越界异常"></a>3.1 数组越界异常</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static void main(String[] args){    int[] arr = {1,2,3};    System.out.print(arr[3]);}</code></pre><p>创建数组，赋值3个元素，数组索引就是0,1,2,没有索引3。如果我们访问了数组中不存在的索引，程序运行后就会抛出<code>ArrayIndexOutOfBoundsException</code>数组越界异常。</p><h3 id="3-2-数组空指针异常"><a href="#3-2-数组空指针异常" class="headerlink" title="3.2 数组空指针异常"></a>3.2 数组空指针异常</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02ArrayNull {    public static void main(String[] args){        int [] array = null;        &#x2F;&#x2F; array = new int[3];        System.out.println(array[0]);    }}</code></pre><p>所有的引用类型变量，都可以赋值为一个null值。但代表其中什么都没有。</p><ul><li>数组必须进行new初始化才能使用其中的元素，如果赋值一个null，没有进行new创建数组，程序运行后将出现<code>NullPointerException</code>空指针异常。</li></ul><h3 id="3-3-数组遍历"><a href="#3-3-数组遍历" class="headerlink" title="3.3 数组遍历"></a>3.3 数组遍历</h3><ul><li>数组遍历：将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02Array_bianli {    public static void main(String[] args){        int[] arr = {1,2,3,4,5};        for(int i = 0;i &lt; arr.length;i++){            System.out.println(arr[i]);        }    }}</code></pre></li></ul><h3 id="3-4-数组获取最大值元素"><a href="#3-4-数组获取最大值元素" class="headerlink" title="3.4 数组获取最大值元素"></a>3.4 数组获取最大值元素</h3><ul><li>最大值获取：从数组的所有元素中找出最大值。</li><li>实现思路：<ul><li>定义变量，保存数组0索引上的元素</li><li>遍历数组，获取出数组中的每个元素</li><li>将遍历到的元素和保存数组0索引上值的变量进行比较</li><li>如果数组元素值大于保存变量值，则重新赋值给变量，替换掉</li><li>数组循环遍历结束，变量中保存的就是数组中的最大值<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Demo02ArrayMAX {    public static void main(String[] args){        int[] arr = {5,15,2000,10000,100,4000};        int max = 0;        for(int i = 0;i &lt; arr.length;i++){            if(arr[i] &gt; max){                max = arr[i];            }        }        System.out.println(&quot;arr数组最大值为：&quot; + max);    }}</code></pre></li></ul></li></ul><h3 id="3-5-数组反转"><a href="#3-5-数组反转" class="headerlink" title="3.5 数组反转"></a>3.5 数组反转</h3><ul><li>数组的反转：数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1</li><li>实现思路：数组最远端的元素互换位置</li><li>定义两个变量，保存数组的最小索引和最大索引</li><li>两个索引上的元素交换位置</li><li>最小索引++，最大索引–，再次交换位置</li><li>最小索引超过了最大索引，数组反转操作结束</li></ul><h2 id="4-数组作为方法参数和返回值"><a href="#4-数组作为方法参数和返回值" class="headerlink" title="4. 数组作为方法参数和返回值"></a>4. 数组作为方法参数和返回值</h2><h3 id="4-1-数组作为方法参数"><a href="#4-1-数组作为方法参数" class="headerlink" title="4.1 数组作为方法参数"></a>4.1 数组作为方法参数</h3><p>以前的方法中我们学习了方法的参数和返回值，但是使用的都是基本数据类型。</p><ul><li>数组作为方法参数传递，传递的参数是数组内存的地址。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/16/reverse-1555405679573.png" alt="title"></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA的安装与激活</title>
      <link href="/JavaBasics/install-idea.html"/>
      <url>/JavaBasics/install-idea.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IDEA是一个专门针对Java的集成开发工具(IDE)，由Java语言编写。所以，需要有JRE运行环境并配置好环境变量。<br>它可以极大地提升我们的开发效率。可以自动编译，检查错误。</p><a id="more"></a><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li>官网下载IDE安装包<br><a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ官网</a></li><li>agent破解方式<br>详见<a href="https://zhile.io/" target="_blank" rel="noopener">zhile.io</a> 破解教程</li></ol><blockquote><p>仅供个人学习研究使用，不得用于商业用途！若资金允许请点击<a href="https://www.jetbrains.com/idea/buy/" target="_blank" rel="noopener">链接</a>支持正版</p></blockquote><h3 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h3><ol><li>新建一个项目，然后点击src文件夹，右击新建package，新建包后右键新建一个class，编写一个HelloWorld程序验证一下是否正常运行。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/15/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15552997771553-1555299788468.png" alt="title"></li><li>IDEA工具默认字体非常小，代码编辑器和控制台的输出字体都需进行调整</li></ol><ul><li>点击菜单栏上的File&gt;Settings&gt;Editor&gt;Font修改字体。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/15/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15552998363731-1555299845339.png" alt="title"></li></ul><h3 id="IDEA的项目目录"><a href="#IDEA的项目目录" class="headerlink" title="IDEA的项目目录"></a>IDEA的项目目录</h3><ul><li>.idea目录和demo.iml和我们开发无关，是IDEA工具自己使用的</li><li>out目录是存储编译后的.class文件</li><li>src目录是存储我们编写的.java源文件<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/15/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15553000533050-1555300185262.png" alt="title"></li></ul><h3 id="IEAD常用快捷键"><a href="#IEAD常用快捷键" class="headerlink" title="IEAD常用快捷键"></a>IEAD常用快捷键</h3><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/15/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15553002176364-1555300220987.png" alt="title"></p>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java流程控制语句</title>
      <link href="/JavaBasics/flow.html"/>
      <url>/JavaBasics/flow.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>在一个程序执行中，各条语句的执行顺序对程序的结果是有直接影响的。所以必须清楚每条语句的执行流程，而且，我们需要通过控制语句的执行顺序来实现我们要完成的功能。</p><a id="more"></a><h3 id="1-if-else-判断语句"><a href="#1-if-else-判断语句" class="headerlink" title="1. if else 判断语句"></a>1. if else 判断语句</h3><h4 id="1-1-if语句第一种格式：if"><a href="#1-1-if语句第一种格式：if" class="headerlink" title="1.1 if语句第一种格式：if"></a>1.1 if语句第一种格式：if</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">if(关系表达式){    语句体；}</code></pre><ul><li><p>执行流程</p><ul><li>首先判断关系表达式其结果是true还是false</li><li>如果是true就执行语句体</li><li>如果是false就不执行语句体<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/14/if-1555208361145.png" alt="title"><h4 id="1-2-if语句第二种格式：if…else"><a href="#1-2-if语句第二种格式：if…else" class="headerlink" title="1.2 if语句第二种格式：if…else"></a>1.2 if语句第二种格式：if…else</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">if(关系表达式){    语句体1；}else{    语句体2；}</code></pre></li></ul></li><li><p>执行流程</p><ul><li>首先判断关系表达式看其结果是true还是false</li><li>如果是true就执行语句体1</li><li>如果是false就执行语句体2<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/14/if_else-1555208575720.png" alt="title"><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static void main(String[] args){    &#x2F;&#x2F; 判断给定的数据是奇数还是偶数    &#x2F;&#x2F; 定义变量    int a = 1;    if(a % 2 == 0) {        System.out.println(&quot;a是偶数&quot;);    } else{        System.out.println(&quot;a是奇数&quot;);    }    System.out.println(&quot;结束&quot;);}</code></pre></li></ul></li></ul><h4 id="1-3-if语句第三种格式：if…else-if…else"><a href="#1-3-if语句第三种格式：if…else-if…else" class="headerlink" title="1.3 if语句第三种格式：if…else if…else"></a>1.3 if语句第三种格式：if…else if…else</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">if (判断条件1) {    执行语句1;} else if (判断条件2) {    执行语句2;}...}else if (判断条件n) {    执行语句n;} else {    执行语句n+1;}</code></pre><ul><li>执行流程<ul><li>首先判断关系表达式1看其结果是true还是false</li><li>如果是true就执行语句体1</li><li>如果是false就继续判断关系表达式2看其结果是true还是false</li><li>true则执行语句体2，false就继续往下判断</li><li>如果没有任何关系表达式为true，则执行else语句体<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/14/ifelseifelse-1555209112731.png" alt="title"></li></ul></li></ul><h3 id="2-switch选择语句"><a href="#2-switch选择语句" class="headerlink" title="2. switch选择语句"></a>2. switch选择语句</h3><h4 id="2-1-选择语句–switch"><a href="#2-1-选择语句–switch" class="headerlink" title="2.1 选择语句–switch"></a>2.1 选择语句–switch</h4><ul><li><p>switch语句格式：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">switch(表达式){    case 常量值1：        语句体1；break；    case 常量值2：语句体2；break；    ...    default:语句体n+1;break;}</code></pre></li><li><p>执行流程</p><ul><li>首先计算表达式的值</li><li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。</li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束。<br><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/14/switch-1555210158065.png" alt="title"></li></ul></li></ul><p>实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class switch_exercise {public static void main(String[] agrs) {int weekday = 6;switch(weekday) {case 1:System.out.println(&quot;今天星期一&quot;);break;case 2:System.out.println(&quot;今天星期二&quot;);break;case 3:System.out.println(&quot;今天星期三&quot;);break;case 4:System.out.println(&quot;今天星期四&quot;);break;case 5:System.out.println(&quot;今天星期五&quot;);break;case 6:System.out.println(&quot;今天星期六&quot;);break;case 7:System.out.println(&quot;今天星期日&quot;);break;default:System.out.println(&quot;输入数据有误&quot;);break;}}}</code></pre></p><p>switch语句使用的注意事项：</p><ol><li>多个case后面的数值不可重复。</li><li>switch后面小括号中只能是下列数据类型：<ul><li>基本数据类型：byte/short/char/int</li><li>引用数据类型：String字符串、enum枚举</li></ul></li><li>switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略，但需要考虑case穿透性。<br>“匹配哪一个case就从哪一个位置向下执行，直到遇到break或者整体结束为止。”</li></ol><h4 id="2-2-case的穿透性"><a href="#2-2-case的穿透性" class="headerlink" title="2.2 case的穿透性"></a>2.2 case的穿透性</h4><p>在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。<br>故编写switch语句时，必须写上break。</p><h3 id="3-for循环语句"><a href="#3-for循环语句" class="headerlink" title="3. for循环语句"></a>3. for循环语句</h3><h4 id="3-1-循环概述"><a href="#3-1-循环概述" class="headerlink" title="3.1 循环概述"></a>3.1 循环概述</h4><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句。当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。</p><h4 id="3-2-循环语句–for"><a href="#3-2-循环语句–for" class="headerlink" title="3.2 循环语句–for"></a>3.2 循环语句–for</h4><ul><li><p>for循环语句格式：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">for（初始化表达式1；布尔表达式2；步进表达式4）{循环体3；}</code></pre></li><li><p>执行流程</p><ul><li>执行顺序：1234&gt;234&gt;234…直到2不满足为止。</li><li>1负责完成循环变量初始化</li><li>2负责判断是否满足循环条件，不满足则跳出循环</li><li>3具体执行的语句</li><li>4循环后，循环条件所涉及变量的变化情况</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/14/for-1555210990394.png" alt="title"></p><p>实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class for_exercise {public static void main(String[] args) {int sum = 0;for (int i = 1;i &lt;= 100;i++) {if(i % 2 == 0) {sum += i;}}System.out.println(&quot;sum:&quot; + sum);}}</code></pre></p><h3 id="4-while循环语句"><a href="#4-while循环语句" class="headerlink" title="4. while循环语句"></a>4. while循环语句</h3><ul><li><p>while循环语句格式：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">初始化表达式1：    while（布尔表达式2）{循环体3；步进表达式4；}</code></pre></li><li><p>执行流程</p><ul><li>执行顺序：1234&gt;234&gt;234&gt;234…直到2不满足为止。</li><li>1负责完成循环变量初始化。</li><li>2负责判断是否满足循环条件，不满足则跳出循环。</li><li>3具体执行的语句。</li><li>4循环后，循环变量的变化情况。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/14/while-1555221264283.png" alt="title"></p><p>实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class while_exercise {public static void main(String[] agrs) {int sum = 0;int i = 1;while(i &lt;= 100) {sum += i;i++;}System.out.println(&quot;1~100的值为：&quot; + sum);}}</code></pre></p><h3 id="5-do-while循环语句"><a href="#5-do-while循环语句" class="headerlink" title="5. do while循环语句"></a>5. do while循环语句</h3><ul><li><p>do…while循环格式：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">初始化表达式1    do{循环体3；步进表达式4；}while（布尔表达式2）；</code></pre></li><li><p>执行流程</p><ul><li>执行顺序：134&gt;234&gt;234…知道2不满足为止。</li><li>1负责完成循环变量初始化。</li><li>2负责判断是否满足循环条件，不满足则跳出循环。</li><li>3具体执行的语句</li><li>4循环后，循环变量的变化情况</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zero6996/GitNote-images/master/GitNote/2019/04/14/do...while-1555221971998.png" alt="title"></p><p>实例：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class do_while_exercise {public static void main(String[] args) {int i = 1;do {System.out.println(&quot;hello:&quot; + i);i++;}while(i&lt;=10);}}</code></pre></p><p>Tips：do…while循环特点是会无条件执行一次循环体，即使我们将循环条件写出false，也依然会循环一次。这样的循环具有一定风险，不推荐使用。</p><h3 id="7-循环语句的区别"><a href="#7-循环语句的区别" class="headerlink" title="7.循环语句的区别"></a>7.循环语句的区别</h3><ul><li>三种循环的小区别：<ul><li>控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率</li><li>在已知循环次数的时候推荐使用for，循环次数未知时推荐使用while。</li><li>如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do…while循环会执行至少一次。</li><li>for循环的变量在小括号当中定义，只有循环内部可以使用。while循环和do…while循环初始化语句本来就在外面，所以出了循环可以继续使用。</li></ul></li></ul><h3 id="8-跳出语句"><a href="#8-跳出语句" class="headerlink" title="8. 跳出语句"></a>8. 跳出语句</h3><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><ul><li>使用场景：终止switch或者循环<ul><li>在选择结构switch语句中</li><li>在循环语句中</li><li>离开使用场景的存在是没有意义的</li></ul></li></ul><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><ul><li>使用场景：结束本次循环，继续下一次循环</li></ul><h3 id="9-扩展知识点"><a href="#9-扩展知识点" class="headerlink" title="9.扩展知识点"></a>9.扩展知识点</h3><h4 id="9-1嵌套循环"><a href="#9-1嵌套循环" class="headerlink" title="9.1嵌套循环"></a>9.1嵌套循环</h4><ul><li>所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总共的循环次数 = 外循环次数 * 内循环次数</li><li><p>嵌套循环格式：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">for(初始化表达式1；循环条件2；步进表达式7){    for(初始化表达式3；循环条件4；步进表达式6){执行语句5；    }}</code></pre></li><li><p>嵌套循环执行流程：</p><ul><li>执行顺序：123456&gt;456&gt;723456&gt;456</li><li>外循环一次，内循环多次</li><li>比如跳绳：一共5组，每组跳10个。5组就是外循环，10个就是内循环。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java运算符</title>
      <link href="/JavaBasics/operator.html"/>
      <url>/JavaBasics/operator.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><ul><li><code>+</code> ：加法运算，字符串连接运算</li><li><code>-</code> : 减法运算</li><li><code>*</code> : 乘法运算</li><li><code>/</code> : 除法运算</li><li><code>%</code> : 取模运算，两个数字相除取余数</li><li><code>++</code>,<code>--</code> : 自增自减运算</li></ul><a id="more"></a><p>Java中，整数使用以上运算符，不会得到小数。</p><ul><li>++运算，变量自增长1。反之，–运算，变量自己减少1。<ul><li>独立运算：++i和i++没有区别</li><li>混合运算：和其他变量放在一起，++i和i++就有不同结果。</li></ul></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;变量前++：变量a自己先+1，将加1后的结果赋值给b，也就是说a先计算后赋值。public static void main(String[] args) {    int a = 1;    int b = ++a;    System.out.println(a);&#x2F;&#x2F;计算结果是2    System.out.println(b);&#x2F;&#x2F;计算结果是2}&#x2F;&#x2F;变量后++：变量a先把自己的值1，赋值给变量b，此时b值就是1，变量a自己再加1，a值就是2。先赋值后计算。public static void main(String[] args) {    int a = 1;    int b = a++;    System.out.println(a);&#x2F;&#x2F;计算结果是2    System.out.println(b);&#x2F;&#x2F;计算结果是1}</code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul><li><code>=</code>  : 等于号</li><li><code>+=</code> : 加等于</li><li><code>-=</code> : 减等于</li><li><code>*=</code> : 乘等于</li><li><code>/=</code> : 除等于</li><li><code>%=</code> : 取模</li></ul><p>赋值运算符，就是将符号右边的值，赋给左边的变量。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul><li><code>==</code> : 比较符号两边数据是否相等，相等结果是true。</li><li><code>&lt;</code> : 比较符号左边的数据是否小于右边的数据，如果小于结果是true。</li><li><code>&gt;</code> : 比较符号左边的数据是否大于右边的数据，如果大于结果是true。</li><li><code>&lt;=</code> : 比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是true。</li><li><code>&gt;=</code> : 比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是true。</li><li><code>!=</code> : 不等于符号 ，如果符号两边的数据不相等，结果是true。<br>比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值，true或者false。</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><em>&amp;&amp;短路与</em></p><ol><li>两边都真，则真</li><li>一边是假，则假<br>短路特定：如果左边遇假则可以得到最终结果，右边不再运算</li></ol><p><em>||短路或</em></p><ol><li>两边都假，则假</li><li>一边是真，则真<br>短路特点：如果左边遇真则可以得到最终结果，右边不再运算</li></ol><p><em>！取反</em></p><ol><li>！true 则是假</li><li>！false 则是真<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 falsepublic static void main(String[] args) {    System.out.println(true &amp;&amp; true);&#x2F;&#x2F;true    System.out.println(true &amp;&amp; false);&#x2F;&#x2F;false    System.out.println(false &amp;&amp; true);&#x2F;&#x2F;false，右边不计算    System.out.println(false || false);&#x2F;&#x2F;falase    System.out.println(false || true);&#x2F;&#x2F;true    System.out.println(true || false);&#x2F;&#x2F;true，右边不计算    System.out.println(!false);&#x2F;&#x2F;true}</code></pre></li></ol><p>TIPS：</p><ol><li>逻辑运算符只能用于boolean值。</li><li>与、或需要左右各自有一个boolean值，但是取反只要有唯一一个boolean值即可。</li><li>与、或两种运算符，如果有多个条件，可以连续写。多个条件：条件A &amp;&amp; 条件B &amp;&amp; 条件C</li></ol><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><ul><li><p>三元运算符格式：<br>数据类型 变量名 = 布尔类型表达式？结果1：结果2</p></li><li><p>三元运算符计算方式：</p></li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。&#x2F;&#x2F;布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。public static void main(String[] args) {    int i = (1==2 ? 100 : 200);    System.out.println(i);&#x2F;&#x2F;200    int j = (3&lt;=4 ? 500 : 600);    System.out.println(j);&#x2F;&#x2F;500}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java修饰符</title>
      <link href="/JavaBasics/Modification.html"/>
      <url>/JavaBasics/Modification.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java语言提供了很多修饰符,主要分为以下两类:</p><ul><li>访问修饰符</li><li>非访问修饰符<br>修饰符用来定义类、方法或者变量，通常放在语句的最前端。</li></ul><a id="more"></a><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>Java中，可以使用==访问控制符==来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。</p><ul><li>default（即缺省，什么也不写）：在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>private：在同一类内可见。使用对象：变量、方法。注意：不能修饰类（外部类）</li><li>public：对所有类可见。使用对象：类、接口、变量、方法</li><li>protected：对同一包内的类和所有子类可见。使用对象：变量，方法。注意：不能修饰类（外部类）。</li></ul><h4 id="默认访问修饰符-不使用任何关键字"><a href="#默认访问修饰符-不使用任何关键字" class="headerlink" title="默认访问修饰符-不使用任何关键字"></a>默认访问修饰符-不使用任何关键字</h4><p>使用默认访问修饰符声明的变量和方法，对同一包内的类是可见的。接口里的变量都隐式声明为public static final，而接口里的方法默认情况下访问权限为publi。<br>如下例，变量和方法的声明可以不使用任何修饰符<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">String version = &quot;3.0.3&quot;;boolean processOrder(){    return true;}</code></pre></p><h4 id="私有访问修饰符-private"><a href="#私有访问修饰符-private" class="headerlink" title="私有访问修饰符-private"></a>私有访问修饰符-private</h4><p>私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。<br>声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。<br>Private访问控制修饰符的使用主要用来隐藏类的实现细节和保护类的数据。<br>下面的类使用了私有访问控制符：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Logger{    private String format;    public String getFormat(){return this.format;    }    public void setFormat(String format){this.format = format;    }}</code></pre></p><p>实例中，Logger类中的format变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个public方法：getFormat()（能够返回format的值）和setFormat(String)（设置format的值）</p><h4 id="公有访问修饰符-public"><a href="#公有访问修饰符-public" class="headerlink" title="公有访问修饰符-public"></a>公有访问修饰符-public</h4><p>被声明为public的类、方法、构造方法和接口能够被任何其他类访问。<br>如果几个相互访问的public类分布在不同的包中，则需要导入相应public类所在包。由于类的继承性，类的所有公有方法和变量都能被其子类继承。<br>以下函数使用了公有访问控制：<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public static void main(String[] args){&#x2F;&#x2F; ...}</code></pre></p><p>Java程序的main()方法必须设置公有的，否则，Java解释器将不能运行该类。</p><h4 id="受保护的访问修饰符-protected"><a href="#受保护的访问修饰符-protected" class="headerlink" title="受保护的访问修饰符-protected"></a>受保护的访问修饰符-protected</h4><p>protected需要从以下两个点来分析说明：</p><ul><li>子类与基类在同一包中：被声明protected的变量、方法和构造器能够被同一个包中的任何其他类访问；</li><li>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。<br>protected可以修饰数据成员，构造方法，方法成员，不能修饰类(内部类除外)。<br><br>子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。<br>下面的父类使用了protected访问修饰符，子类重写了父类的openSpeaker()方法。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">class AudioPlayer{    protected boolean openSpeaker(Speaker sp){&#x2F;&#x2F;实现细节    }}class StreamingAudioPlayer extends AudioPlayer{    protected boolean openSpeaker(Speaker sp){    &#x2F;&#x2F;实现细节    }}</code></pre></li></ul><p>如果把 openSpeaker() 方法声明为 private，那么除了 AudioPlayer 之外的类将不能访问该方法。<br><br>如果把 openSpeaker() 声明为 public，那么所有的类都能够访问该方法。<br><br>如果我们只想让该方法对其所在类的子类可见，则将该方法声明为 protected。<br><br><a href="https://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html" target="_blank" rel="noopener">Java protected关键字详解</a></p><h4 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h4><p>请注意以下方法继承的规则:</p><ul><li>父类中声明为public的方法在子类中也必须为public。</li><li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public，不能声明为private。</li><li>父类中声明为private的方法，不能被继承。</li></ul><h3 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h3><p>为了实现一些其他功能，Java也提供了许多非访问修饰符。</p><ul><li>static修饰符，用来修饰类方法和类变量。</li><li>final修饰符，用来修饰类、方法和变量，final修饰的类不能被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li>abstract修饰符，用来创建抽象类和抽象方法。</li><li>synchronized和volatile修饰符，主要用于线程的编程。</li></ul><h4 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h4><ul><li>静态变量：static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为static变量。</li><li>静态方法：static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</li></ul><p>对类变量和方法的访问可以直接使用classname.variablename和classname.methodname方式访问。<br>如下示例，static修饰符用来创建类方法和类变量。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class InstanceCounter {   private static int numInstances = 0;   protected static int getCount() {      return numInstances;   }    private static void addInstance() {      numInstances++;   }    InstanceCounter() {      InstanceCounter.addInstance();   }    public static void main(String[] arguments) {      System.out.println(&quot;Starting with &quot; +      InstanceCounter.getCount() + &quot; instances&quot;);      for (int i = 0; i &lt; 500; ++i){         new InstanceCounter();          }      System.out.println(&quot;Created &quot; +      InstanceCounter.getCount() + &quot; instances&quot;);   }}&#x2F;&#x2F;以上示例运行结果如下：Starting with 0 instancesCreated 500 instances</code></pre></p><h4 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h4><p>final变量：final表示“最后的，最终的”意思，变量一旦赋值后，不能被重新赋值。被final修饰的实例变量必须显式指定初始值。final修饰符通常和static修饰符一起使用来创建类常量。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;实例public class Test{  final int value = 10;  &#x2F;&#x2F; 下面是声明常量的实例  public static final int BOXWIDTH = 6;  static final String TITLE = &quot;Manager&quot;;   public void changeValue(){     value = 12; &#x2F;&#x2F;将输出一个错误  }}</code></pre></p><h5 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h5><ul><li>类中的final方法可以被子类继承，但不能被子类修改。</li><li>声明final方法的主要目的是防止该方法的内容被修改。<br>如下所示，使用final修饰符声明方法。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Test{    public final void changeName(){&#x2F;&#x2F;方法体    }}</code></pre></li></ul><h5 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h5><p>final类不能被继承，没有类能够继承final类的任何特性。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;实例public final class Test{&#x2F;&#x2F;类体}</code></pre></p><h4 id="abstract修饰符"><a href="#abstract修饰符" class="headerlink" title="abstract修饰符"></a>abstract修饰符</h4><h5 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h5><ul><li>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了对该类进行扩充。</li><li>一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将会编译错误。</li><li>抽象类可以包含抽象方法和非抽象方法。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;实例abstract class Caravan{   private double price;   private String model;   private String year;   public abstract void goFast(); &#x2F;&#x2F;抽象方法   public abstract void changeColor();}</code></pre></li></ul><h5 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h5><ul><li>抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。</li><li>抽象方法不能被声明成final和static。</li><li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li><li>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类，抽象类可以不包含抽象方法。<br>抽象方法的声明以分号结尾，例如:public abstract sample();<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;实例public abstract class SuperClass{    abstract void m(); &#x2F;&#x2F;抽象方法} class SubClass extends SuperClass{     &#x2F;&#x2F;实现抽象方法      void m(){          .........      }}</code></pre></li></ul><h4 id="synchronized-同步-修饰符"><a href="#synchronized-同步-修饰符" class="headerlink" title="synchronized(同步)修饰符"></a>synchronized(同步)修饰符</h4><p>synchronized关键字声明的方法同一时间只能被一个线程访问。synchronized修饰符可以应用于四个访问修饰符。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;实例public synchronized void showDetails(){    .......}</code></pre></p><h4 id="transient-瞬态-修饰符"><a href="#transient-瞬态-修饰符" class="headerlink" title="transient(瞬态)修饰符"></a>transient(瞬态)修饰符</h4><p>序列化的对象包含被transient修饰的实例变量时，java虚拟机（JVM）跳过该特定的变量。<br>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;实例public transient int limit = 55;   &#x2F;&#x2F; 不会持久化public int b; &#x2F;&#x2F; 持久化</code></pre></p><h4 id="volatile（挥发性）修饰符"><a href="#volatile（挥发性）修饰符" class="headerlink" title="volatile（挥发性）修饰符"></a>volatile（挥发性）修饰符</h4><p>volatile修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且当成员变量发生变化时，会强制线程将变量值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>一个volatile对象引用可能是null。<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;实例public class MyRunnable implements Runnable{    private volatile boolean active;    public void run()    {        active = true;        while (active) &#x2F;&#x2F; 第一行        {            &#x2F;&#x2F; 代码        }    }    public void stop()    {        active = false; &#x2F;&#x2F; 第二行    }}</code></pre></p><p>通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 第一行 中缓冲区的 active 值被使用，那么在 第二行 的 active 值为 false 时循环不会停止。<br><br>但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。</p><h3 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h3><p>Java的类（外部类）有2种访问权限：public，default。<br>而方法和变量有4种：public、default、protected，private。<br>其中默认访问权限和protected很相似，有着细微的差别。</p><ul><li>public意味着任何地方的其他类都能访问。</li><li>default则是同一个包的类可以访问。</li><li>protected表示同一个包的类可以访问，其他的包的该类子类也可以访问。</li><li>private表示只有自己类能够访问。</li></ul><p>修饰符：abstract、static、final</p><ul><li>abstract：表示是抽象类。使用对象：类、接口、方法。</li><li>static：可以当做普通类使用，而不用先实例化一个外部类。（用他修饰后，就成了静态内部类了）。使用对象：类、变量、方法、初始化函数（注意：修饰类时只能修饰内部类）</li><li>final：表示类不可以被继承。使用对象：类、变量、方法。</li></ul><h5 id="关于static"><a href="#关于static" class="headerlink" title="关于static"></a>关于static</h5><ul><li>static全局变量与普通的全局变量：static全局变量只初使化一次，防止在其他文件单元中被引用;</li><li>static局部变量和普通局部变量：static局部变量只被初始化一次，下一次依据上一次结果值；</li><li>static函数与普通函数：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java变量类型</title>
      <link href="/JavaBasics/variableType.html"/>
      <url>/JavaBasics/variableType.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java语言中,所以的变量在使用前必须声明. 声明变量的基本格式如下:</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">type indentifier = [ = value][, indentifier [= value] ...];</code></pre><a id="more"></a><p>以下列出了一些变量的声明实例.注意有些包含了初始化过程<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">int a,b,c; &#x2F;&#x2F;声明三个int型整数:a,b,cint d = 3,e = 4, f = 5;  &#x2F;&#x2F;声明三个整数并赋予初值byte z = 22; &#x2F;&#x2F; 声明并初始化 zString s = &quot;runoob&quot;;&#x2F;&#x2F;声明并初始化字符串sdouble pi = 3.14159;&#x2F;&#x2F;声明了双精度浮点型变量 pichar x = &#39;x&#39;;&#x2F;&#x2F;声明变量x的值是字符 &#39;x&#39;</code></pre></p><p>Java语言支持的变量类型有:</p><ul><li>类变量:独立于方法之外的变量,用static修饰</li><li>实例变量:独立于方法之外的变量,不用static修饰</li><li>局部变量:类的方法中的变量<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Variable{    static int allClicks = 0; &#x2F;&#x2F;类变量    String str = &quot;hello world&quot;; &#x2F;&#x2F;实例变量    public void method(){    int i = 0 &#x2F;&#x2F; 局部变量    }}</code></pre></li></ul><h3 id="Java局部变量"><a href="#Java局部变量" class="headerlink" title="Java局部变量"></a>Java局部变量</h3><ul><li>局部变量声明在方法,构造方法或者语句块中;</li><li>局部变量在方法,构造方法,或者语句块被执行时创建,当它们执行完毕后,变量将会被销毁;</li><li>访问修饰符不能用于局部变量;</li><li>局部变量只在声明它的方法,构造方法或者语句块中可见;</li><li>局部变量是在栈上分配的;</li><li>局部变量没有默认值,所以局部变量被声明后,必须经过初始化,才可以使用<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3></li><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建时被创建，在对象销毁时被销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方法获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">package zerofirst.test;import java.io.*;public class Employee {public String name; &#x2F;&#x2F;这个实例变量对子类可见private double salary; &#x2F;&#x2F;私有变量，仅在该类可见public Employee (String empName) {name = empName; &#x2F;&#x2F;在构造器中对name赋值}public void setSalary(double empSal) {salary = empSal; &#x2F;&#x2F; 设定salary的值}&#x2F;&#x2F;打印信息public void printEmp() {System.out.println(&quot;名字：&quot; + name);System.out.println(&quot;薪水：&quot; + salary);}public static void main(String[] args) {Employee empOne = new Employee(&quot;Java&quot;);empOne.setSalary(1000);empOne.printEmp();}}&#x2F;&#x2F;以上结果输出名字：Java薪水：1000.0</code></pre></li></ul><h3 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h3><ul><li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li><li>静态变量在第一次被访问时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认是false，引用类型默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：ClassName，VariableName的方式访问。</li><li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本数据类型</title>
      <link href="/JavaBasics/basicType.html"/>
      <url>/JavaBasics/basicType.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>变量就是申请内存来存储值.也就是说,当创建变量时,需要在内存中申请空间.<br>内存管理系统根据变量的类型为变量分配存储空间,分配的空间只能用来存储该类型数据.<br><img src="https://i.loli.net/2019/04/11/5cae9c0f20f05.jpg" alt="title"><br><br>因此,通过定义不同类型的变量,可以在内存中存储整数,小数或者字符<br>Java的两大数据类型:</p><ul><li>内置数据类型</li><li>引用数据类型</li></ul><a id="more"></a><h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><p>Java语言提供了四类八种基本类型。整数型,浮点型, 字符类型,布尔型。</p><h5 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h5><ul><li>byte数据类型是8位,有符号的,以二进制补码表示的整数;</li><li>最小值是-128(-2^7), 最大值是127(2^7-1), 默认值为0;</li><li>byte类型用在大型数组中节约空间,主要代替整数,因为byte变量占用的空间只有int类型的四分之一;</li><li>例子:byte a = 100, byte b = -50;</li></ul><h5 id="short"><a href="#short" class="headerlink" title="short"></a>short</h5><ul><li>short数据类型是16位,有符号的以二进制补码表示的整数;</li><li>最小值是-32768(-2^15),最大值是32767(2^15-1), 默认值为0;</li><li>short数据类型也可以像byte那样节省空间. 一个short变量是int型变量的二分之一;</li><li>例子:short s = 1000, short r = -20000<h5 id="int"><a href="#int" class="headerlink" title="int"></a>int</h5></li><li>int数据类型是32位,有符号的以二进制补码表示的整数;</li><li>最小值是-2 147 483 648(-2^31),最大值是2147483647(2^31-1),默认值为0;</li><li>一般地整型变量默认为int类型;</li><li>例子:int a = 10000, int b = - 200000<h5 id="long"><a href="#long" class="headerlink" title="long"></a>long</h5></li><li>long数据类型是64位,有符号的二进制补码表示的整数;</li><li>最小值是-9 223 372 036 854 775 808(-2^63);</li><li>最大值是9 223 372 036 854 775 807(2^63-1);</li><li>这种类型主要使用在需要比较大整数的系统上;</li><li>默认值是0L;</li><li>例子:long a = 1000000L, Long b = -2000000L<h5 id="float"><a href="#float" class="headerlink" title="float"></a>float</h5></li><li>float数据类型是单精度,32位,符合IEEE754标准的浮点数;</li><li>float在存储大型浮点数值时可以节省内存空间;</li><li>默认值是0.0f;</li><li>浮点数不能用来表示精确的值,如货币;</li><li>例子:float f1 = 234.5f<h5 id="double"><a href="#double" class="headerlink" title="double"></a>double</h5></li><li>double数据类型是双精度,64位,符合IEEE754标准的浮点数;</li><li>浮点数的默认类型为double类型;</li><li>double类型同样不能表示精确的值;</li><li>默认值为0.0d;</li><li>例子: double d1 = 123.4<h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5></li><li>boolean数据类型表示一位的信息;</li><li>只有两个取值:true和false;</li><li>这种类型只作为一种标志来记录true/false情况;</li><li>默认值是false;</li><li>例子:boolean one = true<h5 id="char"><a href="#char" class="headerlink" title="char"></a>char</h5></li><li>char类型是一个单一的16位Unicode字符;</li><li>最小值是\u0000(即为0),最大值是\uffff(即为65535);</li><li>char数据类型可以存储任何字符;</li><li>例子:char letter = ‘A’<br><img src="https://i.loli.net/2019/04/13/5cb143c1690a8.png" alt="title"></li></ul><h4 id="变量定义的格式包括三个要素：数据类型、变量名、数据值"><a href="#变量定义的格式包括三个要素：数据类型、变量名、数据值" class="headerlink" title="变量定义的格式包括三个要素：数据类型、变量名、数据值"></a>变量定义的格式包括三个要素：数据类型、变量名、数据值</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;数据类型 变量名 = 数据值;&#x2F;&#x2F;例子：byte b = 100；short s = 1000;int i = 5;long l = 10000000000L;float f = 5.5F;double d = 8.5;boolean bool = true;char c = &#39;A&#39;;</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class PrimitiveType {public static void main(String[] args) {&#x2F;&#x2F;byteSystem.out.println(&quot;基本类型:byte 二进制位数:&quot; + Byte.SIZE);System.out.println(&quot;包装类:java.lang.Byte&quot;);System.out.println(&quot;最小值:Byte.MIN_VALUE=&quot; + Byte.MIN_VALUE);System.out.println(&quot;最大值:Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE);System.out.println();&#x2F;&#x2F;shortSystem.out.println(&quot;基本类型: short 二进制位数:&quot; + Short.SIZE);System.out.println(&quot;包装类:java.lang.Short&quot;);System.out.println(&quot;最小值:Short.MIN_VALUE=&quot; + Short.MIN_VALUE);System.out.println(&quot;最大值:Short.MAX_VALUE=&quot; + Short.MAX_VALUE);System.out.println();&#x2F;&#x2F;intSystem.out.println(&quot;基本类型: int 二级制位数:&quot; + Integer.SIZE);System.out.println(&quot;包装类:java.lang.Integer&quot;);System.out.println(&quot;最小值:Integer.MIN_VALUE=&quot; + Integer.MIN_VALUE);System.out.println(&quot;最大值:Integer.MAX_VALUE=&quot; + Integer.MAX_VALUE);System.out.println();&#x2F;&#x2F;longSystem.out.println(&quot;基本类型: long 二进制位数:&quot; + Long.SIZE);System.out.println(&quot;包装类:java.lang.Long&quot;);System.out.println(&quot;最小值:Long.MIN_VALUE&quot; + Long.MIN_VALUE);System.out.println(&quot;最大值:Long.MAX_VALUE&quot; + Long.MAX_VALUE);System.out.println();&#x2F;&#x2F;floatSystem.out.println(&quot;基本类型: float 二进制位数:&quot; + Float.SIZE);System.out.println(&quot;包装类:java.lang.Float&quot;);System.out.println(&quot;最小值:Float.MIN_VALUE&quot; + Float.MIN_VALUE);System.out.println(&quot;最大值:Float.MAX_VALUE&quot; + Float.MAX_VALUE);System.out.println();&#x2F;&#x2F;doubleSystem.out.println(&quot;基本类型: double 二进制位数:&quot; + Double.SIZE);System.out.println(&quot;包装类:java.lang.Double&quot;);System.out.println(&quot;最小值:Double.MIN_VALUE&quot; + Double.MIN_VALUE);System.out.println(&quot;最大值:Double.MAX_VALUE&quot; + Double.MAX_VALUE);System.out.println();&#x2F;&#x2F;charSystem.out.println(&quot;基本类型: char 二进制位数:&quot; + Character.SIZE);System.out.println(&quot;包装类: java.lang.Character&quot;);&#x2F;&#x2F; 以数值形式而不是字符形式将Character.MIN_VALUE输出至控制台System.out.println(&quot;最小值:Character.MIN_VALUE=&quot; + (int) Character.MIN_VALUE);System.out.println(&quot;最大值:Character.MAX_VALUE=&quot; + (int) Character.MAX_VALUE);}}&#x2F;&#x2F;学习类之后将该程序改进一下:输入任意类型就打印该类型的信息</code></pre><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li>在Java中,引用类型的变量非常类似于C/C++的指针.引用类型指向一个对象,指向对象的变量是引用变量.这些变量在声明时被指定为一个特定的类型. 比如Employee,Puppy等. 变量一旦声明,类型就不能被改变了.</li><li>对象,数组都是引用数据类型</li><li>所以引用类型的默认值都是null</li><li>一个引用变量可以用来引用任何与之兼容的类型</li><li>例子: Site site = new Site(‘Java’)<h3 id="Java常量"><a href="#Java常量" class="headerlink" title="Java常量"></a>Java常量</h3>常量是指在Java程序中固定不变的数据。以下是常量的分类：</li></ul><ol><li>字符串常量：凡是用双引号引起来的部分，叫做字符串常量。例如：”abc”, “Hello”,”123”</li><li>字符常量：凡是用单引号引起来的单个字符，就是字符常量。例如：’A’,’b’,’9’,’中’</li><li>整数常量：直接写上的数字，没有小数点。例如：100,123,200,0，-1</li><li>浮点数常量：直接写上数字，有小数点的。例如：2.5，-3.14,0.0</li><li>布尔常量：只有量中取值。true，false。</li><li>空常量：null。代表没有任何数据。<br>在Java中使用final关键字来修饰常量,声明方式和变量类似:<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">final double PI = 3.1415927;</code></pre></li></ol><p>虽然常量名也可以用小写,但为了方便识别,通常使用大写字母表示常量.<br>字面量可以赋给任何内置类型的变量.例如:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">byte a = 68;char a = &#39;A&#39;;</code></pre></p><p>byte,int,long和short都可以用十进制,16进制以及8进制的方式来表示.<br>当使用常量时,前缀0表示8进制,而前缀0x代办16进制,例如:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">int decimal = 100;int octal = 0144;int hexa = 0x64;</code></pre></p><p>和其他语言一样,Java的字符串常量也是包含在两个引号之间的字符序列,例子:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&quot;Hello World&quot;&quot;two\nlines&quot;&quot;\&quot;This is in quotes\&quot;&quot;</code></pre></p><p>字符串常量和字符常量都可以包含任何Unicode字符,例如:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">char a = &quot;\u0001&quot;;String a = &quot;\u0001&quot;;</code></pre></p><p>Java支持的转义字符序列</p><h3 id="自动类型转换（显式）"><a href="#自动类型转换（显式）" class="headerlink" title="自动类型转换（显式）"></a>自动类型转换（显式）</h3><p>整型,实型(常量),字符型数据可以混合运算.运算中,不同类型的数据先转化为同一类型,然后进行运算.<br>转换从低级到高级<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">低-------------------------------------&gt;高byte,short,char--&gt; int--&gt; long--&gt; float--&gt; double</code></pre></p><p>数据类型转换必须满足如下规则:</p><ol><li>不能对boolean类型进行类型转换</li><li>不能把对象类型转换成不相关类的对象</li><li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换</li><li>转换过程中可能导致溢出或损失精度,例如:<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">int i = 128;byte b = (byte)i;</code></pre></li></ol><p>因为byte类型是8位,最大值为127,所以当int强制转换为byte类型时,值128会导致溢出<br><br>5. 浮点数到整数的转换是通过舍弃小数得到,而不是四舍五入,例如:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">(int)23.7 == 23;(int)-45.89f == -45;</code></pre></p><h4 id="自动类型转换-隐式"><a href="#自动类型转换-隐式" class="headerlink" title="自动类型转换(隐式)"></a>自动类型转换(隐式)</h4><p>必须满足转换前的数据类型的位数要低于转换后的数据类型,例如 short数据类型的位数为16位,就可以自动转换位数为32的int类型,同样float数据类型的位数为32位,可以自动转换为64位的double类型.<br></p><ul><li>特点：代码不需要进行特殊处理，自动完成</li><li>规则：数据范围从小到大。</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class AutoSwitch{    public static viod main(String[] args){char c1 = &#39;a&#39;; &#x2F;&#x2F; 定义一个char类型int i1 = c1; &#x2F;&#x2F;char自动类型转换为intSystem.out.println(&quot;char自动类型转换为int后的值=&quot; + i1);char c2 = &#39;A&#39;; &#x2F;&#x2F;定义一个char类型int i2 = c2 + 1; &#x2F;&#x2F;char类型金额int类型计算System.out.println(&quot;char类型和int计算后的值为 = &quot; + i2);    }}&#x2F;&#x2F;运行结果为:&#x2F;&#x2F;char自动类型转换为int后的值=97&#x2F;&#x2F;char类型和int计算后的值为 = 66&#x2F;&#x2F;解析:c1的值为字符a,查ASCII码表的对应的int类型值为97,A对应值为65,故i2=65+1=66</code></pre><h4 id="强制类型转换-显式"><a href="#强制类型转换-显式" class="headerlink" title="强制类型转换(显式)"></a>强制类型转换(显式)</h4><p>将取值范围大的类型强制转换成取值范围小的类型</p><ul><li>转换格式：数据类型 变量名 = （数据类型）被强转的数据值；</li></ul><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;double类型强制转换为int类型，直接去掉小数点int i = (int)1.5;public class QiangZhiZhuanHuan{    public static viod main(String[] args){int i1 = 123; &#x2F;&#x2F;byte b = (byte)i1; &#x2F;&#x2F;int类型强制类型转换为byteSystem.out.println(&quot;int强制类型转换为byte后的值为:&quot; + b);    }}&#x2F;&#x2F;运行结果:int强制类型转换为byte后的值等于123</code></pre><p>Tips：</p><ol><li>浮点转成整数，直接取消小数点，可能会造成数据损失精度。</li><li>int强制转成short砍掉2个字节，可能会造成数据溢出，导致数据丢失。  </li><li>byte/short/char这三种类型都可以发生数学运算，例如加法“+”。</li><li>byte/short/char这三种类型在运算时，都会首先自动被提升成为int类型，然后再计算。</li><li>boolean类型不能发生任何数据类型转换<h4 id="强制类型转换-隐式"><a href="#强制类型转换-隐式" class="headerlink" title="强制类型转换(隐式)"></a>强制类型转换(隐式)</h4></li><li>整数的默认类型是int</li><li>浮点型不存在这种情况,因为在定义float类型时必须在数字后面跟上F或者f<br>对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐式地为我们补上一个(byte)(short)(char)。</li></ol><ul><li>如果没有超过左侧的范围，编译器补上强转。</li><li>如果右侧超过了左侧的范围，编译报错。<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Notice{    public static void main(String[] args){&#x2F;&#x2F;右侧确实是一个int数字，但没有超过左侧的范围，故自动隐式强转不会报错。&#x2F;&#x2F;int --&gt; byte 高位到低位，不是自动类型转换byte num1 = 30; &#x2F;&#x2F; 右侧没有超过左侧范围System.out.println(num1);&#x2F;&#x2F;byte num2 = 128; &#x2F;&#x2F; 右侧超过了左侧范围&#x2F;&#x2F; int --&gt; char 只要右侧没超出范围，编译器会自动补上一个隐含的(char)，进行自动隐式强转。char strings = &#x2F;*(char)*&#x2F; 65；System.out.println(strings)    }}</code></pre></li></ul><h4 id="编译器的常量优化"><a href="#编译器的常量优化" class="headerlink" title="编译器的常量优化"></a>编译器的常量优化</h4><p>在给变量进行赋值时，如果右侧表达式当中全部是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。<br>short result = 5+8；//等号右边全部是常量，没有任何变量参与运算，编译之后，得到的.class字节码文件当中相当于==直接就是==：short result = 13;<br>右侧的常量结果数值，没有超过左侧范围，所以正确。<br>这称为“编译器的常量优化”</p><p>但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。</p><h3 id="ASCII编码表"><a href="#ASCII编码表" class="headerlink" title="ASCII编码表"></a>ASCII编码表</h3><p>ASCII码表：American Standard Code for Information Interchange，美国信息交换标准码。<br>Unicode码表：万国码。也是数学和符号的对照关系，开头0-127部分和ASCII完全一样，但从128开始包含更多的字符。<br><img src="https://i.loli.net/2019/04/13/5cb190886bf51.jpg" alt="title"><br>只需特殊记住三个字符，分别是</p><ul><li>‘0’=48</li><li>‘A’=65</li><li>‘a’=97</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/JavaBasics/JavaBasic.html"/>
      <url>/JavaBasics/JavaBasic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h2><p><a href="https://www.runoob.com/java/java-intro.html" target="_blank" rel="noopener">参考Runoob</a></p><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><ul><li>JVM(Java Virtual Machine):Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java最具吸引力的特性之一。我们编写的Java代码，都是运行在Jvm之上。</li><li>跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。</li><li>JRE（Java Runtime Environment）:是Java程序的运行时环境，包含JVM和运行时所需的核心类库。</li><li>JDK（Java Development Kit）:是Java程序开发工具包，包含JRE和开发人员使用工具。<br><img src="https://i.loli.net/2019/04/13/5cb13efcda904.png" alt="title"><br><br><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">下载JDK</a><br><br><a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">下载Eclipse</a></li></ul><a id="more"></a><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>编写Java程序时,需注意以下几点:</p><ul><li>大小写敏感:Java是大小写敏感的,这就意味着标识符Hello与hello是不同的</li><li>类名:对于所有的类来说,类名的首字母应该大写.如果类名由若干单词组成,那么需采用驼峰命名法</li><li>方法名:所有的方法都应该以小写字母开头.如果方法名含有若干单词,则后面的每个单词首字母大写</li><li>源文件名:源文件名必须和类名相同.当保存文件时,你应该使用类名作为文件名保存,文件名的后缀为.java(如文件名和类名不相同则会导致编译错误)</li><li>主方法入口:所有的Java程序由public static void main(String []args)方法开始执行<h3 id="Java标识符"><a href="#Java标识符" class="headerlink" title="Java标识符"></a>Java标识符</h3>Java所有的组成部分都需要名字. 类名,变量名以及方法名都被称为标识符.<br>关于Java标识符,有一下几点需要注意:</li><li>所有的标识符都应该以字母(A-Za-z),美元符($),或者下划线(_)开始</li><li>首字符之后可以是字母(A-Za-z),美元符,下划线或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符大小写敏感</li><li>合法标识符举例:age, $salary, _value, __1_value</li><li>非法标识符举例:123abc, -salary<h3 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h3>像其他语言一样,Java可以使用修饰符来修饰类中方法和属性.主要有两类修饰符:</li><li>访问控制修饰符: default, public, protected, private</li><li>非访问控制修饰符: final, abstract, static, synchronized<h3 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h3>Java中主要有如下几种类型的变量</li><li>局部变量</li><li>类变量(静态变量)</li><li>成员变量(非静态变量)<h3 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h3>数组是存储在堆上的对象,可以保存多个同类型变量<h3 id="Java枚举"><a href="#Java枚举" class="headerlink" title="Java枚举"></a>Java枚举</h3>枚举限制变量只能是预先设定好的值. 使用枚举可以减少代码中的bug.<br><br>例如:为果汁店设计一个程序,它将限制果汁为小杯,中杯,大杯. 这就意味着它不允许顾客点除了这三种尺寸外的果汁<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">class FreshJuice {    enum FreshJuinceSize{ SMALL, MEDIUM, LARGE }    FreshJuiceSize size;}public class FreshJuiceTest {    public static void main(String []args){        FreshJuice juice = new FreshJuice();juice.size = FreshJuice.FreshJuiceSize.MEDIUM;    }}&#x2F;&#x2F;注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义</code></pre></li></ul><h3 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h3><p>以下列出Java关键字,这些保留字不能用于常量,变量,和任何标识符的名称.<br><a href="https://www.runoob.com/java/java-basic-syntax.html" target="_blank" rel="noopener">详见runoob Java关键字</a></p><h3 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h3><p>类似于C/C++, Java也支持单行以及多行注释.注释字符将被Java编译器忽略.<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class HelloWorld {   &#x2F;* 这是第一个Java程序    *它将打印Hello World    * 这是一个多行注释的示例    *&#x2F;    public static void main(String []args){       &#x2F;&#x2F; 这是单行注释的示例       &#x2F;* 这个也是单行注释的示例 *&#x2F;       System.out.println(&quot;Hello World&quot;);     }}</code></pre></p><h3 id="Java空行"><a href="#Java空行" class="headerlink" title="Java空行"></a>Java空行</h3><p>空白行或者有注释的行,Java编译器都会忽略掉</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在Java中,一个类可以由其他类派生.如果你要创建一个类,而且已经存在一个类具有你所需的属性或者方法,那么你可以将新创建的类继承该类.<br><br>利用继承的方法,可以重用已存在类的方法和属性,而不用重写这些代码. 被继承的类称为超类(super class),派生类称为子类(sub class)</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在Java中,接口可以理解为对象间相互通信的协议.接口在继承中扮演者重要的角色<br><br>接口只定义派生要用到的方法,但是方法的具体实现完全取决于派生类</p><h3 id="Java源程序与编译型运行区别"><a href="#Java源程序与编译型运行区别" class="headerlink" title="Java源程序与编译型运行区别"></a>Java源程序与编译型运行区别</h3><p>如图所示:<br><img src="https://i.loli.net/2019/04/10/5cad995bb0b6b.png" alt="Java源程序与编译型运行区别"></p><h2 id="Java对象和类"><a href="#Java对象和类" class="headerlink" title="Java对象和类"></a>Java对象和类</h2><p>Java作为一种面向对象语言,支持以下基本概念:</p><ul><li>多态</li><li>继承</li><li>封装</li><li>抽象</li><li>类</li><li>对象</li><li>实例</li><li>方法</li><li>重载<br>以下重点研究对象和类的概念</li><li>对象:对象是类的一个实例,例如,一条狗是一个对象,它的状态有:颜色,名字,品种;行为有:摇尾巴,叫,吃等</li><li>类:类是一个模板,它描述一类对象的行为和状态.<br>下图中男孩女孩为类,具体每个人为该类的对象:<br><img src="https://i.loli.net/2019/04/10/5cad9e36a063b.jpg" alt="object-class.jpg"><h3 id="Java中的对象"><a href="#Java中的对象" class="headerlink" title="Java中的对象"></a>Java中的对象</h3>现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。<br><br>拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。<br><br>对比现实对象和软件对象，它们之间十分相似。<br><br>软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。<br><br>在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。<h3 id="Java中的类"><a href="#Java中的类" class="headerlink" title="Java中的类"></a>Java中的类</h3>类可以看成是创建Java对象的模板,<br>下面通过一个简单的类来理解下Java中类的定义:<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Dog{    String breed;    int age;    String color;    void barking(){}    void hungry(){}    void sleeping(){        }}</code></pre></li></ul><p>一个类可以包含以下类型变量:</p><ul><li>局部变量:在方法,构造方法或者语句块中定义的变量被称为局部变量.变量声明和初始化都是在方法中,方法结束后,变量就会自动销毁.</li><li>成员变量:成员变量是定义在类中,方法体之外的变量.这种变量在创建对象时实例化.成员变量可以被类中方法,构造方法和特定类的语句块访问</li><li>类变量:类变量也声明在类中,方法体之外,但必须声明为static类型<br>一个类可以拥有多个方法,在上面的例子中:barking(),hungry(),sleeping()都是Dog类的方法<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3>每个类都有构造方法. 如果没有显式地为类定义构造方法,Java编译器将会为该类提供一个默认构造方法<br>在创建一个对象时,至少要调用一个构造方法,构造方法的名称必须与类同名,一个类可以有多个构造方法.<br>下面是一个构造方法实例:<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Puppy{    public Puppy(){}    public Puppy(String name){&#x2F;&#x2F;这个构造器仅有一个参数:name}}</code></pre></li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的.在Java中,使用关键字==new==来创建一个新的对象.创建对象需要以下三步:</p><ul><li>声明:声明一个对象,包括对象名称和对象类型</li><li>实例化:使用关键字new来创建一个对象</li><li>初始化:使用new创建对象时,会调用构造方法初始化对象<br>下面是一个创建对象的例子:<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Puppy{    public Puppy(String name){&#x2F;&#x2F;这个构造器仅有一个参数:nameSyetem.out.println(&quot;小狗的名字是:&quot;+name);    }    public static void main(String []args){&#x2F;&#x2F;下面语句将创建一个Puppy对象Puppy myPuppy = new Puppy(&quot;tommy&quot;);    }}</code></pre></li></ul><h3 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h3><p>通过已创建的对象来访问成员变量和成员方法,如下所示:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">&#x2F;* 实例化对象 *&#x2F;Object referenceVariable = new Constructor();&#x2F;* 访问类中的变量 *&#x2F;referenceVariable.variableName;&#x2F;* 访问类中的方法 *&#x2F;referenceVariable.methodName();</code></pre></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的例子展示如何访问实例变量和调用成员方法:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">public class Puppy {int puppyAge;public Puppy(String name) {&#x2F;*这个构造器仅有一个参数:name*&#x2F;System.out.println(&quot;小狗的名字是:&quot; + name);}public void setAge(int age) {puppyAge = age;}public int getAge() {System.out.println(&quot;小狗的年龄为:&quot; + puppyAge);return puppyAge;}public static void main(String []args) {&#x2F;&#x2F;使用new创建对象Puppy myPuppy = new Puppy(&quot;tommy&quot;);&#x2F;&#x2F;通过方法来设定agemyPuppy.setAge( 2 );&#x2F;&#x2F;调用另一个方法获取agemyPuppy.getAge();&#x2F;&#x2F;你也可以通过下面方法访问成员变量System.out.println(&quot;变量值:&quot; + myPuppy.puppyAge);}}</code></pre></p><h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><p>当在一个源文件中定义多个类,并且还有import语句和package语句时,要特别注意以下规则</p><ul><li>一个源文件中只能有一个public类</li><li>一个源文件可以有多个非public类</li><li>源文件的名称应该和public类的类名保持一致.例如:源文件中public类的类名是Test,那么源文件应该命名为Test.java</li><li>如果一个类定义在某个包中,那么package语句应该在源文件的首行</li><li>如果源文件包含import语句,那么应该放在package语句和类定义之间.如果没有package语句,那么import语句应该在源文件中最前面</li><li>import语句和package语句对源文件中定义的所有类都有效.在同一源文件中,不能给不同的类不同的包声明.<br>类有若干种访问级别,并且类也分不同的类型:抽象类和final类等.<br>除了上述提到的几种类型,Java还有一些特殊类,如:内部类,匿名类.<h3 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h3>包主要用来对类和接口进行分类,当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。<h3 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h3>在Java中,如果给出一个完整的限定名,包括包名,类名,那么Java编译器就可以很容易地定位到源代码或者类.import语句就是用来提供一个合理的路径,使得编译器可以找到某个类.<br>例如,下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类.<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-java">import java.io.*;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaBasics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Git搭建个人博客</title>
      <link href="/Other/hexo-build-blog.html"/>
      <url>/Other/hexo-build-blog.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于hexo+github pages服务搭建博客,快速,便捷,免费的搭建属于自己的个人博客</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>在开始一切之前,你必须已经:</p><ul><li>有一个github账号,没有的话去<a href="https://github.com" target="_blank" rel="noopener">注册一个</a></li><li>电脑 <a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">安装</a> 了node.js,npm,并了解相关基础知识</li><li>安装了<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git for windows</a> (或其他git客户端工具)</li></ul><a id="more"></a><h2 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2.创建仓库"></a>2.创建仓库</h2><ul><li>新建一个名为 用户名.github.io的仓库.比如说,如果你的github用户名是test</li><li>那么你就新建test.github.io的仓库(必须是你的用户名,其他的无效)</li><li>然后你的网站访问地址就是<a href="http://test.github.io" target="_blank" rel="noopener">http://test.github.io</a> 了<br>注意几个地方:<ul><li>注册的邮箱一定要验证,否则不会成功</li><li>仓库名字必须是:username.github.io,其中username就是你的用户名</li><li>仓库创建成功不会立即生效,需要过一段时间(等待github分配网站域名等)</li></ul></li></ul><h2 id="3-绑定域名"><a href="#3-绑定域名" class="headerlink" title="3.绑定域名"></a>3.绑定域名</h2><ul><li>域名配置最常见有2种方式,CNAME和A记录,CNAME填写域名,A记录填写IP</li><li>由于不带WWW方式只能采用A记录,所以先ping一下username.github.io的IP</li><li>然后到你的域名DNS设置页,将A记录指向你ping出来的IP,将CNAME指向:yourname.github.io</li><li>这样可以保证无论是否添加WWW都可以访问</li><li>例:<ul><li>记录类型:A      主机记录:@   解析线路默认  记录值:IP</li><li>记录类型:CNAME  主机记录:www 解析线路默认  记录值:username.github.io</li></ul></li><li>然后到你的github项目跟目录新建一个名为CNAME的文件(无后缀),里面填写你自定义的域名</li></ul><h2 id="4-配置SSH-key"><a href="#4-配置SSH-key" class="headerlink" title="4.配置SSH key"></a>4.配置SSH key</h2><p>提交代码需要github权限才可以,这里使用ssh key来解决本地和服务器的连接问题<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">$ cd ~&#x2F;.ssh # 检查本机已存在的ssh秘钥</code></pre></p><p>如果提示:”No such file or directory”说明你是第一次使用git<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">ssh-keygen -t rsa -C &#39;your email@example.com&#39;</code></pre></p><p>一般情况下直接默认值就行,所以不用设置密码,一路回车就行<br>最终会在.ssh目录下生成两个文件,id_rsa和id_rsa.pub,这两个就是SSH Key的密钥对id_rsa是私钥,不能泄露!<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">cat id_rsa.pub</code></pre></p><p>复制输出的内容,打开你的github主页,打开”Account settings”&gt;&gt;”SSH keys”页面</p><ol><li>点击 ‘Add SSH Key’,填上任意title,在Key文本框内粘贴id_rsa.pub文件的内容</li><li>点击 ‘Add Key’,就成功添加Key了<br>测试是否成功<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">$ ssh -T git@github.com</code></pre></li></ol><p>如果提示”Are you sure you want to continum connecting (yes/no)?” 输入yes,就会看到<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">Hi zero6996! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre></p><p>说明SSH配置成功!<br>此时你还需要配置:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">$ git config --global user.name &#39;zero6996&#39; #你的github用户名$ git config --global user.email &#39;youremail@xx.com&#39; #你的github注册email</code></pre></p><h2 id="5-hexo简介"><a href="#5-hexo简介" class="headerlink" title="5.hexo简介"></a>5.hexo简介</h2><p>Hexo是一个简单,快速,强大的基于GitHub Pages的博客发布工具,支持Markdown格式,有众多优秀的插件和主题<br><a href="http://hexo.io" target="_blank" rel="noopener">官网</a><br><a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Github</a></p><h3 id="5-1-安装注意事项"><a href="#5-1-安装注意事项" class="headerlink" title="5.1.安装注意事项"></a>5.1.安装注意事项</h3><ol><li>很多命令既可以用Windows的cmd来完成,也可以使用git bash来完成,但是部分命令会有一些问题,为避免不必要的问题,这里统一使用git bash来执行</li><li>hexo不同版本差别较大,网上很文章的配置信息都是基于2.x的,所以注意不要被误导</li><li>hexo有两种”_config.yml” 文件,一个是跟目录下的全局的”_config.yml” , 一个是各个”theme” 下的</li><li>安装完node和npm以后,将npm替换为<a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝镜像</a>,执行以下命令即可将,后续命令全部以cnpm执行<!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">npm install -g cnpm --registry=https:&#x2F;&#x2F;registry.npm.taobao.org</code></pre></li></ol><h3 id="5-2-安装"><a href="#5-2-安装" class="headerlink" title="5.2.安装"></a>5.2.安装</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">$ cnpm install -g hexo</code></pre><h3 id="5-3-初始化"><a href="#5-3-初始化" class="headerlink" title="5.3.初始化"></a>5.3.初始化</h3><p>在本地新建一个名为hexo的文件夹(名字任意取),这里作为一个你存放代码的地方,比如我是D:\hexo<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">$ cd &#x2F;d&#x2F;hexo # 进入文件夹$ hexo init # 初始化</code></pre></p><p>hexo会自动下载一些文件到这个目录,包括node_modules,目录结构<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">$ ls_config.yml  node_modules&#x2F;  package-lock.json  scaffolds&#x2F;  themes&#x2F;db.json      package.json   public&#x2F;   source&#x2F;$ hexo g # 生成$ hexo s # 启动服务</code></pre></p><ul><li>执行上述命令之后,hexo就会在public文件夹生成相关html文件,这些文件后续会提交到github上去</li><li>“hexo s”是开启本地预览服务,打开浏览器访问<a href="http://localhost:4000" target="_blank" rel="noopener">localhost:4000</a>即可看到博客内容.</li><li>如果无显示内容或拒绝访问,就是端口占用的问题,重新开启服务,使用”hexo s -p 8888”指定端口</li></ul><h3 id="5-4-修改主题"><a href="#5-4-修改主题" class="headerlink" title="5.4.修改主题"></a>5.4.修改主题</h3><p>hexo社区有丰富的主题可选,从<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网主题</a>自己挑选下载</p><p>下载主题(以<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a>为例):<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">$ cd &#x2F;d&#x2F;hexo&#x2F;$ git clone git@github.com:litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia # 从github克隆主题,到本地的themes&#x2F;yilia文件夹</code></pre></p><p>下载的主题都在hexo/themes文件夹内<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">$ cd themes$ lslandscape&#x2F;  yilia&#x2F;</code></pre></p><p>修改”_config.yml”中的”theme: landscape”改为”theme: yilia”,然后重新执行”hexo g”来生成页面<br>如果出现一些莫名其妙的问题,可以先执行”hexo clean”来清理一下public的内容,然后再来重新生成和发布</p><h3 id="5-5-上传之前"><a href="#5-5-上传之前" class="headerlink" title="5.5.上传之前"></a>5.5.上传之前</h3><p>上传代码到github之前,记得备份以前的所有代码,因为hexo提交代码时会把你以前的所有代码都删除</p><h3 id="5-6-上传到Github"><a href="#5-6-上传到Github" class="headerlink" title="5.6.上传到Github"></a>5.6.上传到Github</h3><p>如果你一切都配置好了,发布上传只需要”hexo d”就可以了,当然关键是所有东西都配置好<br>首先,”ssh key”肯定要配置好<br>其次,配置”_config.yml”中有关deploy的部分:</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">#正确写法deploy:   type: git   repository: git@github.com:zero6996&#x2F;zero6996.github.io.git   branch: master</code></pre><p>如果报如下错误:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">Deployer not found: github 或者 Deployer not found: git</code></pre></p><p>原因是还需安装一个插件:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike"> cnpm install hexo-deployer-git --save</code></pre></p><p>安装无误,输入github账户密码,输入”hexo d”就会将本次有改动的代码全部提交,没有改动的不会</p><h3 id="5-7-常用hexo命令"><a href="#5-7-常用hexo命令" class="headerlink" title="5.7.常用hexo命令"></a>5.7.常用hexo命令</h3><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">hexo new &#39;postName&#39; # 新建文章hexo new page &#39;pageName&#39; # 新建页面hexo generate # 生成静态页面至public目录hexo server # 开启预览访问端口(默认4000,使用-p可更换端口)hexo deploy # 部署至Githubhexo help # 查看帮助hexo version # 查看版本</code></pre><p>以上命令均可缩写<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy</code></pre></p><p>以及组合命令:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">hexo s -g # 生成页面并本地预览hexo d -g # 生成页面并上传hexo s -p # 本地预览并改变端口</code></pre></p><h3 id="5-8-config-yml"><a href="#5-8-config-yml" class="headerlink" title="5.8._config.yml"></a>5.8._config.yml</h3><p>这里面都是一些全局配置,每个参数意思都比较简单明了,需要注意的是冒号后面必须有一个空格</p><h2 id="6-写博客"><a href="#6-写博客" class="headerlink" title="6.写博客"></a>6.写博客</h2><p>进入hexo根目录,执行命令:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">hexo new &#39;my-first-blog&#39;</code></pre></p><p>hexo会帮我们在_posts下生成相关的md文件,我们只需要打开这个文件就可以开始写博客了</p><p>一般完整格式如下:<br><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-clike">---title: postName # 文章页面上的显示名称,一般是中文date: 2018-12-5 15:46:10 # 文章生成时间,一般不用改,也可自定义categories: 默认分类 # 分类tags: [tag1,tag2,tag3] # 文章标签,可空,多标签请用格式description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文内容</code></pre></p><p>hexo new page ‘my-second-blog’ 生成的是:index.md,它不会作为文章出现在博客目录</p><h3 id="6-1-写博客工具"><a href="#6-1-写博客工具" class="headerlink" title="6.1.写博客工具"></a>6.1.写博客工具</h3><p>   个人使用的是 ‘Visual Studio Code’ IDE</p><h3 id="6-2-如何让博文列表不显示全部内容"><a href="#6-2-如何让博文列表不显示全部内容" class="headerlink" title="6.2.如何让博文列表不显示全部内容"></a>6.2.如何让博文列表不显示全部内容</h3><p>默认情况下,生成的博文目录会显示全部文章内容,如何设置文章摘要长度呢?</p><p>可以在合适的位置加上’<!--more-->‘即可,显示在页面上的效果就是新增了一个’more&gt;&gt;’功能选项,查看更多内容</p><h3 id="7-关于缺失模块"><a href="#7-关于缺失模块" class="headerlink" title="7.关于缺失模块"></a>7.关于缺失模块</h3><p>缺失模块</p><ol><li>请确保node版本大于6.2</li><li><p>在博客根目录（注意不是yilia根目录）执行以下命令:</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash"> cnpm i hexo-generator-json-content --save</code></pre></li><li><p>在根目录_config.yml里添加配置：</p><!-- Has Prism --><pre class="line-numbers" style=""><code class="language-bash">jsonContent:    meta: false    pages: false    posts:      title: true      date: true      path: true      text: false      raw: false      content: false      slug: false      updated: false      comments: false      link: false      permalink: false      excerpt: false      categories: false      tags: true</code></pre></li></ol><h4 id="参考自"><a href="#参考自" class="headerlink" title="参考自"></a>参考自</h4><p>   <a href="http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">以上内容整理参考自文章</a></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
