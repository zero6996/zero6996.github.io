<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Redi相关面试题, Zero的博客">
    <meta name="description" content="Redis面试题主流应用架构图


客户端请求数据会先去缓存层查询；
查询到数据直接返回
查询不到数据，就会穿透缓存层去存储层查询；
存储层查询到数据后，携带数据回写到缓存层中，然后返回给客户端；
如果存储层无法完成请求，可以让客户端请求直">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Redi相关面试题 | Zero的博客</title>
    <link rel="icon" type="image/jpeg" href="/huiye.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    

</head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/" class="waves-effect waves-light">
                        
                        <img src="/medias/logo.png" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span">Zero的博客</span>
                    </a>
                </div>
                

<a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search" title="搜索"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Zero的博客</div>
        <div class="logo-desc">
            
            欢迎来到我的博客！
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/zero6996" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Follow Me 秋梨膏~
            </a>
        </li>
        
    </ul>

    <div class="social-link">
    <a href="https://github.com/zero6996" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:1490829140@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1490829140" class="tooltipped" data-tooltip="QQ联系我: 1490829140" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
</div>

            </div>
        </div>

        
        <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/zero6996" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me 秋梨膏~" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>
</header>





<div class="bg-cover post-cover" style="background-image: url('/medias/featureimages/14.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Redi相关面试题
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Redis/" target="_blank">
                                <span class="chip bg-color">Redis</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/DataBase/" class="post-category" target="_blank">
                                DataBase
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-08-17
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        5.4k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        21 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h2><p>主流应用架构图</p>
<p><img src="http://yanxuan.nosdn.127.net/00d1ad6dbbe033d63dc316ecd2fb8f6c.png" alt="主流应用架构"></p>
<ol>
<li>客户端请求数据会先去缓存层查询；</li>
<li>查询到数据直接返回</li>
<li>查询不到数据，就会穿透缓存层去存储层查询；</li>
<li>存储层查询到数据后，携带数据回写到缓存层中，然后返回给客户端；</li>
<li>如果存储层无法完成请求，可以让客户端请求直接打在缓存层上；</li>
<li>不管是否获取到数据，都直接返回。</li>
</ol>
<h3 id="1-缓存中间件对比"><a href="#1-缓存中间件对比" class="headerlink" title="1. 缓存中间件对比"></a>1. 缓存中间件对比</h3><p>Memcache和Redis的区别：</p>
<ul>
<li>Memcache：代码层次类似Hash<ul>
<li>支持简单数据类型</li>
<li>不支持数据持久化存储</li>
<li>不支持主从</li>
<li>不支持分片</li>
</ul>
</li>
<li>Redis<ul>
<li>丰富的数据类型</li>
<li>支持数据磁盘持久化存储</li>
<li>支持主从</li>
<li>支持分片</li>
</ul>
</li>
</ul>
<h3 id="2-为什么Redis能这么快"><a href="#2-为什么Redis能这么快" class="headerlink" title="2. 为什么Redis能这么快"></a>2. 为什么Redis能这么快</h3><p>官方宣称有100000+QPS(QPS即query per second，每秒内查询次数)</p>
<ul>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高；</li>
<li>数据结构简单，对数据操作也简单；</li>
<li>采用<strong>单线程</strong>，单线程也能处理高并发请求，也可启动多实例利用多核性能；</li>
<li>使用多路I/O复用模型，非阻塞IO(NIO)。  </li>
</ul>
<h3 id="3-多路I-O复用模型"><a href="#3-多路I-O复用模型" class="headerlink" title="3. 多路I/O复用模型"></a>3. 多路I/O复用模型</h3><ul>
<li>FD：File Descriptor，文件描述符；指一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射。</li>
</ul>
<h4 id="3-1-传统的阻塞I-O模型-BIO"><a href="#3-1-传统的阻塞I-O模型-BIO" class="headerlink" title="3.1 传统的阻塞I/O模型(BIO)"></a>3.1 传统的阻塞I/O模型(BIO)</h4><p>同步阻塞I/O(Block IO，简称BIO)</p>
<p>这种方式下，用户进程在发起一个I/O操作后，必须等待I/O操作的完成，只有当真正完成了I/O操作以后，用户进程才能运行；模式简单方便使用，但是并发性低。</p>
<h4 id="3-2-多路复用函数：Selector"><a href="#3-2-多路复用函数：Selector" class="headerlink" title="3.2 多路复用函数：Selector"></a>3.2 多路复用函数：Selector</h4><p>同步非阻塞(New IO，简称NIO)</p>
<p>此种方式下，用户进程发起一个I/O操作以后就可以返回做其他事情，但是用户进程需周期性地去询问I/O操作是否就绪，会造成一定的CPU资源的浪费。</p>
<p><img src="http://yanxuan.nosdn.127.net/b9ad045e9c54ced198ddb267404dee97.png" alt="Select"></p>
<p>Select函数可以同时监控多个FD的可读可写情况，当某些文件可读或可写时，Select就会返回FD的可读可写个数；Select是用于监听文件的读写状态，将监听任务交给Select后，用户进程就可以继续做别的事情了，从而不被阻塞。</p>
<h4 id="3-3-Redis采用的多路复用函数"><a href="#3-3-Redis采用的多路复用函数" class="headerlink" title="3.3 Redis采用的多路复用函数"></a>3.3 Redis采用的多路复用函数</h4><p>多路复用函数有多种：epoll、kqueue、evport、select</p>
<p>Redis会智能选择，因地制宜，根据不同的平台会选择不同的多路复用函数，优先会选择时间复杂度为O(1)的I/O多路复用函数作为底层实现；但不管哪个平台都会有select函数作为保底实现。</p>
<ul>
<li>Redis基于react设计模式监听I/O事件</li>
</ul>
<h3 id="4-Redis常用数据类型"><a href="#4-Redis常用数据类型" class="headerlink" title="4. Redis常用数据类型"></a>4. Redis常用数据类型</h3><ul>
<li><strong>String</strong>：最基本的数据类型，键值对形式；二进制安全，可以存储任何数据，包括jpg图片和序列化的对象；一个键最大能存储512MB。</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; set name &quot;z3&quot;
OK
127.0.0.1:6379&gt; get name
&quot;z3&quot;
</code></pre>
<ul>
<li><strong>Hash</strong>：String类型的field和value组成的映射表，特别适合用于存储对象</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; hmset lisi name &quot;lisi&quot; age &quot;20&quot; title &quot;dev&quot;
OK
127.0.0.1:6379&gt; hget lisi name
&quot;lisi&quot;
127.0.0.1:6379&gt; hget lisi age
&quot;20&quot;
127.0.0.1:6379&gt; hset lisi age &quot;23&quot;
(integer) 0
127.0.0.1:6379&gt; hget lisi age
&quot;23&quot;
</code></pre>
<ul>
<li><strong>List</strong>：简单的字符串列表，按照String元素插入顺序排序，可以添加元素到列表的头部或者尾部，先进后出，有点像栈；每个列表可存储40多亿，比较适合实现最新消息，历史记录等功能。</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; lpush mylist aaa
(integer) 1
127.0.0.1:6379&gt; lpush mylist bbb
(integer) 2
127.0.0.1:6379&gt; lpush mylist ccc
(integer) 3
127.0.0.1:6379&gt; lrange mylist 0 10
1) &quot;ccc&quot;
2) &quot;bbb&quot;
3) &quot;aaa&quot;
</code></pre>
<ul>
<li><strong>Set</strong>：String类型的无序不可重复集合，集合是通过哈希表实现的，因此添加、删除、查找复杂度都是O(1)；</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; sadd myset 111
(integer) 1
127.0.0.1:6379&gt; sadd myset 222
(integer) 1
127.0.0.1:6379&gt; sadd myset 333
(integer) 1
127.0.0.1:6379&gt; sadd myset 222
(integer) 0
127.0.0.1:6379&gt; smembers myset
1) &quot;111&quot;
2) &quot;222&quot;
3) &quot;333&quot;
127.0.0.1:6379&gt; sadd myset aaa
(integer) 1
127.0.0.1:6379&gt; sadd myset bbb
(integer) 1
127.0.0.1:6379&gt; sadd myset ccc
(integer) 1
127.0.0.1:6379&gt; smembers myset
1) &quot;333&quot;
2) &quot;222&quot;
3) &quot;bbb&quot;
4) &quot;ccc&quot;
5) &quot;111&quot;
6) &quot;aaa&quot;
</code></pre>
<ul>
<li>Soreed Set：是个有序的不允许重复的集合，通过分数来为集合中的成员进行从小到大的排序。</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; zadd myzset 3 abc
(integer) 1
127.0.0.1:6379&gt; zadd myzset 1 abd
(integer) 1
127.0.0.1:6379&gt; zadd myzset 2 abb
(integer) 1
127.0.0.1:6379&gt; zadd myzset 2 abb
(integer) 0
127.0.0.1:6379&gt; zadd myzset 1 bcc
(integer) 1
127.0.0.1:6379&gt; zrangebyscore myzset 0 10
1) &quot;abd&quot;
2) &quot;bcc&quot;
3) &quot;abb&quot;
4) &quot;abc&quot;
</code></pre>
<ul>
<li>用于技术的HyperLogLog，用于支持存储地理位置信息的Geo，可了解。</li>
</ul>
<h4 id="4-1-各数据类型应用场景"><a href="#4-1-各数据类型应用场景" class="headerlink" title="4.1 各数据类型应用场景"></a>4.1 各数据类型应用场景</h4><table>
<thead>
<tr>
<th>类型</th>
<th>简介</th>
<th>特性</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>String(字符串)</td>
<td>二进制安全</td>
<td>可以包含任何数据，如jpg或序列化的对象，一个键最大存储512MB</td>
<td>/</td>
</tr>
<tr>
<td>Hash(字典)</td>
<td>键值对集合，对应Java中的Map类型</td>
<td>适合存储对象，且可以像数据库中update一个属性一样只修改某一项属性值</td>
<td>存储、读取、修改用户属性</td>
</tr>
<tr>
<td>List(列表)</td>
<td>类似双向链表数据结构</td>
<td>增删快，先进后出FILO</td>
<td>最新消息排行、历史记录、消息队列</td>
</tr>
<tr>
<td>Set(集合)</td>
<td>哈希表实现，元素不重复</td>
<td>增删查复杂度都是O(1)，提供了求交集、并集、差集等操作</td>
<td>微博共同好友、利用唯一性统计访问网站的独立IP</td>
</tr>
<tr>
<td>Sorted Set(有序集合)</td>
<td>通过分数来设置元素的权重，按照分数有序排列</td>
<td>数据插入集合时，已经进行了排序</td>
<td>排行榜功能、带权重的消息队列</td>
</tr>
</tbody>
</table>
<h3 id="5-从海量Key里查询出某一固定前缀的Key"><a href="#5-从海量Key里查询出某一固定前缀的Key" class="headerlink" title="5. 从海量Key里查询出某一固定前缀的Key"></a>5. 从海量Key里查询出某一固定前缀的Key</h3><p>首先要问清楚数据规模，就是问清楚边界。</p>
<h4 id="5-1-使用keys命令对线上业务的影响"><a href="#5-1-使用keys命令对线上业务的影响" class="headerlink" title="5.1 使用keys命令对线上业务的影响"></a>5.1 使用keys命令对线上业务的影响</h4><ul>
<li><code>KEYS pattern</code>：查找所有符合给定模式pattern的key<ul>
<li>KEYS指令会一次性返回所有匹配的key</li>
<li>如果符合条件的key数量过大会使服务严重卡顿</li>
</ul>
</li>
</ul>
<h4 id="5-2-SCAN指令解决问题"><a href="#5-2-SCAN指令解决问题" class="headerlink" title="5.2 SCAN指令解决问题"></a>5.2 SCAN指令解决问题</h4><ul>
<li><p><code>SCAN cursor [MATCH pattern][Count count]</code></p>
<ul>
<li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程；</li>
<li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历；</li>
<li>不保证每次执行都返回某个给定数量的元素，支持模糊查询；</li>
<li>一次返回的数量不可控，只能大概率符合count参数</li>
</ul>
</li>
<li><p>大致使用方式</p>
</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; dbsize
(integer) 20000014
127.0.0.1:6379&gt; scan 0 match k1* count 10
1) &quot;1048576&quot;
2) 1) &quot;k1009956&quot;
   2) &quot;k18772691&quot;
   3) &quot;k16159479&quot;
   4) &quot;k16084955&quot;
127.0.0.1:6379&gt; scan 1048576 match k1* count 10
1) &quot;524288&quot;
2) 1) &quot;k14708101&quot;
   2) &quot;k18736411&quot;
   3) &quot;k18277238&quot;
   4) &quot;k15412443&quot;
   5) &quot;k11546971&quot;
   6) &quot;k18222917&quot;
   7) &quot;k18219047&quot;
127.0.0.1:6379&gt; scan 524288 match k1* count 10
1) &quot;11010048&quot;
2) 1) &quot;k16429625&quot;
   2) &quot;k12792948&quot;
   3) &quot;k18338950&quot;
   4) &quot;k18423259&quot;
</code></pre>
<p>可见每次返回的游标并非递增的，所以可能获取重复key，需要在外部程序自行去重（例如Java使用HashSet）。</p>
<h3 id="6-如何通过Redis实现分布式锁"><a href="#6-如何通过Redis实现分布式锁" class="headerlink" title="6. 如何通过Redis实现分布式锁"></a>6. 如何通过Redis实现分布式锁</h3><p>为了保证分布式锁的可用，确保锁实现同时必须满足以下四个条件：</p>
<ul>
<li>互斥性：任意时刻只能有一个客户端获取到锁，不能有两个客户端获取锁；</li>
<li>安全性：锁只能被持有锁的客户端释放，不能被其他客户端释放；</li>
<li>死锁：获取锁的客户端因为某些原因宕机未能释放锁，也需保证其他客户端能加锁；</li>
<li>容错：当某些redis节点宕机时，客户端仍然能获取锁和释放锁。</li>
</ul>
<h4 id="6-1-SETNX命令"><a href="#6-1-SETNX命令" class="headerlink" title="6.1 SETNX命令"></a>6.1 SETNX命令</h4><ul>
<li><code>SETNX key value</code>：如果key不存在，则创建并赋值</li>
</ul>
<p>初期时可以使用这个命令来实现分布式锁，但会有一个问题，SETNX设置的key是长期有效的。</p>
<ul>
<li><code>EXPIRE key seconds</code>：设置key的生存时间，当key过期时，会被自动删除</li>
</ul>
<p>可以通过<code>EXPIRE</code>命令来实现简单的分布式锁，使用<code>setnx</code>命令后返回状态1表示设置成功，然后给该key设置一个过期时间。伪代码如下：</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">RedisService service = SpringUtils.getBean(RedisService.class);
long status = service.setnx(key,&quot;1&quot;);
if (status == 1) {
    service.expire(key,expire);
}
</code></pre>
<p>但有个缺点就是，原子性无法满足，如果设置锁后程序突然奔溃，没有成功设置超时时间，就会发生死锁；两个原子操作结合起来，就不是原子性的了。</p>
<h4 id="6-2-SET命令"><a href="#6-2-SET命令" class="headerlink" title="6.2 SET命令"></a>6.2 SET命令</h4><ul>
<li><code>SET key value [EX seconds][PX milliseconds][NX|XX]</code><ul>
<li>EX seconds：设置键的过期时间为second秒</li>
<li>PX milliseconds：设置键的过期毫秒时间</li>
<li>NX：仅在键不存在时，才对键进行操作</li>
<li>XX：仅在键已存在时，才对键进行操作</li>
<li>SET操作成功，返回OK，反之返回nil</li>
</ul>
</li>
<li>redis中操作示例</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt; set locktarget 12345 ex 10 nx
OK
127.0.0.1:6379&gt; set locktarget 12345 ex 10 nx
(nil)
127.0.0.1:6379&gt; set locktarget 123456 ex 10 nx
(nil)
ten seconds after
127.0.0.1:6379&gt; set locktarget 123456 ex 10 nx
OK
</code></pre>
<ul>
<li>伪代码</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">RedisService service = SpringUtils.getBean(RedisService.class);
String result = service.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);
if (&quot;OK&quot;.equals(result)){
    &#x2F;&#x2F; 执行独占资源逻辑
}
</code></pre>
<h4 id="6-3-当大量key同时过期需注意什么？"><a href="#6-3-当大量key同时过期需注意什么？" class="headerlink" title="6.3 当大量key同时过期需注意什么？"></a>6.3 当大量key同时过期需注意什么？</h4><p>关于集中过期现象，由于清除大量key很耗时，会出现短暂的卡顿现象</p>
<ul>
<li>解决方法：在设置key的过期时间时，给每个key的过期时间加上随机值，使过期时间分散些。</li>
</ul>
<h3 id="7-如何使用Redis做异步队列"><a href="#7-如何使用Redis做异步队列" class="headerlink" title="7. 如何使用Redis做异步队列"></a>7. 如何使用Redis做异步队列</h3><h4 id="7-1-使用List实现"><a href="#7-1-使用List实现" class="headerlink" title="7.1 使用List实现"></a>7.1 使用List实现</h4><p>根据List的数据结构特性，使用RPUSH生产消息，LPOP消费消息。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-sql">127.0.0.1:6379&gt;  rpush testlist aaa
(integer) 1
127.0.0.1:6379&gt;  rpush testlist bbb
(integer) 2
127.0.0.1:6379&gt;  rpush testlist ccc
(integer) 3
127.0.0.1:6379&gt; lpop testlist
&quot;aaa&quot;
127.0.0.1:6379&gt; lpop testlist
&quot;bbb&quot;
127.0.0.1:6379&gt; lpop testlist
&quot;ccc&quot;
</code></pre>
<ul>
<li>缺点：不会等待队列中有值才去消费</li>
<li>弥补：可以在代码层面引入sleep机制去调用lpop重试</li>
<li>如果不用sleep如何实现？：可以使用blpop实现比sleep更加精准的阻塞控制<ul>
<li><code>BLPOP key[key ...] timeout</code>：阻塞直到队列有消息或超时</li>
<li>缺点：只能供一个消费者消费</li>
</ul>
</li>
</ul>
<h4 id="7-2-主题订阅者模式"><a href="#7-2-主题订阅者模式" class="headerlink" title="7.2 主题订阅者模式"></a>7.2 主题订阅者模式</h4><p>使用redis的发布订阅可以实现1对多的生产者消费者模型。</p>
<ul>
<li>发送者（pub）发送消息，订阅者（sub）接收消息。</li>
<li>订阅者可订阅任意数量的频道</li>
<li>使用<code>SUBSCRIBE xxx</code>订阅xxx频道，使用<code>PUBLISH xxx “message”</code>对xxx频道发送消息。</li>
<li>pub/sub的缺点：消息的发布时无状态的，无法保证可达，想解决这个问题就需要使用到专门的消息队列，例如kafka等解决。</li>
</ul>
<h3 id="8-RDB"><a href="#8-RDB" class="headerlink" title="8. RDB"></a>8. RDB</h3><p>RDB（快照）持久化：保存某个时间点的全量数据快照</p>
<h4 id="8-1-默认配置"><a href="#8-1-默认配置" class="headerlink" title="8.1 默认配置"></a>8.1 默认配置</h4><p>默认配置参数位于<code>SNAPSHOTTING</code>配置区，参数如下（<code>save m n</code>触发用的是bgsave）：</p>
<ul>
<li><code>save 900 1</code>：15分钟内改动一次就保存</li>
<li><code>save 300 10</code>：5分钟内改动10次就保存</li>
<li><code>save 60 10000</code>：1分钟内改动1万次就保存</li>
<li><code>save &quot;&quot;</code>：禁用RDB配置</li>
</ul>
<h4 id="8-2-客户端中的相关命令"><a href="#8-2-客户端中的相关命令" class="headerlink" title="8.2 客户端中的相关命令"></a>8.2 客户端中的相关命令</h4><p>redis中也可使用RDB相关命令</p>
<ul>
<li><code>save</code>：马上执行一次RDB，将数据写入到磁盘，会阻塞Redis主进程，不推荐使用。</li>
<li><code>bgsave</code>：redis会后台异步进行快照操作，同时还可以响应客户端请求，推荐；底层会fork出一个子进程来创建rdb文件，不会阻塞主进程。</li>
<li><code>lastsave</code>：查看最后一次成功执行的快照时间</li>
</ul>
<h4 id="8-3-触发RDB情况"><a href="#8-3-触发RDB情况" class="headerlink" title="8.3 触发RDB情况"></a>8.3 触发RDB情况</h4><p>自动触发RDB持久化的情况：</p>
<ul>
<li>根据redis.conf配置文件中的<code>SAVE m n</code>触发</li>
<li>主从复制时，主节点会自动触发</li>
<li>执行Debug Reload时</li>
<li>redis服务Shutdown且没有开启AOF时</li>
</ul>
<h4 id="8-4-BGSAVE原理"><a href="#8-4-BGSAVE原理" class="headerlink" title="8.4 BGSAVE原理"></a>8.4 BGSAVE原理</h4><p><img src="https://s1.ax1x.com/2020/08/13/dpSe2D.png" alt="BGSAVE"></p>
<ul>
<li>系统调用fork()：创建进程，实现了<code>Copy-on-Write</code><ul>
<li>Cow：如果有多个调用者同时要求相同资源（如内存或磁盘上的数据），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初资源不变。</li>
</ul>
</li>
</ul>
<h4 id="8-5-RDB的缺点"><a href="#8-5-RDB的缺点" class="headerlink" title="8.5 RDB的缺点"></a>8.5 RDB的缺点</h4><ul>
<li>rdb备份数据时全量同步，数据量大时会由于I\O而严重影响性能</li>
<li>redis如果突然挂掉会丢失最近一次快照之后的所有数据</li>
</ul>
<h3 id="9-AOF"><a href="#9-AOF" class="headerlink" title="9. AOF"></a>9. AOF</h3><p>AOF（Append-Only-File）持久化：保存写操作指令，简单来说就是RDB备份数据，AOF备份写操作命令</p>
<ul>
<li>会记录下除查询以外的所有变更数据库状态的指令</li>
<li>以append形式追加到AOF文件中（增量）</li>
</ul>
<p>AOF的配置位于Redis配置文件的<code>APPEND ONLY MODE</code>配置区，配置<code>appendonly</code>参数，默认关闭。默认保存文件是<code>appendonly.aof</code>，位于redis启动目录下。默认是每秒保存一次。</p>
<h4 id="9-1-AOF重写机制"><a href="#9-1-AOF重写机制" class="headerlink" title="9.1 AOF重写机制"></a>9.1 AOF重写机制</h4><p>AOF采用的文件追加方式，文件会越来越大，为避免出现此种情况，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可使用命令<code>bgrewriteaof</code>手动启动。</p>
<ul>
<li>重写机制的原理<ul>
<li>调用fork()，创建子进程进行重写操作</li>
<li>子进程把新的AOF写到临时文件中，不依赖旧AOF文件</li>
<li>主进程持续将新变动写到内存和旧AOF中</li>
<li>主进程获取到子进程重写AOF完成信号，往新AOF中同步增量变动</li>
<li>使用新AOF文件替换掉旧AOF文件</li>
</ul>
</li>
</ul>
<p>AOF文件持续增长且文件过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有些类似。</p>
<ul>
<li>触发机制</li>
</ul>
<p>Redis会记录上次重写时的AOF文件大小，默认配置是当AOF文件大小为上次rewrite后大小的一倍且文件大于64MB时触发。</p>
<h4 id="9-2-RDB和AOF的优缺点"><a href="#9-2-RDB和AOF的优缺点" class="headerlink" title="9.2 RDB和AOF的优缺点"></a>9.2 RDB和AOF的优缺点</h4><ul>
<li>RDB优点：全量数据快照，文件小恢复快</li>
<li>RDB缺点：无法保存最近一次快照之后的数据</li>
<li>AOF优点：可读性高，适合保存增量数据，数据不易丢失</li>
<li>AOF缺点：文件体积大，恢复时间长</li>
</ul>
<h3 id="10-Pipeline"><a href="#10-Pipeline" class="headerlink" title="10. Pipeline"></a>10. Pipeline</h3><ul>
<li>Pipeline和Linux的管道类似</li>
<li>Redis基于请求/响应模型，即单一请求处理会一一应答</li>
<li>Pipeline批量执行指令，能节省多次IO往返的时间</li>
<li>如果是有顺序依赖的指令，建议分批发送</li>
</ul>
<h3 id="11-主从同步的原理"><a href="#11-主从同步的原理" class="headerlink" title="11.  主从同步的原理"></a>11.  主从同步的原理</h3><ol>
<li>Salve启动成功连接到Master后会发送一个同步命令sync</li>
<li>Master启动一个后台进程bgsave，将Redis中的数据快照保存到RDB文件中</li>
<li>Master会将保存数据快照期间接收到的写命令缓存到复制缓冲区中<ol>
<li>全量复制：Master完成备份文件操作后，将该RDB文件发送给Slave节点</li>
<li>增量复制：Master继续将新收集到的写操作命令依次传给slave，完成同步操作</li>
</ol>
</li>
<li>Master将期间收集到的写命令发送给Salve节点以更新至主节点最新状态</li>
</ol>
<h3 id="12-哨兵模式"><a href="#12-哨兵模式" class="headerlink" title="12. 哨兵模式"></a>12. 哨兵模式</h3><p>Redis官方提供的一款集群管理工具，用于解决主机宕机的主从切换问题；本身是独立运行的进程，能够在后台监控主机是否故障，主要功能如下：</p>
<ul>
<li>监控：检查主节点是否运行正常</li>
<li>提醒：通过API向管理员或者其他应用程序发送故障通知</li>
<li>自动故障迁移：主从切换，主机故障会根据投票机制自动选取一台从机转换为主机。</li>
</ul>
<h3 id="13-一致性哈希算法"><a href="#13-一致性哈希算法" class="headerlink" title="13. 一致性哈希算法"></a>13. 一致性哈希算法</h3><p>一致性hash算法可以很好的解决Redis分布式的问题，将缓存均匀分配，提高缓存命中率；大致是通过对2的32次方取模，将哈希值空间组织成一个虚拟的圆环，再将节点分布到圆环上。</p>
<p>基本原理：</p>
<ul>
<li>假设一个圆环，环上有2^32^个点，从0~2^32^-1</li>
<li>对Redis节点进行哈希：hash(服务器IP)%2^32^，将服务器节点映射到环上</li>
<li>对缓存数据进行哈希：hash(缓存项的key)%2^32^，将各缓存项映射到环上</li>
<li>从缓存项的位置开始，顺时针方向遇到第一个服务器就是缓存项的缓存位置</li>
</ul>
<h4 id="13-1-优缺点"><a href="#13-1-优缺点" class="headerlink" title="13.1 优缺点"></a>13.1 优缺点</h4><ul>
<li>优点：当某个节点宕机时，缓存项会打到顺时针下去第一个节点，而不会丢失</li>
<li>缺点：如果节点被密集映射在同一区域，会导致大量缓存项被缓存到同一台服务器，导致数据倾斜，如果该节点宕机，可能会造成缓存雪崩<ul>
<li>解决方案：为每个节点生成多个虚拟节点，并映射到环上，尽量使缓存分配均匀</li>
<li>虚拟节点的哈希计算可以采用节点IP+数字后缀，例如<code>Hash(&quot;192.168.1.101#1&quot;)%2^32</code></li>
</ul>
</li>
</ul>
<h3 id="14-Redis事务和MySQL事务的区别"><a href="#14-Redis事务和MySQL事务的区别" class="headerlink" title="14. Redis事务和MySQL事务的区别"></a>14. Redis事务和MySQL事务的区别</h3><h4 id="14-1-Redis事务的实现原理"><a href="#14-1-Redis事务的实现原理" class="headerlink" title="14.1 Redis事务的实现原理"></a>14.1 Redis事务的实现原理</h4><p>Redis的事务就是：在一个队列中，一次性、顺序性、排他性的串行化执行一系列命令。</p>
<ul>
<li>redis实现事务是基于commands队列的，本质就是一组命令队列；</li>
<li>没有开启事务，命令会被立即执行返回结果，并直接写入磁盘中；</li>
<li>开启事务后，命令不会立即执行，而是按顺序排入队列中，调用exec才会执行命令队列；</li>
</ul>
<h4 id="14-2-MySQL事务的实现原理"><a href="#14-2-MySQL事务的实现原理" class="headerlink" title="14.2 MySQL事务的实现原理"></a>14.2 MySQL事务的实现原理</h4><ul>
<li>mysql实现事务是基于undo/redo日志的；</li>
<li>undo记录修改前的状态，rollback就是基于undo日志实现的，回滚到修改前的状态；</li>
<li>redo记录修改后的状态，commit基于redo日志实现的，提交事务；</li>
<li>mysql无论是否开启事务，sql都会被立即执行并返回结果，只是事务开启后执行的状态记录在redo日志中，只有执行commit命令后，数据才会被写入到磁盘中。</li>
</ul>
<h3 id="15-Redis有几种数据淘汰策略"><a href="#15-Redis有几种数据淘汰策略" class="headerlink" title="15. Redis有几种数据淘汰策略"></a>15. Redis有几种数据淘汰策略</h3><ul>
<li>volatile-lru：加入键时如果过限，首先从设置了过期时间的键集合中移除最久没有使用的键；</li>
<li>allkeys-lru：加入键如过限，首先通过LRU算法移除最久没有使用的键；</li>
<li>volatile-lfu：从所有配置了过期时间的键中移除使用频率最少的键；</li>
<li>allkeys-lfu：从所有键中移除使用频率最少的键；</li>
<li>volatile-random：从过期键的集合中随机移除键</li>
<li>allkeys-random：从所有键集合中随机移除；</li>
<li>volatile-ttl：从配置了过期时间的键中移除将要过期的键；</li>
<li>noeviction：不进行移除，内存过限将返回错误信息；</li>
</ul>
<h3 id="16-缓存穿透及解决"><a href="#16-缓存穿透及解决" class="headerlink" title="16. 缓存穿透及解决"></a>16. 缓存穿透及解决</h3><p>缓存穿透就是查询大量不存在的key，查询不到就穿透缓存层到数据库去查询了，会对后端数据库造成压力。</p>
<ul>
<li>解决方案：<ul>
<li>对查询结果为空的key也进行缓存，可以将过期时间设短一些或者key对应数据insert后清除该缓存。</li>
<li>使用布隆过滤器(bitmap)进行过滤，将所有可能存在的key放到一个大的Bitmap中，查询时过滤。</li>
</ul>
</li>
</ul>
<h3 id="17-缓存雪崩及解决"><a href="#17-缓存雪崩及解决" class="headerlink" title="17. 缓存雪崩及解决"></a>17. 缓存雪崩及解决</h3><p>当某一redis节点突然宕机或者大量缓存集中某一时间段失效，这样失效时，就会越过缓存层直接打到数据库上，对后端系统带来很大压力；此为缓存雪崩。</p>
<ul>
<li>解决方案：<ul>
<li>当缓存失效后，通过加锁或队列来限制读取数据库的线程数量，减轻后端压力。</li>
<li>做二级缓存，A1原始缓存设置短期缓存时间，A2拷贝缓存设置长期，当A1失效时访问A2即可。</li>
<li>设置key缓存时间时，加入随机种子设置不同过期时间，让缓存失效时间尽量均匀</li>
</ul>
</li>
</ul>
<h3 id="18-Redis的常见应用"><a href="#18-Redis的常见应用" class="headerlink" title="18. Redis的常见应用"></a>18. Redis的常见应用</h3><ol>
<li>会话缓存（session cache）</li>
<li>全页缓存（FPC）</li>
<li>队列</li>
<li>排行榜/计数器</li>
<li>发布/订阅</li>
</ol>

            </div>
            <hr>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="https://zero024.cn" class="b-link-green">Zero的博客</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/DataBase/Redis-interview.html" class="b-link-green">Redi相关面试题</a>
                </p>
            </div>
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '232778317d016c12944b',
        clientSecret: 'eff34508ca3902812960cd0c524ad0300bae98d8',
        repo: 'blog-comments',
        owner: 'zero6996',
        admin: "zero6996",
        id: '2020-08-17T23-22-00',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-dot-circle-o"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/DataBase/Redis-interview.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="Redi相关面试题">
                        
                        <span class="card-title">Redi相关面试题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">Redis面试题主流应用架构图


客户端请求数据会先去缓存层查询；
查询到数据直接返回
查询不到数据，就会穿透缓存层去存储层查询；
存储层查询到数据后，携带数据回写到缓存层中，然后返回给客户端；
如果存储层无法完成请求，可以让客户端请求直</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-08-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/DataBase/" class="post-category" target="_blank">
                                    DataBase
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Redis/" target="_blank">
                        <span class="chip bg-color">Redis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/JavaAdvanced/Java-Lock.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="Java锁体系概述">
                        
                        <span class="card-title">Java锁体系概述</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">Java锁体系Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码、使用场景进行举例，以介绍主流锁的知识点及其适用场景。

乐观锁，悲观锁
读锁（共享锁），写锁（排他锁）
自旋锁，非自</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-07-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JavaAdvanced/" class="post-category" target="_blank">
                                    JavaAdvanced
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java-Lock/" target="_blank">
                        <span class="chip bg-color">Java Lock</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('200')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Zero的博客<br />'
            + '作者: Zero<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>

    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">362.4k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/zero6996" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:1490829140@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1490829140" class="tooltipped" data-tooltip="QQ联系我: 1490829140" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input" autofocus>
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/js/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>