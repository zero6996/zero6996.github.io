{"meta":{"title":"Zero的博客","subtitle":"畏惧错误,就是毁灭进步","description":"欢迎来到我的博客！","author":"Zero","url":"https://zero024.cn"},"pages":[{"title":"friends","date":"2020-03-01T07:27:25.000Z","updated":"2020-03-01T07:27:49.061Z","comments":true,"path":"friends/index.html","permalink":"https://zero024.cn/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-01T07:24:33.000Z","updated":"2020-03-01T07:25:29.221Z","comments":true,"path":"categories/index.html","permalink":"https://zero024.cn/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-01T07:26:19.000Z","updated":"2020-03-01T07:26:51.961Z","comments":true,"path":"about/index.html","permalink":"https://zero024.cn/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-03-01T08:33:51.000Z","updated":"2020-03-01T08:34:12.836Z","comments":true,"path":"contact/index.html","permalink":"https://zero024.cn/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-01T07:25:04.000Z","updated":"2020-03-01T07:25:36.932Z","comments":true,"path":"tags/index.html","permalink":"https://zero024.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法之美-[数据结构基础]","slug":"AlgorithmTrip/数据结构基础","date":"2020-03-24T05:55:00.000Z","updated":"2020-03-24T07:35:40.048Z","comments":true,"path":"Algorithm-trip/Data-structure-basic.html","link":"","permalink":"https://zero024.cn/Algorithm-trip/Data-structure-basic.html","excerpt":"1. 算法概述 什么是算法$(algorithm)$？ 在计算机领域里，算法就是一系列程序指令，用于处理特定的运算和逻辑问题。衡量算法优劣的主要标准是时间复杂度和空间复杂度。","text":"1. 算法概述 什么是算法$(algorithm)$？ 在计算机领域里，算法就是一系列程序指令，用于处理特定的运算和逻辑问题。衡量算法优劣的主要标准是时间复杂度和空间复杂度。 什么是数据结构$(data \\ structure)$？ 数据结构是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。 数据结构包含数组、链表这样的线性数据结构，也包含树、图这样的复杂数据结构。 什么是时间复杂度？ 时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作$T(n)=O(f(n))$。 常见的时间复杂度按照从低到高的顺序，包括$O(1),O(logn),O(n),O(nlogn),O(n^2)$等。 什么是空间复杂度？ 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大O表示法，记作$S(n)=O(f(n))$。 常见的空间复杂度按照从低到高的顺序，包括$O(1),O(N),O(n^2)$等。其中递归算法的空间复杂度和递归深度成正比。 2. 数据结构基础2.1 数组和链表2.1.1 数组数组是有限个相同类型的变量所组成的有序集合，每个数组中的变量被称为元素。数组在内存中是顺序存储的，因此可以很好的实现逻辑上的顺序表。 数组读取元素和更新元素的时间复杂度都是$O(1)$。 插入数组元素存在3种情况： 尾插入：直接把插入的元素放在数组尾部的空闲位置即可，等同于更新元素的操作。复杂度$O(1)$。 中间插入：由于数组中的每个元素都是其固定的下表，所以不得不首先把插入位置及后面的元素向后移动，腾出地方，再将要插入的元素放到对应的数组位置上。$O(n)$。 超范围插入：会涉及到数组的扩容，可以创建一个新数组，长度是旧数组的2倍，再把旧数组中的元素全部过去，就实现数组的扩容了。$O(n)$。 数组删除元素操作和插入操作相反，如果是中间删除，那么其后的元素都要前移。 2.1.2 数组小结数组的插入操作，数组扩容的时间复杂度是$O(n)$，插入并移动元素的时间复杂度也是$O(n)$，综合起来插入操作的时间复杂度为$O(n)$。删除操作只涉及到元素的移动，复杂度也是$O(n)$。 数组的优势 数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。有一种高效查找元素的算法叫二分查找法，就是利用了数组的这个优势。 数组的劣势 数组的劣势体现在插入和删除元素方面。由于数组元素连续紧密地存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。 数组适合的是读操作多、写操作少的场景。 2.1.3 链表链表是一种在物理上非连续、非顺序的数据结构，由若干节点(node)所组成。单向链表的每个节点细分为两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next。 private static class Node{ int data; Node next; } 链表的第一个节点被称为头节点，最后一个节点被称为尾节点，尾节点的next指针指向null。 2.1.4 双向链表双向链表比单向链表稍微复杂一下，它每个节点除了拥有data和next指针，还有指向前置节点的prev指针。 链表在内存中的存储方式是随机存储，链表采用了见缝插针的存储方式，每个节点分布在内存的不同位置，依靠next指针关联起来，这样可以灵活有效地利用零散的碎片空间。 链表中的数据只能按顺序逐级查找，最坏的时间复杂度是$O(n)$。 链表的插入和删除操作，复杂度是$O(1)$。 2.1.5 数组和链表小结数组和链表相关操作的性能对比 查找 更新 插入 删除 数组 $O(1)$ $O(1)$ $O(n)$ $O(n)$ 链表 $O(n)$ $O(1)$ $O(1)$ $O(1)$ 数组的优势在于能快速定位元素，对于读操作多、写操作少的场景非常适合。相反，链表优势在于能够灵活地进行插入和删除操作，如果需在尾部频繁插入、删除元素，用链表更合适。 2.2 栈和队列2.2.1 物理结构和逻辑结构 物理结构 如果把数据结构比作人类，那么物理结构就是人的血肉和骨骼，看得见摸得着实实在在的。例如数组和链表都是内存中实实在在的存储结构。 逻辑结构 在物质的人体之上，还存在着人的思想和精神，它们看不见、摸不着。提供把物质层面的人体比作数据存储的物理结构，那么精神层面的人格则是数据存储的逻辑结构。逻辑结构是抽象的概念，它依赖于物理结构而存在。 2.2.2 栈栈是一种线性数据结构，栈中的元素只能先入后出(First In Last Out,简称FILO)。最早进入的元素存放位置叫栈底(bottom)，最后进入的元素存放位置叫栈顶(top)。栈这种数据结构既可以用数组实现，也可以用链表。 入栈 入栈操作(push)就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将成为新栈顶。 出栈 出栈操作(pop)就是把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶。 代码实现如下 &#x2F;** * @Author: zero * @Description: 使用数组实现栈的基本操作 * Date: Create in 2020&#x2F;3&#x2F;21 8:40 * Modified By: *&#x2F; public class MyStack { private int[] array; private int top; public MyStack(int capacity){ this.array = new int[capacity]; } public void push(int element) throws Exception { if (top &gt; array.length){ throw new Exception(&quot;StackOverflowError&quot;); } array[top++] = element; } public void pop() throws Exception { if (top==0){ throw new Exception(&quot;No ElementError&quot;); } delete(top-1, array); top--; } &#x2F;** * 数组的删除操作，就是覆盖前一位 * @param index 栈顶位置 * @param array 当前栈 *&#x2F; public void delete(int index, int[] array) { int[] arrNew = new int[array.length - 1]; System.out.println(array[index]); for (int i = index; i &lt; array.length - 1; i++) { array[i] = array[i + 1]; } System.arraycopy(array, 0, arrNew, 0, arrNew.length); this.array = arrNew; } public void show(){ System.out.println(Arrays.toString(this.array)); } public static void main(String[] args) throws Exception { MyStack myStack = new MyStack(8); System.out.println(&quot;压栈&quot;); for (int i = 1; i &lt;= 8; i++) { myStack.push(i); } myStack.show(); for (int i = 0; i &lt;= 7; i++) { System.out.print(&quot;弹栈&quot;); myStack.pop(); } myStack.show(); } } 出栈入栈只会影响最后一个元素，因此时间复杂度都是${O(1)}$。 2.2.3 队列队列(queue)是一种线性数据结构，它跟单向隧道类似，队列中的元素只能先入先出(First In First Out，简称FIFO)。队列的出口端叫作队头(front)，队列的入口端叫作队尾(rear)。 入队 入队(enqueue)就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。 出队 出队(dequeue)操作就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。 循环队列 如果按照上面的方式不断出队，队头指针右移，队头左边的空间就失去作用了，故用数组实现的队列可以采用循环队列的方式来维持队列容量的恒定。 什么是循环队列 你可以把它理解为一个首尾相连的圆环，其中有两个指针：队头指针和队尾指针。这两个指针始终按照同一个方向前进，两个指针互相追赶着对方；入队操作时队尾指针(队尾指针会占据一个空闲空间)一直前进，直到遇到队头指针便代表空间用完了，停止入队；出队操作就是标记释放空间(数组内实际没有删除元素)，队头指针一直前进，直到遇到队尾指针便代表空间释放完了，停止出队。下面就是循环队列的简单示意图： 循环队列如何实现 那么如何做到队头队尾指针能持续前进的同时不超过数组大小呢？我们可以用到取余%操作符，当队头或队尾值达到数组最大值时，重新归零，当队头队尾值相同时不做添加删除操作，以实现数组的循环。 实现过程 入队操作：队尾下标 = (队尾下标+1)%数组长度 出队操作：队头下标 = (队头下标+1)%数组长度 队列空间满的条件：(队尾下标+1)%数组长度==队头下标 代码实现 &#x2F;** * @Author: zero * @Description: 使用数组实现循环队列 * Date: Create in 2020&#x2F;3&#x2F;23 10:20 * Modified By: *&#x2F; public class MyQueue { private int[] array; &#x2F;&#x2F; 队头 private int front; &#x2F;&#x2F; 队尾 private int rear; public MyQueue(int capacity){ &#x2F;&#x2F; 因为队尾始终要占一个空间，故这里把空间补上 this.array = new int[capacity + 1]; } &#x2F;** * 入队操作 * @param element 入队的元素 *&#x2F; public void enQueue(int element) throws Exception{ if ((rear + 1) % array.length == front){ throw new Exception(&quot;The Queue is Full!&quot;); } array[rear] = element; rear = (rear + 1) % array.length; } &#x2F;** * 出队操作 * @return * @throws Exception *&#x2F; public int deQueue() throws Exception{ if (rear == front){ throw new Exception(&quot;The Queue is Empty!&quot;); } int deQueueElement = array[front]; front = (front + 1) % array.length; return deQueueElement; } &#x2F;** * 输出队列 *&#x2F; public void output(){ for (int i = front; i!=rear ; i=(i+1)%array.length) { System.out.println(array[i]); } } public static void main(String[] args) throws Exception { MyQueue myQueue = new MyQueue(6); myQueue.enQueue(3); myQueue.enQueue(5); myQueue.enQueue(2); myQueue.enQueue(7); myQueue.enQueue(4); System.out.println(&quot;输出一下&quot;); myQueue.output(); myQueue.deQueue(); myQueue.deQueue(); System.out.println(&quot;输出二下&quot;); myQueue.output(); myQueue.enQueue(8); myQueue.enQueue(6); myQueue.enQueue(1); System.out.println(&quot;输出三下&quot;); myQueue.output(); } } 循环队列充分利用了数组的空间，也避免了数组元素的整体移动，入队和出队的时间复杂度都是${O(1)}$ 2.3 栈和队列的应用 栈的应用 栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。例如实现递归操作，就可以用栈来代替，因为栈可以回溯方法的调用链。还有一个经典的应用场景就是面包屑导航，使用户在浏览页面时可以轻松地回溯到上一级或更上一级页面。 队列的应用 队列的输出顺序和输入顺序相同，所有队列通常用于对“历史”的回放，也就是按照顺序，把“历史”重演一遍。例如在多线程中争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序。网络爬虫实现网站抓取时，也是把待爬取的网站URL存入队列中，在按照存入的顺序依次抓取和解析的。 双端队列 双端队列(deque)这种数据结构，结合了栈和队列的优点，从队头一端可以入队或出队，从队尾一端也可以入队或出队。 优先队列 优先队列遵循谁优先级高谁先出队，元素被赋予优先级。当访问元素时，高优先级的优先被访问到。 2.4 散列表散列表也叫做哈希表(hash table)，这种数据结构提供了键(key)和值(value)的映射关系。只要给出一个key，就可以高效查找到它所匹配的value，时间复杂度接近于${O(1)}$。 2.4.1 哈希函数在Java及大多数面向对象的语言中，每个对象都有属于自己的hashcode，这个hashcode是区分不同对象的重要标志。无论对象自身的类型是什么，它的hashcode都是一个整型变量。既然是整型变量那么转化为数组下标也不难实现，最简单的转化方式是按照数组长度进行取模运算。在Java中的哈希函数并没有直接采用取模运算，而是利用了位运算的方式来优化性能。 2.4.2 散列表的读写2.4.2.1 写操作(put)写操作就是在散列表中插入新的键值对(JDK中叫Entry)。例如调用hashMap.put(&quot;002931&quot;,&quot;王五&quot;)，就是插入一组key为002931、value为王五的键值对。具体操作如下： 通过哈希函数，计算key的哈希值，然后通过取模运算转化为数组的下标5。 如果数组下标5对应的位置没有元素，就把Entry填充到数组下标5的位置。 由于数组的长度是有限的，当插入的Entry越来越多时，不同的key通过哈希函数获得的下标可能是相同的。这种情况，就叫作哈希冲突。 解决哈希冲突主要有两种方式，开放寻址法和链表法。 开放寻址法就是当计算出的数组下标相同时，以该冲突下标经过一定算法重新计算一个下标，再尝试放入元素，如果还冲突就如上操作继续计算，直到不冲突为止。 链表法就是在发生冲突时将具有相同哈希值的元素放到同一个单链表中。 Java集合类HashMap就是使用链表法解决哈希冲突的，HashMap数组的每个元素不仅是一个Entry对象，还是链表的头节点。当新的Entry映射到冲突的数组位置时，只要插入到对应的链表中即可。 2.4.2.2 读操作(get)读操作就是通过给定key，在散列表中查找对应的value。具体操作如下： 通过哈希函数，把key转换为数组下标5。 找到数组下标5对应的元素，如果这个元素的key为002936，那么就找到了；如果不是，就遍历该位置的链表，看能否找到与key相匹配的元素。 2.4.2.3 扩容(resize)当经过多次元素插入后，散列表达到一定饱和度时，key映射位置发生冲突的概率会逐渐提高。如此就会形成大量元素拥挤在相同的数组下标位置，形成很长的链表，对插入和查询操作的性能都有很大影响。 此时，散列表就需要进行扩容操作。对于HashMap来说，影响扩容的因素有两个： Capacity，即HashMap当前的长度 LoadFactor，即HashMap的负载因子，默认值为0.75f。 threshold，经上述两个值计算出的临界值。 扩容操作步骤： 扩容，创建一个新的Entry空数组，长度是原数组的两倍。 重新Hash，遍历原Entry数组，把所有的Entry重新hash到新数组中。 2.5. 小结 什么是数组：数组是由有限个相同类型的变量所组成的有序集合，它的物理存储方式是顺序存储，访问方式是随机访问。利用下标查找数组元素的时间复杂度是${O(1)}$，中间插入、删除数组元素的时间复杂度是${O(n)}$。 什么是链表：链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。查找链表节点的时间复杂度是${O(n)}$，中间插入、删除节点的时间复杂度是${O(1)}$。 什么是栈：栈是一种线性逻辑结构，可以用数组实现也可以用链表实现。栈包含入栈和出栈操作，遵循先入后出的原则(FILO)。 什么是队列：队列也是一种线性逻辑结构，可以用数组和链表实现。队列包含入队和出队操作，遵循先入先出原则(FIFO)。 什么是散列表：散列表也叫哈希表，是存储Key-Value映射的集合。对于某个Key，散列表可以在接近${O(1)}$的时间内进行读写操作。散列表通过哈希函数实现Key和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突。","categories":[{"name":"Algorithm trip","slug":"Algorithm-trip","permalink":"https://zero024.cn/categories/Algorithm-trip/"}],"tags":[{"name":"Data structure","slug":"Data-structure","permalink":"https://zero024.cn/tags/Data-structure/"}]},{"title":"最全面的MySQL7种JOIN连接","slug":"Database/7种JOIN连接","date":"2020-03-20T07:00:00.000Z","updated":"2020-03-28T08:49:16.528Z","comments":true,"path":"DataBase/Join.html","link":"","permalink":"https://zero024.cn/DataBase/Join.html","excerpt":"1. MySQL逻辑架构简介MySQL的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。","text":"1. MySQL逻辑架构简介MySQL的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离，这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 1.1. 连接层最上层是一些客户端和连接服务，例如连接处理，身份验证，安全性等。 1.2. 服务层MySQL核心部分，主要完成权限判断，查询缓存，SQL解析及优化等功能。 1.3. 引擎层存储引擎层负责MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信；不同的存储引擎具有不同的功能特性。 1.4. 存储层数据存储层主要是将数据存储在运行于裸系统的文件系统上，并完成与存储引擎的交互。 补充文章 2. SQL语句执行流程 3. MyISAM和InnoDB 对比项 MyISAM InnoDB 主外键 不支持 支持 事务 不支持 支持 行表锁 表锁，即操作一条记录就锁住整个表，不适合高并发的操作 行所，即操作时只锁某一行，不对其他行有影响适合高并发的操作 缓存 只缓存索引，不缓存真实数据(时间换空间) 不仅缓存索引还缓存真实数据，对内存要求较高，且内存大小对性能有影响(空间换时间) 表空间 小 大 关注点 性能 事务 4. SQL性能下降的原因4.1 查询语句没写好避免select *全表扫描 4.2 索引失效建立好索引，且保证索引不失效，或为热点字段建立索引 单值索引：create index idx_user_name on user(name); 复合索引：create index idx_user_nameEmail on user(name,email); 4.3 关联查询太多join设计缺陷或不得已的必要需求 4.4 服务器调优及参数设置缓冲，线程数等。 5. Join连接完整的SQL Join连接图示如下： 5.1 INNER JOIN(内连接) 内连接查询返回表A和表B中所有匹配行的结果，示例如下： SELECT &lt;select_list&gt; FROM Table_A a INNER JOIN Table_B b ON a.key = b.key 5.2 LEFT JOIN(左连接) 左连接查询返回所有表A中的记录，不管是否有匹配记录在表B中(匹配不到的标记为null)，示例如下： SELECT &lt;select_list&gt; FROM Table_A a LEFT JOIN Table_B b on a.key = b.key 5.3 RIGHT JOIN(右连接) 和左连接相反，右连接查询会返回所有表B中的记录，不管是否有匹配记录在表A中(无匹配标记null)，示例如下： SELECT &lt;select_list&gt; FROM Table_A a RIGHT JOIN Table_B b on a.key = b.key 5.4 LEFT Excluding JOIN 左排除右连接，它会返回表A中所有不在表B中的行(返回表A独有部分)，示例： SELECT &lt;select_list&gt; FROM Table_A a LEFT JOIN Table_B b on a.key = b.key WHERE b.key IS NULL 5.5 RIGHT Excluding JOIN 右排除左连接，它会返回表B中所有不在表A中的行，示例： SELECT &lt;select_list&gt; FROM Table_A a RIGHT JOIN Table_B b on a.key = b.key WHERE a.key IS NULL 5.6 OUTER Excluding JOIN 外连接排除内连接结果，它会返回所有表A和表B中没有匹配的行(返回各自独有部分)，示例： SELECT &lt;select_list&gt; FROM Table_A A FULL OUTER JOIN Table_B B ON A.Key = B.Key WHERE A.Key IS NULL OR B.Key IS NULL 5.7 FULL OUTER JOIN 全连接，返回表A和表B中的所有行(匹配不到标记null)，示例如下： SELECT &lt;select_list&gt; FROM Table_A a FULL OUTER JOIN Table_B b on a.key = b.key 注意：MySQL天生不支持全连接，你可以使用UNION函数连接两个查询(左连接+右连接)来实现全连接。 UNION函数用于合并两个或多个SELECT语句的结果集并去重。 参考文章 5.8 常规SQL查询语句模板 SELECT DISTINCT &lt;select_list&gt; FROM &lt;left_table&gt; &lt;join_type&gt; JOIN &lt;right_table&gt; on &lt;join_condition&gt; WHERE &lt;where_condition&gt; GROUP BY &lt;group_by_list&gt; HAVING &lt;having_condition&gt; ORDER BY &lt;order_by_condition&gt; LIMIT &lt;limit number&gt;","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://zero024.cn/categories/DataBase/"}],"tags":[{"name":"MySQL Join","slug":"MySQL-Join","permalink":"https://zero024.cn/tags/MySQL-Join/"}]},{"title":"趟坑之路-[SpringBoot整合Redis做缓存]","slug":"FrameWork/SpringBoot整合Redis","date":"2020-03-14T06:00:00.000Z","updated":"2020-03-25T01:17:11.379Z","comments":true,"path":"FrameWork/Springboot-Integrate-Redis.html","link":"","permalink":"https://zero024.cn/FrameWork/Springboot-Integrate-Redis.html","excerpt":"redis是一个高性能的非关系型内存数据库，通常被用作数据缓存，此文记录了SpringBoot2.x整合Redis做缓存服务器的常规步骤及排错。","text":"redis是一个高性能的非关系型内存数据库，通常被用作数据缓存，此文记录了SpringBoot2.x整合Redis做缓存服务器的常规步骤及排错。 本文使用到的环境： OS win10 JDK 1.8 SpringBoot版本 2.2.5.RELEASE redis版本 2.x以上 下面开始整合redis。 1. 整合Redis步骤1.1 引入依赖在pom.xml文件中引入redis依赖 &lt;!-- redis的支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 1.5版本默认采用的客户端是jedis, 2.x版本默认是lettuce jedis：多线程使用同一连接时是线程不安全的，需使用到连接池为每个jedis分配一个连接。 lettuce：当多线程使用同一连接时，是线程安全的，底层基于Netty的 。 1.2 配置文件中配置redis在项目的application.properties配置文件中配置redis，配置如下 ########redis配置############## # Redis数据库索引(默认为0) spring.redis.database=0 #服务器地址 spring.redis.host=127.0.0.1 #连接端口号 spring.redis.port=6379 #连接密码，默认空 spring.redis.password= #连接池最大连接数(负值表示无限制) spring.redis.jedis.pool.max-active=10 #连接池最大阻塞等待时间(负值表示无限制) spring.redis.jedis.pool.max-wait=-1 #连接池中的最大空闲连接 spring.redis.jedis.pool.max-idle=8 #连接池中的最小空闲连接 spring.redis.jedis.pool.min-idle=0 #连接超时时间(毫秒) spring.redis.timeout=5000 # 若开启redis方式的session存储，type值应为redis spring.session.store-type=redis spring.session.timeout=10 server.servlet.session.timeout=10 # 显示hibernate的sql语句,方便查看是否成功缓存 spring.jpa.show-sql=true 1.3 创建一个Redis缓存配置类 @Configuration @EnableCaching public class RedisConfig { &#x2F;* SpringBoot2.x的ReidsCacheManager自定义配置方法 缓存之后,key会多一个前缀,默认是将CacheName作为key的前缀 *&#x2F; @Bean public RedisCacheManager redisCacheManager(RedisConnectionFactory connectionFactory) { RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); &#x2F;&#x2F;解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); &#x2F;&#x2F; 配置序列化（可解决Redis中非中文的问题，但会导致反序列化异常，原因是PageImpl没有空参构造器导致的，如果只是做缓存 &#x2F;&#x2F; 可以选择不自定义value的序列化规则，因为jackson2的序列化器反序列化时需要序列化类有空参构造，如果没有就会报错 &#x2F;&#x2F; 且不自定义value的序列化规则，不影响其反序列化出来的内容，只是redis中显示非中文，或者使用JDK默认的序列化器） RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() &#x2F;&#x2F; 缓存有效期60s .entryTtl(Duration.ofSeconds(60)) &#x2F;&#x2F; &#x2F;&#x2F; 设置key序列化 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) &#x2F;&#x2F; &#x2F;&#x2F; 设置value序列化 .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) &#x2F;&#x2F;不缓存null值 .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(connectionFactory) .cacheDefaults(config) .build(); System.out.println(&quot;ReidsCacheManager自定义配置方法被调用了...&quot;); return cacheManager; } } 如果开启设置value序列化，会和我下面自定义的Page类冲突，故如果使用到我自定义的Page类，需要将value序列化关闭。 1.4 在适当的地方加入缓存 User类 @Entity &#x2F;&#x2F; 表示这是个实体类 @Table(name = &quot;user_&quot;) &#x2F;&#x2F; 表示该类对应的表名是user @SuppressWarnings(&quot;all&quot;) &#x2F;&#x2F; 压制所有警告 @JsonIgnoreProperties({&quot;handler&quot;,&quot;hibernateLazyInitianlizer&quot;}) public class User implements Serializable{ &#x2F;&#x2F;注意需实现序列化接口 private static final long serialVersionUID = -6373343588870458520L; @Id &#x2F;&#x2F; 表明主键 @GeneratedValue(strategy = GenerationType.IDENTITY) &#x2F;&#x2F; 表明自增长方式 @Column(name = &quot;id&quot;) &#x2F;&#x2F; 表名对应的数据库字段名 private int id; @Column(name = &quot;name&quot;) private String name; public User() { } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;}&#39;; } } UserDao public interface UserDao extends JpaRepository&lt;User,Integer&gt; { } UserService public interface UserService { public Page4Navigator&lt;User&gt; getList(Pageable pageable); public void save(User user); public void delete(User user); public User get(int id); } UserServiceImpl @Service &#x2F;&#x2F; 设置缓存名称 @CacheConfig(cacheNames = &quot;user&quot;) public class UserServiceImpl implements UserService { @Autowired UserDao userDao; @Override &#x2F;&#x2F; 开启缓存 @Cacheable(key = &quot;&#39;user&#39;+#p0.offset+&#39;-&#39;+#p0.pageSize &quot;) public Page4Navigator&lt;User&gt; getList(Pageable pageable) { Page&lt;User&gt; pageFromJPA = userDao.findAll(pageable); Page4Navigator&lt;User&gt; page = new Page4Navigator&lt;&gt;(pageFromJPA, 5); return page; } @Override &#x2F;&#x2F; 该方法调用后立即清除缓存 @CacheEvict(allEntries = true) public void save(User user) { userDao.save(user); } @Override @CacheEvict(allEntries = true) public void delete(User user) { userDao.delete(user); } @Override &#x2F;&#x2F; 将查询结果缓存到redis中， user+#p0指定传入的第一个参数+user做为redis的key @Cacheable(key = &quot;&#39;user &#39;+ #p0&quot;) public User get(int id) { return userDao.findById(id).get(); } } Redis注解方式@CacheConfig定义该类下所有缓存到redis中的父名称。 @Cacheable根据方法的请求参数对其结果进行缓存，根据Key进行判断，如已在缓存中，则不执行方法，直接从redis中查询返回结果。 cacherNames：存储该方法调用结果的缓存名称。 key：缓存的key，可以为空；如果指定要按照SpEL表达式编写，不指定默认按照方法的所有参数进行组合。 cacheManager：指定使用的cacheManager condition：缓存的条件，可以为空，使用SpEL编写，返回布尔值，只有为true才进行缓存。举例：@Cacheable(cacheNames=“userTemp1”, key = “‘UserId_’ + #id”,condition = “#id&lt;=110”) 表示判断id值，如果id值小于等于110，在方法执行成功后，缓存到redis中。 @CachePut根据方法的请求参数对其结果进行缓存，更新Redis中对应键的值，参数同上。 @CacheEvict根据一定条件对缓存进行清空，特有参数如下： allEntries：是否清空所有缓存内容，默认false；指定为true则方法调用后将立即清空所有缓存。 beforeInvocation：是否在方法执行前就清空，默认false；指定为true则方法还未执行时就会清空缓存。缺省清空下如果方法抛出异常，则不会清空缓存。 其他详细Redis注解内容可见文章 分页工具类Page public class Page4Navigator&lt;T&gt; implements Serializable{ private static final long serialVersionUID = -4042369404722051112L; Page&lt;T&gt; page4jpa; int navigatePages; int totalPages; int number; long totalElements; int size; int numberOfElements; List&lt;T&gt; content; boolean isHasContent; boolean first; boolean last; boolean isHasNext; boolean isHasPrevious; int[] navigatepageNums; public Page4Navigator() { } public Page4Navigator(Page&lt;T&gt; page4jpa, int navigatePages) { this.page4jpa = page4jpa; this.navigatePages = navigatePages; totalPages = page4jpa.getTotalPages(); number = page4jpa.getNumber(); totalElements = page4jpa.getTotalElements(); size = page4jpa.getSize(); numberOfElements = page4jpa.getNumberOfElements(); content = page4jpa.getContent(); isHasContent = page4jpa.hasContent(); first = page4jpa.isFirst(); last = page4jpa.isLast(); isHasNext = page4jpa.hasNext(); isHasPrevious = page4jpa.hasPrevious(); calcNavigatepageNums(); } private void calcNavigatepageNums() { int navigatepageNums[]; int totalPages = getTotalPages(); int num = getNumber(); &#x2F;&#x2F;当总页数小于或等于导航页码数时 if (totalPages &lt;= navigatePages) { navigatepageNums = new int[totalPages]; for (int i = 0; i &lt; totalPages; i++) { navigatepageNums[i] = i + 1; } } else { &#x2F;&#x2F;当总页数大于导航页码数时 navigatepageNums = new int[navigatePages]; int startNum = num - navigatePages &#x2F; 2; int endNum = num + navigatePages &#x2F; 2; if (startNum &lt; 1) { startNum = 1; &#x2F;&#x2F;(最前navigatePages页 for (int i = 0; i &lt; navigatePages; i++) { navigatepageNums[i] = startNum++; } } else if (endNum &gt; totalPages) { endNum = totalPages; &#x2F;&#x2F;最后navigatePages页 for (int i = navigatePages - 1; i &gt;= 0; i--) { navigatepageNums[i] = endNum--; } } else { &#x2F;&#x2F;所有中间页 for (int i = 0; i &lt; navigatePages; i++) { navigatepageNums[i] = startNum++; } } } this.navigatepageNums = navigatepageNums; } &#x2F;&#x2F;省略get&#x2F;set方法 ... ... } 控制器 @RestController public class UserController_Json { @Autowired UserService userService; &#x2F;** * 获取全部user对象 * @return * @throws Exception *&#x2F; @GetMapping(&quot;&#x2F;user&quot;) public List&lt;User&gt; listUser(@RequestParam(value = &quot;start&quot;,defaultValue = &quot;0&quot;) int start, @RequestParam(value = &quot;size&quot;,defaultValue = &quot;5&quot;) int size) throws Exception{ start = start &lt; 0?0:start; new Sort.Order(Sort.Direction.DESC,&quot;id&quot;); Sort orders = Sort.by(&quot;id&quot;); &#x2F;&#x2F; 根据start、size和sort创建分页对象 PageRequest pageable = PageRequest.of(start,size,orders); &#x2F;&#x2F; DAO根据这个分页对象获取结果page,这个page对象里，不仅包含了分页信息，还包含了数据信息,类转换异常？ Page4Navigator&lt;User&gt; list = userService.getList(pageable); return list.getContent(); } &#x2F;** * 获取单个user对象 * @param id * @return * @throws Exception *&#x2F; @GetMapping(&quot;&#x2F;user&#x2F;{id}&quot;) @ResponseBody public User getUser(@PathVariable(&quot;id&quot;) int id, HttpServletResponse response) throws Exception{ User user = userService.get(id); System.out.println(user); return user; } &#x2F;** * 添加用户 * @param user * @throws Exception *&#x2F; @PutMapping(&quot;&#x2F;user&quot;) public void addUser(@RequestBody User user) throws Exception{ System.out.println(&quot;SpringBoot接受到浏览器以JSON格式提交的数据：&quot;+user); userService.save(user); } } 1.5 启动redis找到redis-server.exe，双击运行。 1.6 启动项目启动项目测试接口，http://localhost/user，http://localhost/user/4，查看hql语句输出，可以看到除了第一次访问会查询数据库，后续都没有查询数据库，而是从redis中获取数据。 2. 踩坑记录2.1 二次查询报错，PageImpl没有构造方法，导致无法反序列化其原因在于我自定义的Page类中有使用到org.springframework.data.domain.Page类，该类有一个实现类PageImpl，此类是没有实现无参构造器的，故从缓存中读取数据反序列化时会报错：org.springframework.data.redis.serializer.SerializationException: Could not read JSON: Can not construct instance of org.springframework.data.domain.PageImpl .... 解决这个问题有两个方法： 不设置RedisConfig配置类中自定义的value序列化规则，因为使用jackson2JsonRedisSerializer设置value的序列化值就会报错，不设置就不会；不设置的弊端就是，Redis数据库中存储的数据是HEX格式的，也就是16进制数据，不方便查阅。 可以使用另一个Page类，替换我原本的page类，暂时没有深入研究这两个类的区别，有兴趣的同学可以研究下。 public class MyPage&lt;T&gt; implements Iterable&lt;T&gt;, Serializable { private static final long serialVersionUID = -3720998571176536865L; private List&lt;T&gt; content = new ArrayList&lt;&gt;(); private long totalElements; private int pageNumber; private int pageSize; private boolean first; private boolean last; private boolean empty; private int totalPages; private int numberOfElements; public MyPage() { } public MyPage(Page&lt;T&gt; page) { this.content = page.getContent(); this.totalElements = page.getTotalElements(); this.pageNumber = page.getPageable().getPageNumber(); this.pageSize = page.getPageable().getPageSize(); this.numberOfElements = page.getNumberOfElements(); } &#x2F;&#x2F; 省略get&#x2F;set方法 ... ... &#x2F;&#x2F;迭代器 @Override public Iterator&lt;T&gt; iterator() { return getContent().iterator(); } } 2.2 java.util.LinkedHashMap cannot be cast to XXX发生在读取redis缓存的时候报错，java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to XXX，但是我个人代码中并没有定义和使用到LinkedHashMap，查资料后发现原因是Jackson2JsonRedisSerializer，该序列化器中默认使用的ObjectMapper是直接new ObjectMapper()创建的，这样ObjectMapper会将redis中的字符串反序列化为LinkedHashMap类型，导致后续类型转换错误。 解决方法，配置objectMapper的默认类型： Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.configure(MapperFeature.USE_ANNOTATIONS, false); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false); &#x2F;&#x2F; 配置如下，解决LinkedHashMap转换异常 objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); 2.3 redis数据非中文只需在redisCacheManager方法中进行redis的缓存配置，设置value序列化。 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() &#x2F;&#x2F; 缓存有效期60s .entryTtl(Duration.ofSeconds(60)) &#x2F;&#x2F; 设置key序列化 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) &#x2F;&#x2F; 设置value序列化 .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) &#x2F;&#x2F;不缓存null值 .disableCachingNullValues(); 2.4 相同类转换异常关闭IDEA的热部署即可，原因和JVM的双亲委派有关，感兴趣的自查。","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://zero024.cn/tags/Redis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zero024.cn/tags/SpringBoot/"}]},{"title":"SpringBoot简单入门","slug":"FrameWork/SpringBoot简单入门","date":"2020-03-08T01:00:00.000Z","updated":"2020-03-25T01:17:03.438Z","comments":true,"path":"FrameWork/SpringBoot-Basic.html","link":"","permalink":"https://zero024.cn/FrameWork/SpringBoot-Basic.html","excerpt":"SpringBoot简单入门Spring是一个JavaWeb开发框架，极大的简化开发，降低了对配置文件的要求；能迅速的开发web应用，几行代码就可以开发一个http接口。","text":"SpringBoot简单入门Spring是一个JavaWeb开发框架，极大的简化开发，降低了对配置文件的要求；能迅速的开发web应用，几行代码就可以开发一个http接口。 1. 创建简单项目 点击菜单-&gt;New-&gt;Project-&gt;Spring Initalizr 然后点击Next 输入如图所示两个地方参数，其他参数一般默认，然后Next 接着选择Web,然后勾选Spring Web即可，Next 最后确认一下项目名称和位置即可，点击Finish完成项目创建。 项目创建好后，自带一个Application，在里面填写如下内容 启动Application项目，测试访问。 2. 关于打包问题通常部署SpringBoot项目可以采用两种方式：全部打包成一个jar包，或者打包成一个war包。 2.1 打包成jar包使用IDEA的话非常简单，找到右侧侧边栏的maven图标，点击项目生命周期，然后双击install即可，没问题应该显示BUILD SUCCESS。 使用maven的mvn install一样可以，该命令需在项目根目录打开命令行窗口下运行。 该命令会在你项目的target目录下生产一个jar文件，使用命令java -jar yourjarName.jar运行该jar文件即可启动项目。 这个jar包里面包含项目的全部文件，以及Tomcat服务器，所以无论放到哪里只要有java环境就可以运行启动项目。 2.2 打包成war包 修改pom.xml，添加打包类型和依赖 &lt;!-- 打包成war包需加这一行--&gt; &lt;packaging&gt;war&lt;&#x2F;packaging&gt; &lt;!-- 打包从war包时需添加此依赖,防止打包冲突--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;!-- 表示只在编译和测试过程有效，生成war包不会加入--&gt; &lt;&#x2F;dependency&gt; 修改启动类文件，继承SpringBootServletInitializer @SpringBootApplication public class HelloDemoApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(HelloDemoApplication.class); } public static void main(String[] args) { SpringApplication.run(HelloDemoApplication.class, args); } } SpringBoot项目想运行在第三方Tomcat上必须实现SpringBootServletInitializer接口的configure方法才能让外部容器运行。 使用maven的clean命令，然后使用package命令，就会在target目录下生成.war文件 将该文件复制到外部Tomcat的webapps目录下，重命名为ROOT.war，方便访问。 不修改为ROOT，需要加项目名称才可以访问。 bin目录下点击startup.bat文件，启动项目，测试访问。 3. 关于Tomcat中文乱码问题在tomcat的conf文件夹下，打开logging.properties文件，将java.util.logging.ConsoleHandler.encoding = UTF-8修改java.util.logging.ConsoleHandler.encoding = GBK 4. SpringBoot热部署 在settings中开启Build project automatically，自动构建项目功能。 开启动态自动编译，同时按住Ctrl+Shift+Alt+/，然后点击Registry，勾选如下参数，并配置时间。 开启项目的热部署策略，在项目配置中选择如下选项即可。 项目添加热部署插件，在xml中配置如下。 &lt;!-- 热部署依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;!-- true才生效 --&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;!--仅在运行期有效，不参与打包--&gt; &lt;&#x2F;dependency&gt; 保险起见，浏览器f12 ✅Disable cache。 5. 关于错误处理定义一个全局的异常处理器，然后跳转到错误页面 @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = Exception.class) public ModelAndView defaultErrorHandler(HttpServletRequest req,Exception e) throws Exception{ ModelAndView view = new ModelAndView(); view.addObject(&quot;exception&quot;,e); view.addObject(&quot;url&quot;,req.getRequestURL()); view.setViewName(&quot;errorPage&quot;); return view; } }","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zero024.cn/tags/SpringBoot/"}]},{"title":"OSI7层模型和TCP/IP四层模型简要总结","slug":"Interview/OSI七层模型","date":"2020-03-02T11:00:00.000Z","updated":"2020-03-25T00:59:02.212Z","comments":true,"path":"Interview/computer-networks.html","link":"","permalink":"https://zero024.cn/Interview/computer-networks.html","excerpt":"前言关于OSI7层模型相关知识点，以前是总结过一篇文章的，但因为太过详细，显的有些繁琐了，今天复习到计网知识，便重新写一篇精简版的，方便回顾记忆。","text":"前言关于OSI7层模型相关知识点，以前是总结过一篇文章的，但因为太过详细，显的有些繁琐了，今天复习到计网知识，便重新写一篇精简版的，方便回顾记忆。 1. OSI7层模型和TCP4层模型 1.1 模型各层功能 OSI7层模型 TCP/IP4层模型 功能 各层协议簇 应用层 应用层 文件传输,电子邮件,文件服务,虚拟终端 TFTP,HTTP,SNMP,FTP,SMTP,DNS,Telent 表示层 数据格式化,代码转换,数据加解密 无协议 会话层 提供建立或解除连接的方法 无协议 传输层 传输层 提供端对端的接口 TCP,UDP 网络层 网络层 为数据包选择路由 IP,ICMP,RIP,OSPF,BCP 数据链路层 链路层 传输有地址的帧及差错控制等功能，提供可靠的数据传输 SLIP,CSLIP,PPP,ARP,RARP,MTU 物理层 利用传输介质以比特流数据形式透明传输数据 ISO2100,IEEE802,IEEE 简言之：OSI7层模型下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。 2. TCP和UDP的区别 类型 特点 性能 应用场景 首部字节 是否面向连接 传输可靠性 传输形式 传输效率 所需资源 TCP 面向连接 可靠 字节流 慢 多 要求通信数据可靠(如文件传输,邮件收发等) 20-60 UDP 无连接 不可靠 数据报文段 快 少 要求通信速度高(如视频直播,语音聊天等) 8 TCP是面向连接的高可靠性的服务，利用握手确认和重传机制保证数据不丢失，利用序列号保证消息包的顺序交互，因其要保证消息的可靠性和有序性，故传输效率较慢；且消息头最少20字节，资源消耗较多。 UDP是无连接的不保证数据可靠性的服务，可能会丢失数据且无序；因无序考虑连接和可靠性，故传输效率很快，消息头只需8字节，轻量级。 3. 浏览器输入URL后经历的流程 DNS解析：首先浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名所对应的IP地址。DNS缓存从近到远依次是：浏览器缓存:arrow_right: 系统hosts文件:arrow_right: 路由器缓存:arrow_right:IPS服务器缓存 :arrow_right:根域名服务器缓存:arrow_right:顶级域名服务器缓存。找到IP则返回，不会查询后续缓存。 TCP连接：根据IP地址和默认端口(80)来和服务器建立TCP连接(三次握手)。 发送HTTP请求：浏览器发出读取文件的HTTP请求，该请求将发送给服务器。 服务器处理请求并返回HTTP报文：服务器对浏览器请求作出响应，并把对应的带有HTML文本的HTTP响应报文发送给浏览器。 浏览器解析渲染页面：浏览器接收到HTML，并在显示窗口内渲染它。 连接结束：浏览器释放TCP连接(四次挥手)。 4. TCP三次握手和四次挥手(老面试题了)4.1 三次握手为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。 详细图解如下： 简单示意图： 一次握手：客户端发送带有SYN标志的数据包给服务端； 二次握手：服务端发送带有SYN/ACK标志的数据包给客户端； 三次握手：客户端发送带有ACK标志的数据包给服务端，连接建立。 4.2 为什么要三次握手？三次握手的目的是建立可靠的通信信道，通讯就是数据的发送和接收，也就是说三次握手的主要目的是双方确认自己和对方的发送与接收功能是正常的。故三次握手的含义如下： 第一次握手：客户端什么都确认不了；服务端确认了对方发送正常 第二次握手：客户端可以确认：自己发送、接收正常，对方发送、接收正常；服务端可以确认，自己接收正常，对方发送正常 第三次握手：客户端已经确认过自己收发正常，对方收发正常；服务器端收到确认包后可以确认，自己发送、接收正常，对方发送接收也正常 所以只需三次握手就能确认双方收发功能是否正常 4.2.1 第二次握手中，传了SYN，为什么还要传ACK双方通信无误必须是两者互相发送信息都无误。传了SYN，证明发送方到接收方的通道是没有问题，但是接收方到发送方的通道还需要ACK信号来验证。 4.3 四次挥手断开一个TCP连接需进行“四次挥手”。 详细图解如下： 文字流程： 客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态； 服务器收到这个FIN，回发一个ACK，确认序号为收到的序号加1，此时服务器进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。 服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态。 客户端收到FIN后，进入TIME_WAIT状态，接着回发一个ACK给服务器；服务器进入CLOSED状态，客户端在经过2MSL后也会进入CLOSED状态，完成四次挥手。 举个栗子： 我和朋友打电话，通话即将结束时，我说：“我没啥要说的了”，朋友回答：“好的，我知道了”，但是朋友可能还要话要讲，所以我不能直接挂断电话，于是朋友又说了一些话，最后朋友回答：“我说完了”，我回答：“知道了，那我挂了”，这样通信才算结束。","categories":[{"name":"Interview","slug":"Interview","permalink":"https://zero024.cn/categories/Interview/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zero024.cn/tags/计算机网络/"}]},{"title":"Hexo部署至coding","slug":"Other/hexo部署至coding","date":"2020-02-29T11:23:13.000Z","updated":"2020-03-25T01:00:41.202Z","comments":true,"path":"Other/hexo-Deployed-to-coding.html","link":"","permalink":"https://zero024.cn/Other/hexo-Deployed-to-coding.html","excerpt":"前言因本人的hexo是部署至github的，现在换了个主题图片有点多，导致访问速度非常慢，故想到部署到国内的服务器上，所以找到了coding，准备把hexo也同步部署到coding上去。","text":"前言因本人的hexo是部署至github的，现在换了个主题图片有点多，导致访问速度非常慢，故想到部署到国内的服务器上，所以找到了coding，准备把hexo也同步部署到coding上去。 本文章记录了如何将hexo部署至coding，从而加快国内站点的访问，本文前置条件： 拥有hexo博客，会hexo的基本操作； 拥有coding账户，且实名(未实名不能创建静态网站)。 1. coding配置首先进行coding的配置，步骤如下： 打开你的coding页面，新建一个项目； 注意：不要选择代码托管，这样不能创建静态页面 填写项目基本信息； 一般都选择默认配置即可，点击完成创建。 进入项目，点击代码仓库，找到项目的https链接，后面会用到。 2. hexo配置接下来到hexo进行相关配置。 2.1 安装部署服务器插件打开你本地的hexo文件夹，然后打开Cmd或者GitBash窗口，输入以下命令安装插件： npm install hexo-deployer-git --save 我安装过了所以显示的不一样。 本人使用的cnpm是npm的淘宝镜像源，访问速度比npm快一些，比较推荐更换，详见链接 2.2 修改站点配置文件该文件位于主目录下，名称是_config.yml，使用任意编辑器打开。 打开后找到deploy，修改配置如下： # Deployment ## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html deploy: type: git # 部署类型 repo: # 上传仓库地址 github: https:&#x2F;&#x2F;github.com&#x2F;zero6996&#x2F;zero6996.github.io.git # github仓库地址 coding: https:&#x2F;&#x2F;e.coding.net&#x2F;zero024&#x2F;hexo.git # coding仓库地址，将你的coding链接复制到这里。 branch: master # 推送到远程的分支 注意yml的语法，缩进都是空两格，然后：冒号后面要空一格才能生效 2.3 部署项目回到命令行窗口，输入hexo d部署项目，如果没有问题的话应该显示有如下关键信息： Branch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;https:&#x2F;&#x2F;github.com&#x2F;zero6996&#x2F;zero6996.github.io.git&#39;. Everything up-to-date Branch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;https:&#x2F;&#x2F;e.coding.net&#x2F;zero024&#x2F;hexo.git&#39;. Everything up-to-date INFO Deploy done: git 2.4 配置静态网站回到coding的hexo项目，刷新一下可以看到代码仓库中已经有代码了，下面找到左侧构建与部署一栏，进行静态网站的相关配置。 点击立即发布静态网站，进入新建静态网站页面，网站名称任意，其他选项一般默认即可。 保存后点击立即部署，即可部署项目到网站，coding给了个默认地址可以访问，点击即可查看静态网站部署效果。 3. 域名配置如果你拥有域名的话，可以绑定域名，具体操作如下。 3.1 域名解析本人使用的是阿里的域名，其他服务商的操作也大致相同。 首先进入域名解析页面，点击添加记录，设置一个CNAME，主机记录www，解析线路默认，记录值为你coding的默认访问地址； 在添加一个CNAME，主机记录@，解析默认，记录值同上； 这样DNS解析就设置完毕了，回到coding进行域名绑定，点击你的静态网站，右上角有个设置选项，可以进行很多设置。 找到自定义域名，输入你的域名地址进行绑定，添加两个。 大功告成！你可以使用你的域名快速的访问你的博客了。","categories":[{"name":"Other","slug":"Other","permalink":"https://zero024.cn/categories/Other/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zero024.cn/tags/Hexo/"}]},{"title":"计科04:[二进制]","slug":"ComputerScience/04_二进制","date":"2020-01-22T15:30:00.000Z","updated":"2020-03-25T01:04:45.873Z","comments":true,"path":"ComputerScience/binary-system.html","link":"","permalink":"https://zero024.cn/ComputerScience/binary-system.html","excerpt":"二进制视频 1. 二进制原理逻辑门可以判断布尔语句，布尔代数只有两个值：True和False，但如果只有两个值，我们该如何表达更多东西？上文提到，1个二进制可以代表1个数，我们可以把真和假，当做1和0，如果想表示更多东西，加位数就行了。","text":"二进制视频 1. 二进制原理逻辑门可以判断布尔语句，布尔代数只有两个值：True和False，但如果只有两个值，我们该如何表达更多东西？上文提到，1个二进制可以代表1个数，我们可以把真和假，当做1和0，如果想表示更多东西，加位数就行了。 我们熟悉的十进制，只有10个数(0-9)，要表示大于9的数，就需要加位数。拿263举例，这个数字实际代表了：2个100、6个10、3个1，加在一起就是263。每列有不同的乘数(100,10,1)，每个乘数比右边大十倍，如果超过9，就要在下一列进1(满十进一，满二十进二…)，因此叫“基于十的表示法”或十进制。 二进制也是如此，只不过是基于2而已。因为二进制只有两个可能的数，1和0；意味着每个乘数必须是右侧乘数的两倍，就不是十进制的100，10，1了，而是4,2,1。拿二进制数101举例，意味着有1个“4”，0个“2”和1个“1”，加在一起就得到十进制的5。 为了表示更大的数字，二进制需要更多的位数，拿二进制数10110111举例，可以用相同的方法转成十进制：1 x 128 ，0 x 64 ，1 x 32 ，1 x 16 ，0 x 8 ，1 x 4 ，1 x 2 ，1 x 1，加起来等于183。 二进制的计算也不难，以十进制数183加19举例：首先 3 + 9，得到 12，然后位数记作 2，满10向前进 1；再算 8+1+1=10，所以位数记作0，再满10进 1，最后1+1=2，位数记作2，和就是202。 二进制的计算：先把19换算为二进制就是00010011，从个位开始计算，1+1=2，但二进制中没有 2，所以位数记作 0 ，进 1；然后1+1，再加上进位的1，等于3，用二进制表示是11，所以位数记作 1，再进 1，以此类推。最后得到的数字，跟十进制的202是一样的。 二进制中，一个1或0叫一“位”，上面的例子我们用了8位，8位能表示的最小数是0(8位都是0)，最大数是255(8位都是1)；能表示256个不同的值，就是2的8次方。 你可能听过8位机，8位图像，8位音乐，意思是计算机里大部分操作都是8位8位这样处理的；但256个值不算多，意味着8位游戏只能用256种颜色，8位非常常见，以至于有专门的名字：字节(Byte)。 1字节(byte)等于8位(bits)，如果有10个字节，就代表80位。千字节(kb)兆字节(mb)千兆字节(gb)，不同前缀代表不同数量级，就像1千克=1000克，1千字节=1000字节(或8000位)。如今你可能有1TB的硬盘，代表8万亿个1和0。二进制里，1 千字节 = 2的10次方 = 1024 字节，1000 也是千字节（KB）的正确单位，1000 和 1024 都对。 2. 正数、负数、整数、浮点数的表示你应该听过32位或64位计算机，意思是一块块处理数据，每块是32位或64位。32位表示的最大数是43亿左右，也就是32个1。所以 Instagram 照片很清晰，因为它有上百万种颜色，如今都用32位颜色。当然，不是所有数字都是正数，因此就需要有方法表示正数和负数，大部分计算机用第一位表示正负，即1是负，0是正，用剩下31位来表示数字，能表示的数字范围是正20亿到负20亿，虽然是很大的数，但有时还不够用。 计算机必须给内存中每一个位置，做一个 “标记”，这个标记叫 “位址”, 目的是为了方便存取数据，如今硬盘已经增长到 GB 和 TB，上万亿个字节！内存地址也应该有64位；除了负数和正数，计算机也要处理非整数，比如 12.7 和 3.14，或”星历 43989.1”，这叫浮点数。 因为小数点可以在数字间浮动，所以有好几种方法 表示浮点数，最常见的是 IEEE 754 标准，它用类似科学计数法的方法，来存十进制值；例如，625.9 可以写成 0.6259×10 ^ 3，这里有两个重要数字：.6259 叫 “有效位数” , 3 是指数。在32位浮点数中，第一位表示数字的正负，接下来 8 位存指数，剩下 23 位存有效位数。 3. ASCII为了表示文字，最直接的方法是给字母编号：A是1，B是2，C是3，以此类推。著名英国作家 弗朗西斯·培根（Francis Bacon）曾用 5位序列 来编码英文的 26 个字母，在十六世纪传递机密信件。五位（bit）可以存 32 个可能值（2^5） - 这对26个字母够了，但不能表示 标点符号，数字和大小写字母。 ASCII，美国信息交换标准代码，发明于 1963 年，ASCII 是 7 位代码，足够存 128 个不同值，范围扩大之后，可以表示大写字母，小写字母,数字 0 到 9, @ 这样的符号, 以及标点符号；举例，小写字母 a 用数字 97 表示，大写字母 A 是 65，: 是58 ，) 是41等等。 ASCII 甚至有特殊命令符号，比如换行符，用来告诉计算机换行。因为在老计算机系统中，如果没换行符，文字会超出屏幕。 ASCII 是个很早的标准，故被广泛使用，让不同公司制作的计算机，能互相交换数据，这种通用交换信息的能力叫 “互用性”；但其有个限制：它是为英语设计的。 好在一个字节有8位，而不是7位，128到 255 的字符渐渐变得常用，这些字符以前是空的，是给各个国家自己 “保留使用的”。在美国，这些额外的数字主要用于编码附加符号，比如数学符号，图形元素和常用的重音字符；另一方面，虽然拉丁字符被普遍使用，但在俄罗斯，他们用这些额外的字符表示西里尔字符；而希腊电脑用希腊字母，等等。这些保留下来给每个国家自己安排的空位，对大部分国家都够用。 4. Unicode随着计算机在亚洲兴起，这种做法彻底失效了，中文和日文这样的语言有数千个字符，根本没办法用 8 位来表示所有字符！ 为了解决这个问题，每个国家都发明了多字节编码方案，但不相互兼容。日本人总是碰到编码问题，以至于专门有词来称呼：”mojibake” 意思是 乱码。 所以 Unicode 诞生了，它是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求， 设计于 1992 年，解决了不同国家不同标准的问题。最常见的Unicode是16位的，有超过一百万个位置，对所有语言的每个字符都够用了。100多种字母表加起来占了12万个位置。还有位置放数学符号，甚至 Emoji。 就像 ASCII 用二进制来表示字母或是其他格式，比如MP3或GIF，用二进制编码声音/颜色，表示图片、电影、音乐。重要的是，这些标准归根到底就是一长串位，包括短信， YouTube 视频，整个互联网上的每个网页，甚至操作系统，都只不过是一长串的1和0，二进制能表示一切！","categories":[{"name":"ComputerScience","slug":"ComputerScience","permalink":"https://zero024.cn/categories/ComputerScience/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"https://zero024.cn/tags/二进制/"}]},{"title":"计科03:[布尔代数和逻辑门]","slug":"ComputerScience/03_布尔逻辑和逻辑门","date":"2020-01-10T12:00:00.000Z","updated":"2020-03-25T01:04:11.330Z","comments":true,"path":"ComputerScience/logic-gate.html","link":"","permalink":"https://zero024.cn/ComputerScience/logic-gate.html","excerpt":"布尔逻辑和逻辑门视频 1. 什么是二进制计算机是最早的机电设备，一般用十进制计数，比如用齿轮数来代表十进制，再到晶体管计算机。","text":"布尔逻辑和逻辑门视频 1. 什么是二进制计算机是最早的机电设备，一般用十进制计数，比如用齿轮数来代表十进制，再到晶体管计算机。 只用 开/关两种状态来代表信息，这叫二进制。如果只需表示true和false，两个值就够了。电路闭合，电流流过，代表“真”；电路断开，无电流通过，代表“假”。二进制也可以写成1和0而不是true和false，只是不同的表达方式罢了。 晶体管的确可以不只是 开/关，还可以让不同大小的电流通过。一些早期电子计算机是三进制的，有 3 种状态，甚至五进制，5 种状态；问题是，状态越多，越难区分信号。如果手机快没电了或者附近有电噪音，比如有人在用微波炉，信号可能会混在一起，而每秒百万次变化的晶体管会让这个问题变得更糟。所以我们把两种信号尽可能分开，只用”开”和”关”两种状态，可以尽可能减少这类问题。 1.1 布尔代数计算机用二进制的另一个原因是有一整个数学分支存在，专门处理“真”和“假”，它已经解决了所有法则和运算，它叫作“布尔代数”。 乔治·布尔（George Boole）是布尔二字的由来，他是一位19 世纪自学成才的英国数学家。他感兴趣用数学式子扩展亚里士多德基于哲学的逻辑方法，布尔用逻辑方程系统而正式的证明真理(truth)。他在1847 年的第一本书”逻辑的数学分析”中介绍过：在”常规“的代数里，是数字，可以进行加法或乘法之类的操作；但在布尔代数中，变量的值是 true 和 false，能进行逻辑操作。 2. 三个基本操作：NOT,AND,OR布尔代数中三个基本操作：NOT, AND 和 OR，这些操作都非常有用。 2.1 NOTNOT操作把布尔值反转，把true进行NOT就会变成false，反之亦然。 根据NOT操作的输入和输出，做出如下表 使用晶体管可以轻松实现这个逻辑。晶体管只是电控制的开关，有3根线：2根电极和一根控制线。控制线通电时，电流就可以从一个电极流到另一个电极；就像水龙头一样：打开水龙头，水流出，关掉水龙头，就没水了。 可以把控制线，当做输入，底部的电极，当做输出，所以一个晶体管，就有一个输入和一个输出。当打开输入时，输出也会打开，因为电流可以通过；如果关闭输入，输出也会关闭，因为电流无法通过。用布尔代数来说，输入为真，输出为真；输入为假，输出为假。这个电路没什么意思，因为它没有做什么事情。 但稍加修改，即可实现NOT，只要把输出放到上面即可。如下图示： 当打开输入on，电流可以流过然后“接地”，输出就没有电流了，所以输出是off。 当输入是off，电流没法接地，就流过了输出，所以输出是on。 接地：大地是一个电阻非常低、电容量非常大的物体，拥有吸收无限电荷的能力，而且在吸收大量电荷后仍能保持电位不变 ，故接地后设备其他线路就不会有电流输出。 如上图示叫非门(NOT gate)，之所以叫门，是因为它能控制电流的路径。 2.2 ANDAND操作有两个输入，1个输出，如下表所示： 输入 输入 输出 0 0 0 0 1 0 1 0 0 1 1 1 简单记忆：遇假即假，全真即真。 为了实现与门(AND gate)，需要两个晶体管连在一起，如下图示： 这样有2个输入和1个输出，如果只打开A，不打开B，电流无法流到output，所以输出是false；如果只打开B，不开A，也一样，电流无法流到output；只有A和B都打开了，output才有电流。 2.3 OROR操作也有两个输入，1个输出，其中2个输入里1个是true，输出就是true。如下表所示： 输入 输入 输出 0 0 0 0 1 1 1 0 1 1 1 1 遇真即真，全假即假。 为了实现或门(OR gate)，除了晶体管还要额外的线，不是串联起来，而是并联。如下图示： 左边这条线表示电流输入，如果A和B都是OFF，电流就无法通过任意一条线流到输出，所以输出是OFF；如果只打开A，电流可以流过，输出ON；如果只打开B，电流也可以通过，输出ON；只要A或者B是ON，输出就是ON，如果AB都是ON，那么输出自然是ON。 3. XOR异或异或(XOR)，输入相同时输出false，不同才输出true。如下XOR表： 如果两个输入都是true，或者都是false，那么XOR输出false；如果一个输入为true，另一个为false，那么XOR输出才会是true。 相同即假，不同才真。 用晶体管实现异或门(XOR gate)，需使用到前面提到的三种门来做异或门。墙裂推荐配合视频学习理解(时间07:38)。 如上图A和B输入两个true，到下方的OR门，输出依然是true，上方第一个AND门输入两个true，输出也是true，然后电流到NOT门，反转电流高低电平，true变成了false，到最后一个AND门就是输入一个false一个true，输出就是false；如此便满足XOR门第一个条件，输入两个true，输出false，以此类推。","categories":[{"name":"ComputerScience","slug":"ComputerScience","permalink":"https://zero024.cn/categories/ComputerScience/"}],"tags":[{"name":"逻辑门","slug":"逻辑门","permalink":"https://zero024.cn/tags/逻辑门/"}]},{"title":"计科02:[电子计算机]","slug":"ComputerScience/02_电子计算机","date":"2020-01-08T08:20:00.000Z","updated":"2020-03-25T01:03:26.733Z","comments":true,"path":"ComputerScience/electronic-computing.html","link":"","permalink":"https://zero024.cn/ComputerScience/electronic-computing.html","excerpt":"电子计算机视频 1. 计算机的发展20世纪初，早期的计算设备都针对特定用途，比如 制表机，大大推进了政府和企业，它们帮助甚至代替了人工，然而人类社会的规模在以前所未有的速度增长。","text":"电子计算机视频 1. 计算机的发展20世纪初，早期的计算设备都针对特定用途，比如 制表机，大大推进了政府和企业，它们帮助甚至代替了人工，然而人类社会的规模在以前所未有的速度增长。 20世纪上半叶，世界人口几乎翻倍。一战动员7千万人，二战1亿人，全球贸易和运输更加紧密，工程和科学的复杂度也达到新高，我们甚至开始考虑登陆其他行星。 复杂度的增高导致数据量暴增，人们需要更多自动化、更强的计算能力。很快，柜子大小的计算机变成房间大小，维护费用高且容易出错，而正是这些机器，为未来的创新打下基础。 2. 哈佛Mark1号最大的机电计算机之一是：哈佛马克一号。 IBM在1944完成建造，给二战同盟国建造的，它有76万5千个组件，300万个连接点和500英里长的导线。为了保持内部机械装置同步，它有一个50英尺的传动轴，由一个 5 马力的电机驱动。这台机器最早的用途之一 是给”曼哈顿计划”跑模拟，这台机器的大脑是”继电器”。 3. 继电器继电器是：用电控制的机械开关，继电器里，有根“控制线路”，控制电路是开还是关。”控制线路” 连着一个线圈，当电流流过线圈，线圈产生电磁场，吸引金属臂，从而闭合电路。你可以把继电器想成水龙头，控制线路就是打开水龙头，水会流出来，关闭水龙头，水就没有了。继电器是一样的，只不过控制的是电子 而不是水。这个控制电路可以连到其他电路，比如马达，马达让计数齿轮+1，就像制表机一样。 不幸的是，继电器内的机械臂是“有质量的“，因此无法快速开关。1940年代一个好的继电器1秒能翻转50次。看起来好像很快，但还不够快，不足以解决复杂的大问题。哈佛马克一号，1秒能做3次加减法运算，一次乘法要花6秒，除法要花15秒，更复杂的操作比如三角函数，可能要一分钟以上。 除了速度慢，另一个限制就是齿轮磨损，任何会动的机械都会随时间磨损。有些部件会完全损坏，有些则是变黏，变慢，变的不可靠。并且随着继电器数量增加，故障概率也会增加。 哈佛马克一号有大约3500个继电器，哪怕假设继电器的使用寿命是10年，也意味着平均每天得换一个故障继电器！ 这个问题很严重，因为有些重要运算要运算好几天，而且还有更多其他问题要考虑。 4. BUG的由来这些巨大、黑色、温暖的机器也会吸引昆虫，1947年9月，哈佛马克2型的操作员从故障继电器中，拔出一只死虫。Grace Hopper曾说：”从那时起，每当电脑出了问题，我们就说它出了bug(虫子)“。这就是术语“bug”的来源。 5. 真空管的出现如果想进一步提高计算能力，我们需要更快更可靠的东西，来替代继电器。 在1904年，英国物理学家“约翰·安布罗斯·弗莱明”开发了一种新的电子组件，叫“热电子管”，把两个电极装在一个气密的玻璃灯泡里，这就是世上第一个“真空管”。 其中一个电极可以加热，从而发射电子，这叫“热电子发射”；另一个电极会吸引电子，形成“电龙头”电流。但只有带正电才行，如果带负电荷或中性电荷，电子就无法被吸引，越过真空区域，因此就没有电流。电流只能单向流动的电子部件叫 “二极管”，但是我们需要的是，一个能开关电流的东西。 不久之后的1906年，美国发明家 “李·德富雷斯特”在“弗莱明”设计的两个电极之间，加入了第三个”控制“电极，向”控制“电极施加正电荷，它会允许电子流动，但如果施加负电荷，它会阻止电子流动。因此通过控制线路，可以断开或闭合电路。和继电器的功能一样，但重要的是，真空管内没有会动的组件，这意味着更少的磨损，更重要的是，每秒可以开闭数千次。 因此这些”三极真空管”成为了无线电，长途电话以及其他电子设备的基础，持续了接近半个世纪。 真空管并不完美，它很脆弱，像灯泡一样会烧坏，但比起机械继电器是一次巨大进步。 6. 巨人1号第一个大规模使用真空管的计算机是“巨人1号”，由工程师Tommy Flowers 设计，完工于1943年12月。 巨人1号在英国的”布莱切利园”, 用于破解纳粹通信。2 年前 阿兰·图灵也在”布莱切利园”做了台机电装置，叫 “Bombe”，其设计目的是为了纳粹”英格码”通讯加密设备。但Bombe 严格来说不算计算机，后续文章会谈到这个问题。 巨人1号有 1600 个真空管，总共造了 10 台巨人计算机，来帮助破解密码。巨人被认为是第一个可编程的电子计算机，编程的方法是把几百根电线插入插板，有点像老电话交换机，这是为了让计算机执行正确操作。 7. 第一个可编程计算机“ENIAC”几年后在 1946 年，在”宾夕法尼亚大学”，电子数值积分计算机 “ENIAC”完成建造。设计者是John Mauchly 和 J. Presper Eckert。这是世上第一个真正的通用、可编程电子计算机。 ENIAC 每秒可执行 5000 次十位数加减法，它运作了十年，但因为真空管很多，所以故障很常见。ENIAC 运行半天左右就会出一次故障。 8. 晶体管到 1950 年代，真空管计算机都达到了极限，美国空军的 AN/FSQ-7 计算机于 1955 年完成，是 “SAGE” 防空计算机系统的一部分。为了降低成本和大小，同时提高可靠性和速度，我们需要一种新的电子开关。 1947 年，贝尔实验室科学家 John Bardeen，Walter Brattain，William Shockley发明了晶体管，一个全新的计算机时代诞生了！ 晶体管的物理学相当复杂，这里不做概述。晶体管就像之前提过的“继电器”和“真空管”，它是一个开关，可以用来控制线路和控制开或关。 晶体管有两个电极，电极之间有一种材料隔开它们，这种材料有时候导电，有时不导电，这叫“半导体”。控制线连接到一个”门“电极，通过改变 “门” 的电荷，我们可以控制半导体材料的导电性，来允许或不允许 电流流动。 贝尔实验室的第一个晶体管就展示了巨大的潜力，每秒可以开关 10,000 次，而且，比起玻璃制成，小心易碎的真空管，晶体管是固态的，体型也可远远小于继电器或真空管，导致更小更便宜的计算机。比如1957年发布的IBM 608，第一个完全用晶体管，而且消费者也可以买到的计算机，它有 3000 个晶体管，每秒能执行 4500 次加法，执行 80 次左右的乘除法。IBM 很快把所有产品都转向了晶体管，把晶体管计算机带入办公室，最终引入家庭。 晶体管不仅小，还超级快，秒可以切换上百万次，并且能工作几十年。 9. 硅谷的典故和英特尔很多晶体管和半导体的开发在”圣克拉拉谷”，这个地方在加州，位于”旧金山”和”圣荷西”之间，而生产半导体最常见的材料是 “硅”，而生产半导体最常见的材料是 “硅”。 甚至 William Shockley 都搬了过去，创立了”肖克利半导体”，里面的员工后来成立了”仙童半导体”，这里面的员工后来创立了英特尔 - 当今世界上最大的计算机芯片制造商。","categories":[{"name":"ComputerScience","slug":"ComputerScience","permalink":"https://zero024.cn/categories/ComputerScience/"}],"tags":[{"name":"电子计算机","slug":"电子计算机","permalink":"https://zero024.cn/tags/电子计算机/"}]},{"title":"计科01:[计算机早期历史]","slug":"ComputerScience/01_计算机早期历史","date":"2020-01-03T11:27:00.000Z","updated":"2020-03-25T01:02:33.696Z","comments":true,"path":"ComputerScience/early-computing.html","link":"","permalink":"https://zero024.cn/ComputerScience/early-computing.html","excerpt":"计算机早期历史视频 1. 最早的计算设备：算盘公认最早的计算设备是算盘，发明于“美索不达米亚”，大约公元前2500年。它是手动计算器，用来帮助加减数字，它存储着当前的计算状态，类似于如今的硬盘。","text":"计算机早期历史视频 1. 最早的计算设备：算盘公认最早的计算设备是算盘，发明于“美索不达米亚”，大约公元前2500年。它是手动计算器，用来帮助加减数字，它存储着当前的计算状态，类似于如今的硬盘。 人们制造算盘是因为社会的规模已经超出个人心算的能力，例如一个村庄可能有上千个人和上万头牛，如此就需要一些计算工具辅助计算。 算盘有很多变种，最基础的如下所示： 每行代表10的不同次方，最底下一行，一个珠子代表10的0次方，也就是1。再上面一行是10的1次方(也就是10)，再往上就是10的2次方(以此类推)。 假设最底部的3颗珠子，代表3头牛，那么有4头牛，只需向右移动4个珠子，就能代表7头牛。但如果再有5头牛，那最底行珠子就不够用了。 所以把所有珠子移回左边，在把第二排的1颗珠子向右移动，代表10头牛，最底行移动2颗珠子，代表2头牛，合计就是12，如此就可以代表12头牛了。 在接下来4000年，人类发明了各种巧妙的计算设备。比如星盘，让船只可以在海上计算纬度；或计算尺，帮助计算乘法和除法。 人们还创造了上百种时钟，算日出、潮汐、天体位置，或者纯粹计时。 这些设备让原先很费力的事变得更快，更简单，也更精准。 2. Computer从指代职业变成指代机器 计算机先驱Charles Babbage说过：”随着知识的增长和新工具的诞生，人工劳力会越来越少。“ 最早使用“计算机”一词的文献来自1613年的一本书，作者Richard Braithwait，但当时指的不是机器，而是一种职业。Braithwait 说：“我听说过的计算者里最厉害的，能把好几天的工作量大大缩减。” 那时，“Computer”指负责计算的人，“Computer”偶尔会用机器帮忙，但大部分时候靠自己。 这个职位一直到1800年代还存在，之后“Computer”逐渐开始代表机器。 3. 步进计算器“步进计算器”，由德国博学家 戈特弗里德·莱布尼茨 建造于 1694 年。 莱布尼茨说过 “… 让优秀的人浪费时间算数简直侮辱尊严，农民用机器能算得一样准”。 步进计算器有点像汽车里的里程表，不断累加里程数，它有一连串可以转动的齿轮，每个齿轮有十个齿，代表数字0到9，每当一个齿轮转过 9，它会转回 0，同时让旁边的齿轮前进 1 个齿，就像算盘超过 10 一样。做减法时，机器会反向运作。 利用一些巧妙的机械结构，步进计算器也能做到乘法和除法。举例：17除以5，只要减5，减5，再减5，直到不能再减5，就知道了17=5x3+2。 步进计算器可以自动完成这种操作，它是第一台能做到“加减乘除”全部四种运算的机器，它的设计非常成功，以至于沿用了3个世纪。 4. 查表测距不幸的是，即使有机械计算器，很多现实问题，仍然需要很多步，计算一个结果可能要几小时甚至几天。而且这些手工制作的机器非常昂贵，大部分人买不起。 所以在20世纪以前，大部分人会用预先算好的计算表，这些计算表由之前说的“人力计算器”编撰。如果你想知道867,5309的平方根，只需要再表中查找即可找到答案。 5. 差分机Charles Babbage 在 1822 年写了一篇论文，向皇家天文学会指出了这个问题，标题叫：”机械在天文与计算表中的应用“。 Charles Babbage 提出了一种新型机械装置叫 “差分机”，一个更复杂的机器，能近似多项式。多项式描述了几个变量之间的关系，也可用于近似对数和三角函数。 Charles Babbage 在 1823 年开始建造差分机，并在接下来二十年，视图制造和组装25000个零件，总重接近15吨，不幸的是，该项目最终放弃了。 但在1991年，历史学家根据Charles Babbage 的草稿做了一个差分机，而且可以运行。 更重要的是，在差分机的建造期间，Charles Babbage 构想了一个更复杂的机器 - 分析机。 6. 分析机不像差分机，步进计算器和以前的其他计算设备，分析机是“通用计算机”，它可以做很多事情，不只是一种特定运算。甚至可以给它数据，然后按顺序执行一系列操作。它有内存，甚至一个很原始的打印机，就像差分机一样，这台机器太超前了，所以没能键成。然而，这种“自动计算机”的概念思想：计算机可以自动完成一些操作。是个跨时代的概念，预示着计算机程序的诞生。 英国数学家 Ada Lovelace 给分析机写了假想的程序，她说：“未来会诞生一门全新的，强大的，专为分析所用的语言”，因此Ada被认为是世上第一位程序员。 分析机激励了第一代计算机科学家，这些计算机科学家把很多 Charles Babbage 的点子融入到他们的机器，所以Charles Babbage 经常被认为是 “计算之父”。 7. 打孔机到了19世纪末，为了解决人口普查耗时太长的问题，美国人口普查找了Herman Hollerith，他发明了打孔卡片制表机。他的机器是“电动机械的”，用传统机械来计数，结构类似莱布尼茨的乘法器，但用电动结构连接其他组件。Hollerith 的机器用打孔卡，一种纸卡，上面有网格，用打孔来表示数据。Hollerith 的机器速度是手动的 10 倍左右！ 企业开始意识到计算机的价值，可以提升劳动力以及数据密集型任务，来提升利润。为了满足这一需求，Hollerith 成立了制表机器公司。这家公司后来在1924年与其他机械制造商合并，成为了“国际商业机器公司”，简称IBM。","categories":[{"name":"ComputerScience","slug":"ComputerScience","permalink":"https://zero024.cn/categories/ComputerScience/"}],"tags":[{"name":"计科历史","slug":"计科历史","permalink":"https://zero024.cn/tags/计科历史/"}]},{"title":"Hexo博客添加live2d动态模型插件","slug":"Other/Live2D","date":"2019-11-04T06:12:13.000Z","updated":"2020-03-25T01:05:46.416Z","comments":true,"path":"Other/Live2D.html","link":"","permalink":"https://zero024.cn/Other/Live2D.html","excerpt":"前言live2d动态模型插件是一款非常有意思的插件。 使用和安装helper-live2d动态插件，需具备以下前提条件：","text":"前言live2d动态模型插件是一款非常有意思的插件。 使用和安装helper-live2d动态插件，需具备以下前提条件： hexo博客，没有搭建的可以看我以前的文章《hexo+git搭建hexo个人博客》 Node.js环境和npm 插件Github地址：hexo-helper-live2d live2d模型仓库地址：live2d-widget-models以及部分模型预览网址 1. 安装模块在hexo跟目录执行命令 cnpm install --save hexo-helper-live2d 2. 下载模型可先查看模型预览：hexo live2d插件 2.0 2.1 安装模型使用npm install {packagename}安装单独模型，包名称列表如下： live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-haru/01（使用npm install --save live2d-widget-model-haru） live2d-widget-model-haru/02（使用npm install --save live2d-widget-model-haru） live2d-widget-model-haruto live2d-widget-model-hibiki live2d-widget-model-hijiki live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzsche live2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 举例本人安装的模型： cnpm install live2d-widget-model-tororo 3. 进行详细配置在Hexo的_config.yml文件下或主题的_config.yml文件中均可配置： 配置API查看：live2d-widget.js API 3.1 API配置本人博客配置文件如下 # Live 2D settings ## 插件github地址：https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d ## API网址：https:&#x2F;&#x2F;l2dwidget.js.org&#x2F;docs&#x2F;class&#x2F;src&#x2F;index.js~L2Dwidget.html#instance-method-init live2d: enable: true scriptFrom: local # 默认 pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径) pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径 pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: true # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-tororo # npm-module package name # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名 # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径 # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url display: position: right width: 145 height: 315 mobile: show: true # 是否在移动设备上显示 scale: 0.5 # 移动设备上的缩放 react: opacityDefault: 0.7 opacityOnHover: 0.8 本文内容参考摘录自文章Hexo博客添加helper-live2d动态模型插件，欢迎大家关注该作者。","categories":[{"name":"Other","slug":"Other","permalink":"https://zero024.cn/categories/Other/"}],"tags":[{"name":"Live2D","slug":"Live2D","permalink":"https://zero024.cn/tags/Live2D/"}]},{"title":"Git","slug":"Other/Git","date":"2019-10-28T14:48:13.000Z","updated":"2020-03-25T01:06:02.145Z","comments":true,"path":"Other/git-basic.html","link":"","permalink":"https://zero024.cn/Other/git-basic.html","excerpt":"1. Git简介Git是目前世界上最先进的分布式版本控制系统。","text":"1. Git简介Git是目前世界上最先进的分布式版本控制系统。 Linus大神为了解决Linux代码管理问题，在2005年花费两周时间用C编写了Git，此后迅速成为最流行的分布式版本控制系统。2008年，GitHub网站上线，它为开源项目免费提供Git存储，无数开源项目迁移至GitHub。 本文仅做Git最基本操作的学习，方便速查。详细教程请看廖雪峰Git教程 1.1 安装Git进入官网下载Git安装包，直接默认安装即可。 打开CMD，输入git，测试是否安装成功。 2. 远程仓库使用远程仓库，需要先配置SSH。 2.1 配置SSHSSH用于身份验证，我们首先需要生成一个SSH密钥，然后添加到GitHub中。 打开Git Bash 输入以下命令生成一个ssh密钥：ssh-keygen -t rsa -C &#39;your email@example.com&#39;，一般情况下无需设置，一路回车就行。 输入命令cd ~/.ssh/，进入ssh文件夹。里面有两个文件，id_rsa和id_rsa.pub，这两个就是SSH Key的密钥对。其中id_rsa是私钥，不能泄露！id_rsa.pub是公钥，可以公开使用。 将SSH公钥复制到剪贴板：clip &lt; ~/.ssh/id_rsa.pub 登录GitHub，右上角点击个人头像，然后点击settings进入设置界面。 点击SSH and GPG keys，然后点击New SSH key，填上任意title，在Key文本框内粘贴id_rsa.pub文件的内容，点击Add Key，就成功添加SSH key了！ 2.2 克隆远程仓库首先需要在GitHub创建一个仓库，直接点击New repository，然后根据提示即可创建仓库。接下来我们将远程仓库克隆到本地，进行操作。 打开GitHub仓库界面，点击右边的clone or download，选择SSH方式，复制仓库地址。 打开Git Bash 输入git git@github.com:zero6996/Learn_Git.git，即可将远程仓库克隆到本地。 3. Git基本操作 初始化git，将当前文件夹交由git管理：git init 查看当前分支状态：git status 提交到暂存区：git add &lt;file&gt; 提交到仓库：git commit file -m &quot;message&quot; 3.1 配置用户信息 配置全局用户信息：git config --system user.email youremail@email.com 配置当前用户信息：git config --global user.name yourname 用户配置文件在.git/config 3.2 查看日志 查看当前工作日志：git log 查看历史工作日志：git reflog 查看更改日志：git diff 3.3 回退版本 退回到上N个版本：git reset --hard HEAD^，一个^代表退回一个版本，以此类推。 HEAD指向的版本就是当前版本 退回到指定版本：git reset --hard commit_id，commit_id是指定版本号，举例git reset --hard cbc5fdb。 3.4 文件操作 移动文件：git mv movefile_name targetdir/ 删除文件：git rm filename，如果该文件已提交到版本库中，则直接删除版本库中文件。 4. 分支管理4.1 分支基本操作 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 5. 标签管理标签可以用于给版本库中的版本打标记，方便版本管理。 命令 git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit_id。 命令 git tag -a &lt;tagname&gt; -m &#39;message...可以指定标签信息。 命令git tag 可以查看所有标签。 命令 git push origin &lt;tagname&gt; 可以推送一个本地标签到远程 命令 git push origin --tags可以推送本地全部未推送的标签到远程 命令 git tag -d &lt;tagname&gt;可以删除一个本地标签 命令 git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签","categories":[{"name":"Other","slug":"Other","permalink":"https://zero024.cn/categories/Other/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://zero024.cn/tags/Git/"}]},{"title":"SSM整合Demo","slug":"FrameWork/SSM整合项目","date":"2019-09-05T15:00:00.000Z","updated":"2020-03-25T01:17:41.137Z","comments":true,"path":"FrameWork/SSM.html","link":"","permalink":"https://zero024.cn/FrameWork/SSM.html","excerpt":"1. SSM整合项目1.1 搭建环境","text":"1. SSM整合项目1.1 搭建环境 SSM整合可以使用多种方式，这里选择XML+注解的方式 整合思路 先搭建整合环境 把Spring的配置搭建完成 使用Spring整合SpringMVC框架 最后使用Spring整合MyBatis框架 1.2 基本环境 创建数据库表和表结构 create database ssm01; use ssm01; create table account( id int primary key auto_increment, name varchar(100), money double ); 创建一个Maven工程，在pom.xml文件中引入坐标依赖 &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;!--设置版本锁定--&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;&#x2F;spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;&#x2F;slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;&#x2F;log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;&#x2F;mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;&#x2F;mybatis.version&gt; &lt;&#x2F;properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt; &lt;version&gt;1.6.8&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;scope&gt;compile&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;${mysql.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt; &lt;version&gt;${log4j.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt; &lt;version&gt;${slf4j.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt; &lt;version&gt;${slf4j.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;${mybatis.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt; &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt; &lt;version&gt;0.9.1.2&lt;&#x2F;version&gt; &lt;type&gt;jar&lt;&#x2F;type&gt; &lt;scope&gt;compile&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 创建基础环境，具体如下图所示： AccountDao代码 &#x2F;** * 账户dao接口 *&#x2F; public interface AccountDao { &#x2F;** * 查询所有用户 * @return *&#x2F; public List&lt;Account&gt; findAll(); &#x2F;** * 保存账户 * @param account *&#x2F; public void SaveAccount(Account account); } Account实体类代码 &#x2F;** * 账户类 *&#x2F; public class Account implements Serializable { private Integer id; private String name; private Double money; } 业务层代码 public class AccountServiceImpl implements AccountService { @Override public List&lt;Account&gt; findAll() { System.out.println(&quot;业务层：查询所有账户....&quot;); return null; } @Override public void SaveAccount(Account account) { System.out.println(&quot;业务层：保存账户....&quot;); } } 2. Spring框架代码编写2.1 搭建和测试Spring开发环境 在resources项目中创建applicationContext.xml配置文件，编写具体的配置信息。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt; &lt;!-- 开启注解扫描，要扫描的是service和dao层的注解 要忽略web层注解，因为web层让SpringMVC框架去管理 --&gt; &lt;context:component-scan base-package=&quot;com.zero&quot;&gt; &lt;!-- 配置要忽略的注解 --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt; &lt;&#x2F;context:component-scan&gt; &lt;&#x2F;beans&gt; 编写一个测试方法进行测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class TestSpring { @Resource(name = &quot;accountService&quot;) private AccountService accountService; @Test public void test1(){ accountService.findAll(); accountService.SaveAccount(new Account()); } } 3. Spring整合SpringMVC框架3.1 搭建和测试SpringMVC的开发环境 在web.xml中配置DispatcherServlet前端控制器，中文乱码过滤器 &lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt; &lt;!--配置DispatcherServlet前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;!--配置初始化参数，创建完dispatcherServlet对象后加载springMVC.xml配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;!--服务器启动时，就让dispatcherServlet对象创建--&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; &lt;!-- 配置解决中文乱码的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt; &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt; &lt;&#x2F;web-app&gt; 创建springMVC.xml配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:mvc=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation=&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!--扫描controller的注解，别的不用扫描--&gt; &lt;context:component-scan base-package=&quot;com.zero.controller&quot;&gt; &lt;!-- 配置包含的注解 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;&#x2F;&gt; &lt;&#x2F;context:component-scan&gt; &lt;!--配置视图解析器--&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--配置前后缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;&quot; &#x2F;&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--设置静态资源不过滤--&gt; &lt;mvc:resources mapping=&quot;&#x2F;css&#x2F;**&quot; location=&quot;&#x2F;css&#x2F;&quot;&#x2F;&gt; &lt;mvc:resources mapping=&quot;&#x2F;images&#x2F;**&quot; location=&quot;&#x2F;images&#x2F;&quot;&#x2F;&gt; &lt;mvc:resources mapping=&quot;&#x2F;js&#x2F;**&quot; location=&quot;&#x2F;js&#x2F;&quot;&#x2F;&gt; &lt;!--开启对SpringMVC的注解支持--&gt; &lt;mvc:annotation-driven&#x2F;&gt; &lt;&#x2F;beans&gt; 控制器代码 @Controller @RequestMapping(&quot;account&quot;) public class AccountController { @RequestMapping(&quot;&#x2F;findAll&quot;) public String findAll(){ System.out.println(&quot;表现层：查询所有用户....&quot;); return &quot;list&quot;; } } jsp：&lt;a href=&quot;/account/findAll&quot;&gt;查询所有用户&lt;/a&gt; 3.2 Spring整合SpringMVC的框架 目的：能在controller中成功调用service对象中的方法，查询数据。 在项目启动时，就去加载applicationContext.xml的配置文件，在web.xml中配置ContextLoaderListener监听器（该监听器默认只能加载WEB-INF目录下的applicationContext.xml的配置文件）。 &lt;!--配置Spring提供的监听器，用于启动服务器时加载容器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt; &lt;&#x2F;listener&gt; &lt;!--手动指定springMVC配置文件位置--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;context-param&gt; 修改控制器代码，注入service属性，调用方法 @Controller @RequestMapping(&quot;account&quot;) public class AccountController { &#x2F;&#x2F; 注入service对象 @Autowired private AccountService accountService; @RequestMapping(&quot;&#x2F;findAll&quot;) public String findAll(){ System.out.println(&quot;表现层：查询所有用户....&quot;); &#x2F;&#x2F; 调用service的方法 accountService.findAll(); return &quot;list&quot;; } } 测试结果 表现层：查询所有用户.... 业务层：查询所有账户.... 4. Spring整合MyBatis框架4.1 搭建和测试MyBatis的环境 在resources资源文件夹下创建SqlMapConfig.xml的配置文件，编写核心配置文件。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt; &lt;!--MyBatis核心配置文件--&gt; &lt;configuration&gt; &lt;!--配置数据库环境--&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&#x2F;&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;ssm01&quot;&#x2F;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;!-- 引入映射配置文件，这里使用的是注解方式 --&gt; &lt;mappers&gt; &lt;!--&lt;mapper class=&quot;com.zero.dao.AccountDao&quot;&#x2F;&gt;--&gt; &lt;!-- 该包下所有的dao接口都可以使用 --&gt; &lt;package name=&quot;com.zero.dao&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt; &lt;&#x2F;configuration&gt; 使用注解方式进行SQL语句编写 &#x2F;** * 账户dao接口 *&#x2F; @Resource public interface AccountDao { &#x2F;** * 查询所有用户 * @return *&#x2F; @Select(&quot;select * from account&quot;) public List&lt;Account&gt; findAll(); &#x2F;** * 保存账户 * @param account *&#x2F; @Insert(&quot;insert into account (name,money) values(#{name},#{money})&quot;) public void SaveAccount(Account account); } 编写测试方法 public class TestMyBatis { &#x2F;** * 测试查询 * @throws Exception *&#x2F; @Test public void test1() throws Exception { &#x2F;&#x2F; 加载配置文件 InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); &#x2F;&#x2F; 创建工厂 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); &#x2F;&#x2F; 创建sqlSession对象 SqlSession session = factory.openSession(); &#x2F;&#x2F; 获取代理对象 AccountDao dao = session.getMapper(AccountDao.class); List&lt;Account&gt; list = dao.findAll(); for (Account account:list){ System.out.println(account); } &#x2F;&#x2F; 释放资源 session.close(); inputStream.close(); } &#x2F;** * 测试保存 * @throws Exception *&#x2F; @Test public void test2() throws Exception { Account account = new Account(); account.setName(&quot;小黑&quot;); account.setMoney(400d); &#x2F;&#x2F; 加载配置文件 InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); &#x2F;&#x2F; 创建工厂 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); &#x2F;&#x2F; 创建sqlSession对象 SqlSession session = factory.openSession(); &#x2F;&#x2F; 获取代理对象 AccountDao dao = session.getMapper(AccountDao.class); dao.SaveAccount(account); &#x2F;&#x2F; 提交事务 session.commit(); &#x2F;&#x2F; 释放资源 session.close(); inputStream.close(); } } 4.2 Spring整合MyBatis框架 目的：把SqlMapConfig.xml配置文件配置到Spring的配置文件中。 4.2.1 让Spring接管MyBatis的Session工厂 &lt;!--spring整合MyBatis框架--&gt; &lt;!--配置c3p0连接池--&gt; &lt;bean id=&quot;DataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;ssm01&quot;&#x2F;&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置SqlSessionFactory工厂--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;DataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 4.2.2 配置自动扫描所有Mapper接口和文件 &lt;!--配置AccountDao接口所在包--&gt; &lt;!-- 引入映射配置文件--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.zero.dao&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 4.2.4 测试 在AccountDao接口上添加注解 &#x2F;** * 账户dao接口 *&#x2F; @Repository public interface AccountDao { } 在service层调用Dao @Service(&quot;accountService&quot;) &#x2F;&#x2F; 将service交由IOC容器管理 public class AccountServiceImpl implements AccountService { &#x2F;&#x2F; 注入Dao接口 @Autowired private AccountDao accountDao; @Override public List&lt;Account&gt; findAll() { System.out.println(&quot;业务层：查询所有账户....&quot;); &#x2F;&#x2F; 调用dao查询 return accountDao.findAll(); } @Override public void SaveAccount(Account account) { System.out.println(&quot;业务层：保存账户....&quot;); accountDao.SaveAccount(account); } } 控制器代码 @Controller @RequestMapping(&quot;account&quot;) public class AccountController { &#x2F;&#x2F; 注入service对象 @Autowired private AccountService accountService; @RequestMapping(&quot;&#x2F;findAll&quot;) public String findAll(Model model){ System.out.println(&quot;表现层：查询所有用户....&quot;); &#x2F;&#x2F; 调用service的方法 List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(&quot;list&quot;,list); &#x2F;&#x2F; 存入request域 return &quot;list&quot;; } } list.jsp页面 &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;用户列表&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h3&gt;用户列表&lt;&#x2F;h3&gt; &lt;c:forEach items=&quot;${list}&quot; var=&quot;account&quot;&gt; 用户姓名：${account.name}&lt;br&gt; 余额：${account.money}&lt;br&gt; &lt;&#x2F;c:forEach&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 4.2.5 配置Spring的声明式事务管理 在applicationContext.xml中配置事务 &lt;!--3. 配置Spring框架声明式事务管理--&gt; &lt;!--3.1 配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;DataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--3.2 配置事务通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;&#x2F;&gt; &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot;&#x2F;&gt; &lt;&#x2F;tx:attributes&gt; &lt;&#x2F;tx:advice&gt; &lt;!--3.3 配置AOP增强--&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.zero.service.Impl.*ServiceImpl.*(..))&quot;&#x2F;&gt; &lt;&#x2F;aop:config&gt; 控制器新增保存用户方法 &#x2F;** * 保存用户 * @param account * @return *&#x2F; @RequestMapping(&quot;&#x2F;save&quot;) public String save(Account account){ System.out.println(&quot;表现层：保存用户....&quot;); accountService.SaveAccount(account); return &quot;redirect:findAll&quot;; } index.jsp中添加代码，提交用户表单 &lt;h3&gt;保存用户&lt;&#x2F;h3&gt; &lt;form action=&quot;&#x2F;account&#x2F;save&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 金额：&lt;input type=&quot;text&quot; name=&quot;money&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt; &lt;&#x2F;form&gt;","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zero024.cn/tags/SpringMVC/"}]},{"title":"SpringMVC学习2","slug":"FrameWork/SpringMVC框架2","date":"2019-09-04T15:59:00.000Z","updated":"2020-03-25T01:17:31.442Z","comments":true,"path":"FrameWork/SpringMVC-Response-Data.html","link":"","permalink":"https://zero024.cn/FrameWork/SpringMVC-Response-Data.html","excerpt":"1. 响应数据和结果视图1.1 返回值分类","text":"1. 响应数据和结果视图1.1 返回值分类 1.1.1 字符串Controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。 &#x2F;&#x2F; 返回值是字符串 @RequestMapping(&quot;&#x2F;testString&quot;) public String testString(Model model){ System.out.println(&quot;testString方法执行了...&quot;); &#x2F;&#x2F; 模拟从数据库中查询出User对象 User user = new User(&quot;小明&quot;, &quot;123&quot;, 22); &#x2F;&#x2F; 使用model传递数据 model.addAttribute(&quot;user&quot;,user); return &quot;success&quot;; &#x2F;&#x2F; 指定逻辑视图名，经过视图解析器解析为jsp物理路径：&#x2F;WEB-INF&#x2F;pages&#x2F;success.jsp } 1.1.2 void上篇文章中学到Servlet原始API可以作为控制器中方法的参数： @RequestMapping(&quot;&#x2F;testReturnVoid&quot;) public void testReturnVoid(HttpServletRequest request,HttpServletResponse response) throws Exception { xxx } 所以就可以在controller方法形参上可以定义request和response，使用request或response指定响应结果 使用request跳转页面： &#x2F;** * 通过request跳转页面 * @param request * @param response * @throws Exception *&#x2F; @RequestMapping(&quot;&#x2F;testForward&quot;) public void testForward(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(&quot;testForward方法执行了...&quot;); request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;success.jsp&quot;).forward(request,response); } 通过response重定向页面： &#x2F;** * 通过response重定向页面 * @param request * @param response * @throws Exception *&#x2F; @RequestMapping(&quot;&#x2F;testRedirect&quot;) public void testRedirect(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(&quot;testRedirect方法执行了...&quot;); response.sendRedirect(&quot;testString&quot;); &#x2F;&#x2F; 重定向到返回字符串页面 } 通过response指定响应结果： &#x2F;** * 通过 response 指定响应结果 * @param request * @param response * @throws Exception *&#x2F; @RequestMapping(&quot;&#x2F;testReturnJson&quot;) public void testReturnJson(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(&quot;testReturnJson方法执行了...&quot;); &#x2F;&#x2F; 解决中文乱码问题 response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); response.getWriter().write(&quot;响应json串&quot;); } 1.1.3 ModelAndView ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。 该对象中有两个主要方法 ModelAndView addObject(String,Object)：添加模型到ModelMap对象中。 void serViewName(String)：用于设置逻辑视图名称，视图解析器会根据名称前往指定视图。 示例代码 控制器 &#x2F;** * 返回ModelAndView * @return *&#x2F; @RequestMapping(&quot;&#x2F;testReturnModelAndView&quot;) public ModelAndView testReturnModelAndView(){ ModelAndView modelAndView = new ModelAndView(); &#x2F;&#x2F; 将user对象存入到modelAndView对象中，底层会把user对象存入request域中 modelAndView.addObject(&quot;user&quot;,new User(&quot;小张&quot;,&quot;222&quot;,21)); modelAndView.setViewName(&quot;success&quot;); &#x2F;&#x2F; 设置视图名称 return modelAndView; } jsp： &lt;h3&gt;访问成功！&lt;&#x2F;h3&gt; ${user.username} ${user.password} ${user.age} 1.2 转发和重定向1.2.1 forward转发controller方法提供了String类型的返回值之后，默认就是请求转发。我们也可以写成如下形式： @RequestMapping(&quot;&#x2F;testForward&quot;) public String testForward() { System.out.println(&quot;testForward方法执行了...&quot;); return &quot;forward:&#x2F;WEB-INF&#x2F;pages&#x2F;success.jsp&quot;; &#x2F;&#x2F; 使用了forward:,路径就必须写成物理视图url } 注意：如果用了forward:，则路径必须写成实际视图 URL，不能写逻辑视图。 它相当于：request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request,response); 使用请求转发，即可以转发到jsp，也可以转发到其他控制器方法。例：return &quot;forward:testString&quot;; 1.2.2 Redirect重定向 @RequestMapping(&quot;&#x2F;testRedirect&quot;) public String testRedirect() { System.out.println(&quot;testRedirect方法执行了...&quot;); return &quot;redirect:testString&quot;; &#x2F;&#x2F; 重定向到返回字符串页面 } 相当于：response.sendRedirect(&quot;testString&quot;); 注意：如果是重定向到 jsp 页面，则 jsp 页面不能写在 WEB-INF 目录中，否则无法找到。 1.3 ResponseBody响应Json数据 作用：该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml 等，通过Response响应给客户端。 1.3.1 关于静态资源拦截问题DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。解决问题就是需要配置静态资源不进行拦截 方法1：在SpringMVC.xml配置文件内使用mvc:resources标签配置资源文件不拦截 location元素表示webapp目录下的包下的所有文件 mapping元素表示以/static开头的所有请求路径 &lt;!-- 设置静态资源不过滤 --&gt; &lt;mvc:resources location=&quot;&#x2F;css&#x2F;&quot; mapping=&quot;&#x2F;css&#x2F;**&quot;&#x2F;&gt; &lt;!-- 样式 --&gt; &lt;mvc:resources location=&quot;&#x2F;images&#x2F;&quot; mapping=&quot;&#x2F;images&#x2F;**&quot;&#x2F;&gt; &lt;!-- 图片 --&gt; &lt;mvc:resources location=&quot;&#x2F;js&#x2F;&quot; mapping=&quot;&#x2F;js&#x2F;**&quot;&#x2F;&gt; &lt;!-- javascript --&gt; 方法2：在web.xml配置文件中配置如下 &lt;!--设置访问静态资源--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;*.css&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;*.js&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; 1.3.2 示例简单的获取json数据 控制器代码 &#x2F;** * 测试响应json数据 * @param * @return *&#x2F; @RequestMapping(&quot;&#x2F;testResponseJson&quot;) public void testResponseJson(@RequestBody String body){ System.out.println(&quot;异步请求:&quot;+body); } jsp &lt;script&gt; &#x2F;&#x2F; 页面加载,绑定单机事件 $(function () { $(&quot;#btn&quot;).click(function () { &#x2F;&#x2F; 发送ajax请求 $.ajax({ type:&quot;post&quot;, url:&quot;user&#x2F;testResponseJson&quot;, contentType:&quot;application&#x2F;json;charset=utf-8&quot;, data:&#39;{&quot;username&quot;:&quot;小明&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:33}&#39;, dataType:&quot;json&quot;, success:function (data) { alert(data); } }) }) }) &lt;&#x2F;script&gt; &lt;h3&gt;6. ResponseBody响应Json数据&lt;&#x2F;h3&gt; &lt;button id=&quot;btn&quot;&gt;发送Ajax请求&lt;&#x2F;button&gt; 测试结果：异步请求:{&quot;username&quot;:&quot;小明&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:33} 如果需要将获取的json格式数据转换为JavaBean对象，则需要导入额外的jar包 在pom.xml中导入坐标 &lt;!--导入json和JavaBean对象相互转换所需jar包：jackson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 控制器代码修改 @RequestMapping(&quot;&#x2F;testResponseJson&quot;) public @ResponseBody User testResponseJson(@RequestBody User user){ System.out.println(&quot;异步请求:&quot;+user); user.setUsername(&quot;花花&quot;); user.setAge(18); return user; } 前端修改js &lt;script&gt; &#x2F;&#x2F; 页面加载,绑定单机事件 $(function () { $(&quot;#btn&quot;).click(function () { &#x2F;&#x2F; 发送ajax请求 $.ajax({ type:&quot;post&quot;, url:&quot;user&#x2F;testResponseJson&quot;, contentType:&quot;application&#x2F;json;charset=utf-8&quot;, data:&#39;{&quot;username&quot;:&quot;小明&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:33}&#39;, dataType:&quot;json&quot;, success:function (data) { &#x2F;&#x2F; data是服务器端响应的json数据 alert(data.username); alert(data.password); alert(data.age); } }) }) }) &lt;&#x2F;script&gt; 2. SpringMVC实现文件上传2.1 文件上传回顾2.1.1 必要前提 form表单的enctype(表单请求正文的类型)取值必须是：multipart/form-data，默认值是application/x-www-form-urlencoded。 method属性取值必须是Post 提供一个文件选择域&lt;input type=&quot;file&quot;/&gt; 2.1.2 原理分析 当form表单的enctype取值不是默认值后，request.getParameter()将会失效。 enctype=”application/x-www-form-urlencoded”时，form 表单的正文内容是键值对形式。 当form表单的enctype取值为multipart/form-data时，请求正文内容就变成：每一部分都是MIME类型描述的正文。 -----------------------------7de1a433602ac --&gt;分界符 Content-Disposition: form-data; name=&quot;userName&quot; --&gt;协议头 文件上传测试 --&gt;协议的正文 -----------------------------7de1a433602ac Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;C:\\Users\\zhy\\Desktop\\fileupload_demofile\\b.txt&quot; Content-Type: text&#x2F;plain --&gt;协议的类型（MIME 类型） 文件实际内容xxxxxx -----------------------------7de1a433602ac-- 2.1.3 借助第三方组件实现文件上传使用 Commons-fileupload 组件实现文件上传，需要导入该组件相应的支撑 jar 包：Commons-fileupload 和commons-io。commons-io 不属于文件上传组件的开发 jar 文件，但Commons-fileupload 组件从 1.1 版本开始，它工作时需要 commons-io 包的支持。 在pom.xml中导入所需jar包 &lt;!--导入文件上传相关jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt; &lt;version&gt;2.4&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 2.2 SpringMVC传统方式的文件上传传统方式的文件上传，指的是我们上传的文件和访问的应用存在于同一台服务器上。且上传完毕后，浏览器可能跳转。 2.2.1 编写控制器 &#x2F;** * SpringMVC框架方式文件上传 *&#x2F; @RequestMapping(&quot;&#x2F;MVCfileUpLoad&quot;) public String MVCfileUpLoad(String picname, MultipartFile uploadFile, HttpServletRequest request) throws Exception{ System.out.println(&quot;SpringMVC框架方式文件上传&quot;); &#x2F;&#x2F; 1.定义文件名称 String fileName = &quot;&quot;; &#x2F;&#x2F; 1.1. 获取原始文件名 String originalFilename = uploadFile.getOriginalFilename(); &#x2F;&#x2F; 1.2. 截取文件扩展名 String extentName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;) + 1, originalFilename.length()); &#x2F;&#x2F; 1.3. 将文件加上随机数，防止文件重复 String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).toUpperCase(); &#x2F;&#x2F; 1.4. 判断是否输入了文件名 if (!StringUtils.isEmpty(picname)){ fileName = uuid+&quot;_&quot;+picname+&quot;.&quot;+extentName; }else { fileName = uuid+&quot;_&quot;+originalFilename; } System.out.println(&quot;文件名称：&quot;+fileName); &#x2F;&#x2F; 2. 获取文件路径 String basePath = request.getSession().getServletContext().getRealPath(&quot;&#x2F;uploads&quot;); System.out.println(&quot;文件路径：&quot;+basePath); &#x2F;&#x2F; 3. 解决用一文件夹中文件过多问题 String datePath = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date()); &#x2F;&#x2F; 4. 判断路径是否存在 File file = new File(basePath+&quot;&#x2F;&quot;+datePath); if (!file.exists()){ &#x2F;&#x2F; 如果文件夹不存在 file.mkdirs(); &#x2F;&#x2F; 创建 } &#x2F;&#x2F; 5. 使用MultipartFile接口中方法，将上传的文件写到指定位置 uploadFile.transferTo(new File(file,fileName)); return &quot;success&quot;; } 2.2.2 编写jsp页面 &lt;h3&gt;文件上传&lt;&#x2F;h3&gt; &lt;form action=&quot;&#x2F;file&#x2F;MVCfileUpLoad&quot; method=&quot;post&quot; enctype=&quot;multipart&#x2F;form-data&quot;&gt; 文件名称：&lt;input type=&quot;text&quot; name=&quot;picname&quot;&gt; 选择上传文件:&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&#x2F;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;&#x2F;form&gt; 2.2.3 配置文件解析器在SpringMVC.xml中添加如下配置 &lt;!--配置文件上传解析器,id:multipartResolver是固定值--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!--设置上传文件的最大尺寸为 5MB=5*1024*1024=5242880字节 --&gt; &lt;property name=&quot;maxUploadSize&quot;&gt; &lt;value&gt;5242880&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; 2.3 跨服务器方式的文件上传2.3.1 分服务器的目的实际开发中，会有很多处理不同功能的服务器，例 应用服务器：负责部署我们的应用 数据库服务器：运行数据库 缓存和消息服务器：负责处理大并发访问的缓存和消息 文件服务器：负责存储用户上传文件的服务器 2.3.2 准备文件服务器创建一个新的Tomcat服务器，在WEB-INF下创建一个uploads文件夹，用于存放文件 2.3.3 具体代码 控制器 &#x2F;** * 跨服务器文件上传 * @return *&#x2F; @RequestMapping(&quot;&#x2F;MVCfileUpLoad2&quot;) public String MVCfileUpLoad2(String picname, MultipartFile uploadFile) throws Exception{ System.out.println(&quot;跨服务器文件上传&quot;); &#x2F;&#x2F; 1.定义文件名称 String fileName = &quot;&quot;; &#x2F;&#x2F; 1.1. 获取原始文件名 String originalFilename = uploadFile.getOriginalFilename(); System.out.println(originalFilename); &#x2F;&#x2F; 1.2. 截取文件扩展名 String extentName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;) + 1, originalFilename.length()); &#x2F;&#x2F; 1.3. 将文件加上随机数，防止文件重复 String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).toUpperCase(); if (!StringUtils.isEmpty(picname)){ fileName = uuid+&quot;_&quot;+picname+&quot;.&quot;+extentName; }else { fileName = uuid+&quot;_&quot;+originalFilename; } &#x2F;&#x2F; 定义上传文件服务器路径 String path = &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;uploads&#x2F;&quot;; &#x2F;&#x2F; 完成文件上传，跨服务器版 &#x2F;&#x2F; 创建客户端的对象 Client client = Client.create(); &#x2F;&#x2F; 和文件服务器进行连接 WebResource resource = client.resource(path+ fileName); &#x2F;&#x2F; 上传文件 todo:中文乱码问题? resource.put(uploadFile.getBytes()); return &quot;success&quot;; } jsp &lt;h3&gt;跨服务器文件上传&lt;&#x2F;h3&gt; &lt;form action=&quot;&#x2F;file&#x2F;MVCfileUpLoad2&quot; method=&quot;post&quot; enctype=&quot;multipart&#x2F;form-data&quot;&gt; 文件名称：&lt;input type=&quot;text&quot; name=&quot;picname&quot;&gt; 选择上传文件:&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&#x2F;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;&#x2F;form&gt; 403Forbidden问题 上传文件涉及到读写权限，这个报错的意思就是服务器（Tomcat）没有写入的权限，需要在服务器的web.xml文件中找到servlet标签，在servlet里添加如下字段，开启文件读写 &lt;init-param&gt; &lt;param-name&gt;readonly&lt;&#x2F;param-name&gt; &lt;param-value&gt;false&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; 409 Conflict 问题 文件夹未创建，在服务器target\\fileUploadServer下创建uploads文件夹即可 关于中文文件名上传报错问题 见文章 Tomcat版本8.5，尚未解决问题 3. SpringMVC中的异常处理3.1 异常处理的思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springMVC前端控制器交由异常处理器进行异常处理，如下图示： 3.2 实现步骤 控制器代码，模拟一个异常 @Controller @RequestMapping(&quot;user&quot;) public class UserController { @RequestMapping(&quot;&#x2F;testException&quot;) public String testException() throws SysException{ System.out.println(&quot;testException.....&quot;); try { &#x2F;&#x2F; 模拟异常 int i = 1&#x2F;0; } catch (Exception e) { e.printStackTrace(); &#x2F;&#x2F; 抛出自定义异常信息 throw new SysException(&quot;查询错误....&quot;); } return &quot;success&quot;; } } jsp访问页面和错误页面 访问页面： &lt;h3&gt;异常处理&lt;&#x2F;h3&gt; &lt;a href=&quot;&#x2F;user&#x2F;testException&quot;&gt;测试异常处理&lt;&#x2F;a&gt; 错误页面： &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;出错啦！&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h4&gt;${errorMsg}&lt;&#x2F;h4&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 编写自定义异常类 &#x2F;** * 自定义异常类 *&#x2F; public class SysException extends Exception { &#x2F;&#x2F; 存储提示信息的 private String message; public SysException(String message) { this.message = message; } @Override public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } } 编写自定义异常解析器 &#x2F;** * 异常处理类 *&#x2F; public class SysExceptionResolver implements HandlerExceptionResolver { &#x2F;** * 处理异常业务逻辑 * @param request * @param response * @param handler * @param ex 当前抛出的异常对象 * @return *&#x2F; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { &#x2F;&#x2F; 获取异常对象 SysException e = null; &#x2F;&#x2F; 如果抛出的是系统自定义异常则直接转换 if (ex instanceof SysException){ &#x2F;&#x2F; instanceof：判断ex是否是SysException的对象、直接或间接子类、其接口实现类 e = (SysException) ex; }else { &#x2F;&#x2F; 如果抛出的不是系统自定义异常则重新构造一个系统错误异常 e = new SysException(&quot;系统维护中....&quot;); } &#x2F;&#x2F; 创建ModelAndView对象，跳转页面 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;errorMsg&quot;,e.getMessage()); &#x2F;&#x2F; 获取异常消息，存入对象 modelAndView.setViewName(&quot;error&quot;); &#x2F;&#x2F; 跳转错误页面 return modelAndView; } } 在SpringMVC.xml中，配置异常处理器 &lt;!--配置自定义异常处理器对象--&gt; &lt;bean id=&quot;SysExceptionResolver&quot; class=&quot;cn.zero.exception.SysExceptionResolver&quot;&#x2F;&gt; 4. SpringMVC中的拦截器4.1 拦截器的作用 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。 可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。 拦截器和过滤器的功能比较类似，区别点如下： 过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。 拦截器是SpringMVC框架独有的。 过滤器配置了/*，可以拦截任何资源 拦截器只会对控制器中的方法进行拦截，不会拦截类似js、css等资源。 拦截器也是AOP思想的一种实现方式。 想要自定义拦截器，需要实现HandlerInterceptor接口。 4.2 自定义拦截器的步骤 编写拦截器类，实现HandlerInterceptor接口，重写方法 &#x2F;** * 定义拦截器 *&#x2F; public class CustomInterceptor implements HandlerInterceptor { &#x2F;** * 预处理，controller方法执行前处理 * return true放行，执行下一个拦截器，如果没有下一拦截器，执行控制器方法 * return false不放行 * @param request * @param response * @param handler * @return * @throws Exception *&#x2F; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;CustomInterceptor执行了....预处理&quot;); &#x2F;&#x2F; request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;error.jsp&quot;).forward(request,response); return true; } &#x2F;** * 后处理，controller方法执行后处理 * @param request * @param response * @param handler * @param modelAndView * @throws Exception *&#x2F; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;postHandle....后处理&quot;); &#x2F;&#x2F; request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;error.jsp&quot;).forward(request,response); } &#x2F;** * 结尾处理，最后执行的，success.jsp页面执行完毕后，该方法执行。 * @param request * @param response * @param handler * @param ex * @throws Exception *&#x2F; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;afterCompletion....尾处理&quot;); } } 配置拦截器 &lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体方法--&gt; &lt;mvc:mapping path=&quot;&#x2F;user&#x2F;*&quot;&#x2F;&gt; &lt;!--不要拦截的方法--&gt; &lt;!--&lt;mvc:exclude-mapping path=&quot;&quot;&#x2F;&gt;--&gt; &lt;!-- 配置拦截器对象--&gt; &lt;bean class=&quot;com.zero.interceptor.CustomInterceptor&quot;&#x2F;&gt; &lt;&#x2F;mvc:interceptor&gt; &lt;&#x2F;mvc:interceptors&gt; 控制器 @Controller @RequestMapping(&quot;user&quot;) public class UserController { @RequestMapping(&quot;&#x2F;testInterceptor&quot;) public String testInterceptor(){ System.out.println(&quot;testInterceptor....控制器执行&quot;); return &quot;success&quot;; } } success.jsp &lt;h3&gt;访问成功！&lt;&#x2F;h3&gt; &lt;% System.out.println(&quot;success.jsp执行了.....&quot;);%&gt; 测试结果 CustomInterceptor执行了....预处理 testInterceptor....控制器执行 postHandle....后处理 success.jsp执行了..... afterCompletion....尾处理 4.3 拦截器简单案例(验证用户是否登录)4.3.1 实现思路 编写登录页面，需要一个控制器访问页面。 登录页面有提交表单的动作，需在控制器中处理。 判断用户名密码是否正确 正确，向session中写入用户信息 返回登录成功 拦截用户请求，判断用户是否登录 如已经登录，放行 如未登录，跳转到登录页面 登录后使用重定向退出，涉及到RedirectView类 作用：跟return &quot;redirect:xxx&quot;类似，也是重定向操作。 重定向相对地址：return new RedirectView(&quot;index.jsp&quot;)，在此请求路径下找相应路。 重定向绝对路径：return new RedirectView(&quot;/index.jsp&quot;，相当于项目路径+此路径。 4.3.2 核心代码 控制器代码 @Controller @RequestMapping(&quot;user&quot;) public class UserController { &#x2F;** * 跳转登录页面 * @param model * @return * @throws Exception *&#x2F; @RequestMapping(&quot;&#x2F;login&quot;) public String login(Model model) throws Exception{ return &quot;login&quot;; } &#x2F;** * 登录提交 * @param session * @param userId 用户账户 * @param pwd 密码 * @return * @throws Exception *&#x2F; @RequestMapping(&quot;&#x2F;loginSubmit&quot;) public String loginSubmit(HttpSession session,String userId,String pwd) throws Exception{ &#x2F;&#x2F; 在session中记录用户身份信息 session.setAttribute(&quot;activeUser&quot;,userId); System.out.println(&quot;用户已登录&quot;); return &quot;success&quot;; } &#x2F;** * 退出 * @param session * @param request * @param response * @return * @throws Exception *&#x2F; @RequestMapping(&quot;&#x2F;logOut&quot;) public RedirectView logOut(HttpSession session, HttpServletRequest request, HttpServletResponse response) throws Exception{ &#x2F;&#x2F; 设置session过期 session.invalidate(); &#x2F;&#x2F; return new RedirectView(&quot;index.jsp&quot;); 相当于：localhost&#x2F;user&#x2F;index.jsp return new RedirectView(&quot;&#x2F;index.jsp&quot;); &#x2F;&#x2F; 相当于：localhost&#x2F;index.jsp } } 定义登录拦截器 &#x2F;** * 登录拦截器 *&#x2F; public class LoginInterceptor implements HandlerInterceptor { &#x2F;** * 预处理验证用户是否登录 * @param request * @param response * @param handler * @return * @throws Exception *&#x2F; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;登录拦截器执行&quot;); &#x2F;&#x2F; 如果是登录页面则放行 if (request.getRequestURI().indexOf(&quot;login&quot;)&gt;=0){ return true; } HttpSession session = request.getSession(); &#x2F;&#x2F; 如果用户已登录也放行 if (session.getAttribute(&quot;activeUser&quot;)!=null){ return true; } &#x2F;&#x2F; 用户没有登录则跳转到登录页面 request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;login.jsp&quot;).forward(request,response); System.out.println(&quot;用户尚未登录&quot;); return false; } } 配置拦截器 &lt;!--配置登录拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体方法--&gt; &lt;mvc:mapping path=&quot;&#x2F;user&#x2F;**&quot;&#x2F;&gt; &lt;!--不要拦截的方法--&gt; &lt;!--&lt;mvc:exclude-mapping path=&quot;&quot;&#x2F;&gt;--&gt; &lt;!-- 配置拦截器对象--&gt; &lt;bean class=&quot;com.zero.interceptor.LoginInterceptor&quot;&#x2F;&gt; &lt;&#x2F;mvc:interceptor&gt; &lt;&#x2F;mvc:interceptors&gt; jsp登录页面，其他页面就不贴代码了 &lt;h3&gt;用户登录&lt;&#x2F;h3&gt; &lt;form action=&quot;&#x2F;user&#x2F;loginSubmit&quot; method=&quot;post&quot;&gt; 用户名称：&lt;input type=&quot;text&quot; name=&quot;userId&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;&#x2F;form&gt;","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zero024.cn/tags/SpringMVC/"}]},{"title":"SpringMVC学习1","slug":"FrameWork/SpringMVC框架1","date":"2019-09-02T15:59:00.000Z","updated":"2020-03-25T01:17:18.464Z","comments":true,"path":"FrameWork/SpringMVC-Basic2.html","link":"","permalink":"https://zero024.cn/FrameWork/SpringMVC-Basic2.html","excerpt":"1. SpringMVC基本概念1.1 关于三层架构和MVC","text":"1. SpringMVC基本概念1.1 关于三层架构和MVC 1.1.1 三层架构 开发服务器端程序，一般基于两种形式，一种C/S架构程序，一种B/S架构程序 使用Java语言基本上都是开发B/S架构的程序，B/S架构又分为了三层架构 三层架构 表现层：WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型 业务层：处理公司具体的业务逻辑 持久层：用来操作数据库 1.1.2 MVC模型 MVC全名是Model View Controller模型视图控制器，每个部分各司其职。 Model：数据模型，JavaBean的类，用来进行数据封装。 View：指JSP、HTML用来展示数据给用户 Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 1.2 SpringMVC概述1.2.1 SpringMVC是什么 是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级Web框架。 Spring MVC属于SpringFrameWork的后续产品，已经融合在SpringWebFlow里面。Spring框架提供了构建 Web 应用程序的全功能MVC模块。 使用Spring可插入的MVC架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2等。 它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。 1.2.2 SpringMVC在三层架构的位置 1.2.3 SpringMVC的优势 清晰的角色划分： 前端控制器（DispatcherServlet） 请求到处理器映射（HandlerMapping） 处理器适配器（HandlerAdapter） 视图解析器（ViewResolver） 处理器或页面控制器（Controller） 验证器（ Validator） 命令对象（Command 请求参数绑定到的对象就叫命令对象） 表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。 分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。 和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。 可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。 可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。 功能强大的数据验证、格式化、绑定机制。 利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。 本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。 强大的 JSP 标签库，使 JSP 编写更容易。 支持RESTful风格的编程支持 1.2.4 SpringMVC和Struts2的优劣分析[了解] 共同点： 都是表现层框架，基于MVC模型编写的。 底层都离不开原始ServletAPI。 它们处理请求的机制都是一个核心控制器。 区别： Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter。 Spring MVC 是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。所以 Spring MVC 会稍微比 Struts2 快些。 Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便。 Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提升，尤其是 Struts2 的表单标签，远没有 html 执行效率高。 OGNL是对象 - 图形导航语言的缩写，它是一种功能强大的表达式语言，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。 2. SpringMVC入门2.1 SpringMVC入门案例1. 创建Web工程，引入开发相关的jar包 &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;!--版本锁定--&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;&#x2F;spring.version&gt; &lt;&#x2F;properties&gt; &lt;dependencies&gt; &lt;!--引入spring相关jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 2. 配置核心控制器(DispatcherServlet) 在web.xml中配置前端控制器 &lt;!--配置核心前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;!--加载mvc配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:SpringMVC.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;!--启动服务器就自动加载配置文件，生成对象--&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;!--配置控制器映射，拦截所有请求--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; 3. 编写SpringMVC.xml的配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:mvc=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation=&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;cn.zero.controller&quot;&#x2F;&gt; &lt;!--配置视图解析器对象--&gt; &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--配置前缀后缀，访问路径等于：&#x2F;WEB-INF&#x2F;pages&#x2F;xxx.jsp--&gt; &lt;property name=&quot;prefix&quot; value=&quot;&#x2F;WEB-INF&#x2F;pages&#x2F;&quot;&#x2F;&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--开启SpringMVC框架注解的支持--&gt; &lt;mvc:annotation-driven&#x2F;&gt; &lt;&#x2F;beans&gt; 4. 编写index.jsp和HelloController控制器类 index.jsp &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;主页&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h3&gt;SpringMVC快速入门&lt;&#x2F;h3&gt; &lt;a href=&quot;&#x2F;hello&quot;&gt;入门程序&lt;&#x2F;a&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; HelloController &#x2F;&#x2F; 控制器类 @Controller public class HelloController { @RequestMapping(&quot;&#x2F;hello&quot;) public String sayHello(){ System.out.println(&quot;Hello SpringMVC!&quot;); return &quot;success&quot;; } } 5. 在WEB-INF下创建pages文件夹，编写success.jsp的成功页面 &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;访问成功&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h3&gt;入门程序访问成功&lt;&#x2F;h3&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 6. 启动服务器访问localhost/index.jsp，点击入门程序，查看是否正常跳转。 2.2 入门案例的执行过程及原理分析2.2.1 入门案例的执行流程 当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，就会加载springmvc.xml配置文件 开启了注解扫描，那么HelloController对象就会被创建 从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解 找到执行的具体方法 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件 Tomcat服务器渲染页面，做出响应 如下图示流程图： 2.2.2 SpringMVC的请求响应流程 官方完整流程图： 2.3 组件详解 前端控制器(DispatcherServlet) 用户请求到达前端控制器，它相当于mvc模式中的c。DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器(HandlerMapping) HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器(Handler) 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 处理器适配器(HandlerAdapter) 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 视图解析器(ViewResolver) View Resolver 负责将处理结果生成 View 视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 视图(View) SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 2.3.1 &lt;mvc:annotation-driven/&gt;在SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为SpringMVC的三大组件。 使用自动加载 RequestMappingHandlerMapping(处理映射器)和RequestMappingHandlerAdapter(处 理 适 配 器)， 可用在SpringMVC.xml配置文件中使用替代注解处理器和适配器的配置。 2.4 @RequestMapping注解详解 RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系 RequestMapping注解可以作用在方法和类上 作用在类上：第一级的访问目录 作用在方法上：第二级的访问目录 细节：前端路径可以不写 / 表示应用的根目录开始 细节：${pageContext.request.contextPath}也可以省略不写，但是路径上不能写 / RequestMapping的属性 path：指定请求路径的url value：value属性等同于path属性，指定请求路径url mthod：指定该方法的请求方式 params：指定限制请求参数的条件，允许简单的表达式，例params={“money!100”}表示请求参数中money不能是100。 headers：发送的请求中必须包含的请求头 以上属性出现两个以上时，他们的关系是&amp;&amp;逻辑与关系 3. 请求参数的绑定[重点]3.1 绑定说明3.1.1 绑定的机制 表单提交的数据都是key=value格式的，例：username=xiaoming&amp;password=123456 SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的 要求：提交表单的name和参数的名称必须是相同的 3.1.2 支持的数据类型 基本类型参数：包括基本类型和String类型 POJO类型参数：包括实体类，以及关联的实体类 数组和集合类型参数：包括List结构和Map结构的集合(包括数组) 3.1.3 使用要求 如果是基本类型或String类型 要求参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写) 如果是 POJO 类型，或者它的关联对象 要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。 如果是集合类型,有两种方式： 要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。给 List 集合中的元素赋值，使用下标。给 Map 集合中的元素赋值，使用键值对。 接收的请求参数是 json 格式数据。需要借助一个注解实现。 3.1.4 绑定参数示例1. 基本类型和String类型作为参数 控制器代码 @RequestMapping(&quot;&#x2F;testParam&quot;) public String testParam(String username){ System.out.println(&quot;用户名：&quot;+username); return &quot;success&quot;; } jsp代码 &lt;a href=&quot;param&#x2F;testParam?username=xiaoming&quot;&gt;请求参数绑定&lt;&#x2F;a&gt; 2. POJO类型作为参数 需创建实体类Account和User，User类作为账户类的参数。 public class Account implements Serializable { private String username; private String password; private Double money; private User user; } public class User { private String name; private Integer age; } 控制器代码 &#x2F;** * 接收参数，封装为POJO类型 * @param account * @return *&#x2F; @RequestMapping(value = &quot;&#x2F;testPojo&quot;,method = RequestMethod.POST) public String testPojo(Account account){ System.out.println(account); return &quot;success&quot;; } Jsp &lt;form action=&quot;&#x2F;param&#x2F;testPojo&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 余额：&lt;input type=&quot;text&quot; name=&quot;money&quot;&gt;&lt;br&gt; 真实姓名：&lt;input type=&quot;text&quot; name=&quot;user.name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;user.age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;&#x2F;form&gt; 访问结果：Account{username=&#39;admin&#39;, password=&#39;123&#39;, money=333.0, user=User{name=&#39;xiaoming&#39;, age=22}} 3. POJO类中包含集合类型参数 修改Account类 public class Account implements Serializable { private String username; private String password; private Double money; &#x2F;&#x2F; 演示绑定POJO对象 &#x2F;&#x2F; private User user; &#x2F;&#x2F; POJO类中包含集合类型参数 private List&lt;User&gt; list; private Map&lt;String,User&gt; map; } 控制器添加方法 &#x2F;** * POJO类中包含集合类型参数 *&#x2F; @RequestMapping(value = &quot;&#x2F;testSetType&quot;,method = RequestMethod.POST) public String testSetType(Account account){ System.out.println(account); return &quot;success&quot;; } Jsp &lt;h3&gt;POJO类中包含集合类型参数&lt;&#x2F;h3&gt; &lt;form action=&quot;&#x2F;param&#x2F;testSetType&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 余额：&lt;input type=&quot;text&quot; name=&quot;money&quot;&gt;&lt;br&gt; &lt;h4&gt;封装到list集合中&lt;&#x2F;h4&gt; 真实姓名：&lt;input type=&quot;text&quot; name=&quot;list[0].name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;list[0].age&quot;&gt;&lt;br&gt; &lt;h4&gt;封装到map集合中&lt;&#x2F;h4&gt; 真实姓名：&lt;input type=&quot;text&quot; name=&quot;map[&#39;user&#39;].name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;map[&#39;user&#39;].age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;&#x2F;form&gt; 访问结果：Account{username=&#39;admin&#39;, password=&#39;111&#39;, money=333.0, list=[User{name=&#39;小明&#39;, age=22}], map={user=User{name=&#39;小李&#39;, age=21}}} 4. POST请求参数中文乱码问题在web.xml中，添加过滤器 &lt;!--添加过滤器，解决POST中文乱码问题--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt; &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt; 3.2 特殊情况如果User类中有一个Date参数，在表单提交时日期格式不正确，封装POJO对象就会失败，这时就需要自己定义一个类型转换器。 3.2.1 自定义类型转换器表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换。如果想自定义数据类型转换，可以实现Converter的接口 1. 第一步：定义一个类，实现Converter接口，该接口有两个泛型。 &#x2F;** * 将字符串类型转换为日期格式 *&#x2F; public class StringToDateConverter implements Converter&lt;String, Date&gt; { &#x2F;** * @param source 传入的字符串参数 * @return *&#x2F; @Override public Date convert(String source) { if (source == null){ throw new RuntimeException(&quot;please entry param！&quot;); } DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); &#x2F;&#x2F; 把字符串转换为日期 try { return df.parse(source); } catch (Exception e) { throw new RuntimeException(&quot;Data switch Error！&quot;); } } } 2. 在SpringMVC.xml中配置类型转换器 &lt;!--配置自定义类型转换器--&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;!--注册转换器类--&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;cn.zero.utils.StringToDateConverter&quot;&#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;!--开启SpringMVC框架注解的支持 配置一下让转换器生效--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&#x2F;&gt; 重启服务器在测试一下，就支持yyyy-MM-dd的日期格式了。 3.2.2 使用ServletAPI对象作为方法参数 示例获取Servlet对象 在控制器中新增方法 &#x2F;** * 测试获取ServetlAPI * @param request * @param response * @param session * @return *&#x2F; @RequestMapping(&quot;&#x2F;testServletAPI&quot;) public String testServletAPI(HttpServletRequest request, HttpServletResponse response, HttpSession session){ System.out.println(request); System.out.println(response); System.out.println(session); return &quot;success&quot;; } jsp代码：&lt;a href=&quot;/param/testServletAPI&quot;&gt;测试访问ServletAPI&lt;/a&gt; 4. 常用注解4.1 @RequestParam1. 使用说明 作用：把请求中指定名称的参数给控制器中的形参赋值 属性： value：请求参数中的名称 required：请求参数中是否必须提供此参数。默认为true，表示必须提供，不提供将报错。 2. 示例 控制器代码 @Controller @RequestMapping(&quot;anno&quot;) public class AnnotationController { @RequestMapping(&quot;&#x2F;useRequestParam&quot;) public String useRequestParam(@RequestParam(&quot;name&quot;) String username, @RequestParam(value = &quot;age&quot;,required = false) Integer age){ System.out.println(username+&quot;:&quot;+age); return &quot;success&quot;; } } jsp &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;常用注解测试&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h2&gt;1. 测试requestParam注解的使用&lt;&#x2F;h2&gt; &lt;a href=&quot;&#x2F;anno&#x2F;useRequestParam?name=xiaoming&quot;&gt;@RequestParam注解&lt;&#x2F;a&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 结果：xiaoming:null，因配置了required=false，故请求参数中无age不会报错。 4.2 @RequestBody1. 使用说明 作用：用于获取请求体内容。直接使用得到是key=value&amp;key=value结构的数据。get请求方式不适用。 属性： required：是否必须有请求体。默认值true，表示必须有请求体，故get请求方式会报错。如取值为false，get请求得到的是null。 2. 示例 控制器代码 &#x2F;** * RequestBody:用于获取请求体内容。 * @param body * @return *&#x2F; @RequestMapping(&quot;&#x2F;useRequestBody&quot;) public String useRequestBody(@RequestBody(required = false) String body){ System.out.println(body); return &quot;success&quot;; } jsp &lt;h3&gt;2. 测试@RequestBody注解使用&lt;&#x2F;h3&gt; &lt;h5&gt;POST请求测试&lt;&#x2F;h5&gt; &lt;form action=&quot;&#x2F;anno&#x2F;useRequestBody&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;&#x2F;form&gt; &lt;h5&gt;GET请求测试&lt;&#x2F;h5&gt; &lt;a href=&quot;&#x2F;anno&#x2F;useRequestBody?body=test&quot;&gt;requestBody注解get请求&lt;&#x2F;a&gt; 测试结果： POST请求：name=xiaoming&amp;age=1 GET请求：null 4.3 @ResponseBody1. 使用说明该注解的作用是将控制器方法返回的对象通过适当的转换器转换为指定格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。 注意：使用此注解后不会在走视图解析器，而是直接将数据写入到输出流中，效果等同于通过response对象输出指定格式数据(response.getWriter.write(JSONObject.fromObject(user).toString());)。 2. 示例 控制器代码 @RequestMapping(&quot;&#x2F;testResponseBody&quot;) @ResponseBody public Student testResponseBody(){ return new Student(&quot;小明&quot;,&quot;男&quot;); } 访问页面结果：{&quot;name&quot;:&quot;小明&quot;,&quot;sex&quot;:&quot;男&quot;} 因返回值满足key-value(对象或map)格式，所以会自动将响应头的Content-Type设置为了application/html;charset=utf-8，然后把转换后的内容以输出流的形式响应给客户端。 注意：使用该注解返回json数据还需额外jar包：jackson，依赖坐标如下 &lt;!--添加对json数据的支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt; &lt;/dependency&gt; 如果返回是字符串类型，控制器代码如下 @RequestMapping(value = &quot;&#x2F;testResponseBody&quot;,produces = &quot;text&#x2F;html;charset=utf-8&quot;) @ResponseBody public String testResponseBody(){ return &quot;你好!&quot;; } 访问结果：你好! 如果返回值不能解析为json格式，注解就会将其直接以输出流形式输出到页面上。 注：使用produces设置响应头Content-Type为text/html;charset=utf-8解决中文乱码问题。 4.4 @PathVaribale1. 使用说明路径变量，用于绑定 url 中的占位符。例如：请求url中/delete/{id}，这个{id}就是url占位符。url 支持占位符是 Spring3.0 之后加入的，是 SpringMVC支持REST风格URL的一个重要标志。 属性 value：用于指定url中占位符名称。 required：是否必须提供占位符。 2. 示例 控制器代码 &#x2F;** * PathVaribale：用于绑定 url 中的占位符 *&#x2F; @RequestMapping(&quot;&#x2F;usePathVariable&#x2F;{id}&quot;) public String usePathVariable(@PathVariable(&quot;id&quot;) Integer id){ System.out.println(id); return &quot;success&quot;; } jsp &lt;h3&gt;3. 测试@PathVaribale注解&lt;&#x2F;h3&gt; &lt;a href=&quot;&#x2F;anno&#x2F;usePathVariable&#x2F;100&quot;&gt;PathVariable注解的使用&lt;&#x2F;a&gt; 测试结构：100 3. 关于REST风格URL 什么是REST： 表现层状态转换（REST，英文：Representational State Transfer），一种万维网软件架构风格，目的是便于不同软件/程序在网络中互相传递信息。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。 详细内容见文章 RESTful的优点：结构清晰、符合标准、易于理解、扩展方便。RESTful可以通过一套统一的接口为 Web、iOS和Android提供服务，另外对于很多平台来说（比如像Facebook，Twiter、微博、微信等开放平台），它们不需要有显式的前端，只需要一套提供服务的接口，于是RESTful便是它们最好的选择。 RESTful的特性 资源(Resources)：网络上的一个实体，或说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。通过一个URI来指向它。 表现层(Representation)：把资源具体呈现出来的形式，叫做它的表现层。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。 状态转化(Status Transfer)：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”。而这种转化是建立在表现层上的。所以就是“表现层状态转化”。具体说，就是HTTP协议里面，四个表示操作方式的动词以及对应的基本操作：GET(获取资源)、POST(新建资源)、PUT(更新资源)、DELETE(删除资源)。 4. 基于HiddentHttpMethodFilter的REST风格示例[了解] 作用： 由于浏览器form表单只支持GET和POST请求，而DELETE、PUT等method并不支持，Spring3.0添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持DELETE和PUT请求。 使用步骤： 第一步：在web.xml中配置该过滤器 第二步：请求方式必须使用POST请求 第三部：按照要求提供_method请求参数，该参数的取值就是我们需要的请求方式。 示例代码 jsp &lt;!-- 更新 --&gt; &lt;form action=&quot;springmvc&#x2F;testRestPUT&#x2F;1&quot; method=&quot;post&quot;&gt; 用户名称：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&#x2F;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;更新&quot;&gt; &lt;&#x2F;form&gt; 控制器 &#x2F;** * put 请求：更新 * @param username * @return *&#x2F; @RequestMapping(value=&quot;&#x2F;testRestPUT&#x2F;{id}&quot;,method=RequestMethod.PUT) public String testRestfulURLPUT(@PathVariable(&quot;id&quot;)Integer id,User user){ System.out.println(&quot;rest put &quot;+id+&quot;,&quot;+user); return &quot;success&quot;; } 4.5 @RequestHeader1. 使用说明 作用：用于获取请求消息头 属性 value：提供消息头名称 required：是否必须有此消息头 了解即可，一般不用 2. 示例 控制器代码 &#x2F;** * RequestHeader：用于获取请求消息头。 *&#x2F; @RequestMapping(&quot;&#x2F;useRequestHeader&quot;) public String useRequestHeader(@RequestHeader(value = &quot;Accept-Language&quot;,required = false)String requestHeader){ System.out.println(requestHeader); return &quot;success&quot;; } jsp &lt;h3&gt;4. 测试@RequestHeader注解&lt;&#x2F;h3&gt; &lt;a href=&quot;&#x2F;anno&#x2F;useRequestHeader&quot;&gt;获取请求消息头&lt;&#x2F;a&gt; 结果：zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 4.6 @CookieValue1. 使用说明 作用：用于把指定cookie名称的值传入控制器方法参数 属性： value：指定cookie的名称 required：是否必须有此cookie 2. 示例 控制器代码 &#x2F;** * @CookieValue：用于把指定cookie名称的值传入控制器方法参数。 * @param cookieValue * @return *&#x2F; @RequestMapping(&quot;&#x2F;useCookieValue&quot;) public String useCookieValue(@CookieValue(value = &quot;JSESSIONID&quot;,required = false)String cookieValue){ System.out.println(cookieValue); return &quot;success&quot;; } jsp &lt;h3&gt;5. 测试@CookieValue&lt;&#x2F;h3&gt; &lt;a href=&quot;&#x2F;anno&#x2F;useCookieValue&quot;&gt;绑定cookie的值&lt;&#x2F;a&gt; 结果：C8001453C280DF881950883018287F9C 4.7 @ModelAttribute1. 使用说明 作用：该注解是SpringMVC4.3版本以后新加入的。它可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰有具体返回值的方法，也可以修饰没有返回值的方法。 出现在参数上，获取指定的数据给参数赋值。 属性： value：用于获取数据的key。key可以是POJO的属性名称，也可以是map结构的key。 应用场景 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 2. 示例 基于POJO属性的基本使用 控制器代码 &#x2F;** * 出现在方法上： * 被ModelAttribute 修饰的方法 * 当前方法会在控制器的方法执行之前，先执行。 * @param user *&#x2F; @ModelAttribute public void showModel(User user){ System.out.println(&quot;执行了showModel方法&quot;+user.getName()); } &#x2F;** * 接收请求的方法 * @param user * @return *&#x2F; @RequestMapping(&quot;&#x2F;testModelAttribute&quot;) public String testModelAttribute(User user) { System.out.println(&quot;执行了控制器的方法&quot;+user.getName()); return &quot;success&quot;; } jsp &lt;h3&gt;6. 测试@ModelAttribute&lt;&#x2F;h3&gt; &lt;a href=&quot;&#x2F;anno&#x2F;testModelAttribute?name=test&quot;&gt;测试ModelAttribute注解的使用&lt;&#x2F;a&gt; 测试结果： 执行了showModel方法test 执行了控制器的方法test 基于Map的应用场景示例：修饰方法带返回值 控制器代码 &#x2F;** * 出现在方法上： * 被ModelAttribute 修饰的方法 * 当前方法会在控制器的方法执行之前，先执行。 * 在控制器执行前，查询数据库中用户信息 * @param name *&#x2F; @ModelAttribute public User showModel(String name){ &#x2F;&#x2F; 调用数据库查询方法，返回用户对象 User user = findUserByName(name); System.out.println(&quot;执行了findUser方法&quot;+user); return user; } &#x2F;** * 模拟修改用户方法 * @param user * @return *&#x2F; @RequestMapping(&quot;&#x2F;updateUser&quot;) public String updateUser(User user) { System.out.println(&quot;控制器中处理请求的方法：修改用户&quot;+user); return &quot;success&quot;; } &#x2F;** * 模拟数据库查询操作 * @param name * @return *&#x2F; private User findUserByName(String name) { User user = new User(); user.setName(name); user.setAge(19); user.setDate(new Date()); return user; } jsp &lt;h4&gt;6.1 2 基于Map应用场景示例：修饰方法带返回值&lt;&#x2F;h4&gt; &lt;form action=&quot;&#x2F;anno&#x2F;updateUser&quot; method=&quot;post&quot;&gt; 用户名称：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt; &lt;&#x2F;form&gt; 测试结果： 执行了findUser方法User{name=&#39;小王&#39;, age=19, date=Sun Sep 01 17:02:46 CST 2019} 控制器中处理请求的方法：修改用户User{name=&#39;小王&#39;, age=11, date=Sun Sep 01 17:02:46 CST 2019} 基于Map的应用场景示例：修饰方法不带返回值 前端代码不变，修改控制器方法 @ModelAttribute public void showModel(String name, Map&lt;String,User&gt; map){ &#x2F;&#x2F; 调用数据库查询方法，返回用户对象 User user = findUserByName(name); System.out.println(&quot;showModel&quot;+System.identityHashCode(user)); System.out.println(&quot;执行了findUser方法&quot;+user); map.put(&quot;user&quot;,user); } @RequestMapping(&quot;&#x2F;updateUser&quot;) public String updateUser(@ModelAttribute(&quot;user&quot;) User user) { System.out.println(&quot;update&quot;+System.identityHashCode(user)); System.out.println(&quot;控制器中处理请求的方法：修改用户&quot;+user); return &quot;success&quot;; } 4.8 @SessionAttribute1. 使用说明 作用：用于多次执行控制器方法间的参数共享 属性 value：用于指定存入的属性名称 type：用于指定存入的数据类型 2. 示例2.1 存储值 控制器代码 @Controller @RequestMapping(&quot;anno&quot;) @SessionAttributes(value = {&quot;msg&quot;}) &#x2F;&#x2F; @SessionAttributes该注解只能作用在类上，这里使用效果是将msg再存一份到session域中 public class AnnotationController { &#x2F;** * SessionAttribute注解 * 将值存储到request域中 * @return *&#x2F; @RequestMapping(&quot;&#x2F;useSessionAttribute&quot;) public String useSessionAttribute(Model model) { &#x2F;&#x2F; 底层会存储到request域对象中 model.addAttribute(&quot;msg&quot;,&quot;小明&quot;); return &quot;success&quot;; } } Anno.jsp &lt;h3&gt;7. 测试@SessionAttribute&lt;&#x2F;h3&gt; &lt;a href=&quot;&#x2F;anno&#x2F;useSessionAttribute&quot;&gt;使用SessionAttribute存储值&lt;&#x2F;a&gt;&lt;br&gt; success.jsp &lt;body&gt; &lt;h3&gt;测试程序访问成功&lt;&#x2F;h3&gt; 存储到request域中：${msg} &lt;br&gt; 存储到session域中：${sessionScope} &lt;&#x2F;body&gt; 测试结果： 测试程序访问成功 存储到request域中：小明 存储到session域中：{msg=小明} 2.2 获取值 控制器 &#x2F;** * 获取值 * @param map * @return *&#x2F; @RequestMapping(&quot;&#x2F;getSessionAttribute&quot;) public String getSessionAttribute(ModelMap map) { &#x2F;&#x2F; model无法获取，只能通过它的实现类ModelMap来获取 System.out.println(&quot;getSessionAttribute....&quot;); &#x2F;&#x2F; 获取存储在request域中的数据 String msg = (String) map.get(&quot;msg&quot;); System.out.println(msg); return &quot;success&quot;; } jsp &lt;a href=&quot;&#x2F;anno&#x2F;getSessionAttribute&quot;&gt;获取值&lt;&#x2F;a&gt;&lt;br&gt; 测试结果，后台显示： getSessionAttribute.... 小明 2.3 清除值 控制器 &#x2F;** * 删除值 * @param status * @return *&#x2F; @RequestMapping(&quot;&#x2F;delSessionAttribute&quot;) public String delSessionAttribute(SessionStatus status) { System.out.println(&quot;delSessionAttribute....&quot;); status.setComplete(); &#x2F;&#x2F; 删除session域中存储的值 return &quot;success&quot;; } jsp &lt;a href=&quot;&#x2F;anno&#x2F;delSessionAttribute&quot;&gt;删除值&lt;&#x2F;a&gt; 测试结果，后台显示：delSessionAttribute....","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zero024.cn/tags/SpringMVC/"}]},{"title":"SpringMVC入门","slug":"FrameWork/SpringMVC入门","date":"2019-08-29T15:10:00.000Z","updated":"2020-03-25T01:17:36.784Z","comments":true,"path":"FrameWork/SpringMVC-Basic.html","link":"","permalink":"https://zero024.cn/FrameWork/SpringMVC-Basic.html","excerpt":"1. SpringMVC 入门1.1 简介Spring MVC是Spring提供的一个强大而灵活的web框架，目前最好的实现MVC设计模式的框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，提供Spring的依赖注入功能，这些bean被注入到控制器中。","text":"1. SpringMVC 入门1.1 简介Spring MVC是Spring提供的一个强大而灵活的web框架，目前最好的实现MVC设计模式的框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，提供Spring的依赖注入功能，这些bean被注入到控制器中。 Spring MVC主要由DispatcherServlet、处理器映射、适配器、控制器、视图解析器、视图组成。 1.2 MVC设计模式 MVC是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式。 Controller：负责接收并处理用户请求，响应客户端。 Model：模型数据，业务逻辑。 View：展示模型，与用户进行交互。 1.3 SpringMVC核心组件 DispatcherServlet：前置控制器。 HandlerMapping：将请求映射到Handler。 Handler：后端控制器，完成具体业务逻辑。 HandlerInterceptor：处理器拦截器。 HandlerExecutionChain：处理器执行链。 HandlerAdapter：处理器适配器。 ModelAndView：装载模型数据和视图信息。 ViewResolver：视图解析器。 1.4 SpringMVC实现流程 客户端请求被DispatcherServlet接收。 DispatcherServlet将请求映射到Handler。 生成Handler以及HandlerInterceptor。 返回HandlerExecutionChain(Handler+HandlerInterceptor)。 DispatcherServlet通过HandlerAdapter执行Handler。 返回一个ModelAndView。 DispatcherServlet通过ViewResolver进行解析。 返回填充了模型数据的View，响应给客户端。 2. SpringMVC快速开发大部分组件由框架提供，开发者只需通过配置进行关联。开发者只需手动编写Handler和View。 2.1 基于XML配置的使用 SpringMVC基础配置 XML配置Controller，HandlerMapping组件映射。 XML配置ViewResolver组件映射。 2.1.1 示例 使用maven创建一个简单的web项目，修改pom包导入相关jar包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!--导入SpringMVC所需jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;4.3.1.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--导入servlet相关jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;3.1.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 创建MyHandler控制器，完成具体业务逻辑 public class MyHandler implements Controller { @Override public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { &#x2F;&#x2F; 装载模型数据和逻辑视图 ModelAndView modelAndView = new ModelAndView(); &#x2F;&#x2F; 添加模型数据 modelAndView.addObject(&quot;name&quot;,&quot;Tom&quot;); &#x2F;&#x2F; 添加逻辑视图 modelAndView.setViewName(&quot;show&quot;); return modelAndView; } } 创建show.jsp，做前端显示 &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@page isELIgnored=&quot;false&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; ${name} &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 资源文件夹resources下创建springmvc.xml的配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;!-- URL处理映射的方式有三种： 1. BeanNameUrlHandlerMapping：通过url名字，找到对应的bean的name的控制器 2. 在SimpleUrlHandlerMapping中配置：通过key找到bean 3. ControllerClassNameHandlerMapping：通过类名 --&gt; &lt;!--1. 配置HandlerMapping，将url请求映射到Handler--&gt; &lt;bean id=&quot;handlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;!--配置简单url映射--&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;!--2. 配置test请求对应的handler--&gt; &lt;prop key=&quot;&#x2F;test&quot;&gt;testHandler&lt;&#x2F;prop&gt; &lt;&#x2F;props&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;!--3. 配置控制器--&gt; &lt;bean id=&quot;testHandler&quot; class=&quot;com.zero.handler.MyHandler&quot;&#x2F;&gt; &lt;!--4. 配置视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--配置前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;&#x2F;&quot;&#x2F;&gt; &lt;!--配置后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;beans&gt; 在web.xml下配置DispatcherServlet &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!-- 配置：所有请求由SpringMVC管理 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; &lt;&#x2F;web-app&gt; 启动服务器，访问/test.do路径资源，查看是否显示姓名。 2.2 基于注解方式的使用[重要] SpringMVC基础配置。 Controller，HandlerMapping通过注解进行映射。 XML中配置ViewResolver组件映射。 2.2.1 示例 其余配置不变，新建一个控制器类，使用注解声明 &#x2F;&#x2F; 基于注解实现映射 @Controller public class AnnotationHandler { &#x2F;** * 业务方法1：ModelAndView完成数据的传递，视图的解析 *&#x2F; @RequestMapping(&quot;&#x2F;modelAndViewTest&quot;) public ModelAndView modelAndViewTest(){ &#x2F;&#x2F; 创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); &#x2F;&#x2F; 填充模型数据 modelAndView.addObject(&quot;name&quot;,&quot;Tom&quot;); &#x2F;&#x2F; 设置逻辑视图 modelAndView.setViewName(&quot;show&quot;); return modelAndView; } &#x2F;** * 业务方法2：Model传值，String进行视图解析 * @return *&#x2F; @RequestMapping(&quot;&#x2F;modelTest&quot;) public String ModelTest(Model model){ &#x2F;&#x2F; 填充模型数据 model.addAttribute(&quot;name&quot;,&quot;Jerry&quot;); &#x2F;&#x2F; 设置逻辑视图 return &quot;show&quot;; } &#x2F;** * 业务方法3：Map传值，String进行视图解析 *&#x2F; @RequestMapping(&quot;&#x2F;mapTest&quot;) public String MapTest(Map&lt;String,String&gt; map){ &#x2F;&#x2F; 填充模型数据 map.put(&quot;name&quot;,&quot;Cat&quot;); &#x2F;&#x2F; 设置逻辑视图 return &quot;show&quot;; } } mvc配置文件中，开启自动扫描，并删除前面配置的两个bean对象即可 &lt;!--1. 配置自动扫描包--&gt; &lt;context:component-scan base-package=&quot;com.zero.backoffice.web.controller&quot;&#x2F;&gt; 重启服务器，访问/modelAndViewTest等资源路径，测试是否成功。 2.3 URL处理器映射[了解] BeanNameUrlHandlerMapping 功能：寻找controller，根据url请求去匹配bean的name属性，找到对应的控制器。 &lt;!-- 1. 配置处理器映射，mvc默认的处理器映射器 BeanNameUrlHandlerMapping:根据bean的name属性的url去找Controller --&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&#x2F;&gt; &lt;bean name=&quot;&#x2F;user.do&quot; class=&quot;com.zero.backoffice.web.controller.UserController&quot;&#x2F;&gt; SimpleUrlHandlerMapping 功能：寻找controller，根据浏览器url匹配简单url的key，key就是通过controller的id找到对应的Controller &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;&#x2F;user1.do&quot;&gt;userController&lt;&#x2F;prop&gt; &lt;&#x2F;props&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;bean id=&quot;userController&quot; name=&quot;&#x2F;user.do&quot; class=&quot;com.zero.web.controller.UserController&quot;&#x2F;&gt; ControllerClassNameHandlerMapping 功能：寻找controller，根据类名.do来访问，类名首字母小写。如下访问路径就是userController.do &lt;bean class=&quot;org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping&quot;&#x2F;&gt; &lt;bean class=&quot;com.zero.backoffice.web.controller.UserController&quot;&#x2F;&gt; 2.4 处理器适配器 SimpleControllerHandlerAdapter 功能：执行controller，调用controller里面的方法，返回ModelAndView &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&#x2F;&gt; HttpRequestHandlerAdapter 执行控制器：负责调用实现HttpRequestHandler接口的控制器 2.5 乱码问题 POST请求乱码，需在web.xml中配置编码过滤器 &lt;!-- 配置编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;EncodingFilter&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt; &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;EncodingFilter&lt;&#x2F;filter-name&gt; &lt;&#x2F;filter-mapping&gt; GET请求乱码：Tomcat8默认进行了url编码，故get请求不会乱码，tomcat7会乱码。 3. SpringMVC接收请求参数3.1 封装参数分析 常用的数据绑定类型 基本数据类型 包装类 数组 对象(POJO) 集合(List、Set、Map) JSON 3.2 接收基本数据类型 编写一个注册类register.jsp &lt;body&gt; &lt;form action=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;register.do&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别:&lt;input type=&quot;text&quot; name=&quot;gender&quot;&gt;&lt;br&gt; 年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 生日:&lt;input type=&quot;text&quot; name=&quot;birthday&quot;&gt;&lt;br&gt; 爱好:&lt;input type=&quot;checkbox&quot; name=&quot;hobbyIds&quot; value=&quot;1&quot;&gt;打球 &lt;input type=&quot;checkbox&quot; name=&quot;hobbyIds&quot; value=&quot;2&quot;&gt;看书 &lt;input type=&quot;checkbox&quot; name=&quot;hobbyIds&quot; value=&quot;3&quot;&gt;玩游戏&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt; 控制器中新增注册方法 @Controller @RequestMapping(&quot;user&quot;) public class UserController{ @RequestMapping(&quot;&#x2F;toRegister&quot;) public String toRegister(){ return &quot;user&#x2F;register&quot;; } &#x2F;** * 第一种接收表单参数的方式： * 直接在形参列表写要接受的参数 * 默认日期格式： MM&#x2F;DD&#x2F;YYYY * @return *&#x2F; @RequestMapping(&quot;&#x2F;register&quot;) public String register(String username, String password, int age, String gender, Date birthday, String[] hobbyIds){ System.out.println(username); return &quot;user&#x2F;info&quot;; } } 3.3 接收POJO类型 模型类User新增对应属性 public class User { private String username; private String password; private String gender; private int age; private String birthday; private String[] hobbyIds; } 控制器中新增方法 &#x2F;** * 第二种接收表单参数的方式： * 使用POJO对象接收 * @return *&#x2F; @RequestMapping(&quot;&#x2F;register2&quot;) public String register2(User user){ System.out.println(user); return &quot;user&#x2F;info&quot;; } register.jsp中修改&lt;form action=&quot;${pageContext.request.contextPath}/user/register.do&quot; method=&quot;post&quot;&gt; info.jsp做数据展示 &lt;body&gt; &lt;h4&gt;用户信息&lt;&#x2F;h4&gt; 用户名:${user.username}&lt;br&gt; 密码:${user.password}&lt;br&gt; 性别:${user.gender}&lt;br&gt; 年龄:${user.age}&lt;br&gt; 生日:${user.birthday}&lt;br&gt; 爱好:${user.hobbyIds}&lt;br&gt; &lt;&#x2F;body&gt; 3.4 接收包装类型参数 创建UserExt类，把User写成一个类的属性，模型里面有模型 public class UserExt { private User user; @Override public String toString() { return &quot;UserExt{&quot; + &quot;user=&quot; + user + &#39;}&#39;; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } } 控制器添加注册方法 &#x2F;** * 第三种接收表单参数的方式：接收包装类型参数 * 使用包装类，相当于模型里面有模型 * @return *&#x2F; @RequestMapping(&quot;&#x2F;register3&quot;) public String register3(UserExt user){ System.out.println(user); return &quot;user&#x2F;info&quot;; } 修改form表单 &lt;body&gt; &lt;form action=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;register3.do&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt;&lt;br&gt; 密码:&lt;input type=&quot;text&quot; name=&quot;user.password&quot;&gt;&lt;br&gt; 性别:&lt;input type=&quot;text&quot; name=&quot;user.gender&quot;&gt;&lt;br&gt; 年龄:&lt;input type=&quot;text&quot; name=&quot;user.age&quot;&gt;&lt;br&gt; 生日:&lt;input type=&quot;text&quot; name=&quot;user.birthday&quot;&gt;&lt;br&gt; 爱好:&lt;input type=&quot;checkbox&quot; name=&quot;user.hobbyIds&quot; value=&quot;1&quot;&gt;打球 &lt;input type=&quot;checkbox&quot; name=&quot;user.hobbyIds&quot; value=&quot;2&quot;&gt;看书 &lt;input type=&quot;checkbox&quot; name=&quot;user.hobbyIds&quot; value=&quot;3&quot;&gt;玩游戏&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt; 3.5 接收List集合类型参数 修改UserExt类，添加list集合属性 public class UserExt { private User user; private List&lt;User&gt; users = new ArrayList&lt;&gt;(); @Override public String toString() { return &quot;UserExt{&quot; + &quot;user=&quot; + user + &quot;, users=&quot; + users + &#39;}&#39;; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } public List&lt;User&gt; getUsers() { return users; } public void setUsers(List&lt;User&gt; users) { this.users = users; } } register.jsp中新增一个测试form表单 &lt;h4&gt;接收集合类型的参数&lt;&#x2F;h4&gt; &lt;form action=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;register4.do&quot; method=&quot;post&quot;&gt; 用户名1:&lt;input type=&quot;text&quot; name=&quot;users[0].username&quot;&gt;&lt;br&gt; 密码1:&lt;input type=&quot;text&quot; name=&quot;users[0].password&quot;&gt;&lt;br&gt; &lt;hr&gt; 用户名2:&lt;input type=&quot;text&quot; name=&quot;users[1].username&quot;&gt;&lt;br&gt; 密码2:&lt;input type=&quot;text&quot; name=&quot;users[1].password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt; &lt;&#x2F;form&gt; 添加注册方法 &#x2F;** * 第四种接收表单参数的方式：接收List集合类型参数 * @return *&#x2F; @RequestMapping(&quot;&#x2F;register4&quot;) public String register4(UserExt user){ System.out.println(user.getUsers()); return &quot;user&#x2F;info&quot;; } 3.6 接收Map集合类型参数 UserExt添加一个map集合属性 public class UserExt { private User user; private List&lt;User&gt; users = new ArrayList&lt;&gt;(); private Map&lt;String,Object&gt; infos = new HashMap&lt;String,Object&gt;(); &#x2F;&#x2F; 使用map来接收参数 } 添加注册方法 &#x2F;** * 第五种接收表单参数的方式：接收Map集合类型参数 * @return *&#x2F; @RequestMapping(&quot;&#x2F;register5&quot;) public String register5(UserExt user){ System.out.println(user.getInfos()); return &quot;user&#x2F;info&quot;; } 修改表单 &lt;h4&gt; 表单数据用map接收 &lt;&#x2F;h4&gt; &lt;form action=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;register5.do&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;infos[&#39;username&#39;]&quot;&gt;&lt;br&gt; 密码:&lt;input type=&quot;text&quot; name=&quot;infos[&#39;password&#39;]&quot;&gt;&lt;br&gt; 性别:&lt;input type=&quot;text&quot; name=&quot;infos[&#39;gender&#39;]&quot;&gt;&lt;br&gt; 年龄:&lt;input type=&quot;text&quot; name=&quot;infos[&#39;age&#39;]&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;&#x2F;form&gt; 4. 页面回显 控制器配置一个列表方法 @RequestMapping(&quot;&#x2F;list&quot;) public String userlist(Model model){ &#x2F;&#x2F; 1. 模拟一个数据库中的数据 List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(new User(&quot;小明&quot;,&quot;male&quot;,22,&quot;2018&quot;)); users.add(new User(&quot;小李&quot;,&quot;male&quot;,12,&quot;2019&quot;)); users.add(new User(&quot;小哈&quot;,&quot;male&quot;,32,&quot;2014&quot;)); &#x2F;&#x2F; 将数据存储到model中 model.addAttribute(&quot;userList&quot;,users); return &quot;user&#x2F;userList&quot;; } 前端jsp展示数据 &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot;%&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;UserList&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; 用户列表: &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;姓名：&lt;&#x2F;td&gt; &lt;td&gt;年龄&lt;&#x2F;td&gt; &lt;td&gt;性别&lt;&#x2F;td&gt; &lt;td&gt;生日&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;c:forEach items=&quot;${userList}&quot; var=&quot;user&quot;&gt; &lt;tr&gt; &lt;td&gt;${user.username}&lt;&#x2F;td&gt; &lt;td&gt;${user.age}&lt;&#x2F;td&gt; &lt;td&gt;${user.gender}&lt;&#x2F;td&gt; &lt;td&gt;${user.birthday}&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;c:forEach&gt; &lt;&#x2F;table&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 修改用户方法示例 &#x2F;&#x2F; 编辑页面 @RequestMapping(&quot;&#x2F;edit&quot;) public String edit(Integer id, Model model){ &#x2F;&#x2F; 模拟通过id在数据库中查询数据,返回一个user对象，再将user对象存入model System.out.println(&quot;修改的用户id:&quot;+id); User user = new User(id, &quot;小明&quot;, &quot;male&quot;, 22, &quot;2018&quot;); model.addAttribute(&quot;user&quot;,user); return &quot;user&#x2F;userEdit&quot;; } &#x2F;&#x2F; 修改用户信息 @RequestMapping(&quot;&#x2F;update&quot;) public String update(Integer id,Model model){ System.out.println(&quot;修改的用户id:&quot;+id); return &quot;user&#x2F;userList&quot;; } 编辑jsp界面 &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Edit&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;form action=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;update.do?id=${user.id}&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;${user.username}&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;${user.age}&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;text&quot; name=&quot;gender&quot; value=&quot;${user.gender}&quot;&gt;&lt;br&gt; 生日：&lt;input type=&quot;text&quot; name=&quot;birthday&quot; value=&quot;${user.birthday}&quot;&gt;&lt;br&gt; &lt;button type=&quot;submit&quot; value=&quot;提交修改&quot;&#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 5. URL模板映射模板映射可以RESTful软件架构风格。 修改url格式，体验RESTful &lt;a href=&quot;${pageContext.request.contextPath}&#x2F;user&#x2F;edit1&#x2F;${user.id}.do&quot;&gt;RESTful修改&lt;&#x2F;a&gt; &lt;!--配置接收url模板映射： {}：匹配接收页面url路径参数--&gt; 控制器中添加方法 &#x2F;&#x2F; 编辑页面,使用RESTful风格。{id}里面参数通过@PathVariable注入到后面参数Integer id中去 @RequestMapping(&quot;&#x2F;edit1&#x2F;{id}&quot;) public String edit1(@PathVariable Integer id, Model model){ &#x2F;&#x2F; 模拟通过id在数据库中查询数据,返回一个user对象，再将user对象存入model System.out.println(&quot;修改的用户id:&quot;+id); User user = new User(id, &quot;小明&quot;, &quot;male&quot;, 22, &quot;2018&quot;); model.addAttribute(&quot;user&quot;,user); return &quot;user&#x2F;userEdit&quot;; } 需在web.xml中配置rest路径 &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; &lt;!--RESTful风格--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;rest&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; 测试页面，http://localhost/rest/user/edit1/1 6. 转发和重定向 转发到同一个控制器的方法：forward &#x2F;&#x2F; 示例转发到list.do。同一个控制器中转发 @RequestMapping(&quot;&#x2F;test1&quot;) public String test1(){ return &quot;forward:list.do&quot;; } 转发到不同的控制器 @Controller @RequestMapping(&quot;stu&quot;) public class StudentController { &#x2F;&#x2F; 示例转发到list.do。不同控制器中转发,加上域名&#x2F;user即可 @RequestMapping(&quot;&#x2F;test1&quot;) public String test1(){ return &quot;forward:&#x2F;user&#x2F;list.do&quot;; } } 重定向，只需改成redirect即可 @Controller @RequestMapping(&quot;stu&quot;) public class StudentController { &#x2F;&#x2F; 示例重定向到list.do。不同控制器中转发 @RequestMapping(&quot;&#x2F;test1&quot;) public String test1(){ return &quot;redirect:&#x2F;user&#x2F;list.do&quot;; } } 7. RequestParam 该注解是对参数的一些说明描述 value：参数名称 defaultValue：默认值 required：参数是否必须有值。如果为true，参数又是空且未定义默认值，则会报错。 示例 @Controller @RequestMapping(&quot;stu&quot;) public class StudentController { &#x2F;&#x2F; 示例注解请求参数配置 @RequestMapping(&quot;&#x2F;test1&quot;) public String test1(@RequestParam(value = &quot;uid&quot;,required = true,defaultValue = &quot;1&quot;)Integer uid){ System.out.println(uid); return &quot;redirect:&#x2F;user&#x2F;list.do&quot;; } }","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zero024.cn/tags/SpringMVC/"}]},{"title":"MyBatis进阶","slug":"FrameWork/MyBatis进阶","date":"2019-08-24T15:59:00.000Z","updated":"2020-03-25T01:15:38.624Z","comments":true,"path":"FrameWork/MyBatis-advanced.html","link":"","permalink":"https://zero024.cn/FrameWork/MyBatis-advanced.html","excerpt":"1. MyBatis的关联查询1.1 案例：用户和订单表结构如下：","text":"1. MyBatis的关联查询1.1 案例：用户和订单表结构如下： user和orders user与orders：一个用户可以创建多个订单，一对多。 orders与user：多个订单只由一个用户创建，多对一。 orders和orderdetail orders与orderdetail：一个订单可以包括多个订单明细，因为一个订单可以购买多个商品，每个商品购买信息在orderdetail记录，一对多关系。 orderdetail与orders：多个订单明细包括在一个订单中，多对一。 orderdetail和items orderdetail与items：多个订单明细只对应一个商品信息，多对一。 items与orderdetail：一个商品可以包括在多个订单明细中，一对多。 1.2 一对一：resultType实现复杂查询时，单表对应的PO类已经不能满足结果集的映射。所以要根据需求建立一个扩展类来作为resultType的类型。 创建订单类 public class Orders { private int id; private int user_id; private String number; private Date createtime; private String note; &#x2F;&#x2F; 省略get&#x2F;set，toString } 创建订单类的扩展类 &#x2F;&#x2F; Orders扩展类 public class OrdersExt extends Orders { private String username; private String address; @Override public String toString() { return &quot;OrdersExt{&quot; + &quot;username=&#39;&quot; + username + &#39;\\&#39;&#39; + &quot;, address=&#39;&quot; + address + &#39;\\&#39;&#39; + &#39;}&#39; + super.toString(); } &#x2F;&#x2F; 省略get&#x2F;set } 声明订单接口 public interface OrderMapper { public OrdersExt findOrderById(int id); } 声明订单映射文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt; &lt;!--OrderMapper接口映射文件--&gt; &lt;mapper namespace=&quot;com.zero.mapper.OrderMapper&quot;&gt; &lt;select id=&quot;findOrderById&quot; parameterType=&quot;int&quot; resultType=&quot;ordersExt&quot;&gt; select u.username,u.address,o.* from orders o,user u where u.`id`=o.`user_id` and o.id = #{id} &lt;&#x2F;select&gt; &lt;&#x2F;mapper&gt; 加载映射文件 &lt;mappers&gt; &lt;package name=&quot;com.zero.mapper&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt; 测试 public class OrderMapperTest { private SqlSession session = null; @Before public void before() throws IOException { System.out.println(&quot;before:获取session&quot;); &#x2F;&#x2F;1. 读取配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;); &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); session = sessionFactory.openSession(); } @After public void after(){ System.out.println(&quot;after:关闭会话&quot;); &#x2F;&#x2F;5. 关闭会话。 session.commit(); session.close(); } &#x2F;&#x2F; 测试复杂查询一对一 @Test public void test1(){ OrderMapper mapper = session.getMapper(OrderMapper.class); OrdersExt order = mapper.findOrderById(3); System.out.println(order); } } 1.3 一对一：resultMap实现 Orders类中新增user属性，添加get/set方法，以存储订单所属用户 public class Orders { private Integer id; private Integer user_id; private String number; private Date createtime; private String note; private User user; &#x2F;&#x2F; 订单所属用户 public User getUser() { return user; } public void setUser(User user) { this.user = user; } &#x2F;&#x2F; 注意toString方法要添加user信息 } mapper接口新增方法 public Orders findOrderById2(int id); 映射文件中添加查询，使用resultMap &lt;!--如果模型里面有模型，使用resultMap--&gt; &lt;resultMap id=&quot;orderRslMap&quot; type=&quot;orders&quot;&gt; &lt;!--往orders的模型匹配数据--&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&#x2F;&gt; &lt;id property=&quot;number&quot; column=&quot;number&quot;&#x2F;&gt; &lt;id property=&quot;createtime&quot; column=&quot;createtime&quot;&#x2F;&gt; &lt;id property=&quot;note&quot; column=&quot;note&quot;&#x2F;&gt; &lt;!--往orders中的user匹配数据 使用association进行配置--&gt; &lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;&#x2F;&gt; &lt;id property=&quot;username&quot; column=&quot;username&quot;&#x2F;&gt; &lt;id property=&quot;address&quot; column=&quot;address&quot;&#x2F;&gt; &lt;&#x2F;association&gt; &lt;&#x2F;resultMap&gt; &lt;select id=&quot;findOrderById2&quot; parameterType=&quot;int&quot; resultMap=&quot;orderRslMap&quot;&gt; select u.username,u.address,o.* from orders o,user u where u.`id`=o.`user_id` and o.id = #{id} &lt;&#x2F;select&gt; 测试 &#x2F;&#x2F; 测试resultMap一对一 @Test public void test2(){ OrderMapper mapper = session.getMapper(OrderMapper.class); Orders order = mapper.findOrderById2(3); System.out.println(order); } 小结： resultType：使用resultType实现较为简单，如果POJO中没有包括查询出来的列名， 则必须增加列名对应的属性，才可完成映射。如果没有查询结果的特殊要求建议使用resultType。 resultMap：需单独定义resultMap，实现较麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射到POJO的对象属性中。 resultMap可以实现延迟加载，resultType无法实现延迟加载。 1.4 一对多 需求：根据订单ID查找订单信息、用户信息和订单明细信息。 -- 根据订单ID查找订单信息、用户信息和订单明细信息。 select u.`username`, u.`address`, o.*, od.id detail_id, od.items_id, od.items_num from user u, orders o, orderdetail od where u.`id`=o.`user_id` and o.`id`=od.orders_id and o.`id` = 3; 新建OrderDetail类 &#x2F;&#x2F; 订单详情实体类 public class OrderDetail { private Integer id; &#x2F;&#x2F; 订单详情id private Integer items_id; &#x2F;&#x2F; 商品id private Integer items_num; &#x2F;&#x2F; 商品数量 &#x2F;&#x2F; 省略get&#x2F;set，toString } 修改Orders类，添加订单明细属性 public class Orders { private Integer id; private Integer user_id; private String number; private Date createtime; private String note; private User user; &#x2F;&#x2F; 订单所属用户 &#x2F;&#x2F; 一对多数据封装：订单明细 private List&lt;OrderDetail&gt; orderDetails; } mapper接口 public interface OrderMapper { public OrdersExt findOrderById(int id); public Orders findOrderById2(int id); &#x2F;&#x2F; 一对多关系映射配置 public Orders findOrderById3(int id); } 映射文件添加查询,resultMap中有个extends属性，可继承父类配置的数据映射关系。 &lt;!-- =========== 一对多 ============= --&gt; &lt;resultMap id=&quot;orderRslMap2&quot; type=&quot;orders&quot; extends=&quot;orderRslMap&quot;&gt; &lt;!--如果继承了orderRslMap 下面的orders和user模型无需再次编写。--&gt; &lt;!--往orders的模型匹配数据--&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&#x2F;&gt; &lt;id property=&quot;number&quot; column=&quot;number&quot;&#x2F;&gt; &lt;id property=&quot;createtime&quot; column=&quot;createtime&quot;&#x2F;&gt; &lt;id property=&quot;note&quot; column=&quot;note&quot;&#x2F;&gt; &lt;!--往orders中的user匹配数据 使用association进行配置--&gt; &lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;&#x2F;&gt; &lt;id property=&quot;username&quot; column=&quot;username&quot;&#x2F;&gt; &lt;id property=&quot;address&quot; column=&quot;address&quot;&#x2F;&gt; &lt;&#x2F;association&gt; &lt;!-- 一对多匹配：往orders中的orderDetails匹配数据 注意：集合里类型需使用ofType，而不是javaType--&gt; &lt;collection property=&quot;orderDetails&quot; ofType=&quot;orderDetail&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;detail_id&quot;&#x2F;&gt; &lt;id property=&quot;items_id&quot; column=&quot;items_id&quot;&#x2F;&gt; &lt;id property=&quot;items_num&quot; column=&quot;items_num&quot;&#x2F;&gt; &lt;&#x2F;collection&gt; &lt;&#x2F;resultMap&gt; &lt;select id=&quot;findOrderById3&quot; parameterType=&quot;int&quot; resultMap=&quot;orderRslMap2&quot;&gt; select u.`username`, u.`address`, o.*, od.id detail_id, od.items_id, od.items_num from user u, orders o, orderdetail od where u.`id`=o.`user_id` and o.`id`=od.orders_id and o.`id` = #{id}; &lt;&#x2F;select&gt; 测试 &#x2F;&#x2F; 测试resultMap一对一 @Test public void test3(){ OrderMapper mapper = session.getMapper(OrderMapper.class); Orders order = mapper.findOrderById3(3); System.out.println(order); } 1.4.1 小结Mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。 1.5 多对多 需求：查询用户信息及用户购买的商品信息，要求将关系信息映射到主POJO的POJO属性中。 SELECT u.`id`, u.`username`, u.`address`, o.`id` order_id, o.`number`, o.`createtime`, o.`note`, od.`id` detail_id, od.`items_id`, od.`items_num`, it.`name`, it.`price`, it.`detail` FROM user u, orders o, orderdetail od, items it WHERE u.`id` = o.`user_id` and o.`id` = od.`orders_id` and od.`items_id` = it.`id`; 映射思路 将用户信息映射到user中。 在user类中添加订单列表属性List&lt;Orders&gt; orderslist，将用户创建的订单映射到orderslist中。 在Orders中添加订单明细列表属性List&lt;Orderdetail&gt; detailList，将订单的明细映射到detailList中。 在Orderdetail中添加Items属性，将订单明细所对应的商品映射到Items中。 mapper中添加方法 public interface UserMapper { &#x2F;&#x2F; 多对多查询:查询用户信息及用户购买的商品信息 public List&lt;User&gt; findUserAndOrderInfo(); } 在user类中添加订单列表属性List&lt;Orders&gt; orderslist，将用户创建的订单映射到orderslist中。 public class User implements Serializable { private int id; private String username; private String sex; private Date birthday; private String address; private List&lt;Orders&gt; orderList; &#x2F;&#x2F; 一个用户有多张订单 } 在Orders中添加订单明细列表属性List&lt;Orderdetail&gt; detailList，将订单的明细映射到detailList中。 public class Orders { private Integer id; private Integer user_id; private String number; private Date createtime; private String note; private User user; &#x2F;&#x2F; 订单所属用户 &#x2F;&#x2F; 一对多数据封装：订单明细 private List&lt;OrderDetail&gt; orderDetails; } 新建items类 public class Items { private Integer id; private String name; private Float price; private String detail; } 在Orderdetail中添加Items属性，将订单明细所对应的商品映射到Items中。 public class OrderDetail { private Integer id; &#x2F;&#x2F; 订单详情id private Integer items_id; &#x2F;&#x2F; 商品id private Integer items_num; &#x2F;&#x2F; 商品数量 private Items items; &#x2F;&#x2F; 订单详情 } 映射文件中配置映射关系，查询方法 &lt;!-- 多对多查询:查询用户信息及用户购买的商品信息 --&gt; &lt;resultMap id=&quot;userRslMap&quot; type=&quot;user&quot;&gt; &lt;!--1. 配置user属性--&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&#x2F;&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;&#x2F;&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;&#x2F;&gt; &lt;!--2. 配置user的orderList--&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;orders&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;order_id&quot;&#x2F;&gt; &lt;result property=&quot;number&quot; column=&quot;number&quot;&#x2F;&gt; &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;&#x2F;&gt; &lt;result property=&quot;note&quot; column=&quot;note&quot;&#x2F;&gt; &lt;!--3. 配置orders的orderDetail--&gt; &lt;collection property=&quot;orderDetails&quot; ofType=&quot;orderDetail&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;detail_id&quot;&#x2F;&gt; &lt;result property=&quot;items_id&quot; column=&quot;items_id&quot;&#x2F;&gt; &lt;result property=&quot;items_num&quot; column=&quot;items_num&quot;&#x2F;&gt; &lt;!--4. 匹配订单详情的商品信息：在Orderdetail中添加Items属性，将订单明细所对应的商品映射到Items中。--&gt; &lt;association property=&quot;items&quot; javaType=&quot;items&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;items_id&quot;&#x2F;&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;&#x2F;&gt; &lt;result property=&quot;price&quot; column=&quot;price&quot;&#x2F;&gt; &lt;result property=&quot;detail&quot; column=&quot;detail&quot;&#x2F;&gt; &lt;&#x2F;association&gt; &lt;&#x2F;collection&gt; &lt;&#x2F;collection&gt; &lt;&#x2F;resultMap&gt; &lt;select id=&quot;findUserAndOrderInfo&quot; resultMap=&quot;userRslMap&quot;&gt; SELECT u.`id`, u.`username`, u.`address`, o.`id` order_id, o.`number`, o.`createtime`, o.`note`, od.`id` detail_id, od.`items_id`, od.`items_num`, it.`name`, it.`price`, it.`detail` FROM user u, orders o, orderdetail od, items it WHERE u.`id` = o.`user_id` and o.`id` = od.`orders_id` and od.`items_id` = it.`id` &lt;&#x2F;select&gt; 测试 &#x2F;** * 多对多查询信息：查询用户信息及用户购买的商品信息 *&#x2F; @Test public void test2() { UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; infos = mapper.findUserAndOrderInfo(); for (User user:infos){ System.out.println(&quot;用户信息：&quot;+user); for (Orders order:user.getOrderList()){ System.out.println(&quot;订单信息：&quot;+order); for (OrderDetail od:order.getOrderDetails()){ System.out.println(&quot;订单详情：&quot; + od); } System.out.println(&quot;&lt;---------------------------------&gt;&quot;); } } } 输出结果 用户信息：User{id=1, username=&#39;赵六&#39;, sex=&#39;null&#39;, birthday=null, address=&#39;杭州市&#39;} 订单信息：Orders{id=3, user_id=null, number=&#39;1000010&#39;, createtime=Wed Feb 04 13:22:35 CST 2015, note=&#39;null&#39;, user=null, orderDetails=[OrderDetail{id=1, items_id=1, items_num=1, items=Items{id=1, name=&#39;台式机&#39;, price=3000.0, detail=&#39;该电脑质量非常好！！！！&#39;}}, OrderDetail{id=2, items_id=2, items_num=3, items=Items{id=2, name=&#39;笔记本&#39;, price=6000.0, detail=&#39;笔记本性能好，质量好！！！！！&#39;}}]} 订单详情：OrderDetail{id=1, items_id=1, items_num=1, items=Items{id=1, name=&#39;台式机&#39;, price=3000.0, detail=&#39;该电脑质量非常好！！！！&#39;}} 订单详情：OrderDetail{id=2, items_id=2, items_num=3, items=Items{id=2, name=&#39;笔记本&#39;, price=6000.0, detail=&#39;笔记本性能好，质量好！！！！！&#39;}} &lt;---------------------------------&gt; 订单信息：Orders{id=4, user_id=null, number=&#39;1000011&#39;, createtime=Tue Feb 03 13:22:41 CST 2015, note=&#39;null&#39;, user=null, orderDetails=[OrderDetail{id=3, items_id=3, items_num=4, items=Items{id=3, name=&#39;背包&#39;, price=200.0, detail=&#39;名牌背包，容量大质量好！！！！&#39;}}, OrderDetail{id=4, items_id=2, items_num=3, items=Items{id=2, name=&#39;笔记本&#39;, price=6000.0, detail=&#39;笔记本性能好，质量好！！！！！&#39;}}]} 订单详情：OrderDetail{id=3, items_id=3, items_num=4, items=Items{id=3, name=&#39;背包&#39;, price=200.0, detail=&#39;名牌背包，容量大质量好！！！！&#39;}} 订单详情：OrderDetail{id=4, items_id=2, items_num=3, items=Items{id=2, name=&#39;笔记本&#39;, price=6000.0, detail=&#39;笔记本性能好，质量好！！！！！&#39;}} &lt;---------------------------------&gt; 1.5.1 小结 resultType：将查询结果安装sql列名和POJO属性名一致性映射到POJO中。 resultMap：使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求） association：将关联查询信息映射到一个POJO对象中。 collection：将关联查询信息映射到一个list集合中。 模型里面有模型，用association 模型里面有集合，用collection 2. 延时加载延迟加载又叫懒加载，也叫按需加载。即先加载主信息，在需要的时候，再去加载从信息。 在Mybatis中，resultMap标签的association标签和collection标签具有延迟加载的功能。 分别在两个接口中添加方法 public interface UserMapper { public User findUserById(int id); } public interface OrderMapper { &#x2F;&#x2F; 懒加载订单的用户数据 public List&lt;Orders&gt; findOrderAndUserByLazyloading(); } 映射文件 &lt;!--UserMapper映射文件--&gt; &lt;mapper namespace=&quot;com.zero.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; SELECT * FROM USER WHERE id = #{id} &lt;&#x2F;select&gt; &lt;&#x2F;mapper&gt; &lt;!--OrderMapper接口映射文件--&gt; &lt;mapper namespace=&quot;com.zero.mapper.OrderMapper&quot;&gt; &lt;!-- =========== 懒加载 ============= --&gt; &lt;resultMap id=&quot;orderLazyloadingRslMap&quot; type=&quot;orders&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&#x2F;&gt; &lt;result property=&quot;note&quot; column=&quot;note&quot;&#x2F;&gt; &lt;result property=&quot;number&quot; column=&quot;number&quot;&#x2F;&gt; &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;&#x2F;&gt; &lt;!-- 配置懒加载查询语句，column是子查询所需参数--&gt; &lt;association property=&quot;user&quot; select=&quot;com.zero.mapper.UserMapper.findUserById&quot; column=&quot;user_id&quot;&#x2F;&gt; &lt;&#x2F;resultMap&gt; &lt;select id=&quot;findOrderAndUserByLazyloading&quot; resultMap=&quot;orderLazyloadingRslMap&quot;&gt; select * from orders &lt;&#x2F;select&gt; &lt;&#x2F;mapper&gt; 测试 &#x2F;&#x2F; 懒加载 @Test public void test４(){ OrderMapper mapper = session.getMapper(OrderMapper.class); List&lt;Orders&gt; orders = mapper.findOrderAndUserByLazyloading(); for (Orders order:orders){ System.out.println(&quot;订单信息：&quot;+order); System.out.println(&quot;订单用户：&quot;+order.getUser()); } } 全局配置文件中配置懒加载 &lt;configuration&gt; &lt;!--懒加载配置--&gt; &lt;settings&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;&#x2F;&gt; &lt;&#x2F;settings&gt; &lt;&#x2F;configuration&gt; 3. 查询缓存Mybatis提供查询缓存，用于减轻数据压力，提高数据库抗压力。 Mybatis的缓存，包括一级缓存和二级缓存，一级缓存是默认使用的。二级缓存需手动开启。 在操作数据库时需构造SqlSession对象，在对象中有一个数据结构(HashMap)用于缓存数据。不同的SqlSession之间的缓存数据区域是互不影响的。 Mybatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。 Mybatis二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存，需要在setting全局参数中配置开启二级缓存。 3. 1 一级缓存原理 第一次发起查询，会先去找缓存中是否有id为1的用户信息，如果没有，从数据库中查询用户信息。获取信息后再将用户信息存储到一级缓存中。 第二次发起查询用户id为1的用户信息时，先去缓存中找，如缓存中有，直接从缓存中获取用户信息。 如果SqlSession执行了commit操作(执行插入、更新、删除)，会清空SqlSession中的一级缓存，以确保缓存中存储的是最新数据，避免脏读。 Mybatis内部存储缓存使用一个HashMap。key为HashCode+sqlId+Sql语句，value是查询出来映射生成的java对象。 测试 @Test public void test1() throws IOException { &#x2F;&#x2F;1. 读取配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;); &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); &#x2F;&#x2F; 3. 会话 SqlSession session = sessionFactory.openSession(); &#x2F;&#x2F; 4. 通过会话获取dao接口 UserMapper mapper = session.getMapper(UserMapper.class); &#x2F;** * 默认情况下，一级缓存也就是session级别缓存是开启的 * 保存、删除、更新操作，一级缓存数据会自动清空 *&#x2F; User user1 = mapper.findUserById(1); System.out.println(&quot;user1&quot;+user1); &#x2F;&#x2F; 保存用户,测试缓存是否清空 mapper.save(new User(&quot;小花&quot;,&quot;1&quot;,null,&quot;杭州&quot;)); session.commit(); User user2 = mapper.findUserById(1); System.out.println(&quot;user2&quot;+user1); } 3.2 二级缓存原理 SqlSession1去查询用户id为1的用户信息，查询到用户信息后会将查询数据存储到二级缓存中。 SqlSession2去查询用户id为1的用户信息时，会先去缓存中找是否有数据，有则直接从缓存中取。 二级缓存区域是根据mapper的namespace划分的，同一个namespace的mapper查询数据放在同一个区域，如果使用mapper代理方法每个mapper的namespace都不同，此时可以理解为二级缓存区域是根据mapper划分。 每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。 sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。 开启二级缓存需在配置文件中手动配置。 3.2.1 代码示例 开启二级缓存总开关 &lt;settings&gt; &lt;!--懒加载配置--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;&#x2F;&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;&#x2F;&gt; &lt;&#x2F;settings&gt; 在UserMapper中配置二级缓存 &lt;mapper namespace=&quot;com.zero.mapper.UserMapper&quot;&gt; &lt;!-- 配置缓存：该类下所有查询方法都使用二级缓存 type不写，默认使用的是mybatis自带的缓存技术：perpetualCache --&gt; &lt;cache&gt;&lt;&#x2F;cache&gt; &lt;&#x2F;mapper&gt; User类序列化 public class User implements Serializable {} 测试 &#x2F;&#x2F; 二级缓存 @Test public void test2() throws IOException { &#x2F;&#x2F;1. 读取配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;); &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); &#x2F;&#x2F; 3. 会话 SqlSession session1 = sessionFactory.openSession(); SqlSession session2 = sessionFactory.openSession(); SqlSession session3 = sessionFactory.openSession(); &#x2F;&#x2F; 4. 通过会话获取dao接口 UserMapper mapper1 = session1.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); UserMapper mapper3 = session3.getMapper(UserMapper.class); User user1 = mapper1.findUserById(1); System.out.println(&quot;user1&quot;+user1); &#x2F;&#x2F; session关闭后才会写入二级缓存 session1.close(); &#x2F;&#x2F; 执行修改更新删除等操作，提交后，会清空二级缓存 mapper3.save(user1); session3.commit(); User user2 = mapper2.findUserById(1); System.out.println(&quot;user2&quot;+user2); session3.close(); } 关于禁用指定方法二级缓存 &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot; useCache=&quot;false&quot;&gt; SELECT * FROM USER WHERE id = #{id} &lt;&#x2F;select&gt; 关于刷新缓存 &lt;!-- 默认情况下，插入、更新、删除会清空二级缓存 默认flushCache=&quot;true&quot; 如果设置为false，插入、更新、删除就不会清空二级缓存 --&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;user&quot; flushCache=&quot;false&quot;&gt; INSERT into user (username,sex,birthday,address) values (#{username},#{sex},#{birthday},#{address}) &lt;&#x2F;insert&gt; 3.3 整合EhcacheEhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是一个分布式的缓存框架。 Mybatis本身是一个持久层框架，它不是专门的缓存框架，所以它对缓存的实现不够好，不能支持分布式。 分布式：系统为了提高性能，通常会对系统采用分布式部署(集群部署方式) 整合思路 Cache是一个借口，它的默认实现是mybatis的PerpetualCache。如果想整合mybatis的二级缓存，那么实现Cache接口即可。 实现步骤： 先添加jar包 设置映射文件中的cache标签的type值为ehcache的实现类 &lt;mapper namespace=&quot;com.zero.mapper.UserMapper&quot;&gt; &lt;!-- 配置缓存：该类下所有查询方法都使用二级缓存 type不写，默认使用的是mybatis自带的缓存技术：perpetualCache --&gt; &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;&#x2F;cache&gt; &lt;&#x2F;mapper&gt; 在src下添加ehcache的配置文件 &lt;ehcache xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;..&#x2F;config&#x2F;ehcache.xsd&quot;&gt; &lt;diskStore path=&quot;java.io.tmpdir&quot;&#x2F;&gt; &lt;!--  maxElementsInMemory :设置基于内存的缓存中可存放的对象最大数目  eternal:设置对象是否为永久的,true表示永不过期,此时将忽略  timeToIdleSeconds 和 timeToLiveSeconds属性; 默认值是false  timeToIdleSeconds:设置对象空闲最长时间,以秒为单位, 超过这个时间,对象过期。 当对象过期时,EHCache会把它从缓存中清除。如果此值为0,表示对象可以无限期地处于空闲状态。  timeToLiveSeconds:设置对象生存最长时间,超过这个时间,对象过期。 如果此值为0,表示对象可以无限期地存在于缓存中. 该属性值必须大于或等于 timeToIdleSeconds 属性值  overflowToDisk:设置基于内在的缓存中的对象数目达到上限后,是否把溢出的对象写到基于硬盘的缓存中  diskPersistent 当jvm结束时是否持久化对象 true false 默认是false  diskExpiryThreadIntervalSeconds 指定专门用于清除过期对象的监听线程的轮询时间 memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; maxElementsOnDisk=&quot;10000000&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;persistence strategy=&quot;localTempSwap&quot;&#x2F;&gt; &lt;&#x2F;defaultCache&gt; &lt;&#x2F;ehcache&gt; 测试：用上一个二级缓存案例即可 二级缓存应用场景 对于访问响应速度要求高，但是实时性不高的查询，可以采用二级缓存技术。 4. MyBatis整合Spring4.1 创建工程导包 导入Mybatis包及依赖包 导入mysql数据库驱动：mysql-connector-java-5.1.7-bin.jar DBCP连接池相关包：commons-dbcp-1.4.jar和commons-pool-1.6.jar spring+mvc相关包： Mybatis-spring整合包：mybatis-spring-1.2.2.jar 4.2 配置mybatis的核心配置文件 创建核心配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--加载配置文件--&gt; &lt;!-- &lt;properties resource=&quot;db.properties&quot;&#x2F;&gt;--&gt; &lt;!--别名配置--&gt; &lt;typeAliases&gt; &lt;!-- 批量配置别名--&gt; &lt;!-- [name]：指定批量定义别名的类包，别名为类名，第一个字母小写--&gt; &lt;package name=&quot;com.zero.sm.model&quot;&#x2F;&gt; &lt;&#x2F;typeAliases&gt; &lt;!--加载映射文件--&gt; &lt;mappers&gt; &lt;package name=&quot;com&#x2F;zero&#x2F;sm&#x2F;sqlmap&#x2F;User.xml&quot;&#x2F;&gt; &lt;!-- 加载mapper包下所有映射文件--&gt; &lt;package name=&quot;com.zero.sm.mapper&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt; &lt;&#x2F;configuration&gt; 创建User模型 public class User implements Serializable { private int id; private String username; private String sex; private Date birthday; private String address; &#x2F;&#x2F; 省略get、set、toString } User映射文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;user&quot;&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot; &gt; SELECT * FROM USER WHERE id = #{id} &lt;&#x2F;select&gt; &lt;&#x2F;mapper&gt; 4.3 配置spring数据源 &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:mvc=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.2.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc-3.2.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-3.2.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-3.2.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx-3.2.xsd &quot;&gt; &lt;!-- 1.配置数据库，dbcp数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;mybatis01?useUnicode=true&amp;amp;characterEncoding=utf8&quot;&#x2F;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt; &lt;!-- 最大连接 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;&#x2F;&gt; &lt;!--最大空闲数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;beans&gt; 4.4 spring配置SqlSessionFactory &lt;!--2. 配置会话工厂--&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--引用数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;!--设置全局配置文件路径--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapconfig.xml&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 4.5 编写UserDaoImpl，省略接口 public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao { @Override public User findUserById(int id) { return getSqlSession().selectOne(&quot;user.findUserById&quot;,id); &#x2F;&#x2F; 调用父类方法获取会话对象，然后执行方法 } } 4.6 spring中配置daobean &lt;!--3. 配置dao--&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.zero.sm.dao.Impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sessionFactory&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 4.7 测试 public class Demo01 { @Test public void test1(){ &#x2F;&#x2F; 1. 加载spring的配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;); &#x2F;&#x2F; 2. 获取dao的bean UserDao userDao = (UserDao) context.getBean(&quot;userDao&quot;); &#x2F;&#x2F; 3. 调用dao方法 User user = userDao.findUserById(1); System.out.println(user); } } 4.8 换成Mapper接口整合dao 创建Mapper映射文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.zero.sm.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot; &gt; SELECT * FROM USER WHERE id = #{id} &lt;&#x2F;select&gt; &lt;&#x2F;mapper&gt; 加载映射文件 &lt;mappers&gt; &lt;mapper resource=&quot;com&#x2F;zero&#x2F;sm&#x2F;sqlmap&#x2F;User.xml&quot;&#x2F;&gt; &lt;!-- 加载mapper包下所有映射文件--&gt; &lt;package name=&quot;com.zero.sm.mapper&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt; spring配置MapperFactoryBean &lt;!-- 第二种方法--&gt; &lt;!--4. 使用工厂Bean生成userMapper对象--&gt; &lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sessionFactory&quot;&#x2F;&gt; &lt;property name=&quot;mapperInterface&quot; value=&quot;com.zero.sm.mapper.UserMapper&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 测试 @Test public void test2() { &#x2F;&#x2F; 1. 加载spring的配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;); &#x2F;&#x2F; 2. 获取dao的bean UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;); User us = userMapper.findUserById(1); System.out.println(us); } 4.9 使用MapperScannerConfigurer批量扫描创建代理对象mapper代理开发方式批量mapper配置 ,内部会扫描指定包下的mapper，创建代理对象，bean的名字默认为mapper接口类名的首字母小写。 &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.zero.sm.mapper&quot;&#x2F;&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sessionFactory&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 测试方法同上案例。 Notice：JDK1.8以上使用该方式，无法创建bean，改成JDK1.7即可；或spring版本3.2.9以上。 5. 逆向工程5.1 简介简单的说，就是通过数据库中的表单，自动生成java代码。 Mybatis官方提供了逆向工程，可以针对单表自动生成Mybatis代码(mapper.java\\mapper.xml\\po类) 下载地址 5.2 使用方法 创建简单的java项目； 导入jar包，创建generator配置文件； 使用java类来执行逆向工程； 把生成的代码拷贝到项目中； 在正式项目中使用逆向工程生成的代码。 5.3 案例示范5.3.1 第一步：创建generator配置文件在src下，创建generator配置文件，文件内容可以从官方docs目录下的index.html中找到相关代码 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;context id=&quot;mysqlTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!--数据库配置--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;mybatis01&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;&#x2F;jdbcConnection&gt; &lt;!--java类型解析--&gt; &lt;javaTypeResolver &gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaTypeResolver&gt; &lt;!--模型生成包名--&gt; &lt;javaModelGenerator targetPackage=&quot;com.zero.sm.model&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; &#x2F;&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; &#x2F;&gt; &lt;&#x2F;javaModelGenerator&gt; &lt;!--mybatis的映射 .xml--&gt; &lt;sqlMapGenerator targetPackage=&quot;com.zero.sm.mapper&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; &#x2F;&gt; &lt;&#x2F;sqlMapGenerator&gt; &lt;!--mybatis的mapper接口生成包路径--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.zero.sm.mapper&quot; targetProject=&quot;.\\src&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; &#x2F;&gt; &lt;&#x2F;javaClientGenerator&gt; &lt;!-- 配置生成表的模型 domainObjectName: 默认会根据表名生成，首字母自动大写 --&gt; &lt;table tableName=&quot;items&quot;&#x2F;&gt; &lt;table tableName=&quot;orderdetail&quot; domainObjectName=&quot;OrderDetail&quot;&#x2F;&gt; &lt;table tableName=&quot;orders&quot;&#x2F;&gt; &lt;table tableName=&quot;user&quot;&#x2F;&gt; &lt;&#x2F;context&gt; &lt;&#x2F;generatorConfiguration&gt; 5.3.2 第二步：使用java类来执行逆向工程需导入mysql驱动包和mybatis的逆向工程包 public class Main { public static void main(String[] args) throws Exception{ List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;src&#x2F;generator.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } } 5.3.3 第三步：把生成的代码拷贝到项目中 5.3.4 第四步：测试 &#x2F;&#x2F; 测试基本查询 @Test public void test2() { &#x2F;&#x2F; 1. 加载spring的配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;); &#x2F;&#x2F; 2. 获取dao的bean UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;); &#x2F;&#x2F; 3. 通过主键查询对象 User user = userMapper.selectByPrimaryKey(1); System.out.println(user); } &#x2F;&#x2F; 测试Example @Test public void test3() { &#x2F;&#x2F; 自动生成的Example是用于查询的 &#x2F;&#x2F; 1. 加载spring的配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;springConfig.xml&quot;); &#x2F;&#x2F; 2. 获取dao的bean UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;); UserExample example = new UserExample(); &#x2F;&#x2F; 封装查询条件 UserExample.Criteria criteria = example.createCriteria(); criteria.andSexEqualTo(&quot;1&quot;); &#x2F;&#x2F; 查询男性用户 &#x2F;&#x2F; 通过封装后的查询条件查询 List&lt;User&gt; users = userMapper.selectByExample(example); System.out.println(users); }","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zero024.cn/tags/MyBatis/"}]},{"title":"MyBatis基础入门","slug":"FrameWork/MyBatis入门","date":"2019-08-21T14:50:00.000Z","updated":"2020-03-25T01:17:48.160Z","comments":true,"path":"FrameWork/MyBatis-Basic.html","link":"","permalink":"https://zero024.cn/FrameWork/MyBatis-Basic.html","excerpt":"1. MyBatis简介MyBatis本是apache的一个开源项目iBatis，2010年这个项目由 apache software foundation迁移到了google code，并改名为MyBatis，实质上MyBatis是对iBatis进行进行了一些改进。","text":"1. MyBatis简介MyBatis本是apache的一个开源项目iBatis，2010年这个项目由 apache software foundation迁移到了google code，并改名为MyBatis，实质上MyBatis是对iBatis进行进行了一些改进。 Mybatis是一个优秀的持久层框架，它对jdbc的操作数据库过程进行封装，使开发者只需要关注SQL本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 对jdbc封装的框架有：Hibernate、DBUtils、jdbcTemplate、Mybatis Mybatis原理： 通过XML或注解的方式将要执行的各种statement(preparedStatement)配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象返回。 MyBatis框架核心 mybatis配置文件：包括全局配置文件和映射文件。其中全局配置文件配置了数据源、事务等信息；映射文件配置了SQL执行相关的信息。 mybatis通过读取配置文件信息(全局配置文件和映射文件)，构造出SQLSessionFactory，即会话工厂。 通过SQLSessionFactory，可以创建SQLSession(会话)。Mybatis是通过SQLSession来操作数据库的。 SQLSession本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个普通执行器，一个是缓存执行器(默认)。 Executor执行器要处理的SQL信息是封装到一个底层对象MappedStatement中。该对象包括：SQL语句、输入参数映射信息、输出信息集映射信息。其中输入参数和输出结果的映射类型包括HashMap集合对象、POJO对象类型。 POJO：Plain Ordinary Java Object，简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称 2. MyBatis入门2.1 环境准备 下载Mybatis 下载地址 创建项目导包 添加日志配置 项目src下创建log4j.properties文件，内容如下： # Global logging configuration log4j.rootLogger=DEBUG, stdout # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 2.2 开发步骤 根据需求创建PO类 创建全局配置文件：SqlMapConfig.xml 编写映射文件 在SqlMapConfig.xml中加载映射文件 编写测试代码，连接并操作数据库 读取配置文件 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。 通过SqlSessionFactory创建SqlSession。 调用SqlSession的操作数据库方法。 关闭会话。 2.2.1 创建PO类 public class User implements Serializable { private int id; private String username; private String sex; private Date birthday; private String address; &#x2F;&#x2F; 省略get&#x2F;set &#x2F;&#x2F; 省略toString } 2.2.2 创建全局配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 配置mybatis的环境信息 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt; &lt;!-- 配置数据源，采用dbcp连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;mybatis01?useUnicode=true&amp;amp;characterEncoding=utf8&quot;&#x2F;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;&#x2F;configuration&gt; 2.2.3 编写映射文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt; &lt;!-- namespace：命名空间，它的作用就是对SQL进行分类化管理，可以理解为SQL隔离 注意：使用mapper代理开发时，namespace有特殊且重要的作用 --&gt; &lt;mapper namespace=&quot;test&quot;&gt; &lt;!-- [id]：statement的id，要求在命名空间内唯一 [parameterType]：参数输入类型 [resultType]：查询出的单条结果集对应的java类型，返回值类型 [#{}]： 表示一个占位符? [#{id}]：表示该占位符待接收参数的名称为id。 注意：如果参数为简单类型时，#{}里面的参数名称可以是任意定义 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.zero.model.User&quot;&gt; SELECT * FROM USER WHERE id = #{id1} &lt;&#x2F;select&gt; &lt;&#x2F;mapper&gt; 2.2.4 加载映射文件 &lt;!--加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com&#x2F;zero&#x2F;sqlmap&#x2F;User.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt; 2.2.5 编写测试 public class UserTest { @Test public void test1() throws IOException { &#x2F;&#x2F;1. 读取配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;); &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); &#x2F;&#x2F;3. 通过SqlSessionFactory创建SqlSession。 SqlSession session = sessionFactory.openSession(); &#x2F;&#x2F;4. 调用SqlSession的操作数据库方法。 User user = session.selectOne(&quot;findUserById&quot;,10); System.out.println(user); &#x2F;&#x2F;5. 关闭会话。 session.commit(); } } junit4.12可能会报java.lang.NoClassDefFoundError: org/hamcrest/SelfDescribing，版本切换为5.4后不会报错。 2.2.6 查询案例1. 模糊查询 模糊查询，修改映射文件，添加如下内容： &lt;!-- 模糊查询用户信息： [${}]：表示拼接SQL字符串 [${value}]：表示要拼接的是简单类型参数。 注意： 1、如果参数为简单类型时，${}里面的参数名称必须为value 2、${}会引起SQL注入，一般情况下不推荐使用。但是有些场景必须使用${}，比如order by ${colname} --&gt; &lt;select id=&quot;findUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;com.zero.model.User&quot;&gt; SELECT * FROM USER WHERE username like &#39;%${value}%&#39; &lt;&#x2F;select&gt; 测试文件添加查询语句 &#x2F;&#x2F; 通过姓名模糊查询用户集合 List&lt;User&gt; users = session.selectList(&quot;findUserByName&quot;, &quot;张&quot;); System.out.println(users); 2. 添加用户 修改映射文件，添加内容 &lt;!--插入用户信息--&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.zero.model.User&quot;&gt; &lt;!--如果主键的值是通过MySQL自增机制生成的，那么我们此处无需再‘显式’的给ID赋值--&gt; INSERT into user (username,sex,birthday,address) values (#{username},#{sex},#{birthday},#{address}) &lt;&#x2F;insert&gt; 测试代码，注意：需在PO类User中添加一个没有id属性的全参构造方法 &#x2F;&#x2F; 插入用户 session.insert(&quot;insertUser&quot;,new User(&quot;zero&quot;,&quot;男&quot;,new Date(),&quot;杭州&quot;)); 3. 删除用户 修改映射文件 &lt;!--通过id删除用户--&gt; &lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #{id} &lt;&#x2F;delete&gt; &lt;!--通过姓名删除用户--&gt; &lt;delete id=&quot;deleteUserByName&quot; parameterType=&quot;String&quot;&gt; delete from user where username = #{name} &lt;&#x2F;delete&gt; 测试代码 &#x2F;&#x2F; 通过id删除用户 session.delete(&quot;deleteUserById&quot;,28); &#x2F;&#x2F; 通过姓名删除用户，test是映射文件的命名空间 session.delete(&quot;test.deleteUserByName&quot;,&quot;张小明&quot;); 4. 更新用户 映射文件 &lt;!--通过id更新用户--&gt; &lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.zero.model.User&quot;&gt; update user set username=#{username},sex=#{sex} where id=#{id} &lt;&#x2F;update&gt; 测试代码 &#x2F;&#x2F; 通过id更新用户 User upUser = new User(); upUser.setId(1); &#x2F;&#x2F; 输入要修改的用户id upUser.setUsername(&quot;赵六儿&quot;);&#x2F;&#x2F; 需修改的用户姓名 upUser.setSex(&quot;女&quot;); session.update(&quot;updateUserById&quot;,upUser); 2.2.7 返回MySQL自增主键 MySQL自增主键，是指在insert之前MySQL会自动生成一个自增的主键 可以通过MySQL的函数获取刚插入的自增主键：select LAST_INSERT_ID()，该函数在insert语句之后调用。 修改映射文件添加用户内容 &lt;!--插入用户信息--&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.zero.model.User&quot;&gt; &lt;!-- [selectKey标签]：通过select查询来生成主键 [keyProperty]：指定存放生成主键的属性 [resultType]：生成主键所对应的Java类型 [order]：指定该查询主键SQL语句的执行顺序，相对于insert语句 [last_insert_id]：MySQL的函数，要配合insert语句一起使用 --&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; SELECT LAST_INSERT_ID() &lt;&#x2F;selectKey&gt; &lt;!--如果主键的值是通过MySQL自增机制生成的，那么我们此处无需再‘显式’的给ID赋值--&gt; INSERT into user (username,sex,birthday,address) values (#{username},#{sex},#{birthday},#{address}) &lt;&#x2F;insert&gt; 使用Junit4的注解功能，抽取重复代码 private SqlSession session = null; @Before public void before() throws IOException { System.out.println(&quot;before:获取session&quot;); &#x2F;&#x2F;1. 读取配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;); &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); &#x2F;&#x2F;3. 通过SqlSessionFactory创建SqlSession。 session = sessionFactory.openSession(); } @After public void after(){ System.out.println(&quot;after:关闭会话&quot;); &#x2F;&#x2F;5. 关闭会话。 session.close(); } 测试代码 &#x2F;&#x2F; 插入用户后，将主键返回，设置到模型id中 @Test public void test2(){ User user = new User(&quot;zero001&quot;, &quot;男&quot;, new Date(), &quot;杭州&quot;); int Row = session.insert(&quot;insertUser&quot;, user); session.commit(); System.out.println(&quot;受影响行数：&quot;+Row); System.out.println(&quot;用户ID:&quot;+user.getId()); } 2.2.8 返回MySQL自增UUID 映射文件 &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.gyf.domain.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;String&quot; order=&quot;BEFORE&quot;&gt; SELECT UUID() &lt;&#x2F;selectKey&gt; INSERT INTO USER (username,sex,birthday,address) VALUES(#{username},#{sex},#{birthday},#{address}) &lt;&#x2F;insert&gt; 2.3 小结 parameterType和resultType parameterType：指定输入参数的java类型，可以填写别名或Java类的全限定名(就是全类名)。 resultType：指定输出结果的java类型，可以填写别名或Java类的全限定名。 #{}和${} #{}：相当于预处理中的占位符 #{}里面的参数表示接受java输入参数的名称 #{}可以接受HashMap、POJO类型的参数。当接受简单类型参数时，里面可以是vlaue，也可以是其他。 #{}可以防止SQL注入 ${}：相当于拼接SQL串，对传入的值不做任何解释的原样输出。 会引起SQL注入，所有需谨慎使用 可以接受HashMap、POJO类型的参数。当接受简单类型的参数时，${}里面只能是value。 selectOne和selectList selectOne：只能查询0或1条记录，大于1条记录就会报错。 selectList：可以查询0条或N条记录。 2.4 MyBatis的Dao编写(了解即可) Dao层 public class UserDaoImpl implements UserDao { private SqlSessionFactory ssf; public UserDaoImpl() { } public UserDaoImpl(SqlSessionFactory ssf) { this.ssf = ssf; } @Override public void save(User user) { &#x2F;&#x2F; 获取session SqlSession session = ssf.openSession(); &#x2F;&#x2F; 插入用户 session.insert(&quot;insertUset&quot;,user); session.commit(); session.close(); } @Override public User findUserById(int id) { &#x2F;&#x2F; 获取session SqlSession session = ssf.openSession(); &#x2F;&#x2F; 查询用户 User user = session.selectOne(&quot;findUserById&quot;, id); session.commit(); session.close(); return user; } } 测试 public class UserDaoTest { &#x2F;&#x2F; private SqlSession session = null; private SqlSessionFactory sessionFactory; @Before public void before() throws IOException { System.out.println(&quot;before:获取session&quot;); &#x2F;&#x2F;1. 读取配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;); &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。 sessionFactory = new SqlSessionFactoryBuilder().build(is); } @Test public void test1(){ &#x2F;&#x2F; 调用dao &#x2F;&#x2F; 1. 创建dao UserDaoImpl userDao = new UserDaoImpl(sessionFactory); &#x2F;&#x2F; 2. 查询 User user = userDao.findUserById(1); System.out.println(user); } } 2.5 MyBatis的Dao编写(mapper代理方式实现)Mapper代理的开发方式，程序员只需编写mapper接口(相当于dao接口)即可。MyBatis会自动的为mapper接口生成动态代理实现类。 开发规范 mapper接口的全限定名要和mapper映射文件的namespace的值相同 mapper接口的方法名称要和映射文件中的statement的id相同 mapper的接口方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致。 mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致。 编写示例文件 &#x2F;&#x2F; mapper类 public interface UserMapper { public void save(User user); public User findUserById(int id); } 映射文件: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt; &lt;!-- 注意：使用mapper代理开发时，namespace值必须是接口全限定名 --&gt; &lt;mapper namespace=&quot;com.zero.mapper.UserMapper&quot;&gt; &lt;insert id=&quot;save&quot; parameterType=&quot;com.zero.model.User&quot;&gt; INSERT into user (username,sex,birthday,address) values (#{username},#{sex},#{birthday},#{address}) &lt;&#x2F;insert&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.zero.model.User&quot;&gt; SELECT * FROM USER WHERE id = #{id} &lt;&#x2F;select&gt; &lt;&#x2F;mapper&gt; 开发规范： 添加映射配置文件 &lt;!--加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com&#x2F;zero&#x2F;mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt; 测试 public class UserMapperTest { private SqlSession session = null; @Before public void before() throws IOException { System.out.println(&quot;before:获取session&quot;); &#x2F;&#x2F;1. 读取配置文件 InputStream is = Resources.getResourceAsStream(&quot;SqlMapconfig.xml&quot;); &#x2F;&#x2F;2. 通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is); session = sessionFactory.openSession(); } @After public void after(){ System.out.println(&quot;after:关闭会话&quot;); &#x2F;&#x2F;5. 关闭会话。 session.close(); } @Test public void test1(){ &#x2F;&#x2F; 通过session获取接口代理类[默认代理：JDK实现的代理] UserMapper mapper = session.getMapper(UserMapper.class); &#x2F;&#x2F; 查询 User user = mapper.findUserById(1); System.out.println(user); mapper.save(new User(&quot;xxx&quot;, &quot;x&quot;, new Date(), &quot;xx&quot;)); session.commit(); } } 3. 全局配置文件其他配置3.1 properties数据库文件配置 在src下配置db.properties文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql:&#x2F;&#x2F;&#x2F;mybatis01?useUnicode=true&amp;amp;characterEncoding=utf8 username=root password=123456 在全局配置文件中加载并使用 &lt;configuration&gt; &lt;!--1. 加载配置文件--&gt; &lt;properties resource=&quot;db.properties&quot;&#x2F;&gt; &lt;!-- 配置mybatis的环境信息 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt; &lt;!-- 配置数据源，采用dbcp连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--2. 使用${}，可以引用一句加载的java配置文件中的信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;&#x2F;&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;&#x2F;&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;&#x2F;configuration&gt; 3.2 typeAliases别名的使用是为了在映射文件中，更方便的去指定参数和结果集的类型，不再用写很长一段全限定名。 mybatis支持的别名 java的全部基本数据类型及其对应包装类，引用数据类型等等。 自定义别名 &lt;!-- 在全局配置文件中 进行别名配置--&gt; &lt;typeAliases&gt; &lt;!--单个定义别名--&gt; &lt;typeAlias type=&quot;com.zero.model.User&quot; alias=&quot;user&quot;&#x2F;&gt; &lt;!-- 批量配置别名--&gt; &lt;!-- [name]：指定批量定义别名的类包，别名为类名，第一个字母小写(User=user)--&gt; &lt;package name=&quot;com.zero.model&quot;&#x2F;&gt; &lt;&#x2F;typeAliases&gt; 3.3 加载映射文件的几种方式 使用相对于类路径的资源。 &lt;mappers&gt; &lt;mapper resource=&quot;com&#x2F;zero&#x2F;mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt; 使用mapper接口的全限定名。注意：此方法要求mapper接口和mapper映射文件名称相同，且在同一目录下。 &lt;mappers&gt; &lt;mapper class=&quot;com.zero.mapper.UserMapper&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt; ​ 如果没有映射文件，那么在接口中要声明注解。不推荐使用 public interface UserMapper { @Insert(&quot;INSERT into user (username,sex,birthday,address) values (#{username},#{sex},#{birthday},#{address})&quot;) public void save(User user); @Select(&quot;SELECT * FROM USER WHERE id = #{id}&quot;) public User findUserById(int id); } 注册指定包下的所有映射文件。推荐 &lt;mappers&gt; &lt;!--3. 注册指定包下的所有映射文件--&gt; &lt;package name=&quot;com.zero.mapper&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt; 4. MyBatis的映射文件4.1 输入映射ParameterType指定输入参数的java类型，可以使用别名或类的全限定名。它可以接收简单类型、POJO对象、HashMap 4.1.1 传递简单类型 &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.zero.model.User&quot;&gt; SELECT * FROM USER WHERE id = #{id} &lt;&#x2F;select&gt; 4.1.2 传递POJO对象 &lt;!--插入用户信息--&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;user&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; SELECT LAST_INSERT_ID() &lt;&#x2F;selectKey&gt; INSERT into user (username,sex,birthday,address) values (#{username},#{sex},#{birthday},#{address}) &lt;&#x2F;insert&gt; 4.1.3 传递POJO包装对象开发中通过pojo传递查询条件 ，查询条件是综合的查询条件。不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。 需求：综合查询用户信息，需传入复杂查询条件，如（用户信息、订单信息、商品信息）。 定义POJO包装类 public class UserQueryVO { private User user; public User getUser() { return user; } public void setUser(User user) { this.user = user; } } 修改映射接口 public interface UserMapper { public void save(User user); public User findUserById(int id); public List&lt;User&gt; findUserByUserQueryVo(UserQueryVO vo); } 修改映射文件，添加查询方法 &lt;!--查找用户id为n的用户--&gt; &lt;select id=&quot;findUserByUserQueryVo&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;user&quot;&gt; select u.* from user u where u.id = #{user.id} &lt;&#x2F;select&gt; 测试 @Test public void test1(){ UserMapper mapper = session.getMapper(UserMapper.class); &#x2F;&#x2F; 构造查询对象 UserQueryVO query = new UserQueryVO(); &#x2F;&#x2F; 设置set User user = new User(); user.setId(1); query.setUser(user); &#x2F;&#x2F; 查询用户列表 List&lt;User&gt; queryVo = mapper.findUserByUserQueryVo(query); System.out.println(queryVo); } 4.1.4 传递Map对象 修改映射接口文件,添加方法 public interface UserMapper { public void save(User user); public User findUserById(int id); public List&lt;User&gt; findUserByUserQueryVo(UserQueryVO vo); public List&lt;User&gt; findUserByMap(Map&lt;String,Object&gt; map); } 修改映射文件，添加查询语句 &lt;select id=&quot;findUserByMap&quot; parameterType=&quot;hashMap&quot; resultType=&quot;user&quot;&gt; select u.* from user u where username like &#39;%${username}%&#39; and sex=#{sex} &lt;&#x2F;select&gt; 测试 @Test public void test2(){ UserMapper mapper = session.getMapper(UserMapper.class); &#x2F;&#x2F; 构建map Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;username&quot;,&quot;张&quot;); map.put(&quot;sex&quot;,&quot;1&quot;); &#x2F;&#x2F; 查询数据 List&lt;User&gt; users = mapper.findUserByMap(map); System.out.println(users); } 如果查询不到数据，原因是全局配置文件加载外部数据库属性文件会影响到映射文件中的数据读取，需在全局配置文件中将加载外部数据库属性文件关闭。 4.2 输出映射resultType/resultMap4.2.1 resultType 使用resultType进行结果映射时，查询的列名和映射的POJO属性名完全一致，该列才能映射成功。 如果查询的列名和映射的POJO属性名全部不一致，则不会创建POJO对象。 如果查询的列名和映射的POJO属性名有一个一致，就会创建POJO对象。 4.2.1.1 输出简单类型当输出结果只有一列时，可以使用resultType指定简单类型作为输出结果类型。 示例输出一个count(*) 映射接口文件中添加方法 public int findUserCount(UserQueryVO vo); 映射文件中添加查询方法 &lt;select id=&quot;findUserCount&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;int&quot;&gt; select count(*) from user where sex=#{user.sex} &lt;&#x2F;select&gt; 测试 @Test public void test3(){ UserMapper mapper = session.getMapper(UserMapper.class); UserQueryVO query = new UserQueryVO(); User user = new User(); user.setSex(&quot;1&quot;); query.setUser(user); int userCount = mapper.findUserCount(query); System.out.println(userCount); } 4.2.1.2 输出单个POJO对象 接口文件添加方法 public User findUserById(int id); 映射文件添加查询方法 &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; SELECT * FROM USER WHERE id = #{id} &lt;&#x2F;select&gt; 4.2.1.3 输出多个POJO对象 接口 public List&lt;User&gt; findUserByUserQueryVo(UserQueryVO vo); 映射文件 &lt;select id=&quot;findUserByUserQueryVo&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;user&quot;&gt; select u.* from user u where u.id = #{user.id} &lt;&#x2F;select&gt; 4.2.1 小结输出单个POJO对象和POJO列表时，mapper映射文件中的resultType的类型是一样的，mapper接口的方法返回值不同。 同样的mapper映射文件，返回单个对象和对象列表时，mapper接口在生成动态代理时，会根据返回值的类型，决定调用selectOne方法还是selectList方法。 POJO对象属性跟数据库列名一致，使用resultType。 不一致，使用resultMap定义映射关系。 4.2.2 resultMap如果查询出来的列名和属性名不一致，通过定义一个resultMap将列名和POJO属性名之间作一个映射关系。 mapper接口 public User findUserByIdResultMap(int id); 映射文件 &lt;!--设置返回类型为resultMap--&gt; &lt;resultMap id=&quot;userResultMap&quot; type=&quot;user&quot;&gt; &lt;!--自定义resultMap列名与属性之间的映射关系--&gt; &lt;id property=&quot;id&quot; column=&quot;id_&quot; &#x2F;&gt; &lt;result property=&quot;username&quot; column=&quot;username_&quot; &#x2F;&gt; &lt;result property=&quot;sex&quot; column=&quot;sex_&quot; &#x2F;&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday_&quot; &#x2F;&gt; &lt;result property=&quot;address&quot; column=&quot;address_&quot; &#x2F;&gt; &lt;&#x2F;resultMap&gt; &lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt; select id id_, username username_, sex sex_,birthday birthday_, address address_ from user where id=#{id}; &lt;&#x2F;select&gt; 5. 动态SQL5.1 if和where if标签：作为判断入参来使用的，如果条件符合，则把if标签体内的SQL拼接上。 where标签：会去掉条件中的第一个and符号。 动态SQL示例： 修改mapper接口 public List&lt;User&gt; findUserList(UserQueryVO vo); 修改映射文件 &lt;!-- 动态拼接SQL--&gt; &lt;select id=&quot;findUserList&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;user&quot;&gt; select * from user -- 条件判断 &lt;where&gt; &lt;if test=&quot;user != null&quot;&gt; &lt;if test=&quot;user.sex != null and user.sex != &#39;&#39;&quot;&gt; sex=#{user.sex} &lt;&#x2F;if&gt; &lt;if test=&quot;user.username != null and user.username != &#39;&#39;&quot;&gt; and username like &#39;%${user.username}%&#39; &lt;&#x2F;if&gt; &lt;&#x2F;if&gt; &lt;&#x2F;where&gt; &lt;&#x2F;select&gt; 测试 &#x2F;&#x2F; 动态拼接SQL @Test public void test5(){ UserMapper mapper = session.getMapper(UserMapper.class); UserQueryVO query = new UserQueryVO(); User user = new User(); user.setSex(&quot;1&quot;); user.setUsername(&quot;张&quot;); query.setUser(user); List&lt;User&gt; list = mapper.findUserList(query); System.out.println(list); } 5.2 SQL片段MyBatis提供了SQL片段功能，可提高SQL的可重用性 &lt;!--声明一个SQL片段--&gt; &lt;sql id=&quot;select_user_where&quot;&gt; &lt;if test=&quot;user != null&quot;&gt; &lt;if test=&quot;user.sex != null and user.sex != &#39;&#39;&quot;&gt; sex=#{user.sex} &lt;&#x2F;if&gt; &lt;if test=&quot;user.username != null and user.username != &#39;&#39;&quot;&gt; and username like &#39;%${user.username}%&#39; &lt;&#x2F;if&gt; &lt;if test=&quot;user.address != null and user.address != &#39;&#39;&quot;&gt; and address like &#39;%${user.address}%&#39; &lt;&#x2F;if&gt; &lt;&#x2F;if&gt; &lt;&#x2F;sql&gt; &lt;!--动态拼接SQL--&gt; &lt;select id=&quot;findUserList&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;user&quot;&gt; select * from user -- 条件判断 &lt;where&gt; -- 引用SQL片段 &lt;include refid=&quot;select_user_where&quot;&#x2F;&gt; &lt;&#x2F;where&gt; &lt;&#x2F;select&gt; 5.3 forEach遍历 查询对象类中新增ids属性，存放id列表 public class UserQueryVO { private User user; private List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() { return ids; } public void setIds(List&lt;Integer&gt; ids) { this.ids = ids; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } } mapper接口 &#x2F;** * 查询多个id的用户数据 *&#x2F; public List&lt;User&gt; findUserByIds(UserQueryVO vo); 映射文件 &lt;!--foreach示例--&gt; &lt;select id=&quot;findUserByIds&quot; parameterType=&quot;userQueryVO&quot; resultType=&quot;user&quot;&gt; select * from user -- select * from user where id in (10,24,37); &lt;where&gt; &lt;if test=&quot;ids != null and ids.size &gt; 0&quot;&gt; &lt;!-- foreach标签：表示一个foreach循环 collection：集合参数的名称，如果是直接传入集合参数，则该处参数名称只能填写[list] item：每次遍历出来的对象 open：开始遍历时拼接的串 close：结束遍历时拼接的串 separator：遍历出的每个对象之间需要拼接的字符 --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;id in(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; ${id} &lt;&#x2F;foreach&gt; &lt;&#x2F;if&gt; &lt;&#x2F;where&gt; &lt;&#x2F;select&gt; 测试 @Test public void test6() { UserMapper mapper = session.getMapper(UserMapper.class); UserQueryVO query = new UserQueryVO(); List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); &#x2F;&#x2F;select * from user where id in (10,24,37); ids.add(10); ids.add(24); ids.add(37); query.setIds(ids); List&lt;User&gt; users = mapper.findUserByIds(query); System.out.println(users); } 关于参数直接传入id集合 mapper接口 public List&lt;User&gt; findUserByLists(List&lt;Integer&gt; list); 映射文件 &lt;!--如果参数是数组的话，parameterType可以写全限定名，也可以写别名--&gt; &lt;select id=&quot;findUserByLists&quot; parameterType=&quot;java.util.List&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;list != null and list.size &gt; 0&quot;&gt; -- 如果是直接传入集合参数，则该处参数名称只能填写[list] &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; open=&quot;id in(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; ${id} &lt;&#x2F;foreach&gt; &lt;&#x2F;if&gt; &lt;&#x2F;where&gt; &lt;&#x2F;select&gt; 测试同上，查询方法改一下即可。 6. MyBatis与Hibernate的区别6.1 MyBatis技术特点 好处： 通过直接编写SQL语句，可以直接对SQL进行性能优化 学习成本低，有SQL基础，就可以学习MyBatis，容易上手 由于直接编写SQL语句，所以灵活多变，代码维护性更好 缺点 不能支持数据库无关性，即数据库发生变更，要写多套代码进行支持，移植性不好。 需要编写结果映射。 6.2 Hibernate技术特点 好处 标准的ORM框架，程序员无需编写SQL语句。 具有良好的数据库无关性，即数据库发生变化，代码无需再次编写。 例：mysql数据迁移到oracle，只需更改方言配置即可 缺点 学习门槛高，需要对数据关系模型有良好的基础，而且在设置OR映射时，需考虑好性能和对象模型的权衡 我们不能自主的去进行SQL性能优化。 6.3 MyBatis应用场景需求多变的互联网项目，例如电商项目 6.4 Hibernate应用场景需求明确，业务固定的项目，例如OA项目，ERP项目等。","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zero024.cn/tags/MyBatis/"}]},{"title":"Spring的事务管理","slug":"FrameWork/Spring事务管理","date":"2019-08-18T15:52:00.000Z","updated":"2020-03-25T01:16:57.776Z","comments":true,"path":"FrameWork/Spring-Transaction.html","link":"","permalink":"https://zero024.cn/FrameWork/Spring-Transaction.html","excerpt":"1. Java事务导引1.1 事务简介 什么是事务 事务是正确执行一系列的操作(或动作)，使得数据库从一种状态转换成另一种状态，且保证操作全部成功，或者全部失败。","text":"1. Java事务导引1.1 事务简介 什么是事务 事务是正确执行一系列的操作(或动作)，使得数据库从一种状态转换成另一种状态，且保证操作全部成功，或者全部失败。 事务原则是什么 事务必须服从ISO/IEC所制定的ACID原则 ACID原则具体内容如下： 原子性（Atomicity）：即不可分割性，事务要么全部被执行，要么就全部不被执行。 一致性（Consistency）：事务的执行使得数据库从一种正确状态转换成另一种正确状态。 隔离性（Isolation）：在事务正确提交之前，它可能的结果不应显示给任何其他事务。 持久性（Durability）：事务正确提交后，其结果将永久保存在数据库中。 1.2 Java事务 Java事务的产生 程序操作数据库的需要。以Java编写的程序或系统，实现ACID的操作。 Java事务实现 通过JDBC相应方法间接来实现对数据库的增删改查，把事务转移到Java程序代码中进行控制。 确保事务要么全部执行成功，要么撤销不执行。 总结：Java事务机制和原理就是操作确保数据库操作的ACID特性。 1.3 Java事务实现模式 Java事务的实现 通过Java代码来实现对数据库的事务性操作 Java事务类型 JDBC事务：用Connection对象控制的手动模式和自动模式 JTA(Java Transaction API)事务：与实现无关的，与协议无关的API 容器事务：应用服务器提供的，且大多是基于JTA完成(通常基于JNDI的，相当复杂的API实现) 1.4 三种事务的差异 JDBC事务：控制的局限性在一个数据库连接内，但是其使用简单。 JTA事务：功能强大，可跨越多个数据库或多DAO，使用比较复杂。 容器事务：主要指的是J2EE应用服务器提供的事务管理，局限于EJB应用使用。 2. Spring事务核心接口2.1 事务接口架构 2.2 Spring事务管理器 JDBC事务管理器(DataSourceTransactionManager) 本事务管理器是通过调用java.sql.Connection来管理事务。 Spring配置示例 Hibernate事务管理器(HibernateTransactionManager) 本管理器将事务管理的职责委托给org.hibernate.Transaction对象来管理事务，而后者是从Hibernate Session中获取到的。 JPA事务管理器(JpaTransactionManager) 通过一个JPA实体管理工厂(javax.persistence.EntityManagerFactory接口的任意实现)将与由工厂所产生的JPA EntityManager合作来构建事务。 JTA事务管理器(JtaTransactionManager) 本管理器将事务管理的责任委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象进行事务处理。 2.3 Spring事务属性定义 2.4 事务隔离级别2.4.1 数据读取类型说明 脏读 脏读发生在一个事务A读取了被另一个事务B修改，但是还未提交的数据。假如B回滚，则事务A读取的就是无效数据。跟不可重复读类似，但是第二个事务无需执行提交。 不可重复读 在基于锁的并行控制方法中，如果在执行select时不添加读锁，就会发生不可重复读问题，导致两次读取的数据不一致。 幻读 幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一次查询的不相同。 参考文章 2.4.2 事务隔离级别 隔离级别定义了一个事务可能受其他并发事务影响的程度 隔离级别如下： 隔离级别 含义 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别 ISOLATION_READ_UNCOMMITTED 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 ISOLATION_READ_COMMITTED 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 ISOLATION_REPEATABLE_READ 对同一字段的多次读取结果都是一致的，除非数据时被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生 ISOLATION_SERIALIZABLE 最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读和幻读。也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的 2.5 事务传播行为 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。即两个业务之间如何共享事务 Spring的7种传播行为： 传播行为 含义 PROPAGATION_REQUIRED 表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务 PROPAGATION_SUPPORTS 表示当前方法无需事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行 PROPAGATION_MANDATORY 表示该方法必须在事务中运行，如果当前事务不存在，则会抛异常 PROPAGATION_REQUIRED_NEW 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager PROPAGATION_NOT_SUPPORTED 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager PROPAGATION_NEVER 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常 PROPAGATION_NESTED 表示如果当前存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。参考资源管理器的文档来确认它们是否支持嵌套事务。 2.6 事务中注意的问题 事务是否只读 利用数据库事务的“只读”属性，进行特点优化处理 注意： 事务的是否“只读”属性，不同的数据库厂商支持不同 通常而言：只读属性的应用要参考厂商的具体支持说明，比如： Oracle的“readOnly”不起作用，不影响其增删改查 MySQL的“readOnly”为true，只能查，增删改则出异常 事务超时 事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。 设计事务时注意点 为了使应用程序更好的运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。 事务回滚 默认情况下，事务只有遇到运行期异常才会回滚，而在遇到检查型异常时不会回滚。 自定义回滚策略 声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚； 声明事务遇到特定的异常不回滚，即使这些异常时运行期异常。 2.7 Spring事务状态 事务接口 通过事务管理器获取TransactionStatus实例； 控制事务在回滚或提交时需要应用对应的事务状态； Spring事务接口： &#x2F;&#x2F; Spring事务状态接口： &#x2F;&#x2F; 通过调用PlatformTransactionManager的getTransaction() &#x2F;&#x2F; 获取事务状态实例 public interface TransactionStatus{ boolean isNewTransaction(); &#x2F;&#x2F; 是否是新的事务 boolean hasSavepoint(); &#x2F;&#x2F; 是否有恢复点 void setRollbackOnly(); &#x2F;&#x2F; 设置为只回滚 boolean isRollBackOnly(); &#x2F;&#x2F; 是否为只回滚 boolean isCompleted; &#x2F;&#x2F; 是否已完成 } 2.8 转账案例通过代理工厂实现事务 2.8.1 环境搭建创建用户数据库表 create table account( id int primary key auto_increment, username varchar(50), money int); insert into account(username,money) values(&#39;jack&#39;,10000); insert into account(username,money) values(&#39;rose&#39;,10000); 2.8.2 导入jar包 spring核心：4+1(core+context+beans+expression)+logging aop：4（aop联盟、spring aop、aspectj规范、spring aspect） 数据库：jdbc、tx 驱动：mysql 连接池：dbcp 2.8.3 创建Dao层 public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao { &#x2F;&#x2F; JdbcDaoSupport，在xml中配置数据源即可使用 &#x2F;&#x2F; 转出 @Override public void out(String outer, Integer money) { String sql = &quot;update account set money = money - ? where username = ?&quot;; getJdbcTemplate().update(sql,money,outer); } &#x2F;&#x2F; 进账 @Override public void in(String inner, Integer money) { String sql = &quot;update account set money = money + ? where username = ?&quot;; getJdbcTemplate().update(sql,money,inner); } } 2.8.4 创建Service层 public class AccountServiceImpl implements AccountService { private AccountDao accountDao; &#x2F;&#x2F; 提供set方法，让spring注入属性 public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } @Override public void transfer(String outer, String inner, Integer money) { this.accountDao.out(outer,money); int i = 1&#x2F;0; &#x2F;&#x2F; 手动制造异常，测试事务是否其效果 this.accountDao.in(inner,money); } } 2.8.5 配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt; &lt;!--配置DBCP数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置Template--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置Dao--&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.zero.transaction.dao.Impl.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置service--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.zero.transaction.service.Impl.AccountServiceImpl&quot;&gt; &lt;!--添加属性accountDao--&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置代理工厂--&gt; &lt;bean id=&quot;proxyService&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt; &lt;!--接口，注意配置全类名--&gt; &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.zero.transaction.service.AccountService&quot;&#x2F;&gt; &lt;!--目标对象--&gt; &lt;property name=&quot;target&quot; ref=&quot;accountService&quot;&#x2F;&gt; &lt;!--切面对象，SPring做了，就不用写了--&gt; &lt;!--事务管理器--&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;txManager&quot;&#x2F;&gt; &lt;!-- 事务属性&#x2F;详情配置 prop.key ：确定哪些方法使用当前事务配置 prop.text:用于配置事务详情 格式：PROPAGATION,ISOLATION,readOnly,-Exception,+Exception 传播行为 隔离级别 是否只读 异常回滚 异常提交 --&gt; &lt;property name=&quot;transactionAttributes&quot;&gt; &lt;props&gt; &lt;!--可以配置隔离级别--&gt; &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&lt;&#x2F;prop&gt; &lt;&#x2F;props&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;beans&gt; 2.8.6 测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:transfer.xml&quot;) public class transferTest { &#x2F;&#x2F; @Autowired @Resource(name = &quot;proxyService&quot;) private AccountService accountService; &#x2F;&#x2F; 转账测试 @Test public void test1(){ &#x2F;&#x2F; 获取service accountService.transfer(&quot;jack&quot;,&quot;rose&quot;,100); } } 3. 编程式事务管理3.1 编程式事务实现方式 模板事务(TransactionTemplate)的方式 此为Spring官方团队推荐的编程式事务管理方式 主要工具为JdbcTemplate类。 平台事务管理器(PlatformTransactionManager)方式 类似应用JTA UserTransaction API方式，但异常处理更简洁； 辅助类为：TransactionDefinition和TransactionStatus 3.2 编程式事务实现案例 模板事务(TransactionTemplate)案例 步骤：获取模板对象；选择事务结果类型；业务数据操作处理。 平台事务管理器(PlatformTransactionManager)案例 步骤：获取事务管理器；获取事务属性对象；获取事务状态对象；创建JDBC模板对象；业务数据操作处理。 数据库工具类DButil public class DBUtil { static final String dbDriver = &quot;com.mysql.jdbc.Driver&quot; ; static final String dbUrl = &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;characterEncoding=utf-8&quot; ;&#x2F;&#x2F; static final String userName = &quot;root&quot; ; static final String password = &quot;123456&quot; ; static { try{&#x2F;&#x2F;加载MySql的驱动类 Class.forName(dbDriver) ; }catch(ClassNotFoundException e){ System.out.println(&quot;找不到驱动程序类 ，加载驱动失败！&quot;); e.printStackTrace() ; } } public static Connection getConnection(){ try { return DriverManager.getConnection(dbUrl , userName , password ) ; } catch (SQLException e) { e.printStackTrace(); } return null ; } } 数据库工具类TemplateUtils &#x2F;** * Spring数据库操作工具类 *&#x2F; public class TemplateUtils { private final static String dbDriver = &quot;com.mysql.jdbc.Driver&quot; ; private final static String dbUrl = &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;selection_course?useUnicode=true&amp;characterEncoding=utf-8&quot; ;&#x2F;&#x2F; private final static String dbUser = &quot;root&quot;; private final static String dbPwd = &quot;123456&quot;; private static BasicDataSource dataSource ; &#x2F;&#x2F;静态初识：创建连接数据源 static { &#x2F;&#x2F;创建DBCP简单数据源并初始化相关数据源属性 &#x2F;&#x2F;private void createSimpleDataSource(){ dataSource = new BasicDataSource() ; dataSource.setDriverClassName(dbDriver); dataSource.setUrl(dbUrl); dataSource.setUsername(dbUser); dataSource.setPassword(dbPwd); &#x2F;&#x2F; &#x2F;&#x2F;指定数据库连接池初始连接数 &#x2F;&#x2F; dataSource.setInitialSize(10); &#x2F;&#x2F; &#x2F;&#x2F;设定同时向数据库申请的最大连接数 &#x2F;&#x2F; dataSource.setMaxTotal(50); &#x2F;&#x2F; &#x2F;&#x2F;设置连接池中保持的最少连接数量 &#x2F;&#x2F; dataSource.setMinIdle(5); &#x2F;&#x2F;} } public static TransactionTemplate getTransactionTemplate() { PlatformTransactionManager txManager = new DataSourceTransactionManager( dataSource); return new TransactionTemplate(txManager); } public static JdbcTemplate getJdbcTemplate() { return new JdbcTemplate(dataSource); } public static NamedParameterJdbcTemplate getNamedParameterJdbcTemplate() { return new NamedParameterJdbcTemplate(dataSource); } public static SimpleJdbcInsert getSimpleJdbcTemplate() { return new SimpleJdbcInsert(dataSource); } &#x2F;** * &#x2F;&#x2F;获取事务管理器：TransactionManager * 根据需要，可以是如JDBC、Hibernate,这里定义JDBC事务管理其 * @return DataSourceTransactionManager *&#x2F; public static DataSourceTransactionManager getDataSourceTransactionManager(){ DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); &#x2F;&#x2F; 设置数据源:此事务数据源须和正式事务管理器的数据源一致 dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; } } 事务管理器示例 &#x2F;** * 事务管理器方式案例 *&#x2F; public class ProTransExample { &#x2F;&#x2F; 事务模板：第二种事务编程模式 &#x2F;&#x2F; private TransactionTemplate transactionTemplate ; &#x2F;&#x2F; 数据持久化操作 public void addBook(final Book book) { &#x2F;&#x2F; 获取事务模板对象 TransactionTemplate tt = TemplateUtils.getTransactionTemplate(); &#x2F;&#x2F; 可设置事务属性，如隔离级别、超时时间等,如： &#x2F;&#x2F; tt.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED); &#x2F;&#x2F; 内部类 tt.execute(new TransactionCallbackWithoutResult() { protected void doInTransactionWithoutResult(TransactionStatus s) { try { &#x2F;&#x2F; 数据库操作1 &#x2F;&#x2F; JdbcTemplate jdbcTemplate &#x2F;&#x2F; =TemplateUtils.getJdbcTemplate(); &#x2F;&#x2F; jdbcTemplate.execute(sql); &#x2F;&#x2F; 简单模板化新增数据 SimpleJdbcInsert simpleInsert = TemplateUtils.getSimpleJdbcTemplate(); simpleInsert.withTableName(&quot;books&quot;).usingColumns(&quot;isbn&quot;, &quot;name&quot;, &quot;price&quot;, &quot;pubdate&quot;); Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(); parameters.put(&quot;isbn&quot;, book.getIsbn()); parameters.put(&quot;name&quot;, book.getName()); parameters.put(&quot;price&quot;, book.getPrice()); parameters.put(&quot;pubdate&quot;, book.getPubdate()); simpleInsert.execute(parameters); System.out.println(&quot;新增数据成功！&quot;); &#x2F;&#x2F; 或者DAO数据操作模式： &#x2F;&#x2F; BookDAO.save(book); } catch (Exception e) { s.setRollbackOnly(); e.printStackTrace(); } } }); } public Book findBookByIsbn(final String isbn) { TransactionTemplate tt = TemplateUtils.getTransactionTemplate(); Book book = null; @SuppressWarnings(&quot;unchecked&quot;) List&lt;Map&lt;String, Object&gt;&gt; books = (List&lt;Map&lt;String, Object&gt;&gt;) tt.execute(new TransactionCallback&lt;Object&gt;() { public Object doInTransaction(TransactionStatus arg0) { JdbcTemplate jdbcTemplate = TemplateUtils.getJdbcTemplate(); return jdbcTemplate.queryForList(&quot;select isbn,name,price,pubdate from books where isbn =&#39;&quot; + isbn + &quot;&#39;&quot;); } }); if (books.size() != 0) {&#x2F;&#x2F; 封装获取的数据 Map&lt;String, Object&gt; m = (Map) books.get(0); book = new Book(); book.setIsbn(m.get(&quot;isbn&quot;).toString()); book.setName(m.get(&quot;name&quot;).toString()); book.setPrice((Float) m.get(&quot;price&quot;)); book.setPubdate((Date) m.get(&quot;pubdate&quot;)); } return book; } &#x2F;&#x2F; 1、编程式事务管理：事务管理器PlatformTransactionManager方式实现 public void updateBookByIsbn(Book book) { &#x2F;&#x2F;第一步：获取JDBC事务管理器 DataSourceTransactionManager dtm = TemplateUtils.getDataSourceTransactionManager(); &#x2F;&#x2F; 第二步：创建事务管理器属性对象 DefaultTransactionDefinition transDef = new DefaultTransactionDefinition(); &#x2F;&#x2F; 定义事务属性 &#x2F;&#x2F; 根据需要，设置事务管理器的相关属性 &#x2F;&#x2F; 设置传播行为属性 transDef.setPropagationBehavior(DefaultTransactionDefinition.PROPAGATION_REQUIRED); &#x2F;&#x2F; 第三步：获得事务状态对象 TransactionStatus ts = dtm.getTransaction(transDef); &#x2F;&#x2F; 第四步：基于当前事务管理器,获取数据源，创建操作数据库的JDBC模板对象 JdbcTemplate jt = new JdbcTemplate(dtm.getDataSource()); try { &#x2F;&#x2F;第五步：业务操作 jt.update(&quot;update books set price=&quot;+book.getPrice()+&quot;,name=&#39;&quot;+book.getName() +&quot;&#39; where isbn=&#39;&quot;+book.getIsbn()+&quot;&#39; &quot;); &#x2F;&#x2F; 其它数据操作如增删 &#x2F;&#x2F;第六步：提交事务 dtm.commit(ts); &#x2F;&#x2F; 如果不commit，则更新无效果 System.out.println(&quot;修改成功&quot;); } catch (Exception e) { &#x2F;&#x2F; 报错直接回滚事务 dtm.rollback(ts); e.printStackTrace(); } } public static void main(String[] args) { ProTransExample pte = new ProTransExample(); Book book = pte.findBookByIsbn(&quot;128-166-890-China&quot;); &#x2F;&#x2F; 查询数据 if (book != null){ &#x2F;&#x2F; 如果查询到就更新数据 book.setName(&quot;华夏龙图腾&quot;); book.setPrice(125.5f); pte.updateBookByIsbn(book); }else { &#x2F;&#x2F; 如果没有则添加数据 Book addbook = new Book(); addbook.setIsbn(&quot;128-166-890-China&quot;); addbook.setName(&quot;华夏龙图腾&quot;); addbook.setPrice(128.5f); pte.addBook(addbook); } &#x2F;* *1-新增书籍 * Date pd = new Date(System.currentTimeMillis()); Book book = new * Book(); book.setIsbn(&quot;120-166-990-China&quot;); book.setName(&quot;人性的弱点&quot;); * book.setPrice(65.6f); book.setPubdate(pd); *&#x2F; &#x2F;&#x2F; pte.addBook(book); &#x2F;&#x2F;2-查找书籍 &#x2F;*Book bk = pte.findBookByIsbn(&quot;120-166-890-China&quot;); System.out.println(&quot;书籍名称：&quot; + bk.getName());*&#x2F; &#x2F;&#x2F;3-更新书籍名称和价格 } } 3.3 小结 需要有效的数据源，具体数据源根据实际情况创建 创建编程事务管理对象 事务模板(TransactionTemplate) 事务管理器(PlateformTransactionManager) 业务逻辑处理 基于JdbcTemplate完成业务处理。 4. 声明式事务管理(掌握)4.1 声明式事务实现方式 声明式事务管理的配置类型 5种类型：独立代理；共享代理；拦截器；tx拦截器；全注释。 声明式事务管理配置实现方式： 5种类型的配置实现参考 转账案例基于AOP的事务配置： 基本代码不变，修改xml配置文件如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt; &lt;!--开启自动扫描--&gt; &lt;context:component-scan base-package=&quot;com.zero.jdbc_Template&quot;&#x2F;&gt; &lt;!--配置DBCP数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置Template--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置Dao--&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.zero.transaction.dao.Impl.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置service--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.zero.transaction.service.Impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--使用spring的aop来配置事务--&gt; &lt;!--1. 配置通知事务管理器--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;!--事务详情：传播行为，隔离级别--&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot;&#x2F;&gt; &lt;&#x2F;tx:attributes&gt; &lt;&#x2F;tx:advice&gt; &lt;!--2. 事务通知与切入点关联--&gt; &lt;aop:config&gt; &lt;!-- &lt;aop:pointcut id=&quot;myPoinycut&quot; expression=&quot;execution(* com.zero.transaction.service..*.*(..))&quot;&#x2F;&gt;--&gt; &lt;!-- &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;myPoinycut&quot;&#x2F;&gt;--&gt; &lt;!--事务与连接点关联--&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.zero.transaction.service..*.*(..))&quot;&#x2F;&gt; &lt;&#x2F;aop:config&gt; &lt;&#x2F;beans&gt; 测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:transfer_aop.xml&quot;) public class transferTest { @Autowired &#x2F;&#x2F; 使用自动注入 &#x2F;&#x2F; @Resource(name = &quot;proxyService&quot;) private AccountService accountService; &#x2F;&#x2F; 转账测试 @Test public void test1(){ &#x2F;&#x2F; 获取service accountService.transfer(&quot;jack&quot;,&quot;rose&quot;,100); } &#x2F;&#x2F; 使用aop配置事务 @Test public void test2(){ accountService.transfer(&quot;jack&quot;,&quot;rose&quot;,100); } } 使用注解来实现事务 基本代码不变，修改xml如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt; &lt;!--开启自动扫描--&gt; &lt;context:component-scan base-package=&quot;com.zero.jdbc_Template&quot;&#x2F;&gt; &lt;!--配置DBCP数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置Template--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置Dao--&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.zero.transaction.dao.Impl.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置service--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.zero.transaction.service.Impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--使用spring的注解来实现事务--&gt; &lt;!--1. 配置事务管理器--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--2. 开启事务注解驱动--&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;&#x2F;&gt; &lt;&#x2F;beans&gt; 在需要开启事务的实现类上添加注解信息 @Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.DEFAULT) public class AccountServiceImpl implements AccountService { private AccountDao accountDao; &#x2F;&#x2F; 提供set方法，让spring注入属性 public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } @Override public void transfer(String outer, String inner, Integer money) { this.accountDao.out(outer,money); &#x2F;&#x2F; int i = 1&#x2F;0; this.accountDao.in(inner,money); } } 测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:transfer_anno.xml&quot;) &#x2F;&#x2F; 修改为注解配置的xml即可 public class transferTest { @Autowired &#x2F;&#x2F; @Resource(name = &quot;proxyService&quot;) private AccountService accountService; &#x2F;&#x2F; 使用aop配置事务 @Test public void test2(){ accountService.transfer(&quot;jack&quot;,&quot;rose&quot;,100); } } 5. 事务管理最佳实践5.1 编程事务管理和声明事务管理的区别 编程式事务允许用户在代码中精确定义事务的边界； 声明式事务有助于用户将操作与事务规则进行解耦 基于AOP交由Spring容器实现 实现关注点聚焦在业务逻辑上 简言 编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以即能起到事务管理的作用，又不影响业务代码的具体实现。 5.2 两种事务的选择 小型应用、事务操作少 建议编程式事务管理实现：TransactionTemplate 简单、显式操作、直观明显、可以设置事务名称 大型应用，事务操作量多 业务复杂度高、关联性紧密，建议声明式事务管理实现 关注点聚焦到业务层面，实现业务和事务的解耦。 6. Spring事务管理总结 事务与Spring事务管理 Spring事务核心接口类 编程式事务实现 声明式事务实现 事务的综合案例","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zero024.cn/tags/Spring/"}]},{"title":"JDBC_Template","slug":"FrameWork/JDBCTemplate","date":"2019-08-11T15:28:00.000Z","updated":"2020-03-25T01:16:24.255Z","comments":true,"path":"FrameWork/JDBC.html","link":"","permalink":"https://zero024.cn/FrameWork/JDBC.html","excerpt":"1. JDBC TemplateSpring对数据库的操作在jdbc上面做了深层次的封装，简化了持久层操作。使用spring的注入功能，可以把DataSource注册到JdbcTemplate中。","text":"1. JDBC TemplateSpring对数据库的操作在jdbc上面做了深层次的封装，简化了持久层操作。使用spring的注入功能，可以把DataSource注册到JdbcTemplate中。 为了简化持久化操作，Spring在JDBC API之上提供了JDBC Template组件 1.1 准备阶段 先创建数据库 drop database if exists selection_course; create database selection_course; use selection_course; create table course ( id int not null auto_increment, name char(20), score int, primary key (id) ); create table selection ( student int not null, course int not null, selection_time datetime, score int, primary key (student, course) ); create table student ( id int not null auto_increment, name varchar(20), sex char(2), born date, primary key (id) ); alter table selection add constraint FK_Reference_1 foreign key (course) references course (id) on delete restrict on update restrict; alter table selection add constraint FK_Reference_2 foreign key (student) references student (id) on delete restrict on update restrict; -- 修改表字符集 alter table course default character set utf8 collate utf8_general_ci; insert into course(id,name,score) values(1001,&#39;英语&#39;,5); insert into course(id,name,score) values(1002,&#39;操作系统&#39;,5); insert into course(id,name,score) values(1003,&#39;数据结构&#39;,3); commit; 如果出现1366问题，是表字符集编码问题，需修改表默认字符集为utf8。 创建Maven项目，导入相关jar包 MySQL驱动 Spring组件（core、beans、context、aop） JDBC Template（jdbc、tx） &lt;!--导入数据库驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.32&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--导入Template相关包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt; &lt;version&gt;${spring.version}&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 创建spring.xml文件，配置如下内容 数据源 JDBC Template &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xmlns:tx=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_cource?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置Template--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;beans&gt; 1.2 JDBC Template基本使用1.2.1 execute方法 public void testExecute(){ jdbcTemplate.execute(&quot;create table user1(id int,name varchar(20))&quot;); } 1.2.2 update与batchUpdate方法 update方法：对数据进行增删改操作 int update(String sql, Object[] agrs) int update(String slq, Object... args) &#x2F;&#x2F; 方法示例 &#x2F;&#x2F; int update(String sql, Object[] agrs) @Test public void testUpdate(){ String sql = &quot;insert into student(name,sex) values(?,?)&quot;; jdbcTemplate.update(sql,new Object[]{&quot;小明&quot;,&quot;男&quot;}); } &#x2F;&#x2F; int update(String slq, Object... args) @Test public void testUpdate2(){ String sql = &quot;update student set sex=? where name=?&quot;; jdbcTemplate.update(sql,&quot;女&quot;,&quot;小明&quot;); } batchUpdate方法：批量增删改操作 int[] batchUpdate(String[] sql) int[] barchUpdate(String sql, List&lt;Object[]&gt; args) &#x2F;&#x2F; 方法示例 &#x2F;&#x2F; int[] batchUpdate(String[] sql) @Test public void testBatchUpdate(){ String[] sqls = { &quot;insert into student(name,sex) values(&#39;小李&#39;,&#39;女&#39;)&quot;, &quot;insert into student(name,sex) values(&#39;小花&#39;,&#39;女&#39;)&quot;, &quot;update student set sex=&#39;男&#39; where name = &#39;小李&#39;&quot; }; jdbcTemplate.batchUpdate(sqls); } &#x2F;&#x2F; int[] barchUpdate(String sql, List&lt;Object[]&gt; args),适用于同步sql语句执行,使用率较高。 @Test public void testBatchUpdate2(){ String sql = &quot;insert into selection(student,course) values(?,?)&quot;; List&lt;Object[]&gt; list = new ArrayList&lt;Object[]&gt;(); list.add(new Object[]{2,1002}); list.add(new Object[]{2,1003}); jdbcTemplate.batchUpdate(sql,list); } 1.2.3 query与queryXXX方法 查询简单数据项 获取一个 T queryForObject(String sql, Class&lt;T&gt; type) T queryForObject(String sql, Object[] args, Class&lt;T&gt; type) T queryForObject(String sql, Class&lt;T&gt; type,Object... arg) &#x2F;&#x2F; 方法示例 &#x2F;&#x2F; T queryForObject(String sql, Class&lt;T&gt; type) @Test public void testQueryForObject(){ String sql = &quot;select count(*) from student&quot;; int count = jdbcTemplate.queryForObject(sql, Integer.class); &#x2F;&#x2F; 第一个参数sql语句，第二个参数返回值类型 System.out.println(count); } 获取多个 T queryForList(String sql, Class&lt;T&gt; type) T queryForList(String sql, Object[] args, Class&lt;T&gt; type) T queryForList(String sql, Class&lt;T&gt; type,Object... arg) &#x2F;&#x2F; 方法示例 &#x2F;&#x2F; T queryForList(String sql, Class&lt;T&gt; type) @Test public void testQueryForList(){ String sql = &quot;select name from student where sex=?&quot;; List&lt;String&gt; names = jdbcTemplate.queryForList(sql, String.class, &quot;女&quot;); System.out.println(names); } 查询复杂对象（封装为Map） 获取一个 Map queryForMap(String sql) Map queryForMap(String sql,Object[] args) Map queryForMap(String sql,Object... arg) &#x2F;&#x2F; 方法示例 &#x2F;&#x2F; Map queryForMap(String sql) @Test public void testQueryForMap(){ String sql = &quot;select * from student where id = ?&quot;; Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 1); System.out.println(map); &#x2F;&#x2F; {id=1, name=小明, sex=女, born=null} } 获取多个 List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql) List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql,Object[] args) List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql,Object... arg) &#x2F;&#x2F; 方法示例 &#x2F;&#x2F; List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql) @Test public void testQueryList(){ String sql = &quot;select * from student&quot;; List&lt;Map&lt;String, Object&gt;&gt; stus = jdbcTemplate.queryForList(sql); System.out.println(stus); &#x2F;&#x2F; [{id=1, name=小明, sex=女, born=null}, {id=2, name=小李, sex=男, born=null}, {id=3, name=小花, sex=女, born=null}] } 查询复杂对象（封装为实体对象） RowMapper接口 获取一个 T queryForObject(String sql,RowMapper&lt;T&gt; mapper) T queryForObject(String sql,Object[] args,RowMapper&lt;T&gt; mapper) T queryForObject(String sql,RowMapper&lt;T&gt; mapper,Object... arg) &#x2F;&#x2F; 方法示例 @Test public void testQueryEntity1(){ String sql = &quot;select * from student where id = ?&quot;; Student student = jdbcTemplate.queryForObject(sql, new RowMapper&lt;Student&gt;() { &#x2F;&#x2F; 设置映射关系 public Student mapRow(ResultSet rs, int rowNum) throws SQLException { Student student = new Student(); student.setId(rs.getInt(&quot;id&quot;)); student.setName(rs.getString(&quot;name&quot;)); student.setSex(rs.getString(&quot;sex&quot;)); student.setBorn(rs.getDate(&quot;born&quot;)); return student; } },1); System.out.println(student); &#x2F;&#x2F; Student{id=1, name=&#39;小明&#39;, sex=&#39;女&#39;, born=null} &#x2F;&#x2F; Student student = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;Student&gt;(Student.class), 1); &#x2F;&#x2F; System.out.println(student); } 获取多个 List&lt;T&gt; query(String sql,RowMapper&lt;T&gt; mapper) List&lt;T&gt; query(String sql,Object[] args,RowMapper&lt;T&gt; mapper) List&lt;T&gt; query(String sql,RowMapper&lt;T&gt; mapper,Object... arg) &#x2F;&#x2F; 方法示例 &#x2F;&#x2F; List&lt;T&gt; query(String sql,RowMapper&lt;T&gt; mapper) 获取多条记录，封装成实体类 @Test public void testQueryEntity2(){ String sql = &quot;select * from student&quot;; List&lt;Student&gt; stus = jdbcTemplate.query(sql, new RowMapper&lt;Student&gt;() { &#x2F;&#x2F; 设置映射关系 public Student mapRow(ResultSet rs, int rowNum) throws SQLException { Student student = new Student(); student.setId(rs.getInt(&quot;id&quot;)); student.setName(rs.getString(&quot;name&quot;)); student.setSex(rs.getString(&quot;sex&quot;)); student.setBorn(rs.getDate(&quot;born&quot;)); return student; } }); System.out.println(stus); } 1.3 优缺点分析 优点：简单灵活 缺点： SQL与Java代码掺杂 功能不丰富 2. 连接池技术 JDBC(Java DataBase Connecttivity)，java数据库连接。是一种用于执行SQL语句的Java API ODBC(Open DataBase Connectivity)，开发数据库连接。是微软公司提供的一组对数据库访问的标准API(应用程序编程接口) DBCP(DataBase Connection Pool)数据库连接池，是Java数据库连接池的一种，由Apache开发。 C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。 提问：c3p0和dbcp的区别？ dbcp没有自动回收空闲连接的功能；c3p0有自动回收空闲连接的功能。 对数据连接的处理方式不同：C3P0提供最大空闲时间，DBCP提供最大连接数。C3P0当连接超过最大空闲连接时间时，当前连接就会被断掉。DBCP当前连接超过最大连接数时，所有连接都会被断开。 2.1 配置DBCP导入commons-dbcp2.jar、commons-pool.jar到工程。在spring配置文件中配置如下。 &lt;!--配置DBCP数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置Template--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--依赖注入，注意一定要提供set方法--&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.zero.jdbc_Template.dao.Impl.StudentDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 2.2 配置C3P0导入c3p0-0.9.2.1.jar到工程。在spring配置文件中配置如下。 &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&#x2F;&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&#x2F;&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 2.3 关于JdbcDaoSupportJdbcDaoSupport是spring框架为我们提供的一个类，该类中定义了一个JdbcTemplate对象，我们可以直接获取使用，但是要想创建该对象，需要为其提供一个数据源。 参考文章 2.4 关于引用外部属性文件 将数据库连接的信息配置到属性文件中： username=root password=123456 driver=com.mysql.jdbc.Driver url=jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8 在spring配置文件中引入外部的属性文件 &lt;!-- 引入外部属性文件： --&gt; &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--方法2--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&#x2F;&gt; 总结 持久化操作特点 ORM：对象关系映射 JDBC Template是Spring框架对JDBC操作的封装，简单、灵活但不够强大 实际应用中还需和其他ORM框架混合使用。","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zero024.cn/tags/Spring/"}]},{"title":"AspectJ的AOP开发","slug":"FrameWork/AspectJ的AOP开发","date":"2019-08-10T15:28:00.000Z","updated":"2020-03-25T01:16:16.512Z","comments":true,"path":"FrameWork/Spring-AspectJ.html","link":"","permalink":"https://zero024.cn/FrameWork/Spring-AspectJ.html","excerpt":"1. AspectJ 简介AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。","text":"1. AspectJ 简介AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。 AspectJ是一个基于Java语言的AOP框架 Spring2.0以后新增了对AspectJ切点表达式的支持 @AspectJ是AspectJ1.5新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面 新版本Spring框架，建议使用AspectJ方式来开发AOP 使用AspectJ需要导入Spring AOP和AspectJ相关jar包 spring-aop-4.2.4.RELEASE.jar com.springsource.org.aopalliance-1.0.0.jar spring.aspects-4.2.4.RELEASE.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar 2. 注解方式实现AOP2.1 注解开发：环境准备xml配置如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:aop=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xsi:schemaLocation=&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt; &lt;!--开启AspectJ自动代理--&gt; &lt;aop:aspectj-autoproxy&#x2F;&gt; &lt;&#x2F;beans&gt; 2.2 @AspectJ提供不同的通知类型 @Before：前置通知，相当于BeforeAdvice @AfterReturning：后置通知，相当于AfterReturningAdvice @Around：环绕通知，相当于MethodInterceptor @AfterThrowing：异常抛出通知，相当于ThrowAdvice @After：最终final通知，不管是否异常，该通知都会执行 @DeclareParents：引介通知，相当于IntroductionInterceptor（了解即可） 2.3 在通知中通过value属性定义切点 通过execution函数，可以定义切点的方法切入 语法：execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) 示例： 匹配所有类public方法：execution(public * *(..)) 匹配指定包下所有类方法：execution(* com.zero.dao.*(..))，不包含子包 execution(* com.zero.dao..*(..))：..*表示包含子包 匹配指定类所有方法：execution(* com.zero.service.UserService.*(..)) 匹配实现特定接口所有类方法：execution(* com.zero.dao.GenericDao+.*(..)) 匹配所有save开头的方法：execution(* save*(..)) 2.4 为目标类、定义切面类，实现AOP2.4.1 使用前置通知@Before 首先定义目标类ProductDao public class ProductDao { public void save(){ System.out.println(&quot;保存商品。。。&quot;); } public void delete(){ System.out.println(&quot;删除商品。。。&quot;); } public void update(){ System.out.println(&quot;更新商品。。。&quot;); } public void findOne(){ System.out.println(&quot;查询一个商品。。。&quot;); } public void findAll(){ System.out.println(&quot;查询所有商品。。。&quot;); } } 定义切面类 &#x2F;** * 切面类，注解方式 *&#x2F; @Aspect public class MyAspectAnno { @Before(value = &quot;execution( * com.zero.aspectj.demo1.ProductDao.*(..))&quot;) &#x2F;&#x2F; 匹配任意返回值类型的，具体目标类(com.zero.aspectj.demo1.ProductDao)下的所有任意参数的方法 public void before(JoinPoint joinPoint){ System.out.println(&quot;前置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+joinPoint); &#x2F;&#x2F; 可以在方法中传入JoinPoint对象，用来获得切点信息，格式为：前置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;execution(void com.zero.aspectj.demo1.ProductDao.save()) } } 配置xml文件 &lt;!--开启AspectJ自动代理--&gt; &lt;aop:aspectj-autoproxy&#x2F;&gt; &lt;!--目标类--&gt; &lt;bean id=&quot;productDao&quot; class=&quot;com.zero.aspectj.demo1.ProductDao&quot;&#x2F;&gt; &lt;!--切面类--&gt; &lt;bean class=&quot;com.zero.aspectj.demo1.MyAspectAnno&quot;&#x2F;&gt; 测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class Demo1Test { @Resource(name = &quot;productDao&quot;) &#x2F;&#x2F; 注入目标类 private ProductDao productDao; @Test public void test1(){ productDao.save(); productDao.delete(); productDao.update(); productDao.findAll(); productDao.findOne(); } } 目标类定义方法时，注意要写上访问权限修饰符public，不然定义execution( * com.zero.aspectj.demo1.ProductDao.*(..))时会匹配不到方法 2.4.2 使用后置通知@AfterReturning 只需要在切面类中定义后置通知方法即可，如果目标方法有返回值，可以通过设置returning属性，来获取返回值。 &#x2F;&#x2F; 示例update有返回值，返回更新商品人员 public String update(){ System.out.println(&quot;更新商品。。。&quot;); return &quot;某某某更新了商品&quot;; } &#x2F;&#x2F; 使用后置通知，定义增强方法 @AfterReturning(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.update(..))&quot;,returning = &quot;result&quot;) public void afterReturning(Object result){ &#x2F;&#x2F; 通过returning属性，可以定义方法返回值，作为参数 System.out.println(&quot;后置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+result); } 2.4.3 使用环绕通知@Around Around方法的返回值就是目标代理方法执行的返回值 通过参数ProceedingJoinPoing，可以拦截目标方法执行 示例定义环绕通知方法 &#x2F;&#x2F; 环绕通知 @Around(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.delete(..))&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(&quot;环绕前通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); &#x2F;&#x2F; 环绕前代码区 Object obj = joinPoint.proceed(); &#x2F;&#x2F; 执行目标方法 System.out.println(&quot;环绕后通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);&#x2F;&#x2F; 环绕后代码区 return obj; } 如果不调用ProceedingJoinPoing的proceed方法，那么目标方法就不会被执行，即被拦截了。 2.4.4 异常抛出通知@AfterThrowing 通过设置throwing属性，可以设置发生异常时的处理 &#x2F;&#x2F; 目标类 public void findOne(){ System.out.println(&quot;查询一个商品。。。&quot;); int i = 1&#x2F;0; &#x2F;&#x2F; 手动制造一个异常，测试异常通知 } &#x2F;&#x2F; 切面类中定义异常通知操作 &#x2F;&#x2F; 异常通知 @AfterThrowing(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.findOne(..))&quot;,throwing = &quot;error&quot;) &#x2F;&#x2F; 设置throwing，获取异常信息 public void afterThrowing(Throwable error){ System.out.println(&quot;某某某方法有异常抛出&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+error.getMessage()); } 2.4.5 最终通知@After 无论是否出现异常，最终通知总是会被执行的 &#x2F;&#x2F; 目标类 public void findAll(){ System.out.println(&quot;查询所有商品。。。&quot;); int i = 1&#x2F;0; &#x2F;&#x2F; 手动制造异常，测试最终通知 } &#x2F;&#x2F; 最终通知,无论增强方法是否有异常都会执行 @After(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.findAll(..))&quot;) public void after(){ System.out.println(&quot;最终通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } 2.4.6 通过@Pointcut为切点命名 在每个通知内定义切点，会造成工作量大，不易维护，对于重复的切点，可以使用@Pointcut进行定义 切点方法：private void 无参方法，方法名为切点名 当通知多个切点时，可以使用||进行连接。 切面类代码示例 @Aspect public class MyAspectAnno { &#x2F;&#x2F; 前置通知 @Before(value = &quot;savePointcut()&quot;) &#x2F;&#x2F; 匹配任意返回值类型的，具体目标类(com.zero.aspectj.demo1.ProductDao)下的所有任意参数的方法 public void before(JoinPoint joinPoint){ System.out.println(&quot;前置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+joinPoint); &#x2F;&#x2F; 可以在方法中传入JoinPoint对象，用来获得切点信息，格式为：前置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;execution(void com.zero.aspectj.demo1.ProductDao.save()) } &#x2F;&#x2F; 后置通知 @AfterReturning(value = &quot;updatePointcut()||findOnePointcut()&quot;,returning = &quot;result&quot;) &#x2F;&#x2F; 多个切点通知，用||连接 public void afterReturning(Object result){ &#x2F;&#x2F; 通过returning属性，可以定义方法返回值，作为参数 System.out.println(&quot;后置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+result); } &#x2F;&#x2F; 环绕通知 @Around(value = &quot;deletePointcut()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(&quot;环绕前通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); Object obj = joinPoint.proceed(); &#x2F;&#x2F; 执行目标方法 System.out.println(&quot;环绕后通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); return obj; } &#x2F;&#x2F; 异常通知 @AfterThrowing(value = &quot;findOnePointcut()&quot;,throwing = &quot;error&quot;) &#x2F;&#x2F; 设置throwing，获取异常信息 public void afterThrowing(Throwable error){ System.out.println(&quot;某某某方法有异常抛出&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+error.getMessage()); } &#x2F;&#x2F; 最终通知 @After(value = &quot;findAllPointcut()&quot;) public void after(){ System.out.println(&quot;最终通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } &#x2F;&#x2F; 使用Pointcut为所有切点命名 @Pointcut(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.save(..))&quot;) private void savePointcut(){} @Pointcut(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.delete(..))&quot;) private void deletePointcut(){} @Pointcut(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.update(..))&quot;) private void updatePointcut(){} @Pointcut(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.findOne(..))&quot;) private void findOnePointcut(){} @Pointcut(value = &quot;execution(* com.zero.aspectj.demo1.ProductDao.findAll(..))&quot;) private void findAllPointcut(){} } 3. XML方式实现AOP3.1 使用XML配置切面 编写客户类及其实现类 public class CustomerDaoImpl implements CustomerDao{ public void save() { System.out.println(&quot;保存客户...&quot;); } public void update() { System.out.println(&quot;修改客户...&quot;); } public void delete() { System.out.println(&quot;删除客户...&quot;); } public void findOne() { System.out.println(&quot;查询一个客户...&quot;); } public void findAll() { System.out.println(&quot;查询全部客户...&quot;); } } 编写切面类 &#x2F;** * 切面类，XML方式 *&#x2F; public class MyAspectXml { &#x2F;&#x2F; 前置通知 public void before(){ System.out.println(&quot;XML方式的前置通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } public void afterReturning(Object obj){ System.out.println(&quot;后置增强&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+obj); } public Object around(ProceedingJoinPoint joinPoint) throws Throwable{ System.out.println(&quot;环绕前增强&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); Object obj = joinPoint.proceed(); System.out.println(&quot;环绕后增强&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); return obj; } public void afterThrowing(Throwable e){ System.out.println(&quot;异常抛出通知&gt;&gt;&gt;&gt;&gt;&gt;&quot;+e.getMessage()); } public void after(){ System.out.println(&quot;最终通知&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } } 完成切面类的配置 &lt;!--使用XML配置方式完成AOP开发--&gt; &lt;!--配置目标类--&gt; &lt;bean id=&quot;customerDao&quot; class=&quot;com.zero.aspectj.demo2.CustomerDaoImpl&quot;&#x2F;&gt; &lt;!--配置切面类--&gt; &lt;bean id=&quot;myAspectXml&quot; class=&quot;com.zero.aspectj.demo2.MyAspectXml&quot;&#x2F;&gt; 配置AOP完成增强 &lt;!--进行AOP相关配置--&gt; &lt;aop:config&gt; &lt;!--配置切入点：哪些类的哪些方法需要增强--&gt; &lt;aop:pointcut id=&quot;savePointcut&quot; expression=&quot;execution(* com.zero.aspectj.demo2.CustomerDao.save(..))&quot;&#x2F;&gt; &lt;aop:pointcut id=&quot;updatePointcut&quot; expression=&quot;execution(* com.zero.aspectj.demo2.CustomerDao.update(..))&quot;&#x2F;&gt; &lt;aop:pointcut id=&quot;deletePointcut&quot; expression=&quot;execution(* com.zero.aspectj.demo2.CustomerDao.delete(..))&quot;&#x2F;&gt; &lt;aop:pointcut id=&quot;findOnePointcut&quot; expression=&quot;execution(* com.zero.aspectj.demo2.CustomerDao.findOne(..))&quot;&#x2F;&gt; &lt;aop:pointcut id=&quot;findAllPointcut&quot; expression=&quot;execution(* com.zero.aspectj.demo2.CustomerDao.findAll(..))&quot;&#x2F;&gt; &lt;!--配置AOP的切面--&gt; &lt;aop:aspect ref=&quot;myAspectXml&quot;&gt; &lt;!--配置前置通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;savePointcut&quot;&#x2F;&gt; &lt;!--配置后置通知--&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;updatePointcut&quot; returning=&quot;obj&quot;&#x2F;&gt; &lt;!--配置环绕通知--&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;deletePointcut&quot;&#x2F;&gt; &lt;!--配置异常抛出通知--&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;findOnePointcut&quot; throwing=&quot;e&quot;&#x2F;&gt; &lt;!--配置最终通知--&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;findAllPointcut&quot; &#x2F;&gt; &lt;&#x2F;aop:aspect&gt; &lt;&#x2F;aop:config&gt; 测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext2.xml&quot;) public class Demo2Test { @Resource(name = &quot;customerDao&quot;) private CustomerDao customerDao; @Test public void test1(){ customerDao.save(); customerDao.update(); customerDao.delete(); customerDao.findOne(); customerDao.findAll(); } } 总结 使用AspectJ完成AOP开发所需环境的配置，需要哪些jar包? &lt;!--导入Spring基本开发包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-beans&lt;&#x2F;artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-beans&lt;&#x2F;artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--导入AOP相关包--&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;&#x2F;groupId&gt; &lt;artifactId&gt;aopalliance&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--导入AspectJ相关包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt; &lt;artifactId&gt;aspectjrt&lt;&#x2F;artifactId&gt; &lt;version&gt;1.8.9&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--导入测试相关包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--导入DI属性注入相关包,java注解类--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 注解方式实现AOP AspectJ的各种通知类型 切面类的定义，切入点的配置 XML方式实现AOP，AOP的XML配置","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zero024.cn/tags/Spring/"}]},{"title":"Spring的AOP","slug":"FrameWork/Spring的AOP","date":"2019-08-08T14:30:00.000Z","updated":"2020-03-25T01:16:42.671Z","comments":true,"path":"FrameWork/Spring-Aop.html","link":"","permalink":"https://zero024.cn/FrameWork/Spring-Aop.html","excerpt":"1. AOP的概念1.1 什么是AOP？在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。","text":"1. AOP的概念1.1 什么是AOP？在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP(Aspect Oriented Programing)，面向切面编程 AOP采取横向抽取的机制，取代了传统纵向继承体系重复性代码(性能监视、事务管理、安全检查、缓存) Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码。 1.2 AOP相关术语 Joinpoint(连接点)：所谓连接点是指那些被拦截到的点。在spring中，这些点指的是方法，因为spirng只支持方法类型的连接点。 Pointcut(切入点)：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。 Advice(通知/增强)：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。通知分为前置通知，后置通知，异常通知，最终通知，环绕通知(切面要完成的功能) Introduction(引介)：引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Filed。 Target(目标对象)：代理的目标对象。 Weaving(织入)：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译器织入和类装载期织入。 Proxy(代理)：一个类被AOP织入增强后，就产生一个结果代理类。 Aspect(切面)：是切入点和通知(引介)的结合。 2. AOP的底层实现2.1 JDK动态代理使用JDK本身的一个类Proxy来实现动态代理，核心代码如下： public class MyJDKProxy implements InvocationHandler { private final UserDao userDao; public MyJDKProxy(UserDao userDao){ this.userDao = userDao; } public Object createProxy(){ Object proxy = Proxy.newProxyInstance(userDao.getClass().getClassLoader(),userDao.getClass().getInterfaces(),this); return proxy; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;所有代理对象的方法都会经过invoke调用&quot;); if (&quot;save&quot;.equals(method.getName())){ &#x2F;&#x2F; 进行权限校验代码区 System.out.println(&quot;权限校验...&quot;); return method.invoke(userDao,args); } return method.invoke(userDao,args); } } 2.2 使用CGLIB生成代理 对于不使用接口的业务类，无法使用JDK动态代理 CGlib采用非常底层字节码技术，可以为一个类创建子类，解决无接口代理问题。 &#x2F;** * 示意CGlib生成代理 *&#x2F; public class MyCGlibProxy implements MethodInterceptor { private final UserDao userDao; public MyCGlibProxy(UserDao userDao){ this.userDao = userDao; } public Object createProxy(){ &#x2F;&#x2F; 1. 创建核心类 Enhancer enhancer = new Enhancer(); &#x2F;&#x2F; 2. 设置父类 enhancer.setSuperclass(userDao.getClass()); &#x2F;&#x2F; 3. 设置回调 enhancer.setCallback(this); &#x2F;&#x2F; 4. 生成代理 Object proxy = enhancer.create(); return proxy; } public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { if (&quot;save&quot;.equals(method.getName())){ System.out.println(&quot;权限校验&quot;); return methodProxy.invokeSuper(proxy,args); } return methodProxy.invokeSuper(proxy,args); } } 2.3 小结 Spring在运行期，生成动态代理对象，不需要特殊的编译器 Spring AOP的底层就是通过JDK动态代理或CGlib动态代理技术为目标Bean执行横向织入 若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理 若目标对象没有实现任何接口，spring使用CGlib库生成目标对象的子类 程序中应优先对接口创建代理，便于程序解耦维护 标记为final的方法，不能被代理，因为无法进行覆盖 JDK动态代理，是针对接口生成子类，接口中方法不能使用final修饰 CGlib是针对目标类生成子类，因此类或方法不能使用final Spring只支持方法连接点，不提供属性连接 3. Spring的传统AOP3.1 Spring AOP增强类型 AOP联盟为通知Advice定义了org.aopalliance.aop.Interface.Advice Spring按照通知Advice在目标类方法的连接点位置，可以分为5类 前置通知org.springframework.aop.MethodBeforeAdvice：在目标方法执行前实施增强 后置通知org.springframework.aop.AfterReturningAdvice：在目标方法执行后实施增强 环绕通知org.aopalliance.intercept.MethodInterceptor：在目标方法执行前后实施增强 异常抛出通知org.springframework.aop.ThrowsAdvice：在方法抛出异常后实施增强 引介通知org.springframework.aop.IntroductionInterceptor：在目标类中添加一些新的方法和属性 3.2 Spring AOP切面类型 Advisor：代表一般切面，Advice本身就是一个切面，对目标类所有方法进行拦截 PointcutAdvisor：代表具有切点的切面，可以指定拦截目标类哪些方法 IntroductionAdvisor：代表引介切面，针对引介通知而使用切面(了解即可) 3.3 Advisor切面案例ProxyFactoryBean常用可配置属性： target：代理的目标对象 proxyInterfaces：代理要实现的接口 proxyTargetClass：是否对类代理而不是接口，设置为true时，使用CGlib代理 interceptorNames：需要织入目标的Advice singleton：返回代理是否为单实例，默认为单例 optimize：当设置为true时，强制使用CGlib 代码示例： 创建学生接口及其实现类 public interface StudentDao { void save(); void update(); void delete(); void find(); } public class StudentDaoImpl implements StudentDao { public void save() { System.out.println(&quot;学生保存&quot;); } public void update() { System.out.println(&quot;学生修改&quot;); } public void delete() { System.out.println(&quot;学生删除&quot;); } public void find() { System.out.println(&quot;学生查询&quot;); } } 创建前置通知增强类 &#x2F;&#x2F; 使用前置通知实现增强类 public class MyBeforeAdvice implements MethodBeforeAdvice { public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(&quot;前置增强&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } } 配置xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;!-- 配置目标类--&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.zero.aop.demo2.StudentDaoImpl&quot;&#x2F;&gt; &lt;!-- 前置通知类型--&gt; &lt;bean id=&quot;myBeforeAdvice&quot; class=&quot;com.zero.aop.demo2.MyBeforeAdvice&quot;&#x2F;&gt; &lt;!-- Sprint AOP 产生代理对象--&gt; &lt;bean id=&quot;studentDaoProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;!-- 配置目标类--&gt; &lt;property name=&quot;target&quot; ref=&quot;studentDao&quot;&#x2F;&gt; &lt;!-- 实现的接口--&gt; &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.zero.aop.demo2.StudentDao&quot;&#x2F;&gt; &lt;!-- 采用拦截的名称--&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;myBeforeAdvice&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;beans&gt; 测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class demo2Test { &#x2F;&#x2F; @Resource(name = &quot;studentDao&quot;) @Resource(name = &quot;studentDaoProxy&quot;) &#x2F;&#x2F; 使用代理对象 private StudentDao studentDao; @Test public void test1(){ studentDao.find(); studentDao.delete(); studentDao.save(); studentDao.update(); } } 3.4 PoingcutAdvisor切点切面 使用普通Advice作为切面，将对目标类所有方法进行拦截，不够灵活，在实际开发中常采用带有切点的切面 常用PointcutAdvisor实现类 DefaultPointcutAdvisor：最常用的切面类型，它可以通过任意Pointcut和Advice组合定义切面 JdkRegexpMethodPointcut：构造正则表达式切点 示例，创建客户类 public class CustomerDao { public void save() { System.out.println(&quot;客户保存&quot;); } public void update() { System.out.println(&quot;客户修改&quot;); } public void delete() { System.out.println(&quot;客户删除&quot;); } public void find() { System.out.println(&quot;客户查询&quot;); } } 创建环绕通知型增强类 public class MyAroundAdvice implements MethodInterceptor { public Object invoke(MethodInvocation invocation) throws Throwable { System.out.println(&quot;环绕前增强&gt;&gt;&gt;&gt;&gt;&gt;&quot;); &#x2F;&#x2F; 执行目标方法 Object obj = invocation.proceed(); System.out.println(&quot;环绕后增强&gt;&gt;&gt;&gt;&gt;&gt;&quot;); return obj; } } 配置xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;!--配置目标类--&gt; &lt;bean id=&quot;customerDao&quot; class=&quot;com.zero.aop.demo3.CustomerDao&quot;&#x2F;&gt; &lt;!--配置通知--&gt; &lt;bean id=&quot;myAroundAdvice&quot; class=&quot;com.zero.aop.demo3.MyAroundAdvice&quot;&#x2F;&gt; &lt;!--一般的切面是使用通知作为切面的，因为要对目标类的指定方法进行增强就需要配置一个带有切入点的切面--&gt; &lt;bean id=&quot;MyAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt; &lt;!--pattern中配置正则表达式，以达到对指定方法进行增强的效果--&gt; &lt;!-- 对单个方法进行增强使用pattern即可 如果对多个方法，需使用patterns，多个值用逗号隔开 --&gt; &lt;!--&lt;property name=&quot;pattern&quot; value=&quot;.*save.*&quot;&#x2F;&gt;--&gt; &lt;property name=&quot;patterns&quot; value=&quot;.*save.*,.*delete.*&quot;&#x2F;&gt; &lt;property name=&quot;advice&quot; ref=&quot;myAroundAdvice&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--配置产生代理--&gt; &lt;bean id=&quot;customerDaoProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;customerDao&quot;&#x2F;&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot;&#x2F;&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;MyAdvisor&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;beans&gt; 测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext2.xml&quot;) public class demo3Test { &#x2F;&#x2F; @Resource(name=&quot;customerDao&quot;) &#x2F;&#x2F; 不使用代理 @Resource(name = &quot;customerDaoProxy&quot;) &#x2F;&#x2F; 使用代理对象 private CustomerDao customerDao; @Test public void test1(){ customerDao.find(); customerDao.delete(); customerDao.save(); customerDao.update(); } } 4. Spring传统AOP的自动代理 前面的案例中，每个代理都是通过ProxyFactoryBean织入切面代理，在实际开发中，非常多的Bean每个都配置ProxyFactoryBean的话，开发维护量巨大 解决方案：自动创建代理 BeanNameAutoProxyCreator：根据Bean名称创建代理 DefaultAdvisorAutoProxyCreator：根据Advisor本身包含信息创建代理 AnnotationAwareAspectJAutoProxyCreator：基于Bean中的AspectJ注解进行自动代理 4.1 基于Bean名称的自动代理 代码示例对所有以DAO结尾Bean所有方法进行代理 将前面案例的CustomerDao,StudentDao,StudentDaoImpl,MyBeforeAdvice,MyAroundAdvice复制到一个文件夹，然后配置xml。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;!-- 配置目标类--&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.zero.aop.demo4.StudentDaoImpl&quot;&#x2F;&gt; &lt;bean id=&quot;customerDao&quot; class=&quot;com.zero.aop.demo4.CustomerDao&quot;&#x2F;&gt; &lt;!--配置通知：前置通知--&gt; &lt;bean id=&quot;myBeforeAdvice&quot; class=&quot;com.zero.aop.demo4.MyBeforeAdvice&quot;&#x2F;&gt; &lt;!--配置通知：环绕通知--&gt; &lt;bean id=&quot;myAroundAdvice&quot; class=&quot;com.zero.aop.demo4.MyAroundAdvice&quot;&#x2F;&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt; &lt;property name=&quot;beanNames&quot; value=&quot;*Dao&quot;&#x2F;&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;myBeforeAdvice&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;beans&gt; 测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext3.xml&quot;) public class demo4Test { @Resource(name = &quot;studentDao&quot;) private StudentDao studentDao; @Resource(name = &quot;customerDao&quot;) private CustomerDao customerDao; @Test public void test1(){ studentDao.find(); studentDao.delete(); studentDao.save(); studentDao.update(); customerDao.find(); customerDao.delete(); customerDao.save(); customerDao.update(); } } 4.2 基于切面信息的自动代理 配置环绕代理，将上述案例xml修改如下即可对指定方法进行增强 &lt;!--根据切面信息创建代理--&gt; &lt;!--配置目标类--&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.zero.aop.demo4.StudentDaoImpl&quot;&#x2F;&gt; &lt;bean id=&quot;customerDao&quot; class=&quot;com.zero.aop.demo4.CustomerDao&quot;&#x2F;&gt; &lt;!--配置通知：前置通知--&gt; &lt;bean id=&quot;myBeforeAdvice&quot; class=&quot;com.zero.aop.demo4.MyBeforeAdvice&quot;&#x2F;&gt; &lt;!--配置通知：环绕通知--&gt; &lt;bean id=&quot;myAroundAdvice&quot; class=&quot;com.zero.aop.demo4.MyAroundAdvice&quot;&#x2F;&gt; &lt;!--配置切面--&gt; &lt;bean id=&quot;myAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt; &lt;!--对指定包下指定方法进行增强,注意转义--&gt; &lt;property name=&quot;pattern&quot; value=&quot;com\\.zero\\.aop\\.demo4\\.CustomerDao\\.save&quot;&#x2F;&gt; &lt;property name=&quot;advice&quot; ref=&quot;myAroundAdvice&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;&gt;&lt;&#x2F;bean&gt; 总结 什么是AOP 了解AOP相关术语：连接点，切入点，织入，目标对象，代理对象等。 传统AOP实现原理：JDK动态代理，CGlib代理 Spring的传统AOP：增强类型，切面类型。没有切入点的切面和有切入点的切面。 自动代理：基于Bean名称的，基于切面信息的","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zero024.cn/tags/Spring/"}]},{"title":"SpringBean管理","slug":"FrameWork/Spring Bean管理","date":"2019-08-07T12:28:00.000Z","updated":"2020-03-25T01:16:36.558Z","comments":true,"path":"FrameWork/Spring-Bean.html","link":"","permalink":"https://zero024.cn/FrameWork/Spring-Bean.html","excerpt":"1. Spring的工厂类ApplicationContext是继承自BeanFactory的。BeanFactory是一个老版本的工厂类，只有在调用getBean方法时，才会生成类的实例。","text":"1. Spring的工厂类ApplicationContext是继承自BeanFactory的。BeanFactory是一个老版本的工厂类，只有在调用getBean方法时，才会生成类的实例。 ApplicationContext工厂在加载配置文件时，就会将Spring管理的类都实例化。 加载配置文件一般使用以下两个实现类： ClassPathXmlApplicationContext：加载类路径下的配置文件（src下） FileSystemXmlApplicationContext：加载文件系统下的配置文件（磁盘下的文件） 2. Spring的Bean管理(XML方式)2.1 使用类构造器实例化(默认无参数) 编写Bean1类： &#x2F;** * Bean的实例化的三种方式：采用无参数的构造方法的方式 *&#x2F; public class Bean1 { public Bean1(){ System.out.println(&quot;Bean1被实例化了...&quot;); } } 在xml中配置如下内容： &lt;!-- Bean的实例化的三种方式--&gt; &lt;!-- 第一种：无参构造器的方式--&gt; &lt;bean id=&quot;bean1&quot; class=&quot;com.zero.ioc.demo1.Bean1&quot;&gt;&lt;&#x2F;bean&gt; 在测试方法中加载对象，并完成实例化 @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Bean1 bean1 = (Bean1) context.getBean(&quot;bean1&quot;); } 2.2 使用静态工厂方法实例化(简单工厂模式) 编写Bean2类 &#x2F;** * Bean的实例化的三种方式：使用静态工厂方法实例化 *&#x2F; public class Bean2 { } 编写静态工厂类 &#x2F;&#x2F; Bean2的静态工厂 public class Bean2Factory { public static Bean2 createBean2(){ System.out.println(&quot;Bean2Factory已执行...&quot;); return new Bean2(); } } 配置xml &lt;!-- 第二种：静态工厂的方式--&gt; &lt;bean id=&quot;bean2&quot; class=&quot;com.zero.ioc.demo1.Bean2Factory&quot; factory-method=&quot;createBean2&quot;&#x2F;&gt; 测试 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Bean2 bean2 = (Bean2) context.getBean(&quot;bean2&quot;); } JDK12和Spring3.2不兼容！！！在使用静态工厂方法实例化对象时，会导致java.lang.IllegalArgumentException异常，更换Spring版本至4.2即可。 2.3 使用实例工厂方法实例化(工厂方法模式) 编写Bean3类 &#x2F;** * Bean的实例化三种方式：实例工厂实例化 *&#x2F; public class Bean3 { } 编写实例工厂类 public class Bean3Factory { public Bean3 createBean3(){ System.out.println(&quot;Bean3Factory执行了...&quot;); return new Bean3(); } } 配置xml &lt;!-- 第三种：实例工厂的方式--&gt; &lt;bean id=&quot;bean3Factory&quot; class=&quot;com.zero.ioc.demo1.Bean3Factory&quot;&#x2F;&gt; &lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;createBean3&quot;&#x2F;&gt; 测试 @Test public void test3(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Bean3 bean3 = (Bean3) context.getBean(&quot;bean3&quot;); } 2.4 Bean的配置 id和name 一般情况下，装配一个Bean时，通过指定一个id属性作为Bean的名称 id属性在IOC容器中必须是唯一的 如果Bean的名称中含有特殊字符，就需要使用name属性 class class用于设置一个类的完全路径名称，主要作用是IOC容器生成类的实例 2.5 Bean的作用域 类别 说明 singleton 在SpringIOC容器中仅存在一个Bean实例，Bean以单实例的方式存在 prototype 每次调用getBean()时都会返回一个新的实例 request 每次HTTP请求都会创建一新的Bean，该作用域仅适用于WebApplicationContext环境 session 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。该作用域仅适用于WebApplicationContext环境 在xml中配置 &lt;!-- Bean的作用范围--&gt; &lt;!--仅存在一个Bean实例，单实例--&gt; &lt;bean id=&quot;person&quot; class=&quot;com.zero.ioc.demo2.Person&quot; scope=&quot;singleton&quot;&#x2F;&gt; &lt;!--每次调用getBean()都会返回一个新实例--&gt; &lt;bean id=&quot;person&quot; class=&quot;com.zero.ioc.demo2.Person&quot; scope=&quot;prototype&quot;&#x2F;&gt; 2.6 Spring容器中Bean的生命周期Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean时调用bean的两个生命周期方法。 &lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&#x2F;&gt; &lt;!-- 当bean被载入到容器时调用init 当bean从容器中删除时调用destroy(必须是单例bean才会自动调用，即scope=&quot;singleton&quot;才有效) --&gt; web容器中会自动调用，但是main函数或测试用例需手动调用。 示例，创建一个man类 public class Man { public Man(){ System.out.println(&quot;Man被实例化了&quot;); } public void setup(){ System.out.println(&quot;Man被初始化了&quot;); } public void myDestroy(){ System.out.println(&quot;Man被销毁了&quot;); } } 配置xml &lt;bean id=&quot;man&quot; class=&quot;com.zero.ioc.demo2.Man&quot; init-method=&quot;setup&quot; destroy-method=&quot;myDestroy&quot;&#x2F;&gt; 测试 @Test public void test2(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Man man = (Man) context.getBean(&quot;man&quot;); context.close(); } 2.6.1 Bean完整生命周期过程完整生命周期总共有11个步骤。 instantiate bean，对象实例化 populate properties，封装属性 如果Bean实现BeanNameAware执行setBeanName 如果Bean实现BeanFactoryAware或者ApplicationContextAware设置工厂setBeanFactory或者上下文对象setApplicationContext 如果存在类实现BeanPostProcessor(后处理Bean)，执行postProcessBeforeInitialization 如果Bean实现InitializingBean执行afterPropertiesSet 调用&lt;bean init-method=&quot;init&quot;&gt;指定初始化方法init 如果存在类实现BeanPostProcessor(处理Bean)，执行postProcessAfterInitialization 执行业务处理 如果Bean实现DisposableBean执行destroy 调用&lt;bean destroy-method=&quot;customerDestroy&quot;&gt;指定销毁方法customerDestroy 代码演示： 编写man类 public class Man implements BeanNameAware, ApplicationContextAware, InitializingBean, DisposableBean { private String name; public String getName() { return name; } public void setName(String name) { System.out.println(&quot;第二步：设置属性&quot;); this.name = name; } public Man(){ System.out.println(&quot;第一步：实例化。。。&quot;); } public void setup(){ System.out.println(&quot;第七步：Man被初始化了&quot;); } public void myDestroy(){ System.out.println(&quot;第十一步：执行自己定义的销毁方法&quot;); } @Override public void setBeanName(String s) { System.out.println(&quot;第三步：设置Bean的名称&quot;+s); &#x2F;&#x2F; 就是xml中配置的id的值 } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { System.out.println(&quot;第四步：了解工厂信息&quot;); } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;第六步：属性设置后执行 &quot;); } public void run(){ System.out.println(&quot;第九步：执行业务方法 &quot;); } public void destroy() throws Exception{ System.out.println(&quot;第十步：执行Spring的销毁方法&quot;); } } 编写MyBeanPostProcessor类 public class MyBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object o, String s) throws BeansException { System.out.println(&quot;第五步：初始化前方法。。。&quot;); return o; } @Override public Object postProcessAfterInitialization(Object o, String s) throws BeansException { System.out.println(&quot;第八步：初始化后方法。。。&quot;); return o; } } 配置xml &lt;bean id=&quot;man&quot; class=&quot;com.zero.ioc.demo2.Man&quot; init-method=&quot;setup&quot; destroy-method=&quot;myDestroy&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;bean class=&quot;com.zero.ioc.demo2.MyBeanPostProcessor&quot;&#x2F;&gt; 测试 @Test public void test2(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Man man = (Man) context.getBean(&quot;man&quot;); man.run(); context.close(); } &#x2F;** 输出结果: 第一步：实例化。。。 第二步：设置属性 第三步：设置Bean的名称man 第四步：了解工厂信息 第五步：初始化前方法。。。 第六步：属性设置后执行 第七步：Man被初始化了 第八步：初始化后方法。。。 第九步：执行业务方法 8月 06, 2019 7:48:41 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose 信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@7823a2f9: startup date [Tue Aug 06 19:48:41 CST 2019]; root of context hierarchy 第十步：执行Spring的销毁方法 第十一步：执行自己定义的销毁方法 *&#x2F; 3. Spring的属性注入(XML方式)对于类成员变量，注入方式有三种：构造函数注入、属性setter方法注入、接口注入 Spring支持前两种 3.1 属性注入-构造方法注入 通过构造方法注入Bean的属性值或依赖的对象，它保证了Bean实例在实例化后就可以使用。 构造器注入通过&lt;constructor-arg&gt;元素来声明属性 代码示例 创建user类 public class User { private String name; private Integer age; public User(String name, Integer age){ this.name = name; this.age = age; } @Override public String toString() { return &quot;User{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &#39;}&#39;; } } 配置xml &lt;!-- Spring属性注入-通过构造方法注入--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.zero.ioc.demo3.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&#x2F;&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;22&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 测试 public class demo3Test { @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); System.out.println(user); } } 3.2 属性注入-set方法注入 使用set方法注入，在Spring配置文件中，通过&lt;property&gt;设置注入的属性 代码示例 创建person类 public class Person { private String name; private Integer age; private Cat cat; &#x2F;&#x2F; 省略get&#x2F;set方法 @Override public String toString() { return &quot;Person{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &quot;, cat=&quot; + cat + &#39;}&#39;; } } 创建cat类 public class Cat { private String name; @Override public String toString() { return &quot;Cat{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;}&#39;; } &#x2F;&#x2F; 省略get&#x2F;set方法 } 配置xml &lt;!-- Spring属性注入-通过set方法注入--&gt; &lt;bean id=&quot;person&quot; class=&quot;com.zero.ioc.demo3.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;李四&quot;&#x2F;&gt; &lt;property name=&quot;age&quot; value=&quot;25&quot;&#x2F;&gt; &lt;!-- ref可以引入其他bean的id或name--&gt; &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.zero.ioc.demo3.Cat&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;ketty&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 测试 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Person person = (Person) context.getBean(&quot;person&quot;); System.out.println(person); &#x2F;&#x2F; Person{name=&#39;李四&#39;, age=25, cat=Cat{name=&#39;ketty&#39;}} } 普通类型的值使用value设置值，对象类型的值使用ref。 3.3 属性注入-p名称空间使用p命名空间：为了简化xml文件配置，Spring从2.5开始引入一个新的p名称空间。 语法：p:&lt;属性名&gt;=&quot;xxx&quot; 引入常量值，p:&lt;属性名&gt;-ref=&quot;xxx&quot;引用其他Bean对象 示例，配置xml， &lt;!--先在beans中添加:xmlns:p=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;，引入p命名空间--&gt; &lt;!-- Spring属性注入-通过p名称空间注入--&gt; &lt;!--修改原有的person配置如下，即可实现通过p名称空间注入--&gt; &lt;bean id=&quot;person&quot; class=&quot;com.zero.ioc.demo3.Person&quot; p:name=&quot;赵钱&quot; p:age=&quot;26&quot; p:cat-ref=&quot;cat&quot;&#x2F;&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.zero.ioc.demo3.Cat&quot; p:name=&quot;小黑&quot;&#x2F;&gt; 3.4 属性注入-SpEL注入 SpEL：spring expression language，Spring表达式语言，对依赖注入进行简化 语法：#{表达式}，&lt;bean id=&quot;&quot; value=&quot;#{表达式}&quot;/&gt; Spel表达式语法： 基本语法：#{} #{&#39;hello&#39;}:使用字符串 #{beanId}:使用另一个bean #{beanId.method()}:指定bean和对应方法，并执行方法 #{T(java.lang.Math).PI}:使用静态字段或方法 示例如下，创建Product和Category类用于测试 public class Product { private String name; private Double price; private Category category; @Override public String toString() { return &quot;Product{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, price=&quot; + price + &quot;, category=&quot; + category + &#39;}&#39;; } &#x2F;&#x2F; 省略get&#x2F;set方法 } public class Category { private String name; @Override public String toString() { return &quot;Category{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;}&#39;; } &#x2F;&#x2F; 省略get&#x2F;set方法 } 创建简单的计算类 public class ProductInfo { public Double addPrice(){ return Math.random() * 20; } } 配置xml &lt;!-- Spring属性注入-通过SpEL注入--&gt; &lt;bean id=&quot;category&quot; class=&quot;com.zero.ioc.demo3.Category&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#{&#39;水果&#39;}&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;bean id=&quot;productInfo&quot; class=&quot;com.zero.ioc.demo3.ProductInfo&quot;&#x2F;&gt; &lt;bean id=&quot;product&quot; class=&quot;com.zero.ioc.demo3.Product&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#{&#39;西瓜&#39;}&quot;&#x2F;&gt; &lt;property name=&quot;price&quot; value=&quot;#{productInfo.addPrice()}&quot;&#x2F;&gt; &lt;property name=&quot;category&quot; value=&quot;#{category}&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; 测试 @Test public void test3(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Product product = (Product) context.getBean(&quot;product&quot;); System.out.println(product); } 3.5 复杂类型的属性注入 数组类型的属性注入 List集合类型的属性注入 Set集合类型的属性注入 Map集合类型的属性注入 Properties类型的属性注入 代码示例如下： 创建集合类CollectionBean public class CollectionBean { private String[] arrs; &#x2F;&#x2F; 数组类型 private List&lt;String&gt; list; &#x2F;&#x2F; List集合类型 private Set&lt;String&gt; set; &#x2F;&#x2F; Set集合类型 private Map&lt;String,Integer&gt; map; &#x2F;&#x2F; Map集合类型 private Properties properties; &#x2F;&#x2F; 属性类型 @Override public String toString() { return &quot;CollectionBean{&quot; + &quot;arrs=&quot; + Arrays.toString(arrs) + &quot;, list=&quot; + list + &quot;, set=&quot; + set + &quot;, map=&quot; + map + &quot;, properties=&quot; + properties + &#39;}&#39;; } &#x2F;&#x2F; 省略get&#x2F;set方法 } 配置xml，添加如下内容 &lt;!-- 复杂类型的属性注入--&gt; &lt;bean id=&quot;collectionBean&quot; class=&quot;com.zero.ioc.demo4.CollectionBean&quot;&gt; &lt;!-- 数组类型的属性注入--&gt; &lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;&#x2F;value&gt; &lt;value&gt;bbb&lt;&#x2F;value&gt; &lt;value&gt;ccc&lt;&#x2F;value&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt; &lt;!-- List集合类型的属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;111&lt;&#x2F;value&gt; &lt;value&gt;222&lt;&#x2F;value&gt; &lt;value&gt;333&lt;&#x2F;value&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt; &lt;!-- set集合类型的属性注入--&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;ddd&lt;&#x2F;value&gt; &lt;value&gt;eee&lt;&#x2F;value&gt; &lt;value&gt;fff&lt;&#x2F;value&gt; &lt;&#x2F;set&gt; &lt;&#x2F;property&gt; &lt;!-- map集合类型的属性注入--&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aaa&quot; value=&quot;111&quot;&#x2F;&gt; &lt;entry key=&quot;bbb&quot; value=&quot;222&quot;&#x2F;&gt; &lt;entry key=&quot;ccc&quot; value=&quot;333&quot;&#x2F;&gt; &lt;&#x2F;map&gt; &lt;&#x2F;property&gt; &lt;!-- Properties类型的属性注入--&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;&#x2F;prop&gt; &lt;prop key=&quot;password&quot;&gt;123456&lt;&#x2F;prop&gt; &lt;&#x2F;props&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; 测试 @Test public void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); CollectionBean collectionBean = (CollectionBean) context.getBean(&quot;collectionBean&quot;); System.out.println(collectionBean); } 4. Spring的Bean管理(注解方式)4.1 使用注解定义Bean Spring2.5 引入使用注解去定义Bean @Component，描述Spring框架中的Bean 除了@Component外，Spring还提供了3个功能基本等效的注解 @Repository：用于对DAO实现类进行标注 @Service：用于对Service实现类进行标注 @Controller：用于对Controller实现类进行标注 这三个注解是为了让标注类本身的用途更加清晰，Spring在后续版本会对其增强。 代码示例 创建UserService类 &#x2F;** * Spring的Bean管理的注解方式： * 传统方式：需要去XML中配置&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;&#x2F;bean&gt; * *&#x2F; @Service(&quot;userService&quot;) public class UserService { public String hello(String name){ return &quot;Hello&quot; + name; } } 配置xml，开启扫描 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=&quot;com.zero.demo1&quot;&#x2F;&gt; &lt;&#x2F;beans&gt; 测试 @Test public void demo1(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); String hello = userService.hello(&quot;小明&quot;); System.out.println(hello); } 5. Spring的属性注入(注解方式) 使用@Autowired进行自动注入 @Autowired默认按照类型进行注入 如果存在两个相同Bean类型相同，则按照名称注入 @Autowired注入时可以针对成员变量或者set方法 通过@Autowired的required属性，设置一定要找到匹配的Bean 使用@Qualifier指定注入Bean的名称 使用Qualifier指定Bean名称后，注解Bean必须指定相同名称 代码示例： 创建一个dao @Repository(&quot;userDao&quot;) public class UserDao { public void save(){ System.out.println(&quot;Dao中保存用户。。。&quot;); } } 修改UserService @Service(&quot;userService&quot;) public class UserService { &#x2F;&#x2F;使用value直接对属性值进行注入 @Value(&quot;苹果&quot;) private String something; &#x2F;&#x2F; 自动注入 @Autowired @Qualifier(&quot;userDao&quot;) &#x2F;&#x2F; 指定注解的Bean名称必须相同‘ @Resource(name=&quot;userDao&quot;) &#x2F;&#x2F; 可以使用@Resource，指定Bean名称 private UserDao dao; public String hello(String name){ return &quot;Hello&quot; + name; } public void eat(){ System.out.println(&quot;eat:&quot;+something); } public void save(){ System.out.println(&quot;Service中保存用户。。。&quot;); dao.save(); } } 测试 @Test public void demo2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.save(); } Spring提供对JSR-250中定义@Resource标准注解的支持 @Resource和@Autowired注解功能相似 如无法使用@Resource，需在pom.xml中引入javax.annotation-api依赖 5.1 Spring的其他注解Spring初始化Bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean时调用bean的两个生命周期方法。 &lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot; init-method=&quot;setup&quot; destroy-method=&quot;teardown&quot;&#x2F;&gt; &lt;!-- 当bean被载入到容器时调用setup,注解方式：@PostConstruct,初始化 当bean从容器中删除时调用teardown(必须是单例bean才会自动调用，即scope=&quot;singleton&quot;才有效) 注解方式：@PreDestroy，销毁 --&gt; 代码示例，创建bean1类 @Component(&quot;bean1&quot;) public class Bean1 { &#x2F;&#x2F; 生命周期注解，初始化 @PostConstruct public void init(){ System.out.println(&quot;initBean...&quot;); } public void say(){ System.out.println(&quot;say...&quot;); } &#x2F;&#x2F; 生命周期注解，销毁 @PreDestroy public void destroy(){ System.out.println(&quot;destroyBean...&quot;); } } 配置xml &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=&quot;com.zero&quot;&#x2F;&gt; 测试 @Test public void test1(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Bean1 bean1 = (Bean1) context.getBean(&quot;bean1&quot;); bean1.say(); context.close(); } 5.2 Bean的作用范围 使用注解配置的Bean和&lt;bean&gt;配置的一样，默认作用范围都是singleton @Scope注解用于指定Bean的作用范围 代码示例： 创建bean2类，设置其作用范围 @Component(&quot;bean2&quot;) @Scope(&quot;prototype&quot;) &#x2F;&#x2F; 设置作用范围，使用多例创建对象 public class Bean2 { } 测试 @Test public void test2(){ ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Bean2 bean1 = (Bean2) context.getBean(&quot;bean2&quot;); Bean2 bean2 = (Bean2) context.getBean(&quot;bean2&quot;); System.out.println(bean1 == bean2); } 5.3 传统XML配置和注解配置混合使用 XML方式的优势 结构清晰，易于阅读 注解方式的优势 开发便捷，属性注入方便 XML与注解的整合开发 引入context命名空间 在配置文件中添加&lt;context:annotation-config/&gt; 代码示例 创建ProductService，ProductDao，CategoryDao，均创建简单的save方法。 public class ProductService { &#x2F;&#x2F; 使用注解 @Resource(name = &quot;categoryDao&quot;) private CategoryDao categoryDao; @Resource(name = &quot;productDao&quot;) private ProductDao productDao; &#x2F;&#x2F; public void setCategoryDao(CategoryDao categoryDao) { &#x2F;&#x2F; this.categoryDao = categoryDao; &#x2F;&#x2F; } &#x2F;&#x2F; &#x2F;&#x2F; public void setProductDao(ProductDao productDao) { &#x2F;&#x2F; this.productDao = productDao; &#x2F;&#x2F; } public void save(){ System.out.println(&quot;ProductService中的save方法执行了...&quot;); categoryDao.save(); productDao.save(); } } public class ProductDao { public void save(){ System.out.println(&quot;ProductDao中的save方法执行了...&quot;); } } public class CategoryDao { public void save(){ System.out.println(&quot;CategoryDao中的save方法执行了...&quot;); } } 配置xml &lt;!--单独开启注解功能--&gt; &lt;context:annotation-config&#x2F;&gt; &lt;bean id=&quot;productService&quot; class=&quot;com.zero.demo3.ProductService&quot;&gt; &lt;!-- &lt;property name=&quot;productDao&quot; ref=&quot;productDao&quot;&#x2F;&gt;--&gt; &lt;!-- &lt;property name=&quot;categoryDao&quot; ref=&quot;categoryDao&quot;&#x2F;&gt;--&gt; &lt;&#x2F;bean&gt; &lt;bean id=&quot;productDao&quot; class=&quot;com.zero.demo3.ProductDao&quot;&#x2F;&gt; &lt;bean id=&quot;categoryDao&quot; class=&quot;com.zero.demo3.CategoryDao&quot;&#x2F;&gt; 测试 @Test public void test1() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ProductService productService = (ProductService) context.getBean(&quot;productService&quot;); productService.save(); }","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zero024.cn/tags/Spring/"}]},{"title":"Spring简单入门","slug":"FrameWork/Spring入门","date":"2019-08-05T13:10:00.000Z","updated":"2020-03-25T01:16:48.304Z","comments":true,"path":"FrameWork/Spring-Basic.html","link":"","permalink":"https://zero024.cn/FrameWork/Spring-Basic.html","excerpt":"1. Spring介绍Spring是一个开源框架，于2003年兴起的轻量级Java开发框架。Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。 简单来说：Spring是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架。","text":"1. Spring介绍Spring是一个开源框架，于2003年兴起的轻量级Java开发框架。Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。 简单来说：Spring是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架。 1.1 Spring的好处 方便解耦，简化开发 Spring就是一个大工厂，专门负责生产Bean，可以将所有对象创建和依赖关系维护，交给Spring管理。 AOP编程的支持 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。 声明式事务的支持 只需要通过配置就可以完成对事务的管理，而无需手动编程。 方便程序的测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序。 方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架(如：Struts、Hibernate、MyBatis等)的直接支持。 降低JavaEE API的使用难度 Spring对JavaEE开发中非常难用的一些API(JDBC、JavaMail、远程调用等)，都提供了封装，使这些API应用难度大大降低。 1.2 Spring体系结构Spring框架是一个分层架构，它包含一系列的功能要素并被分为大约20个模块。这些模块分为Core Container、Data Access/Integration、Web、AOP（Aspect Oriented Programming）、Instrumentation和测试部分。如下图所示： 2. Spring简单入门基本流程： 下载Spring开发包 导入Spring核心jar包 编写Spring核心配置文件 在程序中读取Spring配置文件，通过Spring框架获取Bean，完成相应操作。 2.1 下载Spring开发包Spring官方下载地址 下载后解压，目录结构如下： 2.2 导入Spring核心jar包到项目中 spring-core-3.2.0.RELEASE.jar 包含Spring框架基本的核心工具类，Spring其他组件都要使用到这个包里的类，是其他组件的基本核心。 spring-beans-3.2.0.RELEASE.jar 所有应用都要用到的，它包含访问配置文件、创建和管理bean，以及进行IOC/DI操作相关的所有类 spring-context-3.2.0.RELEASE.jar Spring提供在基础IOC功能上的扩展功能，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI定位、EJB集成、远程访问、缓存以及各种视图层框架的封装等。 spring-expression-3.2.0.RELEASE.jar Spring表达式语言 commons-logging-1.2.jar 第三方的主要用于处理日志 注意导入时，不要导入带source的源文件。 2.3 编写Spring核心配置文件2.3.1 创建测试方法 在src下创建一个service文件夹，里面创建UserService及其对应实现类，实现add方法，直接打印一句话。 public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(&quot;创建用户...&quot;); } } 创建测试方法，调用add方法。 public class UserServiceTest { @Test public void test1(){ UserService us = new UserServiceImpl(); us.add(); } } 2.3.2 使用Spring IOC控制反转创建实例 编写配置文件beans.xml，xsd约束文件可以在/spring-framework-3.2.0.RC2-docs/reference/html/xsd-config.html中查看 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation=&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;!-- 配置一个bean --&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.zero.service.UserServiceImpl&quot;&gt;&lt;&#x2F;bean&gt; &lt;&#x2F;beans&gt; 2.4 在程序中读取Spring配置文件，通过Spring框架获取Bean，完成相应操作。 public class UserServiceTest { @Test public void test1(){ &#x2F;&#x2F; 不使用spring的方式，自己创建对象 &#x2F;&#x2F; UserService us = new UserServiceImpl(); &#x2F;&#x2F; us.add(); &#x2F;&#x2F; 使用spring容器方式获取UserService &#x2F;&#x2F; 1. 加载beans.xml 这个spring的配置文件，内部就会创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); &#x2F;&#x2F; 2. 获取对象 UserService userService1 = (UserService) context.getBean(&quot;userService&quot;); userService1.add(); System.out.println(userService1); &#x2F;&#x2F; com.zero.service.UserServiceImpl@5f058f00 UserService userService2 = (UserService) context.getBean(&quot;userService&quot;); System.out.println(userService2); &#x2F;&#x2F; com.zero.service.UserServiceImpl@5f058f00 } } 2.5 IOCIOC(Inverse of Control) 反转控制的概念，就是将原本在程序中手动创建对象的控制权，交由Spring框架管理。简单的说，就是创建对象控制权被反转到了Spring框架。 2.6 DI解释 Dependency Injection 依赖输入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件。 例：在UserServiceImpl中提供一个get/set的name方法，在beans.xml中提供property去注入。 public class UserServiceImpl implements UserService{ private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public void add() { System.out.println(&quot;创建用户...&quot;+name); } } 配置文件中使用依赖注入： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation=&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;!-- 配置一个bean --&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.zero.service.UserServiceImpl&quot;&gt; &lt;!-- 使用DI依赖注入数据, 调用属性的set方法--&gt; &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;beans&gt;","categories":[{"name":"FrameWork","slug":"FrameWork","permalink":"https://zero024.cn/categories/FrameWork/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zero024.cn/tags/Spring/"}]},{"title":"计算机网络相关知识汇总(持续更新中~)","slug":"Interview/计算机网络面试核心","date":"2019-08-02T14:00:00.000Z","updated":"2020-03-03T11:20:02.956Z","comments":true,"path":"Interview/undefined.html","link":"","permalink":"https://zero024.cn/Interview/undefined.html","excerpt":"1. OSI开放式互联参考模型OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能就是帮助不同类型的主机实现数据传输 。","text":"1. OSI开放式互联参考模型OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能就是帮助不同类型的主机实现数据传输 。 一个设备在哪一层，关键看它工作时利用哪一层的数据头部信息。举例来说： 物理层：网卡、网线、集线器、中继器、调制解调器 数据链路层：网桥、交换机 网络层：路由器 网关工作在第四层传输层及其以上。集线器是物理层设备，采用广播的形式来传输信息。交换机就是用来进行报文交换的及其，多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文。路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。 1.1 物理层在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。 主要功能：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。 物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 1.2 数据链路层数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。 主要功能：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。 在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。 该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。 MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制 LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。 数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。 1.3 网络层网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。 其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 在实现网络层功能时，需要解决的主要问题如下： 寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。 交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。 路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。 连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。 1.4 传输层OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。 主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。 该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。 传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。 因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下： 传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。 处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。 监控服务质量。 1.5 会话层会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名（DN）就是一种网络上使用的远程地址例如：www.baidu.com 就是一个域名。 会话层的具体功能如下： 会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。 会话流量控制：提供会话流量控制和交叉会话功能。 寻址：使用远程地址建立会话连接。 出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。 1.6 表示层表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。 表示层的具体功能如下： 数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。 数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。 压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。 数据的加密和解密：可以提高网络的安全性。 1.7 应用层应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。 此外，该层还负责协调各个应用程序间的工作。应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。 应用层的主要功能如下： 用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。 实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。 1.8 OSI7层模型小结由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。 在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层、应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。 简言之：下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。 1.9 TCP/IP分层模型 TCP/IP分层模型的四个协议层分别完成以下的功能： 第一层，链路层：包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。 第二层，网络层：对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。 第三层，传输层：对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。 第四层，应用层：对应于OSI七层参考模型的应用层和表达层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等。 2. 三次握手和四次挥手 TCP概述： TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字(socket)，它的定义为端口号拼接到IP地址即构成了套接字。例如，假设IP地址为192.3.4.15，端口号为80，那么得到的套接字为192.3.4.15:80。 2.1 TCP的三次握手所谓三次握手，即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。 2.1.1 传输控制协议TCP简介 面向连接的、可靠的、基于字节流的传输层通信协议 将应用层的数据流分割成报文段并发送给目标节点的TCP层 数据包都有序号，对方收到则发送ACK确认，未收到则重传 使用校验和来校验数据在传输过程中是否有误 2.1.2 TCP报文结构详解 TCP报文由首部和数据两部分组成。首部一般由20-60字节(Byte)构成，长度可变。其中前20B格式固定，后40B为可选。 因为，TCP报文还得传给下层网络层，封装成IP包，而一个IP包最大长度为65535，同时IP包首部也包含最少20B，所以一个IP包或TCP包可以包含的数据部分最多为65535-20-20=65495B。 TCP报文中数据部分是可选的，即TCP报文可以不包含数据（同理IP包也可以不包含数据）。不含数据的TCP报文通常是一些确认和控制信息类的报文，如TCP建立连接时的三次握手和TCP终止时的四次挥手等。 参数详解： 源端口号（Source Port）：长度为16位占2个字节，指明发送数据的进程。 目的端口号（Destination Port）：长度为16位占2个字节，指明目的主机接收数据的进程。 序号（Sequence Number）：也称为序列号，长度为32位占4个字节。TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段是301，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始。 确认号（Acknowledgement Number）：长度为32位占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。确认号只有在ACK标志为1时才有效。 数据偏移：占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远。 首部长度：长度为4位，用于表示TCP报文首部的长度。用4位(bit)表示，十进制值就是[0,15]，一个TCP报文前20个字节是必有的，后40个字节根据情况可有可无。如果TCP报文首部是20个字节，则该位应是20/4=5。 保留位（Reserved）：长度为6位，必须是0，它是为将来定义新用途保留的。 标志（Code Bits）：长度为6位，在TCP报文中不管是挥手还是传数据等，这6位标志都很重要。6位从左到右依次为： URG：紧急标志位，当URG=1时，表明紧急指针有效。告诉系统此报文段中有紧急数据。 ACK：确认标志位，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置为1。 PSH：推标志位，当两个应用程序进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时就可以将PSH=1。 RST：复位标志，用于重建一个已经混乱的连接。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。 SYN：同步标志，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1,ACK=1。 FIN：结束标志，带该标志位的数据包用于结束一个TCP会话。当FIN=1,时，表明此报文的发送方数据已经发送完毕，并且要求释放。 窗口大小（Window Size）：长度为16位占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接收。 校验和（Checksum）：长度为16位占2字节，该字段覆盖整个TCP报文端，是个强制性的字段，是由发送端计算和存储，到接收端后，由接收端进行验证。主要检验首部和数据这两部分。 紧急指针（Urgent Pointer）：长度为16位占2字节，指出本报文段中的紧急数据的字节数，该字段在URG标志置位时有效。 选型（Options）：长度可变，定义一些其他的可选参数。通常包含：最长报文大小（Maximum Segment Size，MSS）、窗口扩大选项、时间戳选项、选择性确认（Selective ACKnowlegement，SACK）等。 数据：TCP 报文段中的数据部分是可选的。 单工数据传输只支持数据在一个方向上传输； 半双工数据传输允许数据在两个方向上传输，但在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信； 全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都具有独立的接收和发送能力。 2.1.3 TCP三次握手流程图 整个流程为： TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态。 TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同步位SYN=1，同时选择一个初始序列号Seq=x，此时TCP客户端进程进入了SYN-SENT(同步已发送)状态。TCP规定，SYN报文段(SYN=1的报文段)不能携带数据，但需要消耗掉一个序号。 TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该ACK=1,SYN=1,确认号是ack=x+1，同时也要为自己初始化一个序列号Seq=y。此时，TCP服务器进程进入了SYN-RCVD(同步收到)状态。这个报文也不能携带数据，但是同样要消耗一个序号。 TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号Seq=x+1。此时，TCP连接建立，客户端进入ESTABLISHED(已建立连接)状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 TCB：传输控制块，它是协议栈的核心数据结构，一个套接字在TCP、IP层的代表就是一个传输控制块，它包含了一个套接字所需要的所有信息。 内容详见文章 流程小结： 在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 第一次握手：建立连接时，客户端发送SYN包{syn=x}到服务器，并进入SYN_SEND(同步已发送)状态，等待服务器确认。 第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包(syn=y)，即SYN+ACK包，此时服务器进入SYN_RECV(同步收到)状态。 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK{ack=y+1}，此包发送完毕，客户端和服务器进入ESTABLISHED（已建立连接）状态，完成三次握手。 2.1.4 SYN攻击在三次握手过程中，服务端发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接，此时服务端处于SYN-RCVD(同步收到)状态。当收到ACK后，服务端才会进入ESTABLISHED（已建立连接）状态。SYN攻击就是客户端在短时间内伪造大量不存在的IP地址，并向服务端不断发送SYN包，服务端回复确认包，并等待客户端的确认，由于源地址IP是不存在的，因此，服务端需要不断重发直至SYN超时。这些伪造的SYN包将占用未连接队列，导致正常的SYN请求因队列满而被丢弃，从而引起网络阻塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当服务端上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。使用如下命令可以让其现行：netstat -nap | grep SYN_RECV 2.2 TCP的四次挥手 数据传输完毕后，双方都可释放连接。最开始时，客户端和服务端都是处于ESTABLISHED状态，然后客户端主动关闭，服务端被动关闭。 具体流程： 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）。此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务端收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层应用进程，客户端要释放向服务器的通信连接了，这时处于半关闭状态，即客户端已经无数据要发送了，但服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1。由于处在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，那么此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1。此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销响应的TCB后，才会进入CLOSED状态。 服务器只要收到了客户端发出的确认，会立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 挥手小结： 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态； 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态，Client进入FIN-WAIT-2状态； 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态； 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，Client在经过2MSL后也会进入CLOSED状态，完成四次挥手； 3. 计算机网络相关面试题3.1 为什么TCP客户端最后还要发送一次确认呢？为什么需要三次握手才能建立起连接？主要为了防止已经失效的连接请求报文突然又传送到了服务端，因而产生错误。 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 3.2 为什么在四次挥手时客户端最后还要等待2MSL？ MSL（Maximum Segment Lifetime）最长报文段寿命，TCP允许不同的实现可以设置不同的MSL值。 第一：保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。 第二：防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 3.3 为什么建立连接是三次握手，关闭连接却是四次挥手呢？建立连接时，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，己方ACK和FIN一般都会分开发送，从而导致多一次数据包传递。 3.4 如果已经建立了连接，但客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 3.5 TCP和UDP的区别 TCP UDP 面向连接 无连接 可靠性高，利用握手确认和重传机制保证数据不丢失 可靠性不高，可能会丢失数据 有序性：利用序列号保证消息包的顺序交互 无有序性 需要创建连接，保证消息的可靠性和有序性，导致速度较慢 无需考虑连接和可靠，速度较快 消息头20字节，重量级 消息头只需8字节，轻量级 3.6 在浏览器地址栏键入URL，按下回车之后经历的流程 DNS解析：首先浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名所对应的IP地址。DNS缓存从近到远依次是：浏览器缓存→系统缓存→路由器缓存→IPS服务器缓存→根域名服务器缓存→顶级域名服务器缓存。找到IP则直接返回，不查询后续缓存。 TCP连接：根据IP地址和默认端口(80)来和服务器建立TCP连接(三次握手)。 发送HTTP请求：浏览器发出读取文件的HTTP请求，该请求将发送给服务器。 服务器处理请求并返回HTTP报文：服务器对浏览器请求作出响应，并把对应的带有HTML文本的HTTP响应报文发送给浏览器。 浏览器解析渲染页面：浏览器接收到HTML，并在显示窗口内渲染它。 连接结束：浏览器释放TCP连接(四次挥手)。 3.7 说说常见的HTTP状态码 200 OK：正常返回信息 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求资源不存在，eg：输入了错误的URL 500 Internal Server Error：服务器发生不可预期的错误 501 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 3.8 GET请求和POST请求的区别从以下几个层面来解答 Http报文层面：GET将请求信息放在URL后面，请求信息与URL以？隔开，请求信息的格式为键值对；POST将请求信息放在报文体中，获取请求信息必须解析报文，因此安全性较GET要高一些。 长度方面：GET请求信息放在URL后面，浏览器会限制URL长度，故GET请求长度有限；POST请求消息放在报文体中，所以长度没有限制。 数据库层面：GET符合幂等性(对数据库的一次操作和多次操作的结果是一致的)和安全性(对数据库的操作没有改变数据库中的数据)，POST不符合。 其他层面：GET可以被缓存、被存储，可以保存在浏览器的浏览记录中，而POST不行。 3.9 Cookie和Session的区别3.9.1 Cookie简介 是由服务器发送给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求时，会把Cookie放在请求头中回发，每一次请求都会带上所有Cookie，过多会造成网络压力 服务器接收到后，会解析Cookie生成与客户端相对应的内容(记住密码功能) Cookie的设置及发送过程如下图： 3.9.2 Session简介 服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id，按需保存状态信息。当服务器需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否包含的session标识(即session id)，如果已包含session id，则说明以前已经为此客户端创建过session了，服务器就根据这个session id把session检索出来使用。如果检索不到，会新建一个。如果客户端不包含session id，则会为此客户端创建一个session，并创建一个与此session相关的session id，这个id会在本次请求中回发给客户端进行保存。 3.9.3 三点主要区别 Cookie数据存放在客户的浏览器上，Session数据放在服务器上 Session相对于Cookie更安全 因Session存放在服务器端，大量存放会造成服务器负担，如考虑到减轻服务器负担，应当使用Cookie。 Cookie的大量使用会造成网络压力，因为每一次请求都会携带所有的Cookie数据。 3.10 HTTP和HTTPS的区别HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP传输协议。 SSL（Security Sockets Layer，安全套接层） 为网络通信提供安全及数据完整性的一种安全协议 是操作系统对外的API，SSL3.0后更名为TLS 采用身份验证和数据加密保证网络通信的安全和数据的完整性 3.10.1 主要区别如下 HTTPS需到CA申请证书，HTTP不需要 HTTPS密文传输，HTTP明文传输 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口 HTTPS=HTTP+SSL加密+身份认证+完整性保护，较HTTP安全 其他参考文章","categories":[{"name":"Interview","slug":"Interview","permalink":"https://zero024.cn/categories/Interview/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zero024.cn/tags/计算机网络/"}]},{"title":"travel项目开发日志","slug":"JavaWeb/travel项目开发日志","date":"2019-07-29T07:50:08.000Z","updated":"2020-03-08T00:52:28.387Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. 项目简介黑马旅游网是一个前后端分离的Web项目，后端采用了MVC设计模式。前端通过Ajax来请求后端服务器，获取json数据，然后填充到前端页面，部分不经常变动数据(如导航栏数据)，使用到了redis来做数据缓存以减少对数据库的访问。","text":"1. 项目简介黑马旅游网是一个前后端分离的Web项目，后端采用了MVC设计模式。前端通过Ajax来请求后端服务器，获取json数据，然后填充到前端页面，部分不经常变动数据(如导航栏数据)，使用到了redis来做数据缓存以减少对数据库的访问。 2. 项目进度截止7月28日，目前已完成的模块为： 登录注册 国内游功能及其内附加功能，如查看详情，收藏等。 线路搜索功能 待完成功能： 首页数据展示功能，包括人气旅游，最新旅游等。 导航栏功能的添加 我的收藏功能 热门推荐 前端部分样式修改 记住密码功能 收藏排行榜 整体细节方面，如登录后登录按钮消失等。 3. 项目展示旅游网项目 无法访问多刷新几次试试","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://zero024.cn/tags/Project/"}]},{"title":"旅游网项目03","slug":"JavaWeb/旅游网项目03","date":"2019-07-27T15:59:00.000Z","updated":"2020-01-03T11:43:19.609Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"前言今日内容为旅游网项目的旅游线路名称查询，详情页展示，线路收藏功能。","text":"前言今日内容为旅游网项目的旅游线路名称查询，详情页展示，线路收藏功能。 1. 旅游线路名称查询功能1.1 查询参数的传递在header.html中添加如下js &#x2F;&#x2F; 给搜索按钮绑定单击事件，获取搜索输入框的内容 $(&quot;#search_btn&quot;).click(function () { &#x2F;&#x2F; 用户输入的线路名称 var rname = $(&quot;#search_input&quot;).val(); var cid = getParameter(&quot;cid&quot;); &#x2F;&#x2F; 跳转路径 http:&#x2F;&#x2F;localhost&#x2F;travel&#x2F;route_list.html?cid=5, 拼接上rname=xxx location.href = &quot;http:&#x2F;&#x2F;localhost&#x2F;travel&#x2F;route_list.html?cid=&quot;+cid+&quot;&amp;rname=&quot;+rname; }); 在route_list.html中添加代码 $(function () { &#x2F;&#x2F; 获取cid的参数值 var cid = getParameter(&quot;cid&quot;); &#x2F;&#x2F; 获取rname的参数值 var rname = getParameter(&quot;rname&quot;); &#x2F;&#x2F; 判断rname不为null if (rname){ &#x2F;&#x2F; url 解码 rname = window.decodeURIComponent(rname); } }); 1.2 后台代码修改主要就是重构查询总记录数方法和查询当前页数据集合方法，添加一个模糊查询的参数rname 设计到重构的模块及方法： RouteServlet部分代修改及添加 &#x2F;&#x2F; 添加以下代码 &#x2F;&#x2F; 接受rname 参数 String rname = request.getParameter(&quot;rname&quot;); rname = new String(rname.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); &#x2F;&#x2F; 重新编码rnmae，解决get请求乱码问题 &#x2F;&#x2F; 修改查询方法，添加rname参数 &#x2F;&#x2F; 3. 调用service查询PageBean对象 PageBean&lt;Route&gt; pb = routeService.pageQuery(cid, currentPage, pageSize,rname); RouteServiceImpl代码修改 &#x2F;&#x2F; 添加rname参数 public PageBean&lt;Route&gt; pageQuery(int cid, int currentPage, int pageSize, String rname) {} &#x2F;&#x2F; 以下方法均添加rname参数 int totalCount = routeDao.findTotalCount(cid,rname); List&lt;Route&gt; list = routeDao.findByPage(cid, start, pageSize,rname); RouteDaoImpl代码修改 @Override public int findTotalCount(int cid, String rname) { &#x2F;&#x2F; String sql = &quot;select count(*) from tab_route where cid = ?&quot;; &#x2F;&#x2F; 1. 定义sql模板,拼接sql时注意空格 String sql = &quot;select count(*) from tab_route where 1 = 1 &quot;; StringBuilder sb = new StringBuilder(sql); List params = new ArrayList(); &#x2F;&#x2F; 条件参数 &#x2F;&#x2F; 2. 判断参数是否有值 if (cid != 0){ sb.append(&quot; and cid = ? &quot;); params.add(cid); &#x2F;&#x2F; 添加？对应值 } if (rname != null &amp;&amp; rname.length() &gt; 0){ sb.append(&quot; and rname like ? &quot;); params.add(&quot;%&quot;+rname+&quot;%&quot;); } sql = sb.toString(); &#x2F;&#x2F; 转换为字符串 return template.queryForObject(sql,Integer.class,params.toArray()); &#x2F;&#x2F; params.toArray() 集合转换为数组 } @Override public List&lt;Route&gt; findByPage(int cid, int start, int pageSize, String rname) { &#x2F;&#x2F; String sql = &quot;select * from tab_route where cid = ? limit ? , ?&quot;; &#x2F;&#x2F; 1. 定义sql模板 String sql = &quot;select * from tab_route where 1 = 1 &quot;; StringBuilder sb = new StringBuilder(sql); List params = new ArrayList(); &#x2F;&#x2F; 条件参数集合 &#x2F;&#x2F; 2. 判断参数是否有值 if (cid != 0){ sb.append(&quot; and cid = ? &quot;); params.add(cid); &#x2F;&#x2F; 添加？对应值 } if (rname != null &amp;&amp; rname.length() &gt; 0){ sb.append(&quot; and rname like ? &quot;); params.add(&quot;%&quot;+rname+&quot;%&quot;); } sb.append(&quot; limit ? , ? &quot;); &#x2F;&#x2F; 分页条件限制 sql = sb.toString(); &#x2F;&#x2F; 加入分页条件参数 params.add(start); params.add(pageSize); return template.query(sql,new BeanPropertyRowMapper&lt;Route&gt;(Route.class),params.toArray()); } 1.3 前台代码修改主要将rname参数添加入load方法中，并且修改所有的跳转页面标签，加上rname参数。 注意在标签处添加rname参数时，该参数是一个字符串，故需使用“\\”进行转义。 &lt;script&gt; $(function () { &#x2F;&#x2F; var search = location.search; &#x2F;&#x2F; &#x2F;&#x2F; alert(search); &#x2F;&#x2F; &#x2F;&#x2F; 切割字符串，拿到第二个值 &#x2F;&#x2F; var cid = search.split(&quot;=&quot;)[1]; &#x2F;&#x2F; 获取cid的参数值 var cid = getParameter(&quot;cid&quot;); &#x2F;&#x2F; 获取rname的参数值 var rname = getParameter(&quot;rname&quot;); &#x2F;&#x2F; 判断rname不为null if (rname){ &#x2F;&#x2F; url 解码 rname = window.decodeURIComponent(rname); } &#x2F;&#x2F; 当页码加载完毕后，调用load方法， load(cid,null,rname); }) function load(cid, currentPage,rname) { &#x2F;&#x2F; 发送ajax请求，请求route&#x2F;pageQuery，传递cid $.get(&quot;route&#x2F;pageQuery&quot;,{cid:cid,currentPage:currentPage,rname:rname},function (pb) { &#x2F;&#x2F; 解析PageBean数据，展示到页面上 &#x2F;&#x2F; 1. 分页工具条数据展示 &#x2F;&#x2F; 1.1 展示总页码和总记录数 $(&quot;#totalPage&quot;).html(pb.totalPage); $(&quot;#totalCount&quot;).html(pb.totalCount); var lis = &quot;&quot;; var fristPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,1,\\&#39;&#39;+rname+&#39;\\&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; &#x2F;&#x2F; 计算上一页的页码 var beforeNum = pb.currentPage - 1; if (beforeNum &lt;= 0){ beforeNum = 1; } var beforePage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+beforeNum+&#39;,\\&#39;&#39;+rname+&#39;\\&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;上一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; lis += fristPage; lis += beforePage; &#x2F;&#x2F; 1.2 展示分页页码 &#x2F;* 仿百度分页样式：前五后四 1. 一共展示10个页码，能够达到前5后4的效果 2. 如果前边不足5个，后边补齐10个 3. 如果后边不足4个，前边补齐10个 *&#x2F; &#x2F;&#x2F; 定义开始位置begin和结束位置end var begin; &#x2F;&#x2F; 开始位置 var end; &#x2F;&#x2F; 结束位置 &#x2F;&#x2F; 1. 显示10个页码 if(pb.totalPage &lt; 10){ &#x2F;&#x2F; 总页码不足10页 begin = 1; end = pb.totalPage; }else{ &#x2F;&#x2F; 总页码超过10页 &#x2F;&#x2F; 实现前5后4效果 begin = pb.currentPage - 5; end = pb.currentPage + 4; &#x2F;&#x2F; 进行数据修正 &#x2F;&#x2F; 2. 如果前边不够5个，后边补齐10个 if (begin &lt; 1){ begin = 1; end = begin + 9; } &#x2F;&#x2F; 3. 如果后边不足4个，前边补齐10个 if (end &gt; pb.totalPage){ end = pb.totalPage; begin = end - 9; } } for (var i = begin; i &lt;= end; i++) { var li; &#x2F;&#x2F; 判断当前页码是否等于i if (pb.currentPage == i){ li = &#39;&lt;li class=&quot;curPage&quot; onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;,\\&#39;&#39;+rname+&#39;\\&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; }else{ &#x2F;&#x2F; 创建页码的li li = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;,\\&#39;&#39;+rname+&#39;\\&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; } &#x2F;&#x2F; 拼接进字符串 lis += li; } &#x2F;&#x2F; 计算下一页页码 var nextNum = pb.currentPage + 1; if(nextNum &gt;= pb.totalPage){ nextNum = pb.totalPage; } var nextPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+nextNum+&#39;,\\&#39;&#39;+rname+&#39;\\&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;下一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; var lastPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+pb.totalPage+&#39;,\\&#39;&#39;+rname+&#39;\\&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;末页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; lis += nextPage; lis += lastPage; &#x2F;&#x2F; 将lis内容设置到ul中 $(&quot;#pageNum&quot;).html(lis); &#x2F;&#x2F; 2. 列表数据展示 var route_lis = &quot;&quot;; for (var i = 0; i &lt; pb.list.length; i++) { &#x2F;&#x2F; 获取数据 {rid&quot;: 1,&quot;rname&quot;: &quot;xxx&quot;,&quot;price&quot;: 999.0,xxxx} var route = pb.list[i]; var li = &#39;&lt;li&gt;\\n&#39; + &#39; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;&#39;+route.rimage+&#39;&quot; style=&quot;width: 299px&quot;&gt;&lt;&#x2F;div&gt;\\n&#39; + &#39; &lt;div class=&quot;text1&quot;&gt;\\n&#39; + &#39; &lt;p&gt;&#39;+route.rname+&#39;&lt;&#x2F;p&gt;\\n&#39; + &#39; &lt;br&#x2F;&gt;\\n&#39; + &#39; &lt;p&gt;&#39;+route.routeIntroduce+&#39;&lt;&#x2F;p&gt;\\n&#39; + &#39; &lt;&#x2F;div&gt;\\n&#39; + &#39; &lt;div class=&quot;price&quot;&gt;\\n&#39; + &#39; &lt;p class=&quot;price_num&quot;&gt;\\n&#39; + &#39; &lt;span&gt;&amp;yen;&lt;&#x2F;span&gt;\\n&#39; + &#39; &lt;span&gt;&#39;+route.price+&#39;&lt;&#x2F;span&gt;\\n&#39; + &#39; &lt;span&gt;起&lt;&#x2F;span&gt;\\n&#39; + &#39; &lt;&#x2F;p&gt;\\n&#39; + &#39; &lt;p&gt;&lt;a href=&quot;route_detail.html&quot;&gt;查看详情&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;\\n&#39; + &#39; &lt;&#x2F;div&gt;\\n&#39; + &#39; &lt;&#x2F;li&gt;&#39;; route_lis += li; } $(&quot;#route&quot;).html(route_lis); &#x2F;&#x2F; 每次点击翻页后，定位到页面顶部 window.scrollTo(0,0); }); } &lt;&#x2F;script&gt; ​ 2. 旅游线路的详情展示2.1 分析 2.2 后台代码实现 在RouteServlet中创建一个findOne方法，查询route对象并返回给客户端 &#x2F;** * @Description: 根据id查询一个旅游线路的详细信息 * @Author: zero * @param request * @param response * @return void * @Date 2019&#x2F;7&#x2F;26 20:56 *&#x2F; public void findOne(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 接收id String rid = request.getParameter(&quot;rid&quot;); &#x2F;&#x2F; 2. 调用service查询route对象 Route route = routeService.findOne(Integer.parseInt(rid)); &#x2F;&#x2F; 3. 转为json返回客户端 writeValue(route,response); } 在RouteServiceImpl中新建findOne方法，根据rid查询三表数据，封装进route对象 &#x2F;** * @Description: 根据rid查询三个表数据，封装进route对象 * @Author: zero * @param rid * @return 封装好的route对象 * @Date 2019&#x2F;7&#x2F;26 21:16 *&#x2F; @Override public Route findOne(int rid) { &#x2F;&#x2F; 1. 根据id查询route对象 routeDao Route route = routeDao.findOne(rid); &#x2F;&#x2F; 2. 根据rid线路id查询tab_route_img，将集合设置到route对象中 List&lt;RouteImg&gt; img = routeImgDao.findImg(rid); &#x2F;&#x2F; 2.1 将img集合设置到route对象中 route.setRouteImgList(img); &#x2F;&#x2F; 3. 根据sid卖家id查询tab_seller查询卖家信息，设置到route对象中 Seller seller = sellerDao.findSeller(route.getSid()); &#x2F;&#x2F; 3.1 设置到route对象中 route.setSeller(seller); return route; } 修改RouteDao层，添加findOne方法，新建两个Dao及其对应实现类，分别是RouteImgDao和SellerDao，查询图片信息和卖家信息。 &#x2F;&#x2F; RouteDaoImpl &#x2F;** * 根据id查询 * @param rid * @return *&#x2F; @Override public Route findOne(int rid) { return template.queryForObject(&quot;select * from tab_route where rid = ?&quot;, new BeanPropertyRowMapper&lt;Route&gt;(Route.class),rid); } &#x2F;&#x2F; RouteImgDaoImpl &#x2F;** * 根据rid查询图片信息 * @param rid * @return *&#x2F; @Override public List&lt;RouteImg&gt; findImg(int rid) { return template.query(&quot;select * from tab_route_img where rid = ?&quot;, new BeanPropertyRowMapper&lt;RouteImg&gt;(RouteImg.class),rid); } &#x2F;&#x2F; SellerDaoImpl &#x2F;** * 根据sid查询卖家信息 * @param sid * @return *&#x2F; @Override public Seller findSeller(int sid) { return template.queryForObject(&quot;select * from tab_seller where sid = ?&quot;, new BeanPropertyRowMapper&lt;Seller&gt;(Seller.class),sid); } 2.3 前台代码实现在Route_detail.html中加载后获取rid，然后发送ajax请求，获取route对象，解析对象数据，填充入html中 &lt;script&gt; $(document).ready(function() { goImg(); }); function goImg() { &#x2F;&#x2F;焦点图效果 &#x2F;&#x2F;点击图片切换图片 $(&#39;.little_img&#39;).on(&#39;mousemove&#39;, function() { $(&#39;.little_img&#39;).removeClass(&#39;cur_img&#39;); var big_pic = $(this).data(&#39;bigpic&#39;); $(&#39;.big_img&#39;).attr(&#39;src&#39;, big_pic); $(this).addClass(&#39;cur_img&#39;); }); &#x2F;&#x2F;上下切换 var picindex = 0; var nextindex = 4; $(&#39;.down_img&#39;).on(&#39;click&#39;,function(){ var num = $(&#39;.little_img&#39;).length; if((nextindex + 1) &lt;= num){ $(&#39;.little_img:eq(&#39;+picindex+&#39;)&#39;).hide(); $(&#39;.little_img:eq(&#39;+nextindex+&#39;)&#39;).show(); picindex = picindex + 1; nextindex = nextindex + 1; } }); $(&#39;.up_img&#39;).on(&#39;click&#39;,function(){ var num = $(&#39;.little_img&#39;).length; if(picindex &gt; 0){ $(&#39;.little_img:eq(&#39;+(nextindex-1)+&#39;)&#39;).hide(); $(&#39;.little_img:eq(&#39;+(picindex-1)+&#39;)&#39;).show(); picindex = picindex - 1; nextindex = nextindex - 1; } }); &#x2F;&#x2F;自动播放 &#x2F;&#x2F; var timer = setInterval(&quot;auto_play()&quot;, 5000); } &#x2F;&#x2F;自动轮播方法 function auto_play() { var cur_index = $(&#39;.prosum_left dd&#39;).find(&#39;a.cur_img&#39;).index(); cur_index = cur_index - 1; var num = $(&#39;.little_img&#39;).length; var max_index = 3; if ((num - 1) &lt; 3) { max_index = num - 1; } if (cur_index &lt; max_index) { var next_index = cur_index + 1; var big_pic = $(&#39;.little_img:eq(&#39; + next_index + &#39;)&#39;).data(&#39;bigpic&#39;); $(&#39;.little_img&#39;).removeClass(&#39;cur_img&#39;); $(&#39;.little_img:eq(&#39; + next_index + &#39;)&#39;).addClass(&#39;cur_img&#39;); $(&#39;.big_img&#39;).attr(&#39;src&#39;, big_pic); } else { var big_pic = $(&#39;.little_img:eq(0)&#39;).data(&#39;bigpic&#39;); $(&#39;.little_img&#39;).removeClass(&#39;cur_img&#39;); $(&#39;.little_img:eq(0)&#39;).addClass(&#39;cur_img&#39;); $(&#39;.big_img&#39;).attr(&#39;src&#39;, big_pic); } } $(function () { &#x2F;&#x2F; 1. 获取id var rid = getParameter(&quot;rid&quot;); &#x2F;&#x2F; 2. 发送请求， route&#x2F;findOne $.get(&quot;route&#x2F;findOne&quot;,{rid:rid},function (route) { &#x2F;&#x2F; 3. 解析数据填充html $(&quot;#rname&quot;).html(route.rname); $(&quot;#routeIntroduce&quot;).html(route.routeIntroduce); $(&quot;#price&quot;).html(route.price); $(&quot;#sname&quot;).html(route.seller.sname); $(&quot;#consphone&quot;).html(route.seller.consphone); $(&quot;#address&quot;).html(route.seller.address); &#x2F;&#x2F; 图片展示 var dd_str = &#39;&lt;a class=&quot;up_img up_img_disable&quot;&gt;&lt;&#x2F;a&gt;&#39;; &#x2F;&#x2F; 遍历routeImgList for (var i = 0; i &lt; route.routeImgList.length; i++) { var a_str; &#x2F;&#x2F; 判断图片是否大于4，将大于4的图片设置为display:none if (i &gt;= 4) { a_str = &#39;&lt;a title=&quot;&quot; class=&quot;little_img&quot; data-bigpic=&quot;&#39;+route.routeImgList[i].bigPic+&#39;&quot; style=&quot;display:none;&quot;&gt;\\n&#39; + &#39; &lt;img src=&quot;&#39;+route.routeImgList[i].smallPic+&#39;&quot;&gt;\\n&#39; + &#39; &lt;&#x2F;a&gt;&#39;; } else { a_str = &#39;&lt;a title=&quot;&quot; class=&quot;little_img&quot; data-bigpic=&quot;&#39;+route.routeImgList[i].bigPic+&#39;&quot;&gt;\\n&#39; + &#39; &lt;img src=&quot;&#39;+route.routeImgList[i].smallPic+&#39;&quot;&gt;\\n&#39; + &#39; &lt;&#x2F;a&gt;&#39;; } dd_str += a_str; } dd_str += &#39;&lt;a class=&quot;down_img down_img_disable&quot; style=&quot;margin-bottom: 0;&quot;&gt;&lt;&#x2F;a&gt;&#39;; $(&quot;#dd&quot;).html(dd_str); &#x2F;&#x2F; 图片展示和切换代码的调用 goImg(); }); }); &lt;&#x2F;script&gt; 需注意：在route_list.html中的查看详情URL处修改代码，传递rid值：&lt;p&gt;&lt;a href=&quot;route_detail.html?rid=&#39;+route.rid+&#39;&quot;&gt;查看详情&lt;/a&gt;&lt;/p&gt;\\n&#39; 3. 旅游线路收藏功能3.1 分析 表结构信息： 3.1.1 判断当前登录用户是否收藏过该线路当页面加载完成后，发送ajax请求，获取用户是否收藏的标记，根据此标记展示不同的按钮样式。 3.2 后台代码编写 修改RouteServlet，添加isFavorite方法 &#x2F;** * @Description: 根据线路id和用户id，判断用户是否收藏了该线路 * @Author: zero * @param request * @param response * @return void * @Date 2019&#x2F;7&#x2F;27 23:11 *&#x2F; public void isFavorite(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 获取rid，线路id String rid = request.getParameter(&quot;rid&quot;); &#x2F;&#x2F; 2. 获取udi，通过当前登录用户对象，session User user = (User) request.getSession().getAttribute(&quot;user&quot;); &#x2F;&#x2F; 2.1 如果user对象为null，则表示未登录，设置uid=0 int uid; &#x2F;&#x2F; 用户id if (user == null){ &#x2F;&#x2F; 用户未登录 uid = 0; }else{ &#x2F;&#x2F; 用户已登录 uid = user.getUid(); } &#x2F;&#x2F; 3. 调用FavoriteService查询，传递rid，uid boolean flag = favoriteService.isFavorite(Integer.parseInt(rid), uid); &#x2F;&#x2F; 4. 写回客户端flag标记 writeValue(flag,response); } FavoriteServiceImpl添加isFavorite方法 @Override public boolean isFavorite(int rid, int uid) { Favorite favorite = favoriteDao.findFavorite(rid, uid); return favorite != null ? true : false; &#x2F;&#x2F; 如果对象有值，则表示收藏过了，返回true，反之表示未收藏过返回false。 } FavoriteDaoImpl添加findFavorite方法 &#x2F;** * @Description: 根据线路id和用户id查询数据 * @Author: zero * @param rid * @param uid * @return 查询到的Favorite对象 * @Date 2019&#x2F;7&#x2F;27 22:34 *&#x2F; @Override public Favorite findFavorite(int rid, int uid) { Favorite favorite = null; try{ favorite = template.queryForObject(&quot;select * from tab_favorite where rid = ? and uid = ? &quot;, new BeanPropertyRowMapper&lt;Favorite&gt;(Favorite.class), rid, uid); }catch (DataAccessException e){ e.printStackTrace(); } return favorite; } 3.3 前台代码编写在route.detail.html中添加isFavorite的js方法，在页面加载完毕后请求。 function isFavorite() { &#x2F;&#x2F; 发送请求，判断用户是否收藏过该线路 var rid = getParameter(&quot;rid&quot;); $.get(&quot;route&#x2F;isFavorite&quot;,{rid:rid},function (flag) { if (flag){ &#x2F;&#x2F; 用户已经收藏过了 &#x2F;&#x2F; &lt;a class=&quot;btn already&quot; disabled=&quot;disabled&quot;&gt; &#x2F;&#x2F; 设置收藏按钮的样式 $(&quot;#favorite&quot;).addClass(&quot;already&quot;); $(&quot;#favorite&quot;).attr(&quot;disabled&quot;,&quot;disabled&quot;); &#x2F;&#x2F; 删除按钮的点击事件 $(&quot;#favorite&quot;).removeAttr(&quot;onclick&quot;); } else { &#x2F;&#x2F; 用户没有收藏过 } }); }; 3.4 收藏次数的动态展示前台代码： &#x2F;&#x2F; 设置收藏次数 $(&quot;#favoriteNumber&quot;).html(&quot;已收藏&quot;+route.count+&quot;次&quot;); 后台添加一个查询次数方法即可 &#x2F;&#x2F; RouteService, 在加载页面时调用findOne方法，同时将收藏次数也封装进Route对象中 &#x2F;&#x2F; 4. 查询收藏次数 int count = favoriteDao.findFavoriteCount(route.getRid()); route.setCount(count); &#x2F;&#x2F; FavoriteDao &#x2F;** * @Description: 根据rid查询收藏次数 * @Author: zero * @param rid * @return 收藏次数 * @Date 2019&#x2F;7&#x2F;27 23:20 *&#x2F; @Override public int findFavoriteCount(int rid) { return template.queryForObject(&quot;select count(*) from tab_favorite where rid = ?&quot;, Integer.class,rid); } 3.5 点击按钮收藏线路3.5.1 分析 3.5.2 代码实现 前台代码 &#x2F;&#x2F; 点击收藏按钮触发的方法 function addFavorite() { var rid = getParameter(&quot;rid&quot;); &#x2F;&#x2F; 1. 判断用户是否登录 $.get(&quot;user&#x2F;findOne&quot;,{},function (user) { if (user){ &#x2F;&#x2F; 用户登录了 &#x2F;&#x2F; 调用添加功能 $.get(&quot;route&#x2F;addFavorite&quot;,{rid:rid},function () {}); &#x2F;&#x2F; 刷新页面 location.reload(); } else{ &#x2F;&#x2F; 用户未登录 alert(&quot;您未登录，请登录&quot;); location.href = &quot;http:&#x2F;&#x2F;localhost&#x2F;travel&#x2F;login.html&quot;; } }); }; 后台代码，在RouteServlet中添加addFavorite方法 &#x2F;** * @Description: 添加收藏功能 * @Author: zero * @param request * @param response * @return void * @Date 2019&#x2F;7&#x2F;27 23:46 *&#x2F; public void addFavorite(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 获取线路id rid String rid = request.getParameter(&quot;rid&quot;); &#x2F;&#x2F; 2. 获取用户对象 uid User user = (User) request.getSession().getAttribute(&quot;user&quot;); int uid; &#x2F;&#x2F; 用户id if (user == null){ &#x2F;&#x2F; 用户未登录 return; }else{ &#x2F;&#x2F; 用户已登录 uid = user.getUid(); } &#x2F;&#x2F; 3. 调用service添加 favoriteService.add(Integer.parseInt(rid), uid); } 在FavoriteServiceImpl中添加add方法 @Override public void add(int rid, int uid) { favoriteDao.add(rid,uid); } 在FavoriteDaoImpl中添加add方法 &#x2F;** * @Description: 添加收藏功能 * @Author: zero * @param rid * @param uid * @return void * @Date 2019&#x2F;7&#x2F;27 23:54 *&#x2F; @Override public void add(int rid, int uid) { template.update(&quot;insert into tab_favorite values(?,?,?)&quot;,rid,new Date(),uid); }","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://zero024.cn/tags/Project/"}]},{"title":"旅游网项目02","slug":"JavaWeb/旅游网项目02","date":"2019-07-23T15:59:00.000Z","updated":"2020-01-03T11:43:19.608Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. 前言旅游网项目，今日内容主要为优化Servlet、分类数据查询和分页查询。","text":"1. 前言旅游网项目，今日内容主要为优化Servlet、分类数据查询和分页查询。 2. 优化Servlet2.1 目的为了减少Servlet的数量，现在是一个功能一个Servlet，将其优化为相同功能的Servlet为一个模块。相当于在数据库中一张表对应一个Servlet，在Servlet中提供不同的方法，完成用户的请求。 2.2 BaseServlet编写主要进行方法的分发，利用反射机制，获取请求路径和方法名称，再获取方法对象然后执行。 package cn.itcast.travel.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; &#x2F;** * 使用反射机制，完成方法的分发 *&#x2F; public class BaseServlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;baseServlet的service方法被执行&quot;); &#x2F;&#x2F; 完成方法分发 &#x2F;&#x2F; 1. 获取请求路径 String uri = req.getRequestURI(); &#x2F;&#x2F; uri = &#x2F;travel&#x2F;user&#x2F;add System.out.println(&quot;请求uri：&quot;+uri); &#x2F;&#x2F; 2. 获取方法名称 String methodName = uri.substring(uri.lastIndexOf(&#39;&#x2F;&#39;) + 1);&#x2F;&#x2F; 为何+1？ System.out.println(&quot;方法名称&quot;+methodName); &#x2F;&#x2F; 3. 获取方法对象Method System.out.println(this); &#x2F;&#x2F; this表示当前调用service的对象，谁调用我我表示谁 try { &#x2F;&#x2F; 获取方法 Method method = this.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class); &#x2F;&#x2F; 4.执行方法 method.invoke(this,req,resp); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 2.3 UserServlet改写继承自BaseServlet，所有用户相关的方法都抽取在内。只需访问user/对应方法即可完成相应功能。 package cn.itcast.travel.web.servlet; import cn.itcast.travel.domain.ResultInfo; import cn.itcast.travel.domain.User; import cn.itcast.travel.service.UserService; import cn.itcast.travel.service.impl.UserServiceImpl; import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.commons.beanutils.BeanUtils; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.util.Map; @WebServlet(&quot;&#x2F;user&#x2F;*&quot;) public class UserServlet extends BaseServlet { &#x2F;&#x2F; 声明UserService业务对象 private UserService service = new UserServiceImpl(); &#x2F;** * @Description: 用户注册功能 * @Author: zero * @param request * @param response * @return void * @Date 2019&#x2F;7&#x2F;23 21:35 *&#x2F; public void regist(HttpServletRequest request, HttpServletResponse response) throws IOException { &#x2F;&#x2F; 获取用户输入的验证码 String check = request.getParameter(&quot;check&quot;); &#x2F;&#x2F; 从session中获取生成的验证码 HttpSession session = request.getSession(); String checkcode_server = (String)session.getAttribute(&quot;CHECKCODE_SERVER&quot;); session.removeAttribute(&quot;CHECKCODE_SERVER&quot;); &#x2F;&#x2F; 确保验证码只能使用一次 &#x2F;&#x2F; 如果验证码错误，直接注册失败 if (checkcode_server == null || !checkcode_server.equalsIgnoreCase(check)){ &#x2F;&#x2F; 验证码错误 ResultInfo info = new ResultInfo(); &#x2F;&#x2F; 注册失败 info.setFlag(false); info.setErrorMsg(&quot;验证码错误&quot;); &#x2F;&#x2F; 将info对象序列化为json ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(info); response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); response.getWriter().write(json); return; &#x2F;&#x2F; todo:为何return? } &#x2F;&#x2F; 验证通过 &#x2F;&#x2F; 1. 获取前台表单数据 Map&lt;String, String[]&gt; map = request.getParameterMap(); &#x2F;&#x2F; 2. 封装为user对象 User user = new User(); try { BeanUtils.populate(user,map); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } &#x2F;&#x2F; 3. 调用service完成注册 service = new UserServiceImpl(); boolean flag = service.regist(user); ResultInfo info = new ResultInfo(); &#x2F;&#x2F; 4. 响应结果 if (flag){ &#x2F;&#x2F; 注册成功 info.setFlag(true); }else{ &#x2F;&#x2F; 注册失败 info.setFlag(false); info.setErrorMsg(&quot;注册失败！&quot;); } &#x2F;&#x2F; 将info对象序列化为json ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(info); &#x2F;&#x2F; 将json数据回写客户端 &#x2F;&#x2F; 设置content-type response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); response.getWriter().write(json); } &#x2F;** * @Description: 邮箱激活功能 * @Author: zero * @param request * @param response * @return void * @Date 2019&#x2F;7&#x2F;23 21:36 *&#x2F; public void active(HttpServletRequest request, HttpServletResponse response) throws IOException { &#x2F;&#x2F; 1. 获取激活码 String code = request.getParameter(&quot;code&quot;); if (code != null){ &#x2F;&#x2F; 2. 调用service完成激活 service = new UserServiceImpl(); boolean flag = service.active(code); &#x2F;&#x2F; 3. 判断标记 String msg = null; if (flag){ &#x2F;&#x2F; 激活成功 msg = &quot;激活成功，请&lt;a href=&#39;login.html&#39;&gt;登录&lt;&#x2F;a&gt;&quot;; }else{ &#x2F;&#x2F; 激活失败 msg = &quot;激活失败，请联系管理员！&quot;; } &#x2F;&#x2F; 回写数据 response.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;); response.getWriter().write(msg); } } &#x2F;** * @Description: 用户登录功能 * @Author: zero * @param request * @param response * @return void * @Date 2019&#x2F;7&#x2F;23 21:37 *&#x2F; public void login(HttpServletRequest request, HttpServletResponse response) throws IOException { &#x2F;&#x2F; 1. 获取用户名和密码 Map&lt;String, String[]&gt; map = request.getParameterMap(); &#x2F;&#x2F; 2. 封装User对象 User user = new User(); try { BeanUtils.populate(user,map); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } &#x2F;&#x2F; 3. 调用service查询 service = new UserServiceImpl(); User u = service.login(user); ResultInfo info = new ResultInfo(); &#x2F;&#x2F; 4. 判断用户对象是否为null if (u == null){ &#x2F;&#x2F; 用户名或密码错误 info.setFlag(false); info.setErrorMsg(&quot;用户名或密码错误&quot;); } &#x2F;&#x2F; 5. 判断用户账户是否激活 if (u != null &amp;&amp; !&quot;Y&quot;.equals(u.getStatus())){ &#x2F;&#x2F; 用户未激活 info.setFlag(false); info.setErrorMsg(&quot;您的账户尚未激活，请激活&quot;); } &#x2F;&#x2F; 6. 判断登录成功 if (u != null &amp;&amp; &quot;Y&quot;.equals(u.getStatus())){ &#x2F;&#x2F; 登录成功 info.setFlag(true); &#x2F;&#x2F; 将登陆用户信息存入session中 request.getSession().setAttribute(&quot;user&quot;,u); } &#x2F;&#x2F; 响应数据 ObjectMapper mapper = new ObjectMapper(); response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); mapper.writeValue(response.getOutputStream(),info); } &#x2F;** * @Description: 查询单个用户，前台显示登录用户功能 * @Author: zero * @param request * @param response * @return void * @Date 2019&#x2F;7&#x2F;23 21:38 *&#x2F; public void findOne(HttpServletRequest request, HttpServletResponse response) throws IOException { &#x2F;&#x2F; 从session中获取登录用户 Object user = request.getSession().getAttribute(&quot;user&quot;); &#x2F;&#x2F; 将user回写客户端 ObjectMapper mapper = new ObjectMapper(); response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); mapper.writeValue(response.getOutputStream(),user); } &#x2F;** * @Description: 用户退出功能 * @Author: zero * @param request * @param response * @return void * @Date 2019&#x2F;7&#x2F;23 21:38 *&#x2F; public void exit(HttpServletRequest request, HttpServletResponse response) throws IOException { &#x2F;&#x2F; 1. 销毁session request.getSession().invalidate(); &#x2F;&#x2F; 2. 跳转到登录页面 response.sendRedirect(request.getContextPath()+&quot;&#x2F;login.html&quot;); } } 2.4 页面路径改写将所有用户相关的请求路径改为user/对应方法。例登录路径：user/login 激活功能URL：String content = &quot;&lt;a href=&#39;http://localhost/travel/user/active?code=&quot;+user.getCode()+&quot;&#39;&gt;点击激活账户&lt;/a&gt;&quot;; 3. 分类数据展示3.1 分析 3.2 后台代码实现3.2.1 CategoryServlet代码 package cn.itcast.travel.web.servlet; import cn.itcast.travel.domain.Category; import cn.itcast.travel.service.CategoryService; import cn.itcast.travel.service.impl.CategoryServiceImpl; import com.fasterxml.jackson.databind.ObjectMapper; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.List; &#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;23 22:51 * Modified By: *&#x2F; @WebServlet(&quot;&#x2F;category&#x2F;*&quot;) public class CategoryServlet extends BaseServlet { private CategoryService service = new CategoryServiceImpl(); &#x2F;** * @Description:查询所有 * @Author: zero * @param request * @param response * @return void * @Date 2019&#x2F;7&#x2F;23 22:52 *&#x2F; public void findAll(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 调用servvice查询所有 List&lt;Category&gt; categories = service.findAll(); &#x2F;&#x2F; 2. 序列化为json返回 writeValue(categories,response); } } 3.2.2 CategoryService代码 package cn.itcast.travel.service.impl; import cn.itcast.travel.dao.CategoryDao; import cn.itcast.travel.dao.impl.CategoryDaoImpl; import cn.itcast.travel.domain.Category; import cn.itcast.travel.service.CategoryService; import java.util.List; &#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;23 22:49 * Modified By: *&#x2F; public class CategoryServiceImpl implements CategoryService { private CategoryDao categoryDao = new CategoryDaoImpl(); @Override public List&lt;Category&gt; findAll() { return categoryDao.findAll(); } } 3.2.3 CategoryDao代码 package cn.itcast.travel.dao; import cn.itcast.travel.domain.Category; import java.util.List; &#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;23 22:42 * Modified By: *&#x2F; public interface CategoryDao { &#x2F;** * @Description: 查询所有 * @Author: zero * @param * @return List集合 * @Date 2019&#x2F;7&#x2F;23 22:44 *&#x2F; List&lt;Category&gt; findAll(); } 3.2.4 优化部分代码将序列化json方法封装在BaseServlet，减少代码冗余 &#x2F;** * @Description: 直接将传入的对象序列化为json，并且写回客户端 * @Author: zero * @param obj * @param response * @return void * @Date 2019&#x2F;7&#x2F;23 23:16 *&#x2F; public void writeValue(Object obj,HttpServletResponse response) throws IOException{ ObjectMapper mapper = new ObjectMapper(); response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); mapper.writeValue(response.getOutputStream(),obj); } &#x2F;** * @Description: 将传入的对象序列化为json后返回 * @Author: zero * @param obj * @return String * @Date 2019&#x2F;7&#x2F;23 23:18 *&#x2F; public String writeValueAsString(Object obj) throws JsonProcessingException { return new ObjectMapper().writeValueAsString(obj); } 3.3 前台代码实现 &#x2F;&#x2F; 查询分类数据 $.get(&quot;category&#x2F;findAll&quot;,{},function (data) { &#x2F;&#x2F; [{cid:1,cname:xxx},{cid:2,cname:xxx},] var lis = &#39;&lt;li class=&quot;nav-active&quot;&gt;&lt;a href=&quot;index.html&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; &#x2F;&#x2F; 遍历数组，拼接字符串（&lt;li&gt;） for (var i = 0; i &lt; data.length; i++) { var li = &#39;&lt;li&gt;&lt;a href=&quot;route_list.html&quot;&gt;&#39;+data[i].cname+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; lis += li; } &#x2F;&#x2F; 拼接收藏排行榜的li，&lt;li&gt;&lt;a href=&quot;favoriterank.html&quot;&gt; 收藏排行榜&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; lis+=&#39;&lt;li&gt;&lt;a href=&quot;favoriterank.html&quot;&gt;收藏排行榜&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; &#x2F;&#x2F; 将lis字符串，设置到ul的html内容中 $(&quot;#category&quot;).html(lis); }) 3.4 对分类数据进行缓存优化分类的数据在每一次页面加载后都会重新请求数据库来加载，对数据库的压力比较大，且分类的数据不会经常产生变化，故在此可以使用redis来缓存这个数据。 3.5 优化代码实现 &#x2F;** * @Description: 使用redis缓存，优化代码，减少对数据库的访问 * @Author: zero * @param * @return List * @Date 2019&#x2F;7&#x2F;24 20:52 *&#x2F; @Override public List&lt;Category&gt; findAll() { &#x2F;&#x2F; 初始化集合对象 List&lt;Category&gt; cs = null; &#x2F;&#x2F; 1. 从redis中查询数据 &#x2F;&#x2F; 1.1 获取redis客户端连接对象 Jedis jedis = JedisUtil.getJedis(); &#x2F;&#x2F; 1.2 使用sortedset排序查询 Set&lt;String&gt; categorys = jedis.zrange(&quot;category&quot;, 0, -1); &#x2F;&#x2F; 2. 判断集合是否为null if (categorys == null || categorys.size() == 0){ &#x2F;&#x2F; 2.1 为空，则表示第一次访问 System.out.println(&quot;redis中无数据，查询数据库...&quot;); &#x2F;&#x2F; 2.2 查询数据库，获取数据 cs = categoryDao.findAll(); &#x2F;&#x2F; 2.3 将集合数据存储到redis中的category的key for (int i = 0; i &lt; cs.size(); i++) { jedis.zadd(&quot;category&quot;,cs.get(i).getCid(),cs.get(i).getCname()); } }else{ &#x2F;&#x2F; 3. 不为空，将查询到的set集合数据存入list再返回 &#x2F;&#x2F; 因返回的是list集合，故将查询到的set集合数据转换为list数据 System.out.println(&quot;redis中有数据，查询缓存...&quot;); cs = new ArrayList&lt;Category&gt;(); for (String name : categorys) { Category category = new Category(); category.setCname(name); cs.add(category); } } return cs; } 4. 旅游线路的分页展示4.1 类别id的传递 从redis中查询数据是，需要将分数也查询出来；并且在返回list集合里，将cid的值设置为对应分数 前台页面传递对应cid，修改header.html，加上data[i].cid即可。 var li = &#39;&lt;li&gt;&lt;a href=&quot;route_list.html?cid=&#39;+data[i].cid+&#39;&quot;&gt;&#39;+data[i].cname+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; 获取cid $(function(){ var search = location.search; &#x2F;&#x2F; alert(search); &#x2F;&#x2F; 切割字符串，拿到第二个值 var cid = search.split(&quot;=&quot;)[1]; }); 4.2 根据id查询不同类别的旅游线路4.2.1 分析 4.2.2 后台代码实现4.2.2.1 PageBean对象后台返回给前台的对象 public class PageBean&lt;T&gt; { private int totalCount; &#x2F;&#x2F; 总记录数 private int totalPage; &#x2F;&#x2F; 总页数 private int currentPage; &#x2F;&#x2F; 当前页码 private int pageSize; &#x2F;&#x2F; 每页显示的条数 private List&lt;T&gt; list; &#x2F;&#x2F; 每页显示的数据集合 &#x2F;&#x2F; 省略getset方法 } 4.2.2.2 RouteServlet控制器代码负责接收前台传递的参数并处理，调用service查询到PageBean对象后序列化为json再返回给前端。 package cn.itcast.travel.web.servlet; import cn.itcast.travel.domain.PageBean; import cn.itcast.travel.domain.Route; import cn.itcast.travel.service.RouteService; import cn.itcast.travel.service.impl.RouteServiceImpl; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; &#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;24 21:52 * Modified By: *&#x2F; @WebServlet(&quot;&#x2F;route&#x2F;*&quot;) public class RouteServlet extends BaseServlet { private RouteService routeService = new RouteServiceImpl(); public void pageQuery(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 接受参数 String currentPageStr = request.getParameter(&quot;currentPage&quot;); String pageSizeStr = request.getParameter(&quot;pageSize&quot;); String cidStr = request.getParameter(&quot;cid&quot;); &#x2F;&#x2F; 2. 处理参数 int cid = 0; &#x2F;&#x2F; 类别id if (cidStr != null &amp;&amp; cidStr.length() &gt; 0){ cid = Integer.parseInt(cidStr); } int currentPage = 0; &#x2F;&#x2F; 当前页码，如果不传递，则默认为第一页 if (currentPageStr != null &amp;&amp; currentPageStr.length() &gt; 0){ currentPage = Integer.parseInt(currentPageStr); }else { currentPage = 1; } int pageSize = 0; &#x2F;&#x2F; 每页显示条数，默认为5 if (pageSizeStr != null &amp;&amp; pageSizeStr.length() &gt; 0){ pageSize = Integer.parseInt(pageSizeStr); }else { pageSize = 5; } &#x2F;&#x2F; 3. 调用service查询PageBean对象 PageBean&lt;Route&gt; pb = routeService.pageQuery(cid, currentPage, pageSize); &#x2F;&#x2F; 4. 将pageBean对象序列化为json，返回 writeValue(pb,response); } } 4.2.2.3 RouteServiceImpl代码根据当前页码，类别信息等，从数据库中查询出当前类别对应数据集合，封装PageBean对象后返回 package cn.itcast.travel.service.impl; import cn.itcast.travel.dao.RouteDao; import cn.itcast.travel.dao.impl.RouteDaoImpl; import cn.itcast.travel.domain.PageBean; import cn.itcast.travel.domain.Route; import cn.itcast.travel.service.RouteService; import java.util.List; &#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;24 22:04 * Modified By: *&#x2F; public class RouteServiceImpl implements RouteService { private RouteDao routeDao = new RouteDaoImpl(); &#x2F;** * @Description: 查询当前页数据集合并封装为PageBean对象后返回 * @Author: zero * @param cid * @param currentPage * @param pageSize * @return 封装好的PageBean对象 * @Date 2019&#x2F;7&#x2F;24 22:50 *&#x2F; @Override public PageBean&lt;Route&gt; pageQuery(int cid, int currentPage, int pageSize) { &#x2F;&#x2F; 封装PageBean PageBean&lt;Route&gt; pb = new PageBean&lt;&gt;(); &#x2F;&#x2F; 设置当前页码 pb.setCurrentPage(currentPage); &#x2F;&#x2F; 设置每页显示的条数 pb.setPageSize(pageSize); &#x2F;&#x2F; 设置总记录数 int totalCount = routeDao.findTotalCount(cid); pb.setTotalCount(totalCount); &#x2F;&#x2F; 设置当前页显示的数据集合 int start = (currentPage - 1) * pageSize; &#x2F;&#x2F; 开始的记录数 List&lt;Route&gt; list = routeDao.findByPage(cid, start, pageSize); pb.setList(list); &#x2F;&#x2F; 设置总页数 = 总记录数 &#x2F; 每页显示条数 int totalPage = totalCount % pageSize == 0 ? totalCount &#x2F; pageSize : (totalCount &#x2F; pageSize) + 1; pb.setTotalPage(totalPage); return pb; } } 4.2.2.4 RouteDaoImpl，DAO实现类查询当前类别总记录数和类别当前页的数据集合 package cn.itcast.travel.dao.impl; import cn.itcast.travel.dao.RouteDao; import cn.itcast.travel.domain.Route; import cn.itcast.travel.util.JDBCUtils; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import java.util.List; &#x2F;** * @Author: zero * @Description: Date:Create: in 2019&#x2F;7&#x2F;24 22:09 * Modified By: *&#x2F; public class RouteDaoImpl implements RouteDao { private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); &#x2F;** * @Description: 根据cid查询总记录数 * @Author: zero * @param cid * @return 总记录数 * @Date 2019&#x2F;7&#x2F;24 22:08 *&#x2F; @Override public int findTotalCount(int cid) { return template.queryForObject(&quot;select count(*) from tab_route where cid = ?&quot;,Integer.class,cid); } &#x2F;** * @Description: 根据cid，start，pageSize查询当前页的数据集合 * @Author: zero * @param cid * @param start * @param pageSize * @return 查询到的当前页数据集合 * @Date 2019&#x2F;7&#x2F;24 22:08 *&#x2F; @Override public List&lt;Route&gt; findByPage(int cid, int start, int pageSize) { String sql = &quot;select * from tab_route where cid = ? limit ? , ?&quot;; return template.query(sql,new BeanPropertyRowMapper&lt;Route&gt;(Route.class),cid,start,pageSize); } } 4.2.3 前台代码实现 &lt;script&gt; $(function () { var search = location.search; &#x2F;&#x2F; alert(search); &#x2F;&#x2F; 切割字符串，拿到第二个值 var cid = search.split(&quot;=&quot;)[1]; &#x2F;&#x2F; 当页码加载完毕后，调用load方法， load(cid); }) function load(cid, currentPage) { &#x2F;&#x2F; 发送ajax请求，请求route&#x2F;pageQuery，传递cid $.get(&quot;route&#x2F;pageQuery&quot;,{cid:cid,currentPage:currentPage},function (pb) { &#x2F;&#x2F; 解析PageBean数据，展示到页面上 &#x2F;&#x2F; 1. 分页工具条数据展示 &#x2F;&#x2F; 1.1 展示总页码和总记录数 $(&quot;#totalPage&quot;).html(pb.totalPage); $(&quot;#totalCount&quot;).html(pb.totalCount); var lis = &quot;&quot;; var fristPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; &#x2F;&#x2F; 计算上一页的页码 var beforeNum = pb.currentPage - 1; if (beforeNum &lt;= 0){ beforeNum = 1; } var beforePage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+beforeNum+&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;上一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; lis += fristPage; lis += beforePage; &#x2F;&#x2F; 1.2 展示分页页码 &#x2F;* 仿百度分页样式：前五后四 1. 一共展示10个页码，能够达到前5后4的效果 2. 如果前边不足5个，后边补齐10个 3. 如果后边不足4个，前边补齐10个 *&#x2F; &#x2F;&#x2F; 定义开始位置begin和结束位置end var begin; &#x2F;&#x2F; 开始位置 var end; &#x2F;&#x2F; 结束位置 &#x2F;&#x2F; 1. 显示10个页码 if(pb.totalPage &lt; 10){ &#x2F;&#x2F; 总页码不足10页 begin = 1; end = pb.totalPage; }else{ &#x2F;&#x2F; 总页码超过10页 &#x2F;&#x2F; 实现前5后4效果 begin = pb.currentPage - 5; end = pb.currentPage + 4; &#x2F;&#x2F; 进行数据修正 &#x2F;&#x2F; 2. 如果前边不够5个，后边补齐10个 if (begin &lt; 1){ begin = 1; end = begin + 9; } &#x2F;&#x2F; 3. 如果后边不足4个，前边补齐10个 if (end &gt; pb.totalPage){ end = pb.totalPage; begin = end - 9; } } for (var i = begin; i &lt;= end; i++) { var li; &#x2F;&#x2F; 判断当前页码是否等于i if (pb.currentPage == i){ li = &#39;&lt;li class=&quot;curPage&quot; onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; }else{ &#x2F;&#x2F; 创建页码的li li = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; } &#x2F;&#x2F; 拼接进字符串 lis += li; } &#x2F;&#x2F; for (var i = 1; i &lt;= pb.totalPage ; i++) { &#x2F;&#x2F; var li; &#x2F;&#x2F; &#x2F;&#x2F; 判断当前页码是否等于i &#x2F;&#x2F; if (pb.currentPage == i){ &#x2F;&#x2F; li = &#39;&lt;li class=&quot;curPage&quot; onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; &#x2F;&#x2F; }else{ &#x2F;&#x2F; &#x2F;&#x2F; 创建页码的li &#x2F;&#x2F; li = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+i+&#39;)&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;&#39;+i+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; &#x2F;&#x2F; } &#x2F;&#x2F; &#x2F;&#x2F; 拼接进字符串 &#x2F;&#x2F; lis += li; &#x2F;&#x2F; } &#x2F;&#x2F; 计算下一页页码 var nextNum = pb.currentPage + 1; if(nextNum &gt;= pb.totalPage){ nextNum = pb.totalPage; } var nextPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+nextNum+&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;下一页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; var lastPage = &#39;&lt;li onclick=&quot;javascript:load(&#39;+cid+&#39;,&#39;+pb.totalPage+&#39;)&quot; class=&quot;threeword&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;末页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; lis += nextPage; lis += lastPage; &#x2F;&#x2F; 将lis内容设置到ul中 $(&quot;#pageNum&quot;).html(lis); &#x2F;&#x2F; 2. 列表数据展示 var route_lis = &quot;&quot;; for (var i = 0; i &lt; pb.list.length; i++) { &#x2F;&#x2F; 获取数据 {rid&quot;: 1,&quot;rname&quot;: &quot;xxx&quot;,&quot;price&quot;: 999.0,xxxx} var route = pb.list[i]; var li = &#39;&lt;li&gt;\\n&#39; + &#39; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;&#39;+route.rimage+&#39;&quot; style=&quot;width: 299px&quot;&gt;&lt;&#x2F;div&gt;\\n&#39; + &#39; &lt;div class=&quot;text1&quot;&gt;\\n&#39; + &#39; &lt;p&gt;&#39;+route.rname+&#39;&lt;&#x2F;p&gt;\\n&#39; + &#39; &lt;br&#x2F;&gt;\\n&#39; + &#39; &lt;p&gt;&#39;+route.routeIntroduce+&#39;&lt;&#x2F;p&gt;\\n&#39; + &#39; &lt;&#x2F;div&gt;\\n&#39; + &#39; &lt;div class=&quot;price&quot;&gt;\\n&#39; + &#39; &lt;p class=&quot;price_num&quot;&gt;\\n&#39; + &#39; &lt;span&gt;&amp;yen;&lt;&#x2F;span&gt;\\n&#39; + &#39; &lt;span&gt;&#39;+route.price+&#39;&lt;&#x2F;span&gt;\\n&#39; + &#39; &lt;span&gt;起&lt;&#x2F;span&gt;\\n&#39; + &#39; &lt;&#x2F;p&gt;\\n&#39; + &#39; &lt;p&gt;&lt;a href=&quot;route_detail.html&quot;&gt;查看详情&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;\\n&#39; + &#39; &lt;&#x2F;div&gt;\\n&#39; + &#39; &lt;&#x2F;li&gt;&#39;; route_lis += li; } $(&quot;#route&quot;).html(route_lis); &#x2F;&#x2F; 每次点击翻页后，定位到页面顶部 window.scrollTo(0,0); }); } &lt;&#x2F;script&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://zero024.cn/tags/Project/"}]},{"title":"旅游网项目01","slug":"JavaWeb/旅游网项目01","date":"2019-07-21T15:59:00.000Z","updated":"2020-01-03T11:43:19.607Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. 前言为了巩固web基础知识，提升综合运用能力，故编写此项目，以做练习。 今日内容为登录注册内容。","text":"1. 前言为了巩固web基础知识，提升综合运用能力，故编写此项目，以做练习。 今日内容为登录注册内容。 2. 技术选型2.1 Web层 Servlet：前端控制器 html：视图 Filter：过滤器 BeanUtils：数据封装 Jackson：json序列化工具 2.2 Service层 Javamail：java发送邮件工具 Redis：nosql内存数据库 Jedis：java的Redis客户端 2.3 Dao层 MySQL：后台数据库 Druid：数据库连接池 JdbcTemplate：jdbc的工具 3. 创建数据库 -- 创建数据库 create database travel; -- 使用数据库 use travel; -- 创建表 &#x2F;*==============================================================*&#x2F; &#x2F;* DBMS name: MySQL 5.0 *&#x2F; &#x2F;* Created on: 2019&#x2F;7&#x2F;21 20:13:29 *&#x2F; &#x2F;*==============================================================*&#x2F; set names utf8; drop table if exists tab_favorite; drop table if exists tab_route_img; drop table if exists tab_route; drop table if exists tab_category; drop table if exists tab_seller; drop table if exists tab_user; &#x2F;*==============================================================*&#x2F; &#x2F;* Table: tab_category *&#x2F; &#x2F;*==============================================================*&#x2F; create table tab_category ( cid int not null auto_increment, cname varchar(100) not null, primary key (cid), unique key AK_nq_categoryname (cname) ); &#x2F;*==============================================================*&#x2F; &#x2F;* Table: tab_favorite *&#x2F; &#x2F;*==============================================================*&#x2F; create table tab_favorite ( rid int not null, date date not null, uid int not null, primary key (rid, uid) ); &#x2F;*==============================================================*&#x2F; &#x2F;* Table: tab_route *&#x2F; &#x2F;*==============================================================*&#x2F; create table tab_route ( rid int not null auto_increment, rname varchar(500) not null, price double not null, routeIntroduce varchar(1000), rflag char(1) not null, rdate varchar(19), isThemeTour char(1) not null, count int default 0, cid int not null, rimage varchar(200), sid int, sourceId varchar(50), primary key (rid), unique key AK_nq_sourceId (sourceId) ); &#x2F;*==============================================================*&#x2F; &#x2F;* Table: tab_route_img *&#x2F; &#x2F;*==============================================================*&#x2F; create table tab_route_img ( rgid int not null auto_increment, rid int not null, bigPic varchar(200) not null, smallPic varchar(200), primary key (rgid) ); &#x2F;*==============================================================*&#x2F; &#x2F;* Table: tab_seller *&#x2F; &#x2F;*==============================================================*&#x2F; create table tab_seller ( sid int not null auto_increment, sname varchar(200) not null, consphone varchar(20) not null, address varchar(200), primary key (sid), unique key AK_Key_2 (sname) ); &#x2F;*==============================================================*&#x2F; &#x2F;* Table: tab_user *&#x2F; &#x2F;*==============================================================*&#x2F; create table tab_user ( uid int not null auto_increment, username varchar(100) not null, password varchar(32) not null, name varchar(100), birthday date, sex char(1), telephone varchar(11), email varchar(100), status char(1) , code varchar(50), primary key (uid), unique key AK_nq_username (username), unique key AK_nq_code (code) ); -- 建立表连接 alter table tab_favorite add constraint FK_route_favorite foreign key (rid) references tab_route (rid) on delete restrict on update restrict; alter table tab_favorite add constraint FK_user_favorite foreign key (uid) references tab_user (uid) on delete restrict on update restrict; alter table tab_route add constraint FK_category_route foreign key (cid) references tab_category (cid) on delete restrict on update restrict; alter table tab_route add constraint FK_seller_route foreign key (sid) references tab_seller (sid) on delete restrict on update restrict; alter table tab_route_img add constraint FK_route_routeimg foreign key (rid) references tab_route (rid) on delete restrict on update restrict; -- 修改表默认字符集,解决1366问题 alter table tab_category convert to character set utf8 collate utf8_general_ci; alter table tab_favorite convert to character set utf8 collate utf8_general_ci; alter table tab_route convert to character set utf8 collate utf8_general_ci; alter table tab_route_img convert to character set utf8 collate utf8_general_ci; alter table tab_seller convert to character set utf8 collate utf8_general_ci; alter table tab_user convert to character set utf8 collate utf8_general_ci; 关于报错1366问题：详见文章 4. 注册功能4.1 功能分析 4.2 代码实现4.2.1 表单校验 &#x2F;&#x2F; 使用Jquery完成表单校验 &#x2F;&#x2F; 定义校验方法 &#x2F;&#x2F; 用户名校验 function checkUsername() { &#x2F;&#x2F; 1. 获取用户名值 var username = $(&quot;#username&quot;).val(); &#x2F;&#x2F; 2. 定义正则 var reg_username = &#x2F;^[\\u4e00-\\u9fa5]|[0-9a-zA-Z]{2,20}$&#x2F;; &#x2F;&#x2F; 3. 判断，给出提示信息 var flag = reg_username.test(username); if (flag){ &#x2F;&#x2F; 用户名合法 $(&quot;#username&quot;).css(&quot;border&quot;,&quot;&quot;); }else { &#x2F;&#x2F; 用户名非法，加红色边框 $(&quot;#username&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;); } return flag; } &#x2F;&#x2F; 密码校验 function checkPwd() { &#x2F;&#x2F; 1. 获取值 var password = $(&quot;#password&quot;).val(); &#x2F;&#x2F; 2. 定义正则 var reg_password = &#x2F;^[\\w_-]{6,20}$&#x2F;; &#x2F;&#x2F; 3. 判断，返回信息 var flag = reg_password.test(password); if (flag){ &#x2F;&#x2F; 密码合法 $(&quot;#password&quot;).css(&quot;border&quot;,&quot;&quot;); } else { &#x2F;&#x2F; 非法，加红色边框 $(&quot;#password&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;); } return flag; } &#x2F;&#x2F; 邮箱校验 function checkEmail() { var email = $(&quot;#email&quot;).val(); var reg_email = &#x2F;^\\w+@\\w+\\.\\w+$&#x2F;; var flag = reg_email.test(email); if(flag){ $(&quot;#email&quot;).css(&quot;border&quot;,&quot;&quot;); }else { $(&quot;#email&quot;).css(&quot;border&quot;,&quot;1px solid red&quot;); } return flag; } $(function () { &#x2F;&#x2F; 当表单提交时，调用所有校验方法 $(&quot;#registerForm&quot;).submit(function () { return checkUsername() &amp;&amp; checkPwd() &amp;&amp; checkEmail(); }); &#x2F;&#x2F; 当某一组件失去焦点时，调用对应的校验方法 $(&quot;#username&quot;).blur(checkUsername); $(&quot;#password&quot;).blur(checkPwd); $(&quot;#email&quot;).blur(checkEmail); }); 4.2.2 异步提交表单使用异步提交表单是为了获取服务器响应的数据。因为前台使用的是html作为视图层，不能够直接从servlet相关的域对象获取值，只能通过ajax获取响应数据。 $(function () { &#x2F;&#x2F; 当表单提交时，调用所有校验方法 $(&quot;#registerForm&quot;).submit(function () { &#x2F;&#x2F; 1. 发送数据到服务器 if ( checkUsername() &amp;&amp; checkPwd() &amp;&amp; checkEmail()){ &#x2F;&#x2F; 校验通过，发送ajax请求，提交表单数据 $.post(&quot;registUserServlet&quot;,$(this).serialize(),function (data) { &#x2F;&#x2F; 处理服务器响应的数据 data {flag:true,errorMsg:&quot;注册失败&quot;} if (data.flag){ &#x2F;&#x2F; 注册成功，跳转到成功页面 location.href = &quot;register_ok.html&quot;; }else{ &#x2F;&#x2F; 注册失败，给errorMsg添加提示信息 $(&quot;#errorMsg&quot;).html(data.errorMsg); } }) } &#x2F;&#x2F; 2. 不让页面跳转，不提交 return false; }); &#x2F;&#x2F; 当某一组件失去焦点时，调用对应的校验方法 $(&quot;#username&quot;).blur(checkUsername); $(&quot;#password&quot;).blur(checkPwd); $(&quot;#email&quot;).blur(checkEmail); }); 4.3 后台代码实现4.3.1 注册用户控制器：RegistUserServlet package cn.itcast.travel.web.servlet; import cn.itcast.travel.domain.ResultInfo; import cn.itcast.travel.domain.User; import cn.itcast.travel.service.UserService; import cn.itcast.travel.service.impl.UserServiceImpl; import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.commons.beanutils.BeanUtils; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.util.Map; @WebServlet(&quot;&#x2F;registUserServlet&quot;) public class RegistUserServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 获取用户输入的验证码 String check = request.getParameter(&quot;check&quot;); &#x2F;&#x2F; 从session中获取生成的验证码 HttpSession session = request.getSession(); String checkcode_server = (String)session.getAttribute(&quot;CHECKCODE_SERVER&quot;); session.removeAttribute(&quot;CHECKCODE_SERVER&quot;); &#x2F;&#x2F; 确保验证码只能使用一次 &#x2F;&#x2F; 如果验证码错误，直接注册失败 if (checkcode_server == null || !checkcode_server.equalsIgnoreCase(check)){ &#x2F;&#x2F; 验证码错误 ResultInfo info = new ResultInfo(); &#x2F;&#x2F; 注册失败 info.setFlag(false); info.setErrorMsg(&quot;验证码错误&quot;); &#x2F;&#x2F; 将info对象序列化为json ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(info); response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); response.getWriter().write(json); return; &#x2F;&#x2F; todo:为何return? } &#x2F;&#x2F; 验证通过 &#x2F;&#x2F; 1. 获取前台表单数据 Map&lt;String, String[]&gt; map = request.getParameterMap(); &#x2F;&#x2F; 2. 封装为user对象 User user = new User(); try { BeanUtils.populate(user,map); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } &#x2F;&#x2F; 3. 调用service完成注册 UserService service = new UserServiceImpl(); boolean flag = service.regist(user); ResultInfo info = new ResultInfo(); &#x2F;&#x2F; 4. 响应结果 if (flag){ &#x2F;&#x2F; 注册成功 info.setFlag(true); }else{ &#x2F;&#x2F; 注册失败 info.setFlag(false); info.setErrorMsg(&quot;注册失败！&quot;); } &#x2F;&#x2F; 将info对象序列化为json ObjectMapper mapper = new ObjectMapper(); System.out.println(info); String json = mapper.writeValueAsString(info); &#x2F;&#x2F; 将json数据回写客户端 &#x2F;&#x2F; 设置content-type response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); response.getWriter().write(json); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } 4.3.2 用户服务业务层以及对应实现类服务层接口 package cn.itcast.travel.service; import cn.itcast.travel.domain.User; public interface UserService { boolean regist(User user); } 实现类 package cn.itcast.travel.service.impl; import cn.itcast.travel.dao.UserDao; import cn.itcast.travel.dao.impl.UserDaoImpl; import cn.itcast.travel.domain.User; import cn.itcast.travel.service.UserService; public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); &#x2F;** * 注册用户服务 * @param user * @return 是否注册成功 *&#x2F; @Override public boolean regist(User user) { &#x2F;&#x2F; 1. 根据用户名查询用户对象 User u = userDao.findByUsername(user.getUsername()); &#x2F;&#x2F; 判断是否为null if (u != null){ &#x2F;&#x2F; 不为空，说明用户名存在，注册失败 return false; } &#x2F;&#x2F; 2. 保存用户信息 userDao.save(user); return true; } } 4.3.3 数据操作层及对应实现类Dao package cn.itcast.travel.dao; import cn.itcast.travel.domain.User; public interface UserDao { User findByUsername(String username); void save(User user); } 实现类 package cn.itcast.travel.dao.impl; import cn.itcast.travel.dao.UserDao; import cn.itcast.travel.domain.User; import cn.itcast.travel.util.JDBCUtils; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; public class UserDaoImpl implements UserDao { private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); &#x2F;** * 查询用户是否存在 * @param username * @return 返回查询到的用户 *&#x2F; @Override public User findByUsername(String username) { &#x2F;* queryForObject()方法 如果查询结果条数为0或者大于1)都会返回异常，我们希望没查到直接返回null *&#x2F; User user = null; try{ user = template.queryForObject(&quot;select * from tab_user where username = ? &quot;, new BeanPropertyRowMapper&lt;User&gt;(User.class),username); }catch (Exception e){ System.out.println(&quot;用户未查询到&quot;); } return user; } @Override public void save(User user) { &#x2F;&#x2F; 1. 定义sql String sql = &quot;insert into tab_user(username,password,name,birthday,sex,telephone,email) values(?,?,?,?,?,?,?)&quot;; &#x2F;&#x2F; 2. 执行sql template.update(sql,user.getUsername(),user.getPassword(),user.getName(), user.getBirthday(),user.getSex(),user.getTelephone(),user.getEmail()); } } 4.3.4 邮件激活为什么要进行邮件激活？为了保证用户填写的邮箱是正确的。将来可以推广一些宣传信息，到用户邮箱中。 4.3.5 发送邮件 打开邮箱 开启授权码，并生成一个 在MailUtils中设置自己的邮箱账号和密码(授权码) MailUtils是邮箱工具类，调用其中的sendMail方法可以完成邮件发送 4.3.6 用户点击邮件激活4.3.6.1 功能分析 4.3.6.2 发送邮件代码实现 @Override public boolean regist(User user) { &#x2F;&#x2F; 1. 根据用户名查询用户对象 User u = userDao.findByUsername(user.getUsername()); &#x2F;&#x2F; 判断是否为null if (u != null){ &#x2F;&#x2F; 不为空，说明用户名存在，注册失败 return false; } &#x2F;&#x2F; 2. 保存用户信息 &#x2F;&#x2F; 2.1 设置激活码，唯一字符串 String uuid = UuidUtil.getUuid(); System.out.println(uuid); user.setCode(uuid); &#x2F;&#x2F; 2.2 设置激活状态 user.setStatus(&quot;N&quot;); &#x2F;&#x2F; 默认未激活 userDao.save(user); &#x2F;&#x2F; 3. 激活邮件发送，邮件正文 &#x2F;&#x2F; 邮件正文 todo:后期项目部署需要将href改为服务器域名 String content = &quot;&lt;a href=&#39;http:&#x2F;&#x2F;localhost&#x2F;travel&#x2F;activeUserServlet?code=&quot;+user.getCode()+&quot;&#39;&gt;点击激活账户&lt;&#x2F;a&gt;&quot;; &#x2F;&#x2F; 发送邮件 MailUtils.sendMail(user.getEmail(),content,&quot;激活邮件&quot;); return true; } 4.3.6.3 修改保存Dao代码，以及存储status和code代码逻辑 4.3.6.4 激活Servlet实现 package cn.itcast.travel.web.servlet; import cn.itcast.travel.service.impl.UserServiceImpl; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;&#x2F;activeUserServlet&quot;) public class ActiveUserServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 获取激活码 String code = request.getParameter(&quot;code&quot;); if (code != null){ &#x2F;&#x2F; 2. 调用service完成激活 UserServiceImpl service = new UserServiceImpl(); boolean flag = service.active(code); &#x2F;&#x2F; 3. 判断标记 String msg = null; if (flag){ &#x2F;&#x2F; 激活成功 msg = &quot;激活成功，请&lt;a href=&#39;login.html&#39;&gt;登录&lt;&#x2F;a&gt;&quot;; }else{ &#x2F;&#x2F; 激活失败 msg = &quot;激活失败，请联系管理员！&quot;; } &#x2F;&#x2F; 回写数据 response.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;); response.getWriter().write(msg); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } 4.3.6.5 激活Service代码 @Override public boolean active(String code) { &#x2F;&#x2F; 1. 根据激活码查询用户对象 User user = userDao.findByCode(code); if (user != null){ &#x2F;&#x2F; 2. 调用dao的修改激活状态的方法 userDao.updateStatus(user); return true; }else{ return false; } } 4.3.6.6 激活Dao代码：findByCode&amp;updateStatus &#x2F;** * 根据激活码查询用户对象 * @param code * @return 查询到的对象 *&#x2F; @Override public User findByCode(String code) { User user = null; try{ String sql = &quot;select * from tab_user where code = ?&quot;; user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), code); }catch (DataAccessException e){ e.printStackTrace(); } return user; } &#x2F;** * 修改指定用户激活状态 * @param user *&#x2F; @Override public void updateStatus(User user) { template.update(&quot;update tab_user set status = &#39;Y&#39; where uid = ?&quot;,user.getUid()); } 5. 登录5.1 分析 5.2 前台代码实现 &lt;script&gt; $(function () { &#x2F;&#x2F; 1. 给登录按钮绑定单击事件 $(&quot;#btn_sub&quot;).click(function () { &#x2F;&#x2F; 2. 发送ajax请求，提交表单数据 $.post(&quot;loginServlet&quot;,$(&quot;#loginForm&quot;).serialize(),function (data) { &#x2F;&#x2F; data: {flag:false,errorMsg:&quot;&quot;} if (data.flag){ &#x2F;&#x2F; 登录成功 location.href = &quot;index.html&quot;; } else{ &#x2F;&#x2F; 登录失败 $(&quot;#errorMsg&quot;).html(data.errorMsg); } }); }); }); &lt;&#x2F;script&gt; 5.3 后台代码实现5.3.1 登录控制器：LoginServlet package cn.itcast.travel.web.servlet; import cn.itcast.travel.domain.ResultInfo; import cn.itcast.travel.domain.User; import cn.itcast.travel.service.impl.UserServiceImpl; import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.commons.beanutils.BeanUtils; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.util.Map; @WebServlet(&quot;&#x2F;loginServlet&quot;) public class LoginServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 获取用户名和密码 Map&lt;String, String[]&gt; map = request.getParameterMap(); &#x2F;&#x2F; 2. 封装User对象 User user = new User(); try { BeanUtils.populate(user,map); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } &#x2F;&#x2F; 3. 调用service查询 UserServiceImpl service = new UserServiceImpl(); User u = service.login(user); ResultInfo info = new ResultInfo(); &#x2F;&#x2F; 4. 判断用户对象是否为null if (u == null){ &#x2F;&#x2F; 用户名或密码错误 info.setFlag(false); info.setErrorMsg(&quot;用户名或密码错误&quot;); } &#x2F;&#x2F; 5. 判断用户账户是否激活 if (u != null &amp;&amp; !&quot;Y&quot;.equals(u.getStatus())){ &#x2F;&#x2F; 用户未激活 info.setFlag(false); info.setErrorMsg(&quot;您的账户尚未激活，请激活&quot;); } &#x2F;&#x2F; 6. 判断登录成功 if (u != null &amp;&amp; &quot;Y&quot;.equals(u.getStatus())){ &#x2F;&#x2F; 登录成功 info.setFlag(true); &#x2F;&#x2F; 将登陆用户信息存入session中 request.getSession().setAttribute(&quot;user&quot;,u); } &#x2F;&#x2F; 响应数据 ObjectMapper mapper = new ObjectMapper(); response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); mapper.writeValue(response.getOutputStream(),info); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } 5.3.2 服务层代码 &#x2F;** * 进行登录操作 * @param user * @return User对象 *&#x2F; @Override public User login(User user) { return userDao.findByUsernameAndPassword(user.getUsername(),user.getPassword()); } 5.3.3 Dao层代码 &#x2F;** * 根据用户名和密码，查询是否有此用户 * @param username * @param password * @return user对象 *&#x2F; @Override public User findByUsernameAndPassword(String username, String password) { User user = null; try{ String sql = &quot;select * from tab_user where username = ? and password = ?&quot;; user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), username,password); }catch (DataAccessException e){ e.printStackTrace(); } return user; } 5.3.4 用户登录后，主页显示登录用户名功能header.html代码 &lt;script&gt; $(function () { $.get(&quot;findUserServlet&quot;,{},function (data) { var msg = &quot;欢迎回来，&quot;+data.name; $(&quot;#span_username&quot;).html(msg); }) }); &lt;&#x2F;script&gt; 控制器代码 package cn.itcast.travel.web.servlet; import com.fasterxml.jackson.databind.ObjectMapper; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;&#x2F;findUserServlet&quot;) public class FindUserServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 从session中获取登录用户 Object user = request.getSession().getAttribute(&quot;user&quot;); &#x2F;&#x2F; 将user回写客户端 ObjectMapper mapper = new ObjectMapper(); response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); mapper.writeValue(response.getOutputStream(),user); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } 6. 退出什么情况下算登录了？答：session中有user对象。 实现步骤： 访问servlet，将session销毁 跳转到登录页面 前台代码实现： &lt;a href=&quot;javascript:location.href=&#39;exitServlet&#39;;&quot;&gt;退出&lt;&#x2F;a&gt; 后台代码实现： package cn.itcast.travel.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;&#x2F;exitServlet&quot;) public class ExitServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 销毁session request.getSession().invalidate(); &#x2F;&#x2F; 2. 跳转到登录页面 response.sendRedirect(request.getContextPath()+&quot;&#x2F;login.html&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } }","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://zero024.cn/tags/Project/"}]},{"title":"Maven","slug":"JavaWeb/Maven","date":"2019-07-16T14:30:00.000Z","updated":"2020-01-03T11:43:19.601Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. Maven基础概念和配置Maven是一个项目管理工具，它包含了一个项目对象模型(POM:Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。","text":"1. Maven基础概念和配置Maven是一个项目管理工具，它包含了一个项目对象模型(POM:Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 1.1 Maven能解决的问题 依赖管理 编译代码 单元测试 打包项目 1.2 安装与配置1.2.1 官网下载Maven官网下载链接 点击apache-maven-3.6.1-bin.zip下载 1.2.2 解压 1.2.3 配置环境变量 注意：安装maven之前，确保电脑中已安装JDK，如安装Maven3则必须是JDK1.7以上。 新建一个系统变量，变量名：MAVEN_HOME，变量值为你解压的文件路径，例我的路径是：D:\\Maven\\apache-maven-3.6.1 添加到系统路径中： 完成后打开cmd输入mvn -v，显示版本信息则配置正确。 1.3 本地仓库配置仓库分三类：本地仓库，远程仓库[私服]，中央仓库。 本地仓库：用于存储从远程仓库或中央仓库下载的插件和jar包，项目使用的一些插件或jar包。优先从本地仓库查找，默认本地仓库位置在${user.home}/.m2/repository，${user.home}表示windows用户目录。 在maven的conf文件夹下的settings.xml文件中配置本地仓库。 远程仓库：又叫私服仓库，如果私服仓库存在，且在本地仓库所需的插件或jar包没有的情况下，会从当前仓库下载。 中央仓库：在maven软件中内置一个远程仓库地址http://repo1.maven.org/maven2。它是中央仓库(Central Repository)，服务于整个互联网，由Maven官方团队维护，里面存储了非常全面的jar包，包含了世界上大部分主流的开源项目构件。 2. Maven工程的认识2.1 Maven工程的目录结构 工程目录结构： 作为一个Maven工程，它的src目录和pom.xml是必备的。 target：项目输出位置，编译后的class文件会输出到此目录。 pom.xml：maven项目核心配置文件。 src目录结构： 标准src目录结构： src/main/java：存放项目的.java文件。 src/main/resources：存放项目资源文件，如spring,hibernate配置文件。 src/test/java：存放所有单元测试.java文件，如Junit测试类。 src/test/resources：测试资源文件。 运行项目：进入maven工程目录(当前目录有pom.xml)，打开cmd，运行mvn tomcat:run命令即可。 3. Maven常用命令我们可以在cmd中通过一系列的maven命令来对我们的maven工程进行编译、测试、运行、打包、安装、部署。 3.1 compilecompile是maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下。 3.2 testtest是maven工程的测试命令，执行mvn test命令，会执行src/test/java下的单元测试类。 3.3 cleanclean是maven工程的清理命令，执行mvn clean命令会删除target目录及内容。 3.4 packagepackage是maven工程的打包命令，对于java工程执行该命令会打包成jar包，web工程则会打包成war包。 3.5 installinstall是maven工程的安装命令，执行该命令会将maven打包成jar包或war包发布到本地仓库。 3.6 Maven指令的生命周期maven对项目构建过程分为三套相互独立的生命周期，请注意是三套且相互独立的。 这三套生命周期分别是： Clean Lifecycle：在进行真正的构建之前进行一些清理工作。 Default Lifecycle：构建的核心部分，进行编译、测试、打包、部署等等。 Site Lifecycle：生成项目报告、站点，发布站点。 3.7 maven的概念模型Maven包含了一个项目对象模型(POM:Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 项目对象模型：一个maven工程都有一个pom.xml文件，通过该文件定义项目的坐标、项目依赖、项目信息、插件目标等。 依赖管理系统：通过maven的依赖管理对项目所依赖的jar包进行统一管理。 如：项目依赖junit4.9，通过在pom.xml中定义junit4.9的依赖即使用junit4.9，如下所示junit4.9的依赖定义： &lt;dependencies&gt; &lt;!-- 此项目运行使用junit，所以此项目依赖junit --&gt; &lt;dependency&gt; &lt;!-- junit的项目名称 --&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;!-- junit的模块名称 --&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;!-- junit版本 --&gt; &lt;version&gt;4.9&lt;&#x2F;version&gt; &lt;!-- 依赖范围：单元测试时使用junit --&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 一个项目生命周期：使用maven完成项目的构建，项目构建包括：清理、编译、测试、部署等过程。maven将这些过程规范为一个生命周期，如下所示： 一组标准集合：maven将整个项目管理过程定义一组标准，比如：通过maven构建工程有标准的目录结构，标准的生命周期阶段、依赖管理和标准的坐标定义等。 插件(plugin)目标(goal)：maven管理项目生命周期过程都是基于插件完成的。 4. IDEA开发maven项目4.1 IDEA的maven配置打开--&gt;File--&gt;Settings，搜索maven，配置如下内容： 4.2 在IDEA中创建一个maven的web工程新建工程，选择IDEA提供好的maven的web工程模板 点击Next填写项目信息 点击Next，配置相关属性，此处不做改动。 再点击Next选择项目所在目录，最后点击Finish，等待项目构建。显示如下信息则构建成功。 最终目录结构并不完整，需手动补齐。手动添加src/main/java目录，将java目录设置为Sources Root。 4.2.1 创建一个Servlet package com.zero.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;&#x2F;testServlet&quot;) public class TestServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.getRequestDispatcher(&quot;&#x2F;hello.jsp&quot;).forward(request,response); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } 4.2.2 配置pom.xml此时编译器会提示servlet相关包不存在，需要在pom.xml中添加坐标。添加jar包坐标时，还可指定该jar包的作用范围。 &lt;dependencies&gt; &lt;!-- 放置项目运行所依赖的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.11&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;3.1.0&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 依赖范围表： 依赖范围 编译时有效 测试时有效 运行时有效 例 compile Y Y Y spring-core test - Y - Junit provided Y Y - servlet-api runtime - Y Y JDBC驱动 system Y Y - 本地的，Maven仓库之外的类库 scope范围依赖小结： 默认引入的jar包使用compile[默认范围，可不写,编译、测试、运行都有效] servlet-api、jsp-api使用provided[编译、测试有效，运行时无效，防止和tomcat下jar包冲突] JDBC驱动包使用runtime[测试、运行有效] Junit使用test[仅测试有效] 依赖范围由强到弱的顺序是：compile&gt;provided&gt;runtime&gt;test 4.2.3 运行点击M图标，输入tomcat7:run运行maven项目。 4.2.4 配置断点调试在项目配置中添加maven项目，设置操作命令。 点击小虫子，即可启动debug模式。 5. 总结5.1 maven仓库 maven仓库的类型有哪些？ maven工程查找仓库的流程是什么？ 本地仓库如何配置？ 5.2 常用的maven命令 compile：编译 clean：清理 test：测试 package：打包 install：安装 5.3 坐标定义在pom.xml中定义坐标，内容包括：groupId、artifactld、version，示例如下： &lt;!--项目名称，定义为组织名+项目名，类似包名--&gt; &lt;groupId&gt;com.zero.maven&lt;&#x2F;groupId&gt; &lt;!--模块名称--&gt; &lt;artifactId&gt;maven-first&lt;&#x2F;artifactId&gt; &lt;!--当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本--&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;!--打包类型--&gt; &lt;packaging&gt;war&lt;&#x2F;packaging&gt; &lt;!-- jar:执行package会打包成jar包 war：执行package会打包成war包 pom：用于maven工程的继承，通常父工程设置为pom --&gt; 5.4 pom基本配置pom.xml是Maven项目的核心配置文件，位于每个工程的根目录，基本配置如下： &lt;project&gt;文件的根节点&lt;&#x2F;project&gt; &lt;modelversion&gt;pom.xml使用的对象模型版本&lt;&#x2F;modelversion&gt; &lt;groupId&gt;项目名称，一般写项目的域名&lt;&#x2F;groupId&gt; &lt;artifactld&gt;模块名称或子项目名&lt;&#x2F;artifactld&gt; &lt;version&gt;产品的版本号&lt;&#x2F;version&gt; &lt;packaging&gt;打包类型，有jar、war、pom等&lt;&#x2F;packaging&gt; &lt;name&gt;项目的显示名，常用于Maven生成的文档&lt;&#x2F;name&gt; &lt;description&gt;项目描述，常用于Maven生成的文档&lt;&#x2F;description&gt; &lt;dependencies&gt;项目依赖构件配置，配置项目依赖构件的坐标&lt;&#x2F;dependencies&gt; &lt;build&gt;项目构建配置，配置编译、运行插件等&lt;&#x2F;build&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[]},{"title":"Redis数据库","slug":"Database/Redis","date":"2019-07-14T15:59:00.000Z","updated":"2020-03-28T08:46:20.944Z","comments":true,"path":"DataBase/Redis-Basic.html","link":"","permalink":"https://zero024.cn/DataBase/Redis-Basic.html","excerpt":"RedisRedis是一款高性能的NOSQL系列的非关系型数据库，完全开源免费的数据库，key-value型数据库，遵守BSD协议。","text":"RedisRedis是一款高性能的NOSQL系列的非关系型数据库，完全开源免费的数据库，key-value型数据库，遵守BSD协议。 1. 基本概念1.1 什么是NOSQLNoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1 NoSQL和关系型数据库比较 优点： 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储在缓存中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式： nosql存储格式是key-value形式、文档形式，图片形式等等，所以可以存储基础类型以及对象或是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很难。 缺点： 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库十几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定的用户学习成本和使用成本。 不提供关系型数据库对事务的处理。 1.1.2 关系型数据库的优势 复杂查询可以用SQL语句方便的在单表或多表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.3 非关系型数据库的优势 NoSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所有性能非常高。 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.4 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL时使用NoSQL数据库。 使用NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据。 1.2 主流的NoSQL产品 键值存储数据库 相关产品：Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用：内容缓存，主要用于处理大量数据的高访问负载。 数据模型：一系列键值对 优势：快速查询 劣势：存储的数据缺少结构化 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 文档性数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型：一系列键值对 优势：数据结构要求不严格 劣势：查询性能不高，且缺乏统一的查询语法 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是RedisRedis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型：string 哈希类型：hash 列表类型：list 集合类型：set 有序集合类型：sortedset 1.3.1 redis的应用场景缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离 2. 下载与安装 官网：https://redis.io/ 中文网：https://www.redis.net.cn/ windows下载地址：https://github.com/dmajkic/redis/downloads 安装与使用：解压即可直接使用 redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端 Redis桌面管理工具：下载地址 安装为windows服务：redis-server.exe --service-install redis.windows.conf 启动服务：redis-server --service-start 停止服务：redis-server --service-stop 卸载服务：redis-server --service-uninstall 连接客户端：redis-cli&amp;redis-cli -h [服务器地址] -p [指定端口号] -a [连接数据库的密码,在conf中配置，默认无] 安装与部署服务参考文章 3. 命令操作3.1 redis的数据结构 redis存储的是：key-value格式的数据，其中key都是字符串，value有5种不同的数据结构。 value的五种数据结构 字符串类型：string 哈希类型hash：map格式 列表类型 list：linkedlist格式。支持重复元素 集合类型 set：不允许重复元素 有序集合类型sortedset：不允许重复元素，且元素有顺序 3.2 字符串类型:String 存储：set key value 获取：get key 删除：del key 127.0.0.1:6379&gt; set ts teststring OK 127.0.0.1:6379&gt; get ts &quot;teststring&quot; 127.0.0.1:6379&gt; del ts (integer) 1 3.3 哈希类型:Hash 存储：hset key field value 获取： hget key field：获取指定的field对应的值 hgetall key：获取所有的field和value 删除：hdel key field 127.0.0.1:6379&gt; hset myhash username shangsan (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 127.0.0.1:6379&gt; hget myhash username &quot;shangsan&quot; 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;shangsan&quot; 3) &quot;password&quot; 4) &quot;123&quot; 127.0.0.1:6379&gt; hdel myhash username (integer) 1 127.0.0.1:6379&gt; hdel myhash password (integer) 1 3.4 列表类型:List可以添加一个元素到列表的头部(左边)或尾部(右边) 添加： lpush key value：将元素加入列表左边。 rpush key value：将元素加入列表右边 获取：lrange key start end，获取指定范围的元素数据 删除： lpop key：删除列表最左边的元素，并将元素返回。从左出栈 rpop key：删除列表最右边的元素，并返回。从右出栈 127.0.0.1:6379&gt; lpush mylist c (integer) 9998 127.0.0.1:6379&gt; lpush mylist b (integer) 9999 127.0.0.1:6379&gt; lpush mylist a (integer) 10000 127.0.0.1:6379&gt; lrange mylist 0 2 1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;c&quot; 127.0.0.1:6379&gt; lpop mylist &quot;a&quot; 127.0.0.1:6379&gt; lpop mylist &quot;b&quot; 127.0.0.1:6379&gt; lpop mylist &quot;c&quot; 3.5 集合类型:set不允许重复元素 存储：add key value 获取：smembers key，获取集合中所有元素 删除：srem key value，删除集合中的某个元素 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 127.0.0.1:6379&gt; srem myset a (integer) 1 3.6 有序集合类型:sortedset不允许重复元素，且元素有顺序。每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score vlaue 获取：zrange key start end [withscores]，withscores可以在获取时同时获取分数。 删除：zrem key value 127.0.0.1:6379&gt; zadd mysort 50 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 36 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 88 wangwu (integer) 1 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;zhangsan&quot; 2) &quot;wangwu&quot; 3.7 通用命令 keys *：查询所有的键 type key：获取键对应的value类型 del key：删除指定的key valu 127.0.0.1:6379&gt; keys * 1) &quot;counter:__rand_int__&quot; 2) &quot;mylist&quot; 3) &quot;key:__rand_int__&quot; 4) &quot;mysort&quot; 127.0.0.1:6379&gt; type mylist list 127.0.0.1:6379&gt; type mysort zset 127.0.0.1:6379&gt; del mylist (integer) 1 4. 持久化redis是一个内存数据库，当redis服务器重启或电脑重启时，数据会丢失。我们可以将redis内存中的数据持久化保存到硬盘的文件中。 4.1 redis持久化机制 RDB：默认方式，不需要进行配置。在一定的间隔时间中，检测key的变化情况，然后持久化数据。 编辑redis.windows.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 重启redis服务器，并指定配置文件名称：redis-server.exe redis.windows.conf AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据。 编辑redis.windows.conf文件 # 开启AOF appendonly yes # 三种同步方式: # 1. 每一次操作都进行持久化 # appendfsync always # 2. 每隔一秒进行一次持久化，缺省值 appendfsync everysec # 3. 不进行持久化 # appendfsync no 重启服务器，指定配置文件。 5. Java客户端：JedisJedis是一款java操作redis数据库的工具。 5.1Jedis操作各种Redis中的数据结构5.1.1 字符串类型： @Test public void test2(){ &#x2F;&#x2F; 1. 获取连接 Jedis jedis = new Jedis(); &#x2F;&#x2F; 如果使用空参构造，默认值&#39;localhost&#39;,6379 &#x2F;&#x2F; 2. 操作 &#x2F;&#x2F; 存储 jedis.set(&quot;username&quot;,&quot;wangwu&quot;); &#x2F;&#x2F; 获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); &#x2F;&#x2F; 可以使用setex()方法存储指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;gj8a&quot;); &#x2F;&#x2F;将activecode：gj8a键值对存入redis，并且20秒后自动删除该键值对 &#x2F;&#x2F; 3. 关闭连接 jedis.close(); } 5.1.2 哈希类型： @Test public void test3(){ &#x2F;&#x2F; 1. 获取连接 Jedis jedis = new Jedis(); &#x2F;&#x2F; 2. 操作 &#x2F;&#x2F; 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); &#x2F;&#x2F; 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); &#x2F;&#x2F; 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); Set&lt;String&gt; keySet = user.keySet(); for (String key:keySet) { String value = user.get(key); System.out.println(key+&quot;:&quot;+value); } &#x2F;&#x2F; 3. 关闭连接 jedis.close(); } 5.1.3 列表类型： @Test public void test4() { &#x2F;&#x2F; 1. 获取连接 Jedis jedis = new Jedis(); &#x2F;&#x2F; 2. 操作 jedis.del(&quot;mylist&quot;); &#x2F;&#x2F; list存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); &#x2F;&#x2F; 从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); &#x2F;&#x2F; 从右边存 &#x2F;&#x2F; 获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); &#x2F;&#x2F; [c, b, a, a, b, c] &#x2F;&#x2F; 弹出 String element1 = jedis.lpop(&quot;mylist&quot;); System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;); System.out.println(element2); List&lt;String&gt; mylist２ = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist２); &#x2F;&#x2F; 3.关闭连接 jedis.close(); } 5.1.4 集合类型： @Test public void test5() { &#x2F;&#x2F; 1. 获取连接 Jedis jedis = new Jedis(); &#x2F;&#x2F; 2. 操作 &#x2F;&#x2F; 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c&quot;); &#x2F;&#x2F; 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); jedis.close(); } 5.1.5 有序集合类型： @Test public void test6() { &#x2F;&#x2F; 1. 获取连接 Jedis jedis = new Jedis(); &#x2F;&#x2F; 2. 操作 &#x2F;&#x2F; 存储 jedis.zadd(&quot;mysortedset&quot;,8,&quot;亚索&quot;); jedis.zadd(&quot;mysortedset&quot;,6,&quot;剑圣&quot;); jedis.zadd(&quot;mysortedset&quot;,3,&quot;vn&quot;); &#x2F;&#x2F; 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); &#x2F;&#x2F; [vn, 剑圣, 亚索] jedis.close(); } 5.2 Jedis连接池：JedisPool 使用方法： 创建JedisPool连接池对象 调用方法getResource()方法获取Jedis连接 5.2.1 jedis详细配置 #最大活动对象数 redis.pool.maxTotal=1000 #最大能够保持idel状态的对象数 redis.pool.maxIdle=100 #最小能够保持idel状态的对象数 redis.pool.minIdle=50 #当池内没有返回对象时，最大等待时间 redis.pool.maxWaitMillis=10000 #当调用borrow Object方法时，是否进行有效性检查 redis.pool.testOnBorrow=true #当调用return Object方法时，是否进行有效性检查 redis.pool.testOnReturn=true #“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1. redis.pool.timeBetweenEvictionRunsMillis=30000 #向调用者输出“链接”对象时，是否检测它的空闲超时； redis.pool.testWhileIdle=true # 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3. redis.pool.numTestsPerEvictionRun=50 #redis服务器的IP redis.ip=xxxxxx #redis服务器的Port redis1.port=6379 5.2.2 自定义jedis工具类 package cn.zero.jedis.util; import redis.clients.jedis.Jedis; import redis.clients.jedis.JedisPool; import redis.clients.jedis.JedisPoolConfig; import java.io.IOException; import java.io.InputStream; import java.util.Properties; &#x2F;** * JedisPool工具类 * 加载配置文件，配置连接池参数 * 提供获取连接的方法 *&#x2F; public class JedisPoolUtils { private static JedisPool jedisPool; static { &#x2F;&#x2F; 读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); &#x2F;&#x2F; 创建Properties对象 Properties pro = new Properties(); &#x2F;&#x2F; 关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } &#x2F;&#x2F; 获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); &#x2F;&#x2F; 初始化JedisPool jedisPool = new JedisPool(config, pro.getProperty(&quot;host&quot;), Integer.parseInt(pro.getProperty(&quot;port&quot;))); } &#x2F;** * 获取连接方法 * @return *&#x2F; public static Jedis getJedis(){ return jedisPool.getResource(); } } 6. 练习6.1 需求 提供index.html页面，页面中有一个省份下拉列表 当 页面加载完毕后 发送ajax请求，加载所有省份。 注意：使用redis缓存一些不经常发生变化的数据。 数据库的数据一旦发生改变，则需要更新缓存。 数据库的表执行 增删改的相关操作，需要将redis缓存数据清空，再次存入。 在service对应的增删改方法中，将redis数据删除。 6.2 代码实现后端service实现类核心代码： &#x2F;** * 使用redis缓存 * @return *&#x2F; @Override public String findAllJson() { &#x2F;&#x2F; 1. 先从redis中查询数据 &#x2F;&#x2F; 1.1 获取redis客户端连接对象 Jedis jedis = JedisPoolUtils.getJedis(); &#x2F;&#x2F; 1.2 查询数据 String province_json = jedis.get(&quot;province&quot;); &#x2F;&#x2F; 2. 判断province_json 是否为null if (province_json == null || province_json.length() == 0){ &#x2F;&#x2F; redis中无数据 System.out.println(&quot;redis中无数据，查询数据库...&quot;); &#x2F;&#x2F; 2.1 从数据库中查询 List&lt;Province&gt; ps = dao.findAll(); &#x2F;&#x2F; 2.2 将list序列化为json ObjectMapper mapper = new ObjectMapper(); try { province_json = mapper.writeValueAsString(ps); } catch (JsonProcessingException e) { e.printStackTrace(); } &#x2F;&#x2F; 2.3 将json数据存入redis中 jedis.set(&quot;province&quot;,province_json); &#x2F;&#x2F; 归还连接 jedis.close(); }else { System.out.println(&quot;redis中有数据，查询缓存...&quot;); System.out.println(province_json); } return province_json; } 后端servlet代码： package cn.zero.web.servlet; import cn.zero.domain.Province; import cn.zero.service.impl.ProvinceServiceImpl; import com.fasterxml.jackson.databind.ObjectMapper; import javax.servlet.annotation.WebServlet; import java.io.IOException; import java.util.List; @WebServlet(&quot;&#x2F;provinceServlet&quot;) public class ProvinceServlet extends javax.servlet.http.HttpServlet { protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException { &#x2F;&#x2F; &#x2F;&#x2F; 1. 调用service查询 &#x2F;&#x2F; ProvinceServiceImpl service = new ProvinceServiceImpl(); &#x2F;&#x2F; List&lt;Province&gt; list = service.findAll(); &#x2F;&#x2F; &#x2F;&#x2F; 2. 序列化list为json &#x2F;&#x2F; ObjectMapper mapper = new ObjectMapper(); &#x2F;&#x2F; String json = mapper.writeValueAsString(list); ProvinceServiceImpl service = new ProvinceServiceImpl(); String json = service.findAllJson(); System.out.println(json); &#x2F;&#x2F; 3. 响应结果 response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); response.getWriter().write(json); } protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException { this.doPost(request, response); } } 前端代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Province&lt;&#x2F;title&gt; &lt;script src=&quot;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; $(function () { &#x2F;&#x2F; 发送ajax请求，加载所有省份数据 $.get(&quot;provinceServlet&quot;,{},function (data) { &#x2F;&#x2F; data = [{&quot;id&quot;:1,&quot;name&quot;:&quot;北京&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;上海&quot;},{&quot;id&quot;:3,&quot;name&quot;:&quot;广州&quot;},{&quot;id&quot;:4,&quot;name&quot;:&quot;深圳&quot;}] &#x2F;&#x2F; 1. 获取select var province = $(&quot;#province&quot;); &#x2F;&#x2F; 2. 遍历json数组 $(data).each(function () { &#x2F;&#x2F; 3. 创建&lt;option&gt; var option = &quot;&lt;option name=&#39;&quot;+this.id+&quot;&#39;&gt;&quot;+this.name+&quot;&lt;&#x2F;option&gt;&quot; &#x2F;&#x2F; 4. 调用select的append追加option province.append(option); }); }); }); &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;select name=&quot;&quot; id=&quot;province&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择省份--&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://zero024.cn/categories/DataBase/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://zero024.cn/tags/Redis/"}]},{"title":"AJAX和Json","slug":"JavaWeb/AJAX和JSON","date":"2019-07-10T15:59:00.000Z","updated":"2020-03-08T00:50:22.167Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"AJAXAjax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。","text":"AJAXAjax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 同步和异步：在客户端和服务器端相互通信的基础上。 同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。而传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 Ajax可以提升用户的体验。 实现方式1. 原生的JS实现方式 &lt;script&gt; &#x2F;&#x2F; 定义方法 function fun() { &#x2F;&#x2F; 发送异步请求 &#x2F;&#x2F; 1. 创建核心对象(固定写法) var xmlhttp; if (window.XMLHttpRequest) {&#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else {&#x2F;&#x2F; code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } &#x2F;&#x2F; 2. 建立连接 &#x2F;* 参数： 1. 请求方式：GET,POST - get方式：请求参数在URL后边拼接。send方法为空参 - post方式：请求参数在send方法中定义 2. 请求的URL： 3. 同步还是异步请求：true异步，false同步 *&#x2F; xmlhttp.open(&quot;GET&quot;,&quot;&#x2F;Demo7_10&#x2F;ajaxServlet?username=xiaoming&quot;,true); &#x2F;&#x2F; 3. 发送请求 xmlhttp.send(); &#x2F;&#x2F; 4. 接受和处理来自服务器的响应结果 &#x2F;&#x2F; 获取方式：xmlhttp.responseText; 什么时候获取? 当服务器响应成功后再获取 &#x2F;&#x2F; 当xmlhttp对象的就绪状态改变时，触发事件：onreadystatechange。 xmlhttp.onreadystatechange=function() { &#x2F;&#x2F; 判断readyState就绪状态是否为4，并且status状态码为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { &#x2F;&#x2F; 获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); } } } &lt;&#x2F;script&gt; 2. JQuery实现方式 $.ajax()，语法：$.ajax({键值对})； &lt;script&gt; &#x2F;&#x2F; 定义方法 function fun() { &#x2F;&#x2F; 使用 $.ajax()发送异步请求 $.ajax({ url:&quot;ajaxServlet&quot;,&#x2F;&#x2F; 请求路径 type:&quot;POST&quot;, &#x2F;&#x2F; 请求方式 &#x2F;&#x2F; data:&quot;username=jack$age=23&quot;, &#x2F;&#x2F; 请求参数 data:{&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23}, success:function (data) { alert(data); }, &#x2F;&#x2F; 响应成功后执行的函数 error:function () { alert(&quot;出错啦...&quot;) }, &#x2F;&#x2F; 表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot; &#x2F;&#x2F; 设置接受到的响应数据的格式 }); } &lt;&#x2F;script&gt; $.get()，发送get请求，语法：$.get(url,[data],[callback],[type])，参数如下。 url：请求路径 data：请求参数 callback：回调函数 type：响应结果的类型 &lt;script&gt; &#x2F;&#x2F; 定义方法 function fun() { &#x2F;&#x2F; 使用 $.get()发送异步请求 $.get(&quot;ajaxServlet&quot;,{username:&quot;rose&quot;},function (data) { alert(data); },&quot;text&quot;); } &lt;&#x2F;script&gt; $.post()，发送post请求，语法：$.post(url,[data],[callback],[type])，参数同上。 Json1. 基本概念 JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation），是一种轻量级的数据交换格式。 JSON 是存储和交换文本信息的语法。 进行数据的传输。 JSON 比 XML 更小、更快，更易解析。 2. JSON 语法规则2.1 基本规则JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中：json数据是由键值对构成的 键用引号(单双都可)引起来，也可以不使用引号。 值的取值类型： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true或false） 数组（在方括号中），例：{&quot;persons&quot;:[{},{}]} 对象（在花括号中），例：{&quot;address&quot;:{&quot;province&quot;:&quot;杭州&quot;...}} null 数据由逗号分隔：多个键值对由逗号分隔 花括号保存对象：使用{}定义json格式 方括号保存数组：[] 2.2 获取数据 json对象.键名 json对象[“键名”] 数组对象[索引] 遍历 &lt;script&gt; &#x2F;&#x2F; 1. 定义基本格式 var person = {name:&quot;xiaozhang&quot;,age:23,&#39;gender&#39;:true}; var ps = [ {name:&quot;xiaozhang&quot;,age:23,&#39;gender&#39;:true}, {name:&quot;xiaoli&quot;,age:25,&#39;gender&#39;:true}, {name:&quot;xiaohua&quot;,age:19,&#39;gender&#39;:false}]; &#x2F;&#x2F; 获取person对象中的所有键和值 &#x2F;&#x2F; for in 循环 for(var key in person){ alert(key+&quot;：&quot;+person[key]); } &#x2F;&#x2F; 获取ps数组中所有对象的键值 for (var i = 0; i &lt; ps.length; i++){ var p = ps[i]; for (var key in p){ alert(key+&quot;：&quot;+p[key]); } } &lt;&#x2F;script&gt; 2.3 JSON数据和Java对象的相互转换 JSON解析器，常见的解析器有：Jsonlib,Gson,fastjson,jackson 2.3.1 JSON转为Java对象 导入jackson的相关jar包 创建jackson核心对象：ObjectMapper 调用ObjectMapper的相关方法进行转换：readValue(json字符串数据，Class) &#x2F;&#x2F; 演示JSON字符串转换为Java对象 @Test public void test5() throws Exception { &#x2F;&#x2F; 1. 初始化JSON字符串 String json = &quot;{\\&quot;gender\\&quot;:\\&quot;男\\&quot;,\\&quot;name\\&quot;:\\&quot;张三\\&quot;,\\&quot;age\\&quot;:23}&quot;; &#x2F;&#x2F; 2. 创建ObjectMapper对象 ObjectMapper mapper = new ObjectMapper(); &#x2F;&#x2F; 3. 转为Java对象 Person Person person = mapper.readValue(json, Person.class); System.out.println(person); &#x2F;&#x2F; Person{name=&#39;张三&#39;, age=23, gender=&#39;男&#39;, birthday=null} } 2.3.2 Java对象转为JSON 导入jackson的相关jar包 创建jackson核心对象：ObjectMapper 调用ObjectMapper的相关方法进行转换 转换方法： writeValue(参数，obj) 常用参数： File：将obj对象转换为json字符串，并保存到指定的文件中。 Writer：将obj对象转换为json字符串，并将json数据填充到字符输出流中。 OutputStream：将obj对象转换为json字符串，并将json数据填充到字节输出流中。 writeValueAsString(obj)：将对象转换为json字符串 public void test1() throws Exception { &#x2F;&#x2F; 1. 创建Person对象 Person person = new Person(); person.setName(&quot;张三&quot;); person.setAge(23); person.setGender(&quot;男&quot;); &#x2F;&#x2F; 2. 创建Jackson核心对象 ObjectMapper ObjectMapper mapper = new ObjectMapper(); &#x2F;&#x2F; 3. 调用方法转换 String json = mapper.writeValueAsString(person); System.out.println(json); &#x2F;&#x2F; {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;} &#x2F;&#x2F; writeValue,将数据写到d:&#x2F;&#x2F;json.txt中 mapper.writeValue(new File(&quot;d:&#x2F;&#x2F;json.txt&quot;),person); &#x2F;&#x2F; writeValue,将数据关联到Writer中 mapper.writeValue(new FileWriter(&quot;d:&#x2F;&#x2F;json2.txt&quot;),person); } 注解： @JsonIgnore：排除属性 @JsonFormat：属性值格式化 @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 复杂Java对象转换： List：数组 Map：对象格式一致 综合练习用户注册页面，输入用户名，异步请求数据库验证用户名是否存在。 服务器响应的数据，在客户端使用时，要想当做json数据格式使用，方法有如下： $.get(type);将最后一个参数type指定为“json”； 在服务器端设置MIME类型：response.setContentType(&quot;application/json;charset=utf-8&quot;); 代码实现 前端部分： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户注册&lt;&#x2F;title&gt; &lt;script src=&quot;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;&#x2F; 在页面加载完成后 $(function () { &#x2F;&#x2F; 给username绑定blur(离焦)事件 $(&quot;#username&quot;).blur(function () { &#x2F;&#x2F; 获取username文本框输入的值 var username = $(this).val(); &#x2F;&#x2F; 发送ajax请求 &#x2F;&#x2F; 期望服务器响应会的数据格式：{&quot;userExsit&quot;:true,&quot;msg&quot;:&quot;用户名已存在！&quot;} &#x2F;&#x2F; {&quot;userExsit&quot;:false,&quot;msg&quot;:&quot;用户名可用！&quot;} $.get(&quot;regUserServlet&quot;,{username:username},function (data) { var span = $(&quot;#s_username&quot;); if (data[&quot;userExsit&quot;] == true){ &#x2F;&#x2F; 用户名已存在 span.css(&quot;color&quot;,&quot;red&quot;); span.html(data.msg); }else{ &#x2F;&#x2F; 用户名不存在 span.css(&quot;color&quot;,&quot;green&quot;); span.html(data.msg); } }) }); }) &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt; &lt;span id=&quot;s_username&quot;&gt;&lt;&#x2F;span&gt; &lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 后端部分： package cn.zero.web.servlet; import com.fasterxml.jackson.databind.ObjectMapper; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.HashMap; import java.util.Map; @WebServlet(&quot;&#x2F;regUserServlet&quot;) public class RegUserServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 获取用户名 String username = request.getParameter(&quot;username&quot;); String json = &quot;{\\&quot;userExsit\\&quot;:true,\\&quot;msg\\&quot;:\\&quot;用户名已存在！\\&quot;}&quot;; &#x2F;&#x2F; 2. 调用service层判断用户名是否存在 &#x2F;&#x2F; 期望服务器响应会的数据格式：{&quot;userExsit&quot;:true,&quot;msg&quot;:&quot;用户名已存在！&quot;} &#x2F;&#x2F; {&quot;userExsit&quot;:false,&quot;msg&quot;:&quot;用户名可用！&quot;} &#x2F;&#x2F; 设置响应的数据格式为json response.setContentType(&quot;application&#x2F;json;charset=utf-8&quot;); &#x2F;&#x2F; 解决乱码问题 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); if (&quot;张三&quot;.equals(username)) { map.put(&quot;userExsit&quot;,true); map.put(&quot;msg&quot;,&quot;用户名已存在，请更换！&quot;); }else{ map.put(&quot;userExsit&quot;,false); map.put(&quot;msg&quot;,&quot;用户名可用&quot;); } &#x2F;&#x2F; 将map转为json，并传递给客户端 ObjectMapper mapper = new ObjectMapper(); mapper.writeValue(response.getWriter(),map); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } }","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://zero024.cn/tags/Ajax/"},{"name":"Json","slug":"Json","permalink":"https://zero024.cn/tags/Json/"}]},{"title":"JQuery高级","slug":"JavaWeb/JQuery高级","date":"2019-07-09T15:50:00.000Z","updated":"2020-01-03T11:43:19.597Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"JQuery高级JQuery进阶内容，包括图片显示和隐藏方式、遍历方式、事件绑定方法以及自定义插件。","text":"JQuery高级JQuery进阶内容，包括图片显示和隐藏方式、遍历方式、事件绑定方法以及自定义插件。 1. 动画主要有三种方式显示和隐藏元素 1.1 默认显示和隐藏方式 show([speed,[easing],[fn]]) hide([speed,[easing],[fn]]) toggle([speed,[easing],[fn]]) 通用参数概述： speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;,&quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) easing：用来指定切换效果，默认是&quot;swing&quot;(动画执行时效果是：先慢，中间快，最后再慢)，可用参数&quot;linear&quot;(动画执行时速度是匀速的) fn：在动画完成时执行的函数，每个元素执行一次。 1.2 滑动显示和隐藏方式 slideDown([speed,[easing],[fn]]) slideUp([speed,[easing],[fn]]) slideToggle([speed,[easing],[fn]]) 1.3 淡入淡出显示和隐藏方式 fadeIn([speed,[easing],[fn]]) fadeOut([speed,[easing],[fn]]) fadeToggle([speed,[easing],[fn]]) 示例 &lt;script&gt; &#x2F;&#x2F; 隐藏div function hideFn() { &#x2F;&#x2F; 默认方式 &#x2F;&#x2F; $(&quot;#showDiv&quot;).hide(5000,&quot;swing&quot;); &#x2F;&#x2F; 滑动方式 &#x2F;&#x2F; $(&quot;#showDiv&quot;).slideUp(&quot;slow&quot;); &#x2F;&#x2F; 淡入淡出方式 $(&quot;#showDiv&quot;).fadeOut(&quot;slow&quot;); } &#x2F;&#x2F; 显示div function showFn() { &#x2F;&#x2F; 默认方式 &#x2F;&#x2F; $(&quot;#showDiv&quot;).show(&quot;slow&quot;,&quot;swing&quot;); &#x2F;&#x2F; 滑动方式 &#x2F;&#x2F; $(&quot;#showDiv&quot;).slideDown(&quot;slow&quot;); &#x2F;&#x2F; 淡入淡出方式 $(&quot;#showDiv&quot;).fadeIn(&quot;slow&quot;); } &#x2F;&#x2F; 切换显示和隐藏div function toggleFn() { &#x2F;&#x2F; 默认方式 &#x2F;&#x2F; $(&quot;#showDiv&quot;).toggle(&quot;slow&quot;); &#x2F;&#x2F; 滑动方式 &#x2F;&#x2F; $(&quot;#showDiv&quot;).slideToggle(&quot;slow&quot;); &#x2F;&#x2F; 淡入淡出方式 $(&quot;#showDiv&quot;).fadeToggle(&quot;slow&quot;); } &lt;&#x2F;script&gt; 2. 遍历2.1 JS的遍历方式 for(初始值;循环结束条件;步长) 2.2 JQuery的遍历方式1. JQ对象.each(callback) 语法：jquery对象.each(function(index,element){}); index：就是元素在集合中的索引 element：就是集合中的每一个元素对象 this：集合中的每一个元素对象（当前元素对象） 回调函数返回值 true：如果当前function返回false，则结束循环(相当于break)。 false：如果当前function返回true，则结束本次循环，继续下次循环(相当于continue)。 2. $.each(object,[callback])3. for..of3.0版本之后提供的方式，使用方法：for(元素对象 of 容器对象) 示例 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F; 1. js方法遍历 &#x2F;&#x2F; 获取所有ul下的li var citys = $(&quot;#city li&quot;); &#x2F;&#x2F; 遍历li for (var i = 0; i &lt; citys.length; i++){ if (&quot;上海&quot; == citys[i].innerHTML ){ break; continue; } alert(i+&quot;:&quot;+citys[i].innerHTML); } &#x2F;&#x2F; 2. jq方法遍历，JQ对象.each(callback) citys.each(function (index,element) { &#x2F;&#x2F; 获取li对象,使用this &#x2F;&#x2F; alert(this.innerHTML); &#x2F;&#x2F; 获取li对象，在回调函数中定义参数，index,element &#x2F;&#x2F; 判断如果是上海，则结束循环 if (&quot;上海&quot; == $(element).html()){ &#x2F;&#x2F; 如果当前function返回为false，则结束循环(break); &#x2F;&#x2F; 如果返回为true，则结束本次循环，继续下次循环(continue); return true; } alert(index+&quot;:&quot;+$(element).html()); }) &#x2F;&#x2F; 3. $.each(object,[callback]); $.each(citys,function () { alert($(this).html()); }) &#x2F;&#x2F; 4. for..of(jquery3.0之后提供的方式) for (li of citys){ alert(li.innerHTML); } }) &lt;&#x2F;script&gt; 3. 事件绑定3.1 JQuery标准的绑定方式 JQuery对象.事件方法(回调函数) 如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit(); ： 让表单提交 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F; 1. 获取name对象，表单click事件 $(&quot;#name&quot;).click(function () { alert(&quot;我被点击了&quot;) }); &#x2F;&#x2F; 给name绑定聚焦离焦事件 $(&quot;#name&quot;).mouseover(function () { alert(&quot;鼠标来了...&quot;) }) $(&quot;#name&quot;).mouseout(function () { alert(&quot;鼠标走了...&quot;) }) &#x2F;&#x2F; 简化操作，链式编程 $(&quot;#name&quot;).mouseover(function () { alert(&quot;鼠标来了...&quot;); }).mouseout(function () { alert(&quot;鼠标走了&quot;) }); $(&quot;#name&quot;).focus(); &#x2F;&#x2F; 浏览器默认行为：让文本输入框获得焦点 }) &lt;&#x2F;script&gt; 3.2 on绑定事件/off解除绑定 JQuery对象.on(&quot;事件名称&quot;,回调函数) JQuery对象.off(&quot;事件名称&quot;) 如果off方法不传递任何参数，则会将组件上的所有事件全部解绑。 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F; 1. 使用on绑定点击事件 $(&quot;#btn&quot;).on(&quot;click&quot;,function () { alert(&quot;我被点击了...&quot;) }) $(&quot;#btn2&quot;).click(function () { alert(&quot;解除了单击事件...&quot;) &#x2F;&#x2F; 解绑btn单击事件 &#x2F;&#x2F; $(&quot;#btn&quot;).off(&quot;click&quot;); $(&quot;#btn&quot;).off();&#x2F;&#x2F; 将组件上的所有事件全部解绑 }) }) &lt;&#x2F;script&gt; 3.3 事件切换：toggle JQuery对象.toggle(fn1,fu2...)：当单击JQ对象对应的组件后，会执行fn1，第二次点击会执行fn2... Notice：1.9版本之后.toggle()方法删除，使用JQuery Migrate(迁移)插件可恢复此功能。 &lt;script src=&quot;..&#x2F;js&#x2F;jquery-migrate-1.0.0.js&quot; type=&quot;text&#x2F;javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt; &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F; 获取按钮，调用toggle方法 $(&quot;#btn&quot;).toggle(function () { $(&quot;#myDiv&quot;).css(&quot;backgroundColor&quot;,&quot;green&quot;); },function () { $(&quot;#myDiv&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }) }) &lt;&#x2F;script&gt; 4. 综合案例4.1 广告图片自动显示与隐藏 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;&#x2F;title&gt; &lt;style&gt; #content{width:100%;height:500px;background:#999} &lt;&#x2F;style&gt; &lt;!--引入jquery--&gt; &lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;* 需求： 1. 当页面加载完，3秒后，自动显示广告。 2. 广告显示5秒后，自动消失。 *&#x2F; &#x2F;&#x2F; 1. 使用定时器来完成。setTimeout(执行一次定时器) &#x2F;&#x2F; 2. 通过控制display属性来实现显示和隐藏 $(function () { &#x2F;&#x2F; 定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); &#x2F;&#x2F; 定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); }) &#x2F;&#x2F; 显示广告 function adShow() { &#x2F;&#x2F; 获取div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); } &#x2F;&#x2F; 隐藏广告 function adHide() { $(&quot;#ad&quot;).hide(&quot;slow&quot;); } &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!-- 整体的DIV --&gt; &lt;div&gt; &lt;!-- 广告DIV --&gt; &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt; &lt;img style=&quot;width:100%&quot; src=&quot;..&#x2F;img&#x2F;adv.jpg&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;!-- 下方正文部分 --&gt; &lt;div id=&quot;content&quot;&gt; 正文部分 &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 4.2 抽奖 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery案例之抽奖&lt;&#x2F;title&gt; &lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 - 定义数组，存放图片资源路径 - 生成随机数，数组索引 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 - 等于小相框当前src属性 *&#x2F; &#x2F;&#x2F; 定义图片路径数组 var imgs = [&quot;..&#x2F;img&#x2F;man00.jpg&quot;, &quot;..&#x2F;img&#x2F;man01.jpg&quot;, &quot;..&#x2F;img&#x2F;man02.jpg&quot;, &quot;..&#x2F;img&#x2F;man03.jpg&quot;, &quot;..&#x2F;img&#x2F;man04.jpg&quot;, &quot;..&#x2F;img&#x2F;man05.jpg&quot;, &quot;..&#x2F;img&#x2F;man06.jpg&quot;] var startId; var index; &#x2F;&#x2F; 随机角标 $(function () { &#x2F;&#x2F; 处理按钮是否可以使用效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); &#x2F;&#x2F; 1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () { &#x2F;&#x2F; 1.1 定义循环定时器， 20毫秒执行一次 startId = setInterval(function () { &#x2F;&#x2F; 处理按钮是否可以使用效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); &#x2F;&#x2F; 1.2 生成随机角标 0-6 index = Math.floor(Math.random() * 7); &#x2F;&#x2F; 0.000~0.999 --&gt; *7 =&gt; 0.0~6.9999 &#x2F;&#x2F; 1.3 小相框src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); },20); }) &#x2F;&#x2F; 2. 给结束按钮绑定单击事件 $(&quot;#stopID&quot;).click(function () { &#x2F;&#x2F; 处理按钮是否可以使用效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); &#x2F;&#x2F; 2.1 停止定时器 clearInterval(startId); &#x2F;&#x2F; 2.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); &#x2F;&#x2F; 1秒之后显示 $(&quot;#img2ID&quot;).show(1000); }) }) &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!-- 小像框 --&gt; &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt; &lt;img id=&quot;img1ID&quot; src=&quot;..&#x2F;img&#x2F;man00.jpg&quot; style=&quot;width:160px;height:100px&quot;&#x2F;&gt; &lt;&#x2F;div&gt; &lt;!-- 大像框 --&gt; &lt;div style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt; &lt;img id=&quot;img2ID&quot; src=&quot;..&#x2F;img&#x2F;man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;&#x2F;&gt; &lt;&#x2F;div&gt; &lt;!-- 开始按钮 --&gt; &lt;input id=&quot;startID&quot; type=&quot;button&quot; value=&quot;点击开始&quot; style=&quot;width:150px;height:150px;font-size:22px&quot; &gt; &lt;!-- 停止按钮 --&gt; &lt;input id=&quot;stopID&quot; type=&quot;button&quot; value=&quot;点击停止&quot; style=&quot;width:150px;height:150px;font-size:22px&quot; &gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 5. 插件主要用于增强JQuery的功能，实现方式： $.fn.extend(object)：增强通过JQuery获取的对象的功能，$(&quot;#id&quot;) &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01-jQuery对象进行方法扩展&lt;&#x2F;title&gt; &lt;script src=&quot;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot; type=&quot;text&#x2F;javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt; &lt;script type=&quot;text&#x2F;javascript&quot;&gt; &#x2F;&#x2F; 1. 定义JQuery的对象插件 $.fn.extend({ &#x2F;&#x2F; 定义了一个check()方法。所有的jq对象都可以调用该方法 check:function () { &#x2F;&#x2F; 让复选框选中 &#x2F;&#x2F; this:调用该方法的jq对象 this.prop(&quot;checked&quot;,true); }, uncheck:function () { &#x2F;&#x2F; 不选中 this.prop(&quot;checked&quot;,false); } }); $(function () { $(&quot;#btn-check&quot;).click(function () { $(&quot;input[type=&#39;checkbox&#39;]&quot;).check(); }); $(&quot;#btn-uncheck&quot;).click(function () { $(&quot;input[type=&#39;checkbox&#39;]&quot;).uncheck(); }); }) &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;input id=&quot;btn-check&quot; type=&quot;button&quot; value=&quot;点击选中复选框&quot; &gt; &lt;input id=&quot;btn-uncheck&quot; type=&quot;button&quot; value=&quot;点击取消复选框选中&quot; &gt; &lt;br&#x2F;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;football&quot;&gt;足球 &lt;input type=&quot;checkbox&quot; value=&quot;basketball&quot;&gt;篮球 &lt;input type=&quot;checkbox&quot; value=&quot;volleyball&quot;&gt;排球 &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; $.extend(object)：增强JQuery对象自身的功能，$/jQuery &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01-jQuery对象进行方法扩展&lt;&#x2F;title&gt; &lt;script src=&quot;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot; type=&quot;text&#x2F;javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt; &lt;script type=&quot;text&#x2F;javascript&quot;&gt; &#x2F;&#x2F;对全局方法扩展2个方法，扩展min方法：求2个值的最小值；扩展max方法：求2个值最大值 $.extend({ max:function (a,b) { &#x2F;&#x2F; 返回大值 return a &gt;= b ? a:b; }, min:function (a,b) { &#x2F;&#x2F; 返回小值 return a &lt;= b ? a:b; } }); &#x2F;&#x2F; 调用全局方法 alert($.max(4,3)); alert($.min(4,3)); &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://zero024.cn/tags/JQuery/"}]},{"title":"JQuery基础","slug":"JavaWeb/JQuery基础","date":"2019-07-06T09:30:00.000Z","updated":"2020-01-03T11:43:19.596Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. JQuery基础jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。","text":"1. JQuery基础jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已。 2. 快速入门2.1. 下载JQuery目前JQuery有三个大版本： 1.x：兼容ie678，使用最为广泛的，官方只做BUG维护，功能不再新增。对于一般项目来说，使用1.x版本即可。 2.x：不兼容ie768，很少有人使用，官方只做BUG维护，功能不新增。如果不考虑兼容低版本浏览器可以使用2.x。 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本，很多老的JQuery插件不支持该版本。 jquery-xxx.js与jquery-xxx.min.js的区别： jquery-xxx.js：开发版本。供开发人员查看的，有良好的缩进和注释。体积大一些。 jquery-xxx.min.js：生成版本。程序中使用，没有缩进。体积小巧，程序加载更快。 2.2. 导入JQuery的js文件：导入min.js文件2.3. 使用 &lt;script src=&quot;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; var div1 = $(&quot;#div1&quot;); alert(div1.html()); &lt;&#x2F;script&gt; 3. JQuery对象和JS对象区别和转换 JQuery对象在操作时，更加方便。 JQuery对象和JS对象方法不通用。 两者可以相互转换 jq --- &gt; js：jq对象[索引] 或者 jq对象.get(索引) js --- &gt; jq：$(js对象) &lt;script&gt; &#x2F;&#x2F; 1. 通过js方式来获取元素对象 var divs = document.getElementsByTagName(&quot;div&quot;); alert(divs.length); &#x2F;&#x2F; 可以将其当做数组来使用 &#x2F;&#x2F; 将divs中的所有div标签体内容修改为&quot;aaa&quot; for(var i = 0;i &lt; divs.length; i++){ &#x2F;&#x2F; divs[i].innerHTML = &quot;aaa&quot;; $(divs[i]).html(&quot;ccc&quot;); &#x2F;&#x2F; 将js对象转换为JQuery对象 } &#x2F;&#x2F; 2. 通过Jquery方式来获取元素对象 var $divs = $(&quot;div&quot;); alert($divs); &#x2F;&#x2F; 将$divs中的所有div标签体内容修改为&quot;bbb&quot; &#x2F;&#x2F; $divs.html(&quot;bbb&quot;); &#x2F;&#x2F; 将JQuery对象转换为js对象 $divs[0].innerHTML = &quot;ddd&quot;; $divs[1].innerHTML = &quot;ddd&quot;; &lt;&#x2F;script&gt; 4. 选择器：筛选具有相似特征的元素(标签)4.1 基本操作学习1. 事件绑定 $(&quot;#b1&quot;).click(function () { alert(&quot;abc&quot;); }) 2. 入口函数 $(function () { }); &#x2F;* window.onload 和 $(function)的区别 1. window.onload只能定义一次，如定义多次，后边的会将前边的覆盖掉 2. $(function)可以定义多次 *&#x2F; 3. 样式控制：CSS方法 $(function () { $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }) 4.2 分类1. 基本选择器 选择器名称 语法 标签选择器(元素选择器) $(&quot;html标签名&quot;) ：获取所有匹配标签名称的元素 ID选择器 $(&quot;#id的属性值&quot;)：获取与指定id属性值匹配的元素 类选择器 $(.class的属性值)：获取与指定class属性值匹配的元素 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;改变 id 为 one 的元素的背景色为 红色&quot; id=&quot;b1&quot;&#x2F;&gt; $(&quot;#b1&quot;).click(function () { $(&quot;#one&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变元素名为 &lt;div&gt; 的所有元素的背景色为 红色&quot; id=&quot;b2&quot;&#x2F;&gt; $(&quot;#b2&quot;).click(function () { $(&quot;div&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变 class 为 mini 的所有元素的背景色为 红色&quot; id=&quot;b3&quot;&#x2F;&gt; $(&quot;#b3&quot;).click(function () { $(&quot;.mini&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变所有的&lt;span&gt;元素和 id 为 two 的元素的背景色为红色&quot; id=&quot;b4&quot;&#x2F;&gt; $(&quot;#b4&quot;).click(function () { $(&quot;span&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); $(&quot;#two&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); }); &lt;&#x2F;script&gt; 2. 层级选择器 选择器名称 语法 后代选择器 $(&quot;A B &quot;)：选择A元素内部的所有B元素 子选择器 $(&quot;A &gt; B&quot;)：选择A元素内部的所有B子元素 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变 &lt;body&gt; 内所有 &lt;div&gt; 的背景色为红色&quot; id=&quot;b1&quot;&#x2F;&gt; $(&quot;#b1&quot;).click(function () { $(&quot;body div&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变 &lt;body&gt; 内子 &lt;div&gt; 的背景色为 红色&quot; id=&quot;b2&quot;&#x2F;&gt; $(&quot;#b2&quot;).click(function () { $(&quot;body &gt; div&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); }) &lt;&#x2F;script&gt; 3. 属性选择器 选择器名称 语法 属性名称选择器 $(&quot;A[属性名]&quot;)：选择包含指定属性名称的元素 属性选择器 $(&quot;A[属性名 = &#39;值&#39;]&quot;)：选择指定属性等于指定值的元素 复合属性选择器 $(&quot;A[属性名=&#39;值&#39;][]...&quot;)：包含多个属性条件的选择器 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 含有属性title 的div元素背景色为红色&quot; id=&quot;b1&quot;&#x2F;&gt; $(&quot;#b1&quot;).click(function () { $(&quot;div[title]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 属性title值等于test的div元素背景色为红色&quot; id=&quot;b2&quot;&#x2F;&gt; $(&quot;#b2&quot;).click(function () { $(&quot;div[title=&#39;test&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 属性title值不等于test的div元素(没有属性title的也将被选中)背景色为红色&quot; id=&quot;b3&quot;&#x2F;&gt; $(&quot;#b3&quot;).click(function () { $(&quot;div[title != &#39;test&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 属性title值 以te开始 的div元素背景色为红色&quot; id=&quot;b4&quot;&#x2F;&gt; $(&quot;#b4&quot;).click(function () { $(&quot;div[title ^= &#39;te&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 属性title值 以est结束 的div元素背景色为红色&quot; id=&quot;b5&quot;&#x2F;&gt; $(&quot;#b5&quot;).click(function () { $(&quot;div[title $= &#39;est&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;属性title值 含有es的div元素背景色为红色&quot; id=&quot;b6&quot;&#x2F;&gt; $(&quot;#b6&quot;).click(function () { $(&quot;div[title*=&#39;es&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;选取有属性id的div元素，然后在结果中选取属性title值含有“es”的 div 元素背景色为红色&quot; id=&quot;b7&quot;&#x2F;&gt; $(&quot;#b7&quot;).click(function () { $(&quot;div[id][title*=&#39;es&#39;]&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); }) &lt;&#x2F;script&gt; 4. 过滤选择器 选择器名称 语法 首元素选择器 :first：获得选择的元素中的第一个元素 尾元素选择器 :last：获得选择的元素中的最后一个元素 非元素选择器 :not(selector)：不包含指定内容的元素 偶数选择器 :even：偶数，从0开始计数 计数选择器 :odd：奇数，从0开始计数 等于索引选择器 :eq(index)：指定索引元素 大于索引选择器 :gt(index)：大于指定索引元素 小于索引选择器 :lt(index)：小于指定索引元素 标题选择器 :header：获取标题(h1~h6)元素，固定写法 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变第一个 div 元素的背景色为 红色&quot; id=&quot;b1&quot;&#x2F;&gt; $(&quot;#b1&quot;).click(function () { $(&quot;div:first&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变最后一个 div 元素的背景色为 红色&quot; id=&quot;b2&quot;&#x2F;&gt; $(&quot;#b2&quot;).click(function () { $(&quot;div:last&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变class不为 one 的所有 div 元素的背景色为 红色&quot; id=&quot;b3&quot;&#x2F;&gt; $(&quot;#b3&quot;).click(function () { $(&quot;div:not(.one)&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变索引值为偶数的 div 元素的背景色为 红色&quot; id=&quot;b4&quot;&#x2F;&gt; $(&quot;#b4&quot;).click(function () { $(&quot;div:even&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变索引值为奇数的 div 元素的背景色为 红色&quot; id=&quot;b5&quot;&#x2F;&gt; $(&quot;#b5&quot;).click(function () { $(&quot;div:odd&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变索引值为大于 3 的 div 元素的背景色为 红色&quot; id=&quot;b6&quot;&#x2F;&gt; $(&quot;#b6&quot;).click(function () { $(&quot;div:gt(3)&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变索引值为等于 3 的 div 元素的背景色为 红色&quot; id=&quot;b7&quot;&#x2F;&gt; $(&quot;#b7&quot;).click(function () { $(&quot;div:eq(3)&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变索引值为小于 3 的 div 元素的背景色为 红色&quot; id=&quot;b8&quot;&#x2F;&gt; $(&quot;#b8&quot;).click(function () { $(&quot;div:lt(3)&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 改变所有的标题元素的背景色为 红色&quot; id=&quot;b9&quot;&#x2F;&gt; $(&quot;#b9&quot;).click(function () { $(&quot;:header&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); }); }) &lt;&#x2F;script&gt; 5. 表单过滤选择器 选择器名称 语法 可用元素选择器 :enabled：获取可用元素 不可用元素选择器 :disabled：获取不可用元素 选中选择器 :checked：获取单选/复选框选中的元素 选中选择器 :selected：获取下拉框选中的元素 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 利用 jQuery 对象的 val() 方法改变表单内可用 &lt;input&gt; 元素的值&quot; id=&quot;b1&quot;&#x2F;&gt; $(&quot;#b1&quot;).click(function () { $(&quot;input[type=&#39;text&#39;]:enabled&quot;).val(&quot;可用元素&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 利用 jQuery 对象的 val() 方法改变表单内不可用 &lt;input&gt; 元素的值&quot; id=&quot;b2&quot;&#x2F;&gt; $(&quot;#b2&quot;).click(function () { $(&quot;input[type=&#39;text&#39;]:disabled&quot;).val(&quot;不可用元素&quot;); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 利用 jQuery 对象的 length 属性获取复选框选中的个数&quot; id=&quot;b3&quot;&#x2F;&gt; $(&quot;#b3&quot;).click(function () { var result = $(&quot;input[type=&#39;checkbox&#39;]:checked&quot;).length; alert(result) }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot; 利用 jQuery 对象的 length 属性获取下拉框选中的个数&quot; id=&quot;b4&quot;&#x2F;&gt; $(&quot;#b4&quot;).click(function () { alert($(&quot;#job &gt; option:selected&quot;).length); }); }) &lt;&#x2F;script&gt; 5. DOM操作5.1 内容操作 html()：获取/设置元素的标签体内容 text()：获取/设置元素的标签体纯文本内容 val()：获取/设置元素的value属性值 &lt;script&gt; $(function () { &#x2F;&#x2F; 获取myinput 的value值 alert($(&quot;#myinput&quot;).val()); &#x2F;&#x2F; 设置值 alert($(&quot;#myinput&quot;).val(&quot;李四&quot;)); &#x2F;&#x2F; 获取mydiv的标签体内容 alert($(&quot;#mydiv&quot;).html()); &#x2F;&#x2F; 设置值 alert($(&quot;#mydiv&quot;).html(&quot;&lt;h4&gt;hello&lt;&#x2F;h4&gt;&quot;)); &#x2F;&#x2F; 获取mydiv纯文本内容 alert($(&quot;#mydiv&quot;).text()); &#x2F;&#x2F; 设置值 alert($(&quot;#mydiv&quot;).text(&quot;aaa&quot;)); }) &lt;&#x2F;script&gt; 5.2 属性操作1. 通用属性操作 attr()：获取/设置元素的属性 removeAttr()：删除属性 prop()：获取/设置元素的属性 removeProp()：删除属性 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F;获取北京节点的name属性值 alert($(&quot;#bj&quot;).attr(&quot;name&quot;)); &#x2F;&#x2F;设置北京节点的name属性的值为dabeijing $(&quot;#bj&quot;).attr(&quot;name&quot;,&quot;dabeijing&quot;); &#x2F;&#x2F;新增北京节点的discription属性 属性值是didu $(&quot;#bj&quot;).attr(&quot;discription&quot;,&quot;didu&quot;); &#x2F;&#x2F;删除北京节点的name属性并检验name属性是否存在 $(&quot;#bj&quot;).removeAttr(&quot;name&quot;); &#x2F;&#x2F;获得hobby的的选中状态 alert($(&quot;#hobby&quot;).prop(&quot;checked&quot;)); }) &lt;&#x2F;script&gt; attr和prop区别？ 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素自定义的属性，则建议使用attr 2. 对class属性操作 addClass()：添加class属性值 removeClass()：删除class属性值 toggleClass()：切换class属性值 css()：操作元素css样式 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot;采用属性增加样式(改变id=one的样式)&quot; id=&quot;b1&quot;&#x2F;&gt; $(&quot;#b1&quot;).click(function () { $(&quot;#one&quot;).prop(&quot;class&quot;,&quot;second&quot;); }); &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot; addClass&quot; id=&quot;b2&quot;&#x2F;&gt; $(&quot;#b2&quot;).click(function () { $(&quot;#one&quot;).addClass(&quot;second&quot;); }); &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot;removeClass&quot; id=&quot;b3&quot;&#x2F;&gt; $(&quot;#b3&quot;).click(function () { $(&quot;#one&quot;).removeClass(&quot;second&quot;); }); &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot; 切换样式&quot; id=&quot;b4&quot;&#x2F;&gt; $(&quot;#b4&quot;).click(function () { $(&quot;#one&quot;).toggleClass(&quot;second&quot;); }); &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot; 通过css()获得id为one背景颜色&quot; id=&quot;b5&quot;&#x2F;&gt; $(&quot;#b5&quot;).click(function () { alert($(&quot;#one&quot;).css(&quot;backgroundColor&quot;)); }); &#x2F;&#x2F;&lt;input type=&quot;button&quot; value=&quot; 通过css()设置id为one背景颜色为绿色&quot; id=&quot;b6&quot;&#x2F;&gt; $(&quot;#b6&quot;).click(function () { $(&quot;#one&quot;).css(&quot;backgroundColor&quot;,&quot;blue&quot;); }); }) &lt;&#x2F;script&gt; 5.3 CRUD操作 方法名称 作用 例子 append() 父元素将子元素追加到末尾 对象1.append(对象2)：将对象2添加到对象1元素内部末尾处。 prepend() 父元素将子元素追加到开头 对象1.prepend(对象2)：将对象2添加到对象1元素内部开头处。 appendTo() 对象1.appendTo(对象2)：将对象1添加到对象2内部末尾处。 prependTo() 对象1.prependTo(对象2)：将对象1添加到对象2内部开头处。 after() 添加元素到元素后边 对象1.after(对象2)：将对象2添加到对象1后边。对象1和2是兄弟关系。 before() 添加元素到元素前边 对象1.before(对象2)：将对象2添加到对象1前边。对象1和2是兄弟关系。 insertAfter() 对象1.insertAfter(对象2)：将对象1添加到对象2后边。对象1和2是兄弟关系。 insertBefore() 对象1.insertBefore(对象2)：将对象1添加到对象2前边。对象1和对象2是兄弟关系。 remov() 移除元素 对象.remove()：将对象删除 empty() 清空元素的所有后代元素 对象.empty()：将对象的后代元素全部清空，但保留当前对象及其属性节点。 &lt;script type=&quot;text&#x2F;javascript&quot;&gt; $(function () { &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;将反恐放置到city的后面&quot; id=&quot;b1&quot;&#x2F;&gt; $(&quot;#b1&quot;).click(function () { &#x2F;&#x2F; append &#x2F;&#x2F; $(&quot;#city&quot;).append($(&quot;#fk&quot;)); &#x2F;&#x2F; appendTo $(&quot;#fk&quot;).appendTo($(&quot;#city&quot;)); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;将反恐放置到city的最前面&quot; id=&quot;b2&quot;&#x2F;&gt; $(&quot;#b2&quot;).click(function () { &#x2F;&#x2F; prepend $(&quot;#fk&quot;).prependTo($(&quot;#city&quot;)); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;将反恐插入到天津后面&quot; id=&quot;b3&quot;&#x2F;&gt; $(&quot;#b3&quot;).click(function () { &#x2F;&#x2F; after &#x2F;&#x2F; $(&quot;#tj&quot;).after($(&quot;#fk&quot;)); &#x2F;&#x2F; insertAfter $(&quot;#fk&quot;).insertAfter($(&quot;#tj&quot;)); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;将反恐插入到天津前面&quot; id=&quot;b4&quot;&#x2F;&gt; $(&quot;#b4&quot;).click(function () { $(&quot;#fk&quot;).insertBefore($(&quot;#tj&quot;)); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;删除&lt;li id=&#39;bj&#39; name=&#39;beijing&#39;&gt;北京&lt;&#x2F;li&gt;&quot; id=&quot;b1&quot;&#x2F;&gt; $(&quot;#b1&quot;).click(function () { $(&quot;#bj&quot;).remove(); }); &#x2F;&#x2F; &lt;input type=&quot;button&quot; value=&quot;删除city所有的li节点 清空元素中的所有后代节点(不包含属性节点)&quot; id=&quot;b2&quot;&#x2F;&gt; $(&quot;#b2&quot;).click(function () { $(&quot;#city&quot;).empty(); }); }) &lt;&#x2F;script&gt; 小案例1. 隔行换色 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt; &lt;script src=&quot;..&#x2F;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;&#x2F;需求：将数据行的奇数行背景色设置为 pink，偶数行背景色设置为 yellow $(function () { &#x2F;&#x2F; 1. 获取数据行的奇数行的tr，设置背景色为pink $(&quot;tr:gt(1):odd&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;) &#x2F;&#x2F; 2. 获取数据行的偶数行的tr，设置背景色为yellow $(&quot;tr:gt(1):even&quot;).css(&quot;backgroundColor&quot;,&quot;yellow&quot;) }); &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;table id=&quot;tab1&quot; border=&quot;1&quot; width=&quot;800&quot; align=&quot;center&quot; &gt; &lt;tr&gt; &lt;td colspan=&quot;5&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;删除&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr style=&quot;background-color: #999999;&quot;&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;&#x2F;th&gt; &lt;th&gt;分类ID&lt;&#x2F;th&gt; &lt;th&gt;分类名称&lt;&#x2F;th&gt; &lt;th&gt;分类描述&lt;&#x2F;th&gt; &lt;th&gt;操作&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;0&lt;&#x2F;td&gt; &lt;td&gt;手机数码&lt;&#x2F;td&gt; &lt;td&gt;手机数码类商品&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;电脑办公&lt;&#x2F;td&gt; &lt;td&gt;电脑办公类商品&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;鞋靴箱包&lt;&#x2F;td&gt; &lt;td&gt;鞋靴箱包类商品&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;3&lt;&#x2F;td&gt; &lt;td&gt;家居饰品&lt;&#x2F;td&gt; &lt;td&gt;家居饰品类商品&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 2. 全选/全不选 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt; &lt;script src=&quot;..&#x2F;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; &#x2F;&#x2F; 需要保证下边的选中状态和第一个复选框的状态一致即可。 function selectAll(obj) { &#x2F;&#x2F; 获取下边的所有复选框 $(&quot;.itemSelect&quot;).prop(&quot;checked&quot;,obj.checked); } &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;table id=&quot;tab1&quot; border=&quot;1&quot; width=&quot;800&quot; align=&quot;center&quot; &gt; &lt;tr&gt; &lt;td colspan=&quot;5&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;删除&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; onclick=&quot;selectAll(this)&quot; &gt;&lt;&#x2F;th&gt; &lt;th&gt;分类ID&lt;&#x2F;th&gt; &lt;th&gt;分类名称&lt;&#x2F;th&gt; &lt;th&gt;分类描述&lt;&#x2F;th&gt; &lt;th&gt;操作&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;itemSelect&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;手机数码&lt;&#x2F;td&gt; &lt;td&gt;手机数码类商品&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;itemSelect&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;电脑办公&lt;&#x2F;td&gt; &lt;td&gt;电脑办公类商品&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;itemSelect&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;3&lt;&#x2F;td&gt; &lt;td&gt;鞋靴箱包&lt;&#x2F;td&gt; &lt;td&gt;鞋靴箱包类商品&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; class=&quot;itemSelect&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;4&lt;&#x2F;td&gt; &lt;td&gt;家居饰品&lt;&#x2F;td&gt; &lt;td&gt;家居饰品类商品&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;修改&lt;&#x2F;a&gt;|&lt;a href=&quot;&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 3. qq表情选择 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; &#x2F;&gt; &lt;title&gt;QQ表情选择&lt;&#x2F;title&gt; &lt;script src=&quot;..&#x2F;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;style type=&quot;text&#x2F;css&quot;&gt; *{margin: 0;padding: 0;list-style: none;} .emoji{margin:50px;} ul{overflow: hidden;} li{float: left;width: 48px;height: 48px;cursor: pointer;} .emoji img{ cursor: pointer; } &lt;&#x2F;style&gt; &lt;script&gt; &#x2F;&#x2F;需求：点击qq表情，将其追加到发言框中 $(function () { &#x2F;&#x2F; 1. 给img图片添加onclick事件 $(&quot;ul img&quot;).click(function () { &#x2F;&#x2F; 2. 追加到p标签中即可,$(this)：将js对象转换为JQuery对象 $(&quot;.word&quot;).append($(this).clone()); }); }); &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class=&quot;emoji&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;01.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;02.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;03.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;04.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;05.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;06.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;07.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;08.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;09.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;10.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;11.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;img src=&quot;img&#x2F;12.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;p class=&quot;word&quot;&gt; &lt;strong&gt;请发言：&lt;&#x2F;strong&gt; &lt;img src=&quot;img&#x2F;12.gif&quot; height=&quot;22&quot; width=&quot;22&quot; alt=&quot;&quot; &#x2F;&gt; &lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 4. 多选下拉列表左右移动 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt; &lt;script src=&quot;..&#x2F;..&#x2F;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;style&gt; #leftName , #btn,#rightName{ float: left; width: 100px; height: 300px; } #toRight,#toLeft{ margin-top:100px ; margin-left:30px; width: 50px; } .border{ height: 500px; padding: 100px; } &lt;&#x2F;style&gt; &lt;script&gt; &#x2F;&#x2F;需求：实现下拉列表选择条目左右选择功能 $(function () { $(&quot;#toRight&quot;).click(function () { &#x2F;&#x2F; 获取右边的下拉列表对象，append(左边下拉列表选中的option) $(&quot;#rightName&quot;).append($(&quot;#leftName &gt; option:selected&quot;)); }); $(&quot;#toLeft&quot;).click(function () { $(&quot;#leftName&quot;).append($(&quot;#rightName &gt; option:selected&quot;)); }); }); &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class=&quot;border&quot;&gt; &lt;select id=&quot;leftName&quot; multiple=&quot;multiple&quot;&gt; &lt;option&gt;张三&lt;&#x2F;option&gt; &lt;option&gt;李四&lt;&#x2F;option&gt; &lt;option&gt;王五&lt;&#x2F;option&gt; &lt;option&gt;赵六&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;div id=&quot;btn&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;toRight&quot; value=&quot;--&gt;&quot;&gt;&lt;br&gt; &lt;input type=&quot;button&quot; id=&quot;toLeft&quot; value=&quot;&lt;--&quot;&gt; &lt;&#x2F;div&gt; &lt;select id=&quot;rightName&quot; multiple=&quot;multiple&quot;&gt; &lt;option&gt;钱七&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://zero024.cn/tags/JQuery/"}]},{"title":"Filter和Listener","slug":"JavaWeb/Filter和Listener","date":"2019-06-27T15:30:00.000Z","updated":"2020-03-08T00:51:06.183Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. Filter：过滤器Filter也称之为过滤器，它是Servlet技术中最激动人心的技术，Web开发人员通过Filter技术，对Web服务器管理的所有Web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。","text":"1. Filter：过滤器Filter也称之为过滤器，它是Servlet技术中最激动人心的技术，Web开发人员通过Filter技术，对Web服务器管理的所有Web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 1.1 过滤器的作用一般用于完成通用的操作。如登录验证、统一编码处理、敏感字符过滤等 1.2 快速入门 定义一个类，实现接口Filter 复写方法 配置拦截路径。使用web.xml和注解配置。 @WebFilter(&quot;&#x2F;*&quot;) &#x2F;&#x2F; 访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(&quot;FilterDemo1执行了...&quot;); &#x2F;&#x2F; 放行 filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } 1.3 过滤器细节1.3.1 web.xml配置方法 &lt;filter&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;cn.zero.web.filter.FilterDemo1&lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt; 1.3.2 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下面的代码 1.3.3 过滤器生命周期方法 init：在服务器启动后，会创建Filter对象，然后调用init方法，只执行一次。一般用于加载资源。 doFilter：每一次请求被拦截资源时，会执行该方法，会执行多次 destroy：在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。一般用于释放资源。` 1.3.4 过滤器配置详解拦截路径配置： 具体资源路径：/index.jsp ，只有访问index.jsp资源时，过滤器才会被执行 拦截目录： /user/* ，访问/user下的所有资源时，过滤器都会被执行 后缀名拦截：*.jsp ， 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源：/* ， 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 注解配置：需要设置dispatcharTypes属性 REQUEST：默认值。浏览器直接请求资源。 FORWARD：转发访问资源。 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 &#x2F;&#x2F;@WebFilter(value = &quot;&#x2F;index.jsp&quot;,dispatcherTypes = DispatcherType.REQUEST) &#x2F;&#x2F; 浏览器直接请求index.jsp资源时，该过滤器会被执行 &#x2F;&#x2F;@WebFilter(value = &quot;&#x2F;index.jsp&quot;,dispatcherTypes = DispatcherType.FORWARD) &#x2F;&#x2F; 转发访问index.jsp资源时，该过滤器会被执行 @WebFilter(value = &quot;&#x2F;index.jsp&quot;,dispatcherTypes = {DispatcherType.FORWARD,DispatcherType.REQUEST}) &#x2F;&#x2F; 直接访问或转发访问index.jsp资源时，该过滤器会被执行 web.xml 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 1.3.5 过滤器链(配置多个过滤器)如果有两个过滤器：过滤器1和过滤器2，那么他们的执行顺序是 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题 注解配置：按照类名的字符串比较规则比较，值小的先执行。例：AFilter和BFilter，AFilter就会先执行。 web.xml配置：&lt;filter-mapping&gt; 谁定义在上边，谁先执行。 1.4 案例1. 登录验证将以前做的用户信息管理系统加上访问权限控制。 &#x2F;** * 登录过滤器,访问除了登录资源以外的所有资源，都必须先登录 *&#x2F; @WebFilter(&quot;&#x2F;*&quot;) public class LoginFilter implements Filter { public void destroy() { } public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { &#x2F;&#x2F; 0. 强制转换 HttpServletRequest request = (HttpServletRequest) req; &#x2F;&#x2F; 1. 获取资源请求路径 String uri = request.getRequestURI(); &#x2F;&#x2F; 2. 判断是否是登录相关的资源,要注意排除掉css&#x2F;js&#x2F;图片&#x2F;验证码等资源 if (uri.contains(&quot;&#x2F;login.jsp&quot;) || uri.contains(&quot;loginServlet&quot;) || uri.contains(&quot;checkCodeServlet&quot;) || uri.contains(&quot;&#x2F;css&#x2F;&quot;) || uri.contains(&quot;&#x2F;js&#x2F;&quot;) || uri.contains(&quot;&#x2F;fonts&#x2F;&quot;)){ &#x2F;&#x2F; 是， 说明用户就是想登录，放行 chain.doFilter(req,resp); }else { &#x2F;&#x2F; 不是登录相关资源，需验证用户是否登录才能放行 &#x2F;&#x2F; 3. 从session中获取loginUser Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;); if(loginUser != null){ &#x2F;&#x2F; 登录过了，放行 chain.doFilter(req,resp); }else { &#x2F;&#x2F; 没有登录，跳转到登录页面 request.setAttribute(&quot;login_msg&quot;,&quot;你尚未登录，请登录&quot;); request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,resp); } } &#x2F;&#x2F; 2. 判断当前用户是否登录，通过session值是否有user来判断 } public void init(FilterConfig config) throws ServletException { } } 2. 敏感词汇过滤对用户管理系统项目的录入数据进行敏感词汇过滤，需要对request对象进行增强 增强对象的功能：通过设计模式来解决。 设计模式：一些通用的解决固定问题的方式。 这里主要使用代理模式来增强对象功能。 代理模式代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式；即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。 详见：博客文章 代理模式的关键点是：代理对象与目标对象。代理对象是对目标对象的扩展，并会调用目标对象，类似Python的装饰器。 目标对象：真实的对象，被代理的对象。 代理对象：代理真实对象做一些操作。 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的。 实现方式分静态代理和动态代理，这里主要讲解动态代理的使用。 动态代理动态代理有以下特点： 代理对象,不需要实现接口 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型) 动态代理也叫做:JDK代理,接口代理 JDK生成代理对象的API代理类所在包：java.lang.reflect.Proxy 实现代理使用newProxyInstance方法，该方法需接收三个参数，分别是： ClassLoader loader：指定当前目标对象使用类加载器，获取类加载器的方法是固定的。 Class&lt;?&gt;[] interfaces：目标对象实现的接口类型，使用泛型方式确认类型 InvocationHandler()：事件处理，执行目标对象的方法时，会触发事件处理器的方法，将当前执行目标对象的方法作为参数传入。 增强方式： 增强参数列表 增强返回值类型 增强方法体执行逻辑 代码示例：敏感词汇过滤器 public class SensitiveWordsFilter implements Filter { public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { &#x2F;&#x2F; 1. 创建代理对象，增强getParameter方法 ServletRequest proxy_req = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { &#x2F;&#x2F; 增强getParameter方法 &#x2F;&#x2F; 判断是否是getParameter方法 if (method.getName().equals(&quot;getParameter&quot;)){ &#x2F;&#x2F; 增强返回值 &#x2F;&#x2F; 1. 获取返回值 String value = (String) method.invoke(req, args); &#x2F;&#x2F; 2. 判断不为空 if (value != null){ &#x2F;&#x2F; 3. 遍历敏感词汇数组,判断返回值是否有敏感词 for (String str: list){ if (value.contains(str)){ &#x2F;&#x2F; 有，则替换为*** value = value.replaceAll(str, &quot;***&quot;); } } } return value; } return method.invoke(req,args); }); &#x2F;&#x2F; 放行 chain.doFilter(proxy_req,resp); } private List&lt;String&gt; list = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 敏感词汇集合 public void init(FilterConfig config) throws ServletException { try{ &#x2F;&#x2F; 1. 获取文件真实路径 ServletContext servletContext = config.getServletContext(); String realPath = servletContext.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;SensitiveWords.txt&quot;); &#x2F;&#x2F; 2. 读取文件 BufferedReader br = new BufferedReader(new FileReader(realPath)); &#x2F;&#x2F; 3. 将文件的每一行数据添加到list中 String line = null; while((line = br.readLine()) != null){ list.add(line); } br.close(); System.out.println(list); }catch (Exception e){ e.printStackTrace(); } } public void destroy() { } } 2. Listener：监听器web的三大组件之一。用于监听web常见对象如：HttpServletRequest,HttpSession,ServletContext。 2.1 监听器的作用监听web对象创建与销毁。 监听web对象的属性变化。 监听session绑定JavaBean操作。 2.2 事件监听机制基本概念 事件：一件事件 事件源：产生这件事情的源头。 监听器：对某件事情进行处理监听的一个对象 注册监听：将事件、事件源、监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码。 2.3 ServletContextListener用于监听SeervletContext对象的创建和销毁。有如下两个方法： void contextDestroyed(ServletContextEvent sce)：ServletContext对象被销毁之前会调用该方法。 void contextInitialized(ServletContextEvent sce)：ServletContext对象创建后会调用该方法。 2.4 步骤 定义一个类，实现ServletContextListener接口 复写方法 配置 web.xml配置 &lt;listener&gt; &lt;listener-class&gt;cn.zero.listener.ContextLoaderListener&lt;&#x2F;listener-class&gt; &lt;&#x2F;listener&gt; 注解配置：@WebListener 代码示例 @WebListener public class ContextLoaderListener implements ServletContextListener { &#x2F;** * 监听ServletContext对象创建的。ServletContext对象服务器启动后自动创建。 * * 在服务器启动后自动调用 * @param servletContextEvent *&#x2F; @Override public void contextInitialized(ServletContextEvent servletContextEvent) { &#x2F;&#x2F; 加载资源文件 &#x2F;&#x2F; 1. 获取ServletContext对象 ServletContext servletContext = servletContextEvent.getServletContext(); &#x2F;&#x2F; 2. 加载资源文件 String contextConfigLocation = servletContext.getInitParameter(&quot;contextConfigLocation&quot;); &#x2F;&#x2F; 3. 获取真实路径 String realPath = servletContext.getRealPath(contextConfigLocation); &#x2F;&#x2F; 4. 加载进内存 try { FileInputStream fis = new FileInputStream(realPath); System.out.println(fis); } catch (FileNotFoundException e) { e.printStackTrace(); } System.out.println(&quot;ServletContext对象被创建了....&quot;); } &#x2F;** * 在服务器关闭后，ServletContext对象被销毁。 * * 当服务器正常关闭后该方法被调用。 * @param servletContextEvent *&#x2F; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { System.out.println(&quot;ServletContext对象被销毁了....&quot;); } }","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[]},{"title":"用户管理系统","slug":"JavaWeb/综合练习","date":"2019-06-25T14:30:00.000Z","updated":"2020-01-03T11:43:19.610Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. 综合练习实现管理员登录，对用户信息进行增删改查的小项目","text":"1. 综合练习实现管理员登录，对用户信息进行增删改查的小项目 1.1 简单功能1. 登录登录功能输入用户名密验证码，表单信息会提交到loginServlet进行登录校验，成功则跳转到首页，失败则返回失败信息。 2. 首页列表查询点击查询，会跳转到findUserByPageServlet，这个Servlet主要功能是查询总记录数据findTotalCount()和分页信息数据findByPage()，然后转发到前端做显示。 3. 添加点击添加联系人按钮，跳转到add.jsp页面，填写信息后点击提交，会将form表单填写的所有信息传递给AddUserServlet进行处理。 AddUserServlet主要操作： 设置编码setCharacterEncoding(&quot;utf-8&quot;) 获取所有请求参数request.getParameterMap() 使用BeanUtils.populate将请求参数封装成User对象 调用service的addUser(User user)方法完成保存 跳转回查询界面 UserService业务层主要进行保存操作。 UserDao数据访问层，封装了对数据库的所有操作。 4. 删除点击删除按钮，会将这条数据的ID获取，封装在请求头里面传递给后台 DelUserServlet主要操作： 获取要删除的用户ID，getParameter 调用service的delUser(String id)方法完成删除 跳转回查询页面 5. 修改修改用到了两个Servlet进行处理。首先点击修改按钮，会将用户ID传递随请求头传递给findUserServlet。 findUserServlet主要操作： 获取用户ID 根据ID查询用户信息findUser(id)，返回一个User对象 将User对象存入request 转发到update.jsp update.jsp页面主要操作： 从request域中获取User对象的数据 使用EL表达式将所有数据回写到页面里。${user.xxx} 将获取的ID值填入隐藏域值，以确定修改用户。&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${user.id}&quot;&gt; 点击提交，提交表单信息到UpdateUserServlet进行处理。 UpdateUserServlet主要操作： 设置编码 获取表单数据，并封装成User对象 调用Service方法updateUser(User user)，将User对象传入，完成修改 跳转回查询页面 1.2 复杂功能1. 删除选中点击删除选中按钮，主要问题就是要先获取选中的用户条目，在将这些选中条目的ID提交到后台进行批量删除操作。 1.1 获取选中条目的ID,通过form表单提交到后台。 &#x2F;* 为删除选中按钮绑定单击事件，提交每个条目复选框的值(该值就是条目的ID) 1. 给每一个条目添加checkbox,值是条目对应的ID 2. 获取当前页面的所有复选框标签，然后遍历，判断其是否有checked属性，有则允许提交表单 3. 提交form表单 *&#x2F; window.onload = function () { &#x2F;&#x2F; 为删除选中绑定单击事件 document.getElementById(&quot;delSelected&quot;).onclick = function () { if (confirm(&quot;确定要删除所有选中的信息么?&quot;)){ var flag = false; &#x2F;&#x2F; 判断是否有选中信息 var cbs = document.getElementsByName(&quot;uid&quot;); for (var i = 0; i &lt; cbs.length; i++) { if(cbs[i].checked){ &#x2F;&#x2F; 如果有任何一个信息被选中(checkbox.checked返回布尔值，表示是否被选中) flag = true; &#x2F;&#x2F; 允许提交 break; } } if (flag)&#x2F;&#x2F;判断是否允许提交 &#x2F;&#x2F; 使用提交方法提交信息到后台 document.getElementById(&quot;form&quot;).submit(); } } } &#x2F;* 全选&#x2F;全不选功能JS代码 1. 在表头单元格添加一个复选框 2. 获取该复选框标签对象 3. 为该对象绑定单击事件，点击就获取所有的复选框对象，然后遍历，设置这些复选框的checked=this.checked。(this:就是当前复选框对象,即&#39;firstCB&#39;) *&#x2F; document.getElementById(&quot;firstCB&quot;).onclick = function () { &#x2F;&#x2F; 获取列表所有的cb var cbs = document.getElementsByName(&quot;uid&quot;); &#x2F;&#x2F; 遍历 for (var i = 0; i &lt; cbs.length; i++) { &#x2F;&#x2F; 设置这些cbs[i]的checked状态等于firstCB.checked cbs[i].checked = this.checked; } } 1.2 后台DelSelectedServlet主要操作 获取请求参数的ID数组。getParameterValues() 调用service的delUser(String[] ids)进行批量删除。该方法会对id数组进行遍历，然后调用dao的delUser(Int id)方法操作数据库进行删除。 全部删除完毕，跳转回查询页面。 2. 分页查询2.1 好处： 减轻服务器内存的开销 提升用户的体验 2.2 分析前端需要传递给后台的信息主要有两个，当前页码currentPage和每页显示条数rows 当前页码currentPage：需要查询数据库得到总记录数totalCount=select count(*) from user;，然后通过三元运算符totalCount % rows == 0 ? totalCount / rows:totalCount / rows + 1计算出totalPage总页码。将总页码数返回给前端页面做进一步处理 每页显示条数rows：自定义的条数。 当第一次访问findUserByPageServlet时，后台会做两次SQL查询，查询总记录数和当前分页数据，然后全部封装进PageBean对象，存入request返回。前端接受到这个对象，会在分页查询功能区遍历该对象，进行当前页码计算，以确定有多少分页。当用户点击不同分页时，会将当前页码返回给findUserByPageServlet做进一步的查询操作。 &lt;%--分页查询部分代码,遍历生成li,有多少页就会生成多少li--%&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;${userPage.totalPage}&quot; var=&quot;i&quot;&gt; &lt;c:if test=&quot;${userPage.currentPage == i}&quot;&gt; &lt;%--如果服务器返回的页码等于当前页码，则将按钮激活--%&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;${pageContext.request.contextPath}&#x2F;findUserByPageServlet?currentPage=${i}&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}&quot;&gt;${i}&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;c:if&gt; &lt;c:if test=&quot;${userPage.currentPage != i}&quot;&gt; &lt;%--如果服务器返回的页码不等于当前页码，则正常显示--%&gt; &lt;li&gt;&lt;a href=&quot;${pageContext.request.contextPath}&#x2F;findUserByPageServlet?currentPage=${i}&amp;name=${condition.name[0]}&amp;address=${condition.address[0]}&amp;email=${condition.email[0]}&quot;&gt;${i}&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;c:if&gt; &lt;&#x2F;c:forEach&gt; findUserByPageServlet主要操作： 接受请求参数，获取当前页码和每页显示条目数 调用service的findUserByPage(currentPage,rows,condition)方法查询数据，返回PageBean对象，里面封装了当前分页数据对象。 将PageBean对象存入request域中 转发到list.jsp进行显示 findUserByPage()方法主要功能： 创建一个空的PageBean对象 设置当前页码属性和显示条目属性 调用dao的findTotalCount()方法查询总记录数，并设置进PageBean 计算开始索引start = (currentPage - 1) * rows，然后调用dao的findByPage(start,rows)方法查询当前分页数据集合。 计算总页码数，并设置。 返回PageBean对象 findTotalCount方法功能： 定义模板初始化sql。select count(*) from user where 1 = 1 遍历条件map，获取其值 如果值不为空或null，则拼接sql字符串，同时将对应值传入list集合。 使用queryForObject()方法查询出总记录数，并返回 findByPage方法功能： 定义初始化sql。 遍历条件map，获取其值 如果值不为空或null，则拼接sql字符串，同时将对应值传入list集合。 将分页查询添加进sql字符串。limit ?,? 将分页查询参数值添加入参数集合中。params.add(start); params.add(rows); 使用query查询数据，返回分页数据对象集合。 3. 复杂条件查询前端主要就是要将复杂条件查询的数据通过表单参数提交到后台，后台获取参数map后，调用方法查询数据，返回当前分页数据。将PageBean和条件参数map存入request，交给前端做进一步处理。 项目成果用户信息管理系统 更新日志6月26号完成了项目主体内容，前后端数据交互进行复杂条件查询，分页查询，增加用户，删除用户，批量删除等功能。 6月27号 学习了filter过滤器，编写了过滤器实现访问权限控制。即访问除了登录相关页面以外的页面或者资源，会先进行判断用户是否登录，登录则放行，未登录则转发到登录页面。 将前端分页查询到的内容用户编号显示，进行了唯一操作。即查询到10个用户，第一页会显示编号1~5的用户，第二页显示5~10用户。 7月1号将复杂条件搜索框整合为了一个，实现了输入查询条件，显示符合条件的用户信息。其主要难点在于数据传递和SQL语句的编写。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://zero024.cn/tags/Project/"}]},{"title":"'2019.6.24'","slug":"Jottings/2019-06-24","date":"2019-06-24T15:53:39.000Z","updated":"2020-01-03T11:43:19.612Z","comments":true,"path":"uncategorized/undefined.html","link":"","permalink":"https://zero024.cn/uncategorized/undefined.html","excerpt":"咕咕咕！","text":"咕咕咕！ 最近一直在做一个Web端小项目：用户管理系统 昨天也买了腾讯的云服务器，打算这两天就把项目部署一下。 然后Web阶段的学习预计六月底能结束，可以开始总结知识点，复习一下了。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://zero024.cn/tags/随笔/"}]},{"title":"JSP和MVC","slug":"JavaWeb/JSP","date":"2019-06-19T15:59:00.000Z","updated":"2020-01-03T11:43:19.598Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. JSPJSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头 以%&gt;结束。","text":"1. JSPJSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头 以%&gt;结束。 1.1 指令指令主要用于配置JSP页面，导入资源文件。 格式：&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; 主要有三种指令：page、include、taglib 1.1.1 page主要用于配置JSP页面的 contentType()：设置响应体的mime类型以及字符集，设置当前jsp页面的编码(只有高级的IDE才能生效，如果使用低级工具，则需使用pageEncoding属性来设置当前页面的字符集)。 import：导包，用法同Java中的导包。 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：标识当前页面是否是错误页面，默认值false。设置为true代表当前页面是错误页面，就可以使用内置对象exception。 1.1.2 include页面包含的，用于导入其他页面的资源文件 &lt;%@include file=&quot;other.jsp&quot; %&gt; 1.1.3 taglib导入外部资源 &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; prefix：前缀，自定义的。 1.2 注释 html注释&lt;!-- --&gt;：只能注释html代码片段。 JSP注释&lt;%-- --%&gt;：可以注释所有，推荐使用。 1.3 内置对象在jsp页面中不需要创建，直接使用的对象就是内置对象，一共有9个。 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(通过转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象，this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 面试题：写出JSP中的9个内置对象2. MVC开发模式2.1 JSP演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来出现了jsp，简化了Servlet的开发，但是如果过度的使用jsp，在jsp中既写大量的java代码，又写html标签，会造成代码很难维护，也很难分工协作。 故此后Java的Web开发，借鉴了MVC开发模式，使得程序的设计更加合理性。 2.2 MVCMVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 M：Model(模型)，JavaBean。主要完成具体的业务操作，如：查询数据库，封装对象等。 V：View(视图)，JSP。主要展示数据 C：Controller(控制器)，Servlet。主要功能有获取用户的输入，调用模型，将模型返回的数据交给视图进行展示。 2.2.1 优缺点优点： 耦合性低，方便维护，有利于分工协作 复用性高 缺点： 使得项目架构变得复杂，对开发人员要求高 3. EL表达式 EL（Expression Language） 是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。 语法：${表达式} jsp默认支持el表达式，有两种方法可以忽略el表达式。 忽略当前jsp页面中所有的el表达式：设置jsp中的page指令isELIgnored=&quot;true&quot;即可。 忽略当前el表达式：使用\\${表达式} 3.1 基本使用3.1.1 运算符 算数运算符：+ - * /(div) %(mod) 比较运算符：&gt; &lt; = &gt;= &lt;= == != 逻辑运算符：&amp;&amp;(and) ||(or) !(not) 空运算符：empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0。 ${empty list}：判断list是否为null或者长度为0 ${not empty str}：表示判断str对象是否不为null并且长度&gt;0 3.1.2 获取值el表达式只能从域对象中获取值，语法如下 1.${域名称.键名}表示从指定域中获取指定键的值。域名称对应对象： 域名称 对象 pageScope pageContext requestScope request sessionScope session applicationScope application(ServletContext) 例：在request域中存储了name=张三，使用${requestScope.name}即可获取值。 2. ${键名表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 3. 获取对象、List集合、Map集合的值 获取对象：${域名称.键名.属性名}，其本质上会去调用对象的getter方法 获取List集合：${域名称.键名[索引]} 获取Map集合：${域名称.键名.key名称}或者${域名称.键名[&quot;key名称&quot;]} 3.1.3 隐式对象EL表达式中有11个隐式对象，常用的就pageContext pageContext：获取jsp其他八个内置对象 通常用它来动态获取虚拟目录：${pageContext.request.contextPath} 4. JSTL标签 JavaServer Pages Tag Library：JSP标准标签库，是由Apache组织提供的开源免费的jsp标签 作用：用于简化和替换jsp页面上的java代码 4.1 使用步骤 导入JSTL相关jar包 引入标签库，使用taglib指令：&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; 使用标签 4.2 常用的JSTL标签4.2.1 if相当于java代码的if语句，有一个必须属性test。 test属性：接受布尔表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容。 一般情况下，test属性值会结合el表达式一起使用 注意：c:if标签没有else情况，想要else情况，则可以再定义一个c:if标签 4.2.2 choose相当于java代码的switch语句 4.2.3 foreach相当于java代码的for语句，代码举例如下 &lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt; &lt;%@ page import=&quot;java.util.List&quot; %&gt; &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot;%&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;foreach标签&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;%-- foreach:相当于java的for语句 1. 完成重复性操作 属性： begin:开始值 end：结束值 var：临时遍历 step：步长 varStatus:循环状态对象 index: 容器中元素的索引，从0开始 count：循环次数，从1开始 2. 遍历容器 属性： items：容器对象 var：容器中元素的临时变量 varStatus:循环状态对象 index: 容器中元素的索引，从0开始 count：循环次数，从1开始 --%&gt; &lt;c:forEach begin=&quot;0&quot; end=&quot;10&quot; var=&quot;i&quot; step=&quot;2&quot; varStatus=&quot;s&quot;&gt; ${i} &lt;h3&gt;${s.index}&lt;&#x2F;h3&gt; &lt;&#x2F;c:forEach&gt; &lt;hr&gt; &lt;% List list = new ArrayList(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); request.setAttribute(&quot;list&quot;,list); %&gt; &lt;c:forEach items=&quot;${list}&quot; var=&quot;str&quot; varStatus=&quot;s&quot;&gt; ${s.index} ${s.count} ${str}&lt;br&gt; &lt;&#x2F;c:forEach&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 4.3 综合练习在request域中有一个存有User对象的List集合。需要使用jstl+el将List集合数据展示到jsp页面的表格table中。 &lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt; &lt;%@ page import=&quot;java.util.List&quot; %&gt; &lt;%@ page import=&quot;cn.zero.domain.User&quot; %&gt; &lt;%@ page import=&quot;java.util.Date&quot; %&gt; &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;综合练习&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;%-- 在request域中有一个存有User对象的List集合。 请使用jstl+el将List集合数据展示到jsp页面的表格table中。 --%&gt; &lt;% List list = new ArrayList(); list.add(new User(&quot;小张&quot;,21,new Date())); list.add(new User(&quot;小王&quot;,22,new Date())); list.add(new User(&quot;小李&quot;,23,new Date())); request.setAttribute(&quot;list&quot;,list); %&gt; &lt;table border=&quot;1&quot; width=&quot;500&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;th&gt;编号&lt;&#x2F;th&gt; &lt;th&gt;姓名&lt;&#x2F;th&gt; &lt;th&gt;年龄&lt;&#x2F;th&gt; &lt;th&gt;生日&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;c:forEach items=&quot;${list}&quot; var=&quot;user&quot; varStatus=&quot;s&quot;&gt; &lt;c:if test=&quot;${s.count % 2 == 0}&quot;&gt; &lt;tr bgcolor=&quot;#f08080&quot;&gt; &lt;td&gt;${s.count}&lt;&#x2F;td&gt; &lt;td&gt;${user.name}&lt;&#x2F;td&gt; &lt;td&gt;${user.age}&lt;&#x2F;td&gt; &lt;td&gt;${user.birStr}&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;c:if&gt; &lt;c:if test=&quot;${s.count % 2 != 0}&quot;&gt; &lt;tr bgcolor=&quot;#00bfff&quot;&gt; &lt;td&gt;${s.count}&lt;&#x2F;td&gt; &lt;td&gt;${user.name}&lt;&#x2F;td&gt; &lt;td&gt;${user.age}&lt;&#x2F;td&gt; &lt;td&gt;${user.birStr}&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;c:if&gt; &lt;&#x2F;c:forEach&gt; &lt;&#x2F;table&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 5. 三层架构三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。 界面层(表示层)：用户看的界面。用户可以通过界面上的组件和服务器进行交互。 业务逻辑层：处理业务逻辑的。 数据访问层：操作数据存储文件。 6. 综合案例：用户信息列表展示6.1 需求用户点击查询，显示所有用户，可以对数据进行增删改查操作 6.2 设计6.2.1 技术选型Servlet+JSP+MySQL+JDBCTemplate+Duird+BeanUtils+tomcat 6.2.2 数据库设计 create database Users; -- 创建数据库 use Users; create table user( -- 创建表 id int primary key auto_increment, name varchar(20) not null, gender varchar(5), age int, address varchar(32), qq varchar(20), email varchar(50) ) 6.2.3 开发阶段 环境搭建 创建数据库环境 创建项目，导入所需jar包 编码 6.2.4 测试6.2.5 部署运维6.3 代码实现6.3.1 分析图 代码后续见GitHub","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[]},{"title":"会话技术Cookie和Session","slug":"JavaWeb/Cookie和Session","date":"2019-06-16T07:30:00.000Z","updated":"2020-03-08T00:50:44.594Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. 会话技术会话是浏览器和服务器之间的多次请求和响应，在一次会话中往往会产生一些数据，可以通过会话技术(Session和Cookie)保存会话中产生的数据","text":"1. 会话技术会话是浏览器和服务器之间的多次请求和响应，在一次会话中往往会产生一些数据，可以通过会话技术(Session和Cookie)保存会话中产生的数据 一次会话中包含多次请求和响应 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。 主要功能：在一次会话的范围内的多次请求之间，共享数据 客户端会话技术：Cookie 服务器端会话技术：Session 2. Cookie客户端会话技术，将数据保存到客户端 2.1 快速入门 创建Cookie对象，绑定数据：new Cookie(String name, String value) 发送Cookie对象：response.addCookie(Cookie cookie) 获取Cookie，拿到数据：Cookie[] request.getCookies() 2.2 实现原理基于响应头set-cookie和请求头cookie实现 2.3 cookie的细节 一次可不可以发送多个cookie？ 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁。可以通过设置setMaxAge(int seconds)来进行持久化存储，参数填写正数：将Cookie数据写到硬盘的文件中，持久化存储，并指定cookie存活时间，时间到后，cookie文件自动失效；负数是默认值，即浏览器关闭自动销毁；零表示删除cookie信息。 cookie能不能存储中文？ 在tomcat8之前cookie中不能直接存储中文数据，需要将中文数据进行转码(一般采用URL编码，使用URLEncoder和URLDecoder来编解码)；在tomcat8之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，方便URL解码解析。 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享呢？ 默认情况下cookie不能共享。可以通过setPath(String path)方法设置cookie的获取范围，默认情况下设置当前虚拟目录，如果要共享，将path设置为&quot;/&quot;即可。 在不同的tomcat服务器之间cookie能否共享？ 可以通过setDomain(String path)方法设置域名，如果设置的一级域名相同，那么多个服务器之间cookie可以共享，例：setDomain(&quot;.baidu.com&quot;)，那么tieba.baidu.com和news.baidu.com中的cookie可以共享。 一级域名：一级域名中只含有一个.，且.左边要没有内容。最后一个点的右边被称为一级域名，一级域名又被称为顶级域名。一级域名左边有内容的是二级域名。例tieba.baidu.com中，.baodu.com就是一级域名。 2.4 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie的大小有限制(4kb)，以及对同一个域名下的总cookie数量也有限制(20个) cookie一般用于存储少量的不敏感数据 在不登录的情况下，完成服务器对客户端的身份识别(记住我) 2.5 案例：记住上一次访问时间 2.5.1 需求 访问一个Servlet，如果是第一次访问，则提示：你好，欢迎你首次访问 如果不是第一次访问，则提示：欢迎回来，你上次访问时间是：xxxx 2.5.2 需求分析 采用cookie来完成 在服务器中的Servlet判断是否有一个名为lastTime的cookie 有：代表不是第一次访问，先响应数据：欢迎回来，你上次访问时间是：xxxx。在回写cookie：将lasttime更新 没有：代表是第一次访问，响应数据：你好，欢迎首次访问。回写cookie：设置一个lasttime为当前时间。 2.5.3 代码实现 @WebServlet(&quot;&#x2F;CookieExercise&quot;) public class CookieExercise extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 设置响应的消息体的数据格式以及编码 response.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;); &#x2F;&#x2F; 1. 获取所有cookie Cookie[] cookies = request.getCookies(); boolean flag = false; &#x2F;&#x2F; 默认cookie没有lastTime &#x2F;&#x2F; 如果有cookie，则进行遍历 if (cookies != null &amp;&amp; cookies.length &gt; 0){ &#x2F;&#x2F; 2. 遍历cookie数据 for (Cookie cookie : cookies) { &#x2F;&#x2F; 3. 获取cookie的名称 String name = cookie.getName(); &#x2F;&#x2F; 4. 判断名称是否是：lastTime if (&quot;lastTime&quot;.equals(name)){ &#x2F;&#x2F; 有，则代表不是第一次访问 flag = true; &#x2F;&#x2F; 代表有lastTime &#x2F;&#x2F; 设置cookie的value &#x2F;&#x2F; 获取当前时间的字符串，重新设置cookie的值，然后发送 Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); &#x2F;&#x2F; url编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); &#x2F;&#x2F; 设置cookie的存活时间一个月 cookie.setMaxAge(60 * 60 * 24 * 30); response.addCookie(cookie); &#x2F;&#x2F; 将cookie值添加 &#x2F;&#x2F; 5. 响应数据 &#x2F;&#x2F; 获取cookie的value值 String value = cookie.getValue(); System.out.println(&quot;解码前：&quot;+value); &#x2F;&#x2F; url解码 value = URLDecoder.decode(value,&quot;utf-8&quot;); System.out.println(&quot;解码后：&quot;+value); &#x2F;&#x2F; 将数据响应 response.getWriter().write(&quot;&lt;h3&gt;欢迎回来,你的上次访问时是&quot;+value+&quot;&lt;&#x2F;h3&gt;&quot;); break; } } } &#x2F;&#x2F; 如果没有cookie信息或者没有lastTime if (cookies == null || cookies.length == 0 || flag == false){ &#x2F;&#x2F; 没有，代表是第一次访问 &#x2F;&#x2F; 获取当前时间字符串，设置cookie值发送 Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); &#x2F;&#x2F; url编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); &#x2F;&#x2F; 新建cookie对象，设置lastTime Cookie cookie = new Cookie(&quot;lastTime&quot;, str_date); &#x2F;&#x2F; 设置cookie存活时间 cookie.setMaxAge(60 * 60 * 24 * 30); &#x2F;&#x2F; 发送cookie response.addCookie(cookie); &#x2F;&#x2F; 响应数据 response.getWriter().write(&quot;&lt;h3&gt;你好，欢迎首次访问&lt;&#x2F;h3&gt;&quot;); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } 3. JSP简单入门Java Server Pages（Java服务器端页面），简称JSP。可以理解为一个特殊的页面，其中既可以定义html标签，又可以定义java代码。主要用于简化书写。 3.1 原理 JSP本质上就是一个Servlet，通过HttpJspBase来生成Servlet。 public abstract class HttpJspBase extends HttpServlet implements HttpJspPage 3.2 JSP的脚本就是JSP定义Java代码的方式 &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 &lt;!% 代码 %&gt;：定义的java代码，JSP转换后在java类的成员位置(成员变量、成员方法等) &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。 输出语句中可以定义什么，该脚本中就可以定义什么。 3.3 JSP的内置对象内置对象就是在JSP页面中不需要获取和创建，可以直接使用的对象。JSP一共有9个内置对象。今天简单学习3个。 request response out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 response.getWriter()和out.write()的区别 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据 response.getWriter()数据输出永远在out.write()的之前 4. Session 服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象(HttpSession)中。 4.1 HttpSession对象 获取HttpSession对象：HttpSession session = request.getSession(); 使用HttpSession对象，有三个常用方法 Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 4.2 原理 服务器如何确保在一次会话范围内，多次获取的Session对象是同一个？ Session的实现是依赖于Cookie的。当客户端第一次向服务器发起请求时，没有cookie。会在内存中创建一个新的Session对象，并通过响应头set-cookie将JSESSIONID=xxxxx传递给客户端，客户端保存在cookie信息中。第二次向服务器发起请求时，请求头中会携带这个JSESSIONID=xxxxx，服务器自动获取后会查找内存中是否有这个ID的session对象，能找到就说明是同一个session对象。 4.3 细节问题1. 当客户端关闭后，服务器不关闭，两次获取的session是否为同一个？ 默认情况下，不是 如果需要两次相同，可以创建Cookie，键为JSESSIONID，并设置cookie存活时间。在服务器不关闭的情况下，在存活时间内，只要是同一个cookie访问，两次获取的session对象就是同一个。 &#x2F;&#x2F; 1. 获取session HttpSession session = request.getSession(); &#x2F;&#x2F; 2. 期望客户端关闭后，session也相同 Cookie c = new Cookie(&quot;JSESSIONID&quot;, session.getId()); &#x2F;&#x2F; 手动设置sessionid为当前的session对象id c.setMaxAge(60 * 60); &#x2F;&#x2F; 设置cookie最大存活时间 response.addCookie(c); &#x2F;&#x2F; 发送cookie 2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是我们要确保数据不丢失。 session的钝化：在服务器正常关闭之前，将session对象序列化到硬盘上。 session的活化：在服务器启动后，将session文件转化为内存中的session对象即可。 3. session什么时候被销毁 服务器被关闭 session对象调用invalidate()方法 session默认失效时间是 30分钟，可以在web.xml中配置session-config 4.4 session的特点 session用于存储一次会话的多次请求的数据，存储在服务器端 session可以存储任意类型，任意大小的数据 session与cookie的区别 session存储数据在服务器端，cookie在客户端 session没有数据大小限制，cookie有限制(4kb) session数据安全，cookie相对而言不安全 5. 案例5.1 需求 访问带有验证码的登陆页面login.jsp 用户输入用户名，密码以及验证码 如果用户名和密码输入错误，跳转登陆页面，提示：用户名或密码错误 如果验证码输入有误，跳转登陆页面，提示：验证码错误 如果全部输入正确，则跳转主页success.jsp，显示：用户名，欢迎你 5.2 分析 5.3 代码实现 登陆的Servlet @WebServlet(&quot;&#x2F;loginServlet&quot;) public class LoginServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 设置request编码 request.setCharacterEncoding(&quot;utf-8&quot;); &#x2F;&#x2F; 2. 获取参数 &#x2F;&#x2F; todo：改进，获取参数Map,封装进User对象 Map&lt;String, String[]&gt; map = request.getParameterMap(); User loginUser = new User(); try { BeanUtils.populate(loginUser,map); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } &#x2F;&#x2F; 获取用户输入的验证码 String checkCode = request.getParameter(&quot;checkCode&quot;); &#x2F;&#x2F; 3. 获取生成的验证码 HttpSession session = request.getSession(); String checkCode_session = (String) session.getAttribute(&quot;checkCode_session&quot;); &#x2F;&#x2F; 3.1 删除session中存储的验证码 session.removeAttribute(&quot;checkCode_session&quot;); &#x2F;&#x2F; 4. 判断验证码是否正确 if (checkCode_session != null &amp;&amp; checkCode_session.equalsIgnoreCase(checkCode)){&#x2F;&#x2F; 忽略大小写比较 &#x2F;&#x2F; 验证码正确，调用UserDao的login方法进行登陆操作 UserDao dao = new UserDao(); User user = dao.login(loginUser); &#x2F;&#x2F; 判断用户名是否成功登陆 if (user != null ){ &#x2F;&#x2F; todo: 需要调用UserDao查询数据库，进行数据对比 &#x2F;&#x2F; 登陆成功 &#x2F;&#x2F; 存储用户信息 session.setAttribute(&quot;User&quot;,user.getUsername()); &#x2F;&#x2F; 重定向到success.jsp response.sendRedirect(request.getContextPath() + &quot;&#x2F;success.jsp&quot;); }else { &#x2F;&#x2F; 登陆失败 &#x2F;&#x2F; 存储信息到request request.setAttribute(&quot;login_error&quot;,&quot;用户名或密码错误！&quot;); &#x2F;&#x2F; 转发到登陆页面 request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,response); } }else { &#x2F;&#x2F; 验证码不一致 &#x2F;&#x2F; 存储信息到request request.setAttribute(&quot;cc_error&quot;,&quot;验证码错误！&quot;); &#x2F;&#x2F; 转发到登陆页面 request.getRequestDispatcher(&quot;&#x2F;login.jsp&quot;).forward(request,response); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } 登陆的前端页面 &lt;%@ page contentType=&quot;text&#x2F;html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Login&lt;&#x2F;title&gt; &lt;script&gt; window.onload = function () { document.getElementById(&quot;img&quot;).onclick = function () { this.src = &quot;&#x2F;Demo6_14&#x2F;checkCodeServlet?time=&quot; + new Date().getTime(); } } &lt;&#x2F;script&gt; &lt;style&gt; div{ color: red; } &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;form action=&quot;&#x2F;Demo6_14&#x2F;loginServlet&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;&#x2F;td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;&#x2F;td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;&#x2F;td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;checkCode&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;img src=&quot;&#x2F;Demo6_14&#x2F;checkCodeServlet&quot; id=&quot;img&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;form&gt; &lt;div&gt;&lt;%= request.getAttribute(&quot;cc_error&quot;) == null ? &quot;&quot; : request.getAttribute(&quot;cc_error&quot;) %&gt;&lt;&#x2F;div&gt; &lt;div&gt;&lt;%= request.getAttribute(&quot;login_error&quot;) == null ? &quot;&quot; : request.getAttribute(&quot;login_error&quot;) %&gt;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; Dao类 &#x2F;&#x2F; 操作数据库中User表的类，主要查询数据 public class UserDao { &#x2F;&#x2F; 声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); &#x2F;&#x2F; 登陆方法 public User login(User loginUser){ try{ String sql = &quot;select * from user where username = ? and password = ?&quot;; User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; }catch (DataAccessException e){ &#x2F;&#x2F; 登陆失败，打印异常，返回null e.printStackTrace(); return null; } } } 验证码生成类在上一篇文章","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"Cookie","slug":"Cookie","permalink":"https://zero024.cn/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://zero024.cn/tags/Session/"}]},{"title":"HTTP协议和Response","slug":"JavaWeb/HTTP和Response对象","date":"2019-06-13T15:59:00.000Z","updated":"2020-03-08T00:51:12.887Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. HTTP协议HTTP协议分为请求消息和响应消息两部分。请求消息是客户端发送给服务器端的数据，数据格式由请求行、请求头、请求空行、请求体4部分组成。下面讲解响应消息格式。","text":"1. HTTP协议HTTP协议分为请求消息和响应消息两部分。请求消息是客户端发送给服务器端的数据，数据格式由请求行、请求头、请求空行、请求体4部分组成。下面讲解响应消息格式。 1.1 响应消息响应消息是服务器端发送给客户端的数据，具体数据格式如下4部分。 1.1.1 响应行 格式：HTTP/1.1(协议/版本) 200(响应状态码) OK(状态码描述) 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态，状态码都是3位数字，具体分类如下。 1xx：服务器接收客户端消息，但没有接收完毕，等待一段时间后，服务器会发送1xx状态码询问客户端是否还要继续发送数据。比较特殊的情况，了解即可。 2xx：成功。例：200表示成功 3xx：重定向。例：302(重定向)，304(访问缓存) 4xx：客户端错误。例：404(请求路径没有对应的资源或没权限访问)，405(请求方式没有对应的doXxx方法) 5xx：服务器端错误。例：500(服务器内部出现异常) 1.1.2 响应头 格式：头名称：值 常见响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据。默认值in-line：在当前页面内打开。attachment;filename=xxx：以附件形式打开响应体(用于文件下载)。 1.1.3 响应空行1.1.4 响应体就是传输的数据。 响应字符串格式 HTTP&#x2F;1.1 200 OK &lt;-----响应行 Content-Type: text&#x2F;html;charset=UTF-8 &lt;-----响应头 Content-Length: 90 Date: Thu, 13 Jun 2019 10:01:19 GMT &lt;-----响应空行 &lt;html&gt; &lt;-----响应体 &lt;head&gt; &lt;title&gt;$Title$&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; hello,response &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 2. Response对象主要功能是设置响应消息 2.1 设置响应行 设置状态码：setStatus(int sc) 2.2 设置响应头 设置响应头：setHeader(String name,String value) 2.3 设置响应体数据使用步骤有以下两步 2.3.1 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputSteam() 2.3.2 使用输出流将数据输出到客户端浏览器 2.4 小案例2.4.1 完成重定向 重定向：资源的跳转方式 代码实现 &#x2F;&#x2F; 1. 设置状态码为302 response.setStatus(302); &#x2F;&#x2F; 2. 设置响应头location response.setHeader(&quot;location&quot;,&quot;&#x2F;Demo6_13&#x2F;responseDemo2&quot;); &#x2F;&#x2F; 简单的重定向方法 response.sendRedirect(&quot;&#x2F;Demo6_13&#x2F;responseDemo2&quot;); 重定向(redirect)的特点 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。所以不能使用request对象来共享数据 转发(forward)的特点 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求。故可以使用request对象来共享数据 路径的写法分类 相对路径：通过相对路径不可以确定唯一资源 例：./index.html。不以/开头，而是以.开头的路径 规则：找到当前资源和目标资源之间的相对位置关系。例：./表示当前目录，../表示上一级目录。 绝对路径：通过绝对路径可以确定唯一资源 例：http://localhost/Demo6_13/responseDemo2或/Demo6_13/responseDemo2。这种以/开头的路径 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出。给客户端浏览器使用需要加虚拟目录(项目的访问路径)，给服务器使用不需要加虚拟目录。 虚拟目录建议使用request.getContextPath()来动态获取 2.4.2 服务器输出字符数据到浏览器先获取字符输出流，再输出数据。 &#x2F;&#x2F; 3.1 获取流对象之前，将流的默认编码ISO-8859-1设置为utf-8 response.setCharacterEncoding(&quot;utf-8&quot;); &#x2F;&#x2F; 3.2 告诉浏览器服务器发送的消息体数据的编码，建议浏览器使用该编码来解码 response.setHeader(&quot;Content-type&quot;,&quot;text&#x2F;html;charset=utf-8&quot;); &#x2F;&#x2F; 3.3 可以使用简化的形式，设置编码 response.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;); &#x2F;&#x2F; Notice: 3.1步骤可以省略，推荐使用3.3方法 &#x2F;&#x2F; 1. 获取字符输出流 PrintWriter pw = response.getWriter(); &#x2F;&#x2F; 2. 输出数据 pw.write(&quot;&lt;h1&gt;hello response&lt;&#x2F;h1&gt;&quot;); &#x2F;&#x2F; 3. 解决中文乱码问题 pw.write(&quot;你好，response&quot;); &#x2F;* 乱码原因是：PrintWriter pw = response.getWriter(); 获取的流默认编码是ISO-8859-1 故需在获取流之前，设置该流的默认编码，或者直接告诉浏览器响应体使用的编码，推荐其解码方式。 *&#x2F; 2.4.3 服务器输出字节数据到浏览器获取字节输出流输出数据，一般用于获取图片字节数据然后输出到浏览器显示图片 &#x2F;&#x2F; 1. 获取字节输出流 ServletOutputStream sos = response.getOutputStream(); &#x2F;&#x2F; 2. 输出数据 sos.write(&quot;你好&quot;.getBytes()); sos.write(&quot;hello&quot;.getBytes()); 2.4.4 验证码本质就是一张图片，主要作用是防止恶意表单注册 @WebServlet(&quot;&#x2F;checkCodeServlet&quot;) public class CheckCodeServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 创建一个对象，在内存中画图片(验证码图片对象) int width = 100; int height = 50; BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); &#x2F;&#x2F; 2. 美化图片 &#x2F;&#x2F; 2.1 填充背景色 Graphics g = image.getGraphics(); &#x2F;&#x2F; 获取画笔对象 g.setColor(Color.PINK); &#x2F;&#x2F; 设置画笔颜色 g.fillRect(0,0,width,height); &#x2F;&#x2F; 填充颜色 &#x2F;&#x2F; 2.2 画边框 g.setColor(Color.blue); g.drawRect(0,0,width-1, height-1); &#x2F;&#x2F; 2.3 写验证码 String str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;; &#x2F;&#x2F; 2.3.1 生产随机角标 Random ran = new Random(); for (int i = 1; i &lt;= 4; i++) { int index = ran.nextInt(str.length()); &#x2F;&#x2F; 2.3.2 获取字符 char ch = str.charAt(index); g.drawString(ch+&quot;&quot; ,width&#x2F;5*i,height&#x2F;2); } &#x2F;&#x2F; 2.4 画干扰线 g.setColor(Color.GREEN); for (int i = 0; i &lt; 10; i++) { &#x2F;&#x2F; 2.4.1 随机生产坐标点 int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); &#x2F;&#x2F; 根据坐标点画线 g.drawLine(x1,y1,x2,y2); } &#x2F;&#x2F; 3. 将图片输出到页面展示 ImageIO.write(image,&quot;jpg&quot;,response.getOutputStream()); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 在网页中使用验证码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;验证码&lt;&#x2F;title&gt; &lt;script&gt; &#x2F;&#x2F; 1.给超链接和图片绑定单击事件 &#x2F;&#x2F; 2. 重新设置图片的src属性值 window.onload = function () { &#x2F;&#x2F; 1. 获取图片对象 var img = document.getElementById(&quot;checkCode&quot;); &#x2F;&#x2F; 2. 创建单击事件 changeimg = function () { &#x2F;&#x2F; 获取时间戳 var date = new Date().getTime(); img.src = &quot;&#x2F;Demo6_13&#x2F;checkCodeServlet?&quot;+date; } &#x2F;&#x2F; 3. 绑定单击事件 img.onclick = changeimg; document.getElementById(&quot;change&quot;).onclick = changeimg; } &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;img src=&quot;&#x2F;Demo6_13&#x2F;checkCodeServlet&quot; id=&quot;checkCode&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;change&quot; &gt;看不清？换一张&lt;&#x2F;a&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 3. ServletContext对象这个对象代表整个Web应用，可以和程序的容器(服务器)来进行通信 3.1 获取 通过request对象获取：request.getServletContext(); 通过HttpServlet获取：this.getServletContext(); 3.2 功能3.2.1 获取MIME类型 MIME类型：在互联网通信过程中定义的一种文件数据类型，存储在服务器的web.xml文件中 格式：大类型/小类型，例：text/html，image/jpeg 获取方法：String getMimeType(String file) 3.2.2 域对象：共享数据常用方法如下： setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) ServletContext对象范围：所有用户所有请求的数据 3.2.3 获取文件的真实(服务器)路径 String getRealPath(String path) &#x2F;&#x2F; 获取文件的服务器路径 String c = context.getRealPath(&quot;&#x2F;c.txt&quot;); &#x2F;&#x2F; web目录下的资源访问 String b = context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;b.txt&quot;); &#x2F;&#x2F; WEB-INF目录下的资源访问 String a = context.getRealPath(&quot;&#x2F;WEB-INF&#x2F;classes&#x2F;a.txt&quot;); &#x2F;&#x2F; src目录下的资源访问 4. 综合案例：文件下载4. 1 案例需求 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载 4.2 分析 浏览器默认超链接指向的资源如果能够被解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求！ 任何资源都必须弹出下载提示框 使用响应头设置资源的打开方式：content-disposition:attachment;filename=xxx 4.3 步骤 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 定义Servlet 获取文件名称 使用字节输入流加载文件进内存 指定response的响应头：content-disposition:attachment;filename=xxx 将数据写出到response输出流，返回给客户端 4.2 代码实现downloadServlet代码，主要实现文件的输入输出 @WebServlet(&quot;&#x2F;downloadServlet&quot;) public class DownloadServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F; 1. 获取请求参数，文件名称 String filename = request.getParameter(&quot;filename&quot;); &#x2F;&#x2F; 2. 使用字节输入流加载文件进内存 &#x2F;&#x2F; 2.1 找到文件服务器路径 ServletContext context = this.getServletContext(); String realPath = context.getRealPath(&quot;&#x2F;img&#x2F;&quot; + filename); &#x2F;&#x2F; 2.2 用字节流关联文件对象 FileInputStream fis = new FileInputStream(realPath); &#x2F;&#x2F; 3. 设置response响应头 &#x2F;&#x2F; 3.1 设置响应头类型 String mimeType = context.getMimeType(filename); &#x2F;&#x2F; 获取文件的mime类型 response.setHeader(&quot;content-type&quot;,mimeType); &#x2F;&#x2F; 3.2 解决中文文件名问题 &#x2F;&#x2F; 3.2.1 获取user-agent请求头 String agent = request.getHeader(&quot;user-agent&quot;); &#x2F;&#x2F; 3.2.2 使用工具类方法编码文件名 filename = DownLoadUtils.getFileName(agent, filename); response.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot;+filename); &#x2F;&#x2F; 4. 将输入流的数据写出到输出流中，将文件输出到浏览器中 ServletOutputStream sos = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; int len = 0; while ((len = fis.read(buff)) != -1){ sos.write(buff,0,len); } fis.close(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 前端html页面，提供了文件下载的超链接 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;下载文件&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h2&gt;文件下载&lt;&#x2F;h2&gt; &lt;br&gt; &lt;a href=&quot;&#x2F;Demo6_13&#x2F;downloadServlet?filename=九尾.jpg&quot;&gt;九尾&lt;&#x2F;a&gt; &lt;a href=&quot;&#x2F;Demo6_13&#x2F;downloadServlet?filename=2.jpg&quot;&gt;图片2&lt;&#x2F;a&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; DownLoadUtils工具类，主要功能获取客户端的浏览器版本信息，然后根据不同的版本信息，设置filename的编码方式 public class DownLoadUtils { public static String getFileName(String agent, String filename) throws UnsupportedEncodingException { if (agent.contains(&quot;MSIE&quot;)) { &#x2F;&#x2F; IE浏览器 filename = URLEncoder.encode(filename, &quot;utf-8&quot;); filename = filename.replace(&quot;+&quot;, &quot; &quot;); } else if (agent.contains(&quot;Firefox&quot;)) { &#x2F;&#x2F; 火狐浏览器 BASE64Encoder base64Encoder = new BASE64Encoder(); filename = &quot;=?utf-8?B?&quot; + base64Encoder.encode(filename.getBytes(&quot;utf-8&quot;)) + &quot;?=&quot;; } else { &#x2F;&#x2F; 其它浏览器 filename = URLEncoder.encode(filename, &quot;utf-8&quot;); } return filename; } public static void getFileName(String agent) { } }","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[]},{"title":"HTTP协议和Request对象","slug":"JavaWeb/HTTP协议和Request对象","date":"2019-06-10T15:59:00.000Z","updated":"2020-01-03T11:43:19.592Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. HTTP协议1.1 基本概念HTTP协议：超文本传输协议(Hyper Text Transfer Protocol) 传输协议：定义了客户端和服务器端通信时，发送数据的格式，特点如下： 基于TCP/IP的高级协议 默认端口号：80 基于请求/响应模型的：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据","text":"1. HTTP协议1.1 基本概念HTTP协议：超文本传输协议(Hyper Text Transfer Protocol) 传输协议：定义了客户端和服务器端通信时，发送数据的格式，特点如下： 基于TCP/IP的高级协议 默认端口号：80 基于请求/响应模型的：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 1.2 请求消息数据格式1.2.1 请求行POST(请求方式) /login.html(请求URL) HTTP/1.1(请求协议/版本) HTTP协议有7种请求方式，常用的有2种 GET：请求参数在请求行中，在URL后；请求的URL长度是有限制的；且不太安全。 POST：请求参数在请求体中；请求的URL长度没有限制；相对安全。 1.2.2 请求头客户端浏览器告诉服务器一些信息 常见请求头： User-Agent：浏览器告诉服务器，我们访问你使用的浏览器版本信息；可以在服务器端获取该头的信息，解决浏览器兼容性问题 Referer: http://192.168.1.6/login.html，告诉服务器，我(当前请求)从哪里来？一般用于防盗链和统计工作。 1.2.3 请求空行空行，就是用于分隔POST请求的请求头和请求体的 1.2.4 请求体(正文)封装POST请求消息的请求参数的 请求消息字符串格式： POST &#x2F;login.html HTTP&#x2F;1.1 Host: 192.168.1.6 User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0 Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q=0.9,*&#x2F;*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http:&#x2F;&#x2F;192.168.1.6&#x2F;login.html Content-Type: application&#x2F;x-www-form-urlencoded Content-Length: 10 Connection: keep-alive Upgrade-Insecure-Requests: 1 uname=aaaa 2. Request2.1 request对象和response对象的原理 request和response对象是由服务器创建的，我们来使用它们。 request对象是来获取请求消息的，response对象是来设置响应消息的。 插入原理图解 2.2 request对象继承体系结构 ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(Tomcat实现的类) 2.3 request的功能2.3.1 获取请求消息数据2.3.1.1 获取请求行数据 请求行：GET /reqdemo/demo1?name=zero HTTP/1.1 方法： 获取请求方式(GET)：String getMethod() 获取虚拟目录(/reqdemo)：String getContextPath() 获取Servlet路径(/demo1)：String getServletPath() 获取get方式请求参数(name=zero):String getQueryString() 获取请求URI(/reqdemo/demo1)：String getRequestURI() 获取请求URL(http://localhost/reqdemo/demo1)：String getRequestURL() 获取协议及版本号(HTTP/1.1)：String getProtocol() 获取客户端的IP地址：String getRemoteAddr() URI：统一资源标识符 2.3.1.2 获取请求头数据主要方法： String getHeader(String name)：通过请求头的名称获取请求头的值，常用。 Enumeration&lt;String&gt; getHeaderNames()：获取所有的请求头名称；返回值是一个枚举类，可以当做迭代器使用。 2.3.1.3 获取请求体数据只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 1.获取流对象 BufferedReader getReader() ：获取字符输入流，只能操作字符数据。 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 2.从流对象中拿数据 2.3.2 其他功能2.3.2.1 获取请求参数通用方式不论是get还是post请求方式，都可以使用下列方法来获取请求参数 String getParameter(String name)：根据参数名称获取参数值 String[] getParameterValues(String name)：根据参数名称获取参数值的数组，一般用于复选框 Enumeration&lt;String&gt; getParameterNames()：获取所有请求从参数名称 Map&lt;String,String[]&gt; getParameterMap()：获取所有参数的map集合 中文乱码问题：Tomcat8已解决get方式乱码问题，但post方式还是会乱码。需要在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); 2.3.2.2 请求转发一种在服务器内部的资源跳转方式 使用步骤： 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path); 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 特点： 浏览器地址栏路径不会发生变化 只能转发到当前服务器内部资源中 转发是一次请求 2.3.2.3 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name, Object obj)：存储数据(键值对形式)。 Object getAttibute(String name)：通过键获取值 void removeAttribute(String name)：通过键移除键值对 2.2.2.4 获取ServletContextServletContext getServletContext() 3. 综合案例：用户登录3.1 需求 编写login.html登录页面，有用户名和密码两个输入框 使用Druid数据库连接池技术，操作mysql 使用JdbcTemplate技术封装JDBC 登录成功跳转SuccessServlet展示：登录成功！用户名，欢迎你 登录失败跳转FailServlet展示：登录失败，用户名或密码错误。 3.2 开发步骤 创建项目，导入html页面、配置文件、jar包。 创建数据库环境，创建user表 创建包domain，创建类User &#x2F;&#x2F; 用户实体类 public class User{ private int id; private String username; private String password; &#x2F;&#x2F; 生成get&#x2F;set方法 ... &#x2F;&#x2F; 生成toString方法 ... } 创建util包，编写工具类JDBCUtils &#x2F;&#x2F; JDBC工具类，使用Druid连接池 public class JDBCUtils{ private static DataSource ds = null; static{ &#x2F;&#x2F; 使用静态代码块来加载配置文件等内容 try{ &#x2F;&#x2F; 1. 加载配置文件 Properties pro = new Properties(); &#x2F;&#x2F; 1.1 使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); &#x2F;&#x2F; 2. 使用Druid连接池技术，初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); }catch(IOException e){ e.printStackTrace(); }catch(Exception e){ e.printStackTrace(); } } &#x2F;&#x2F; 获取连接池对象 public static DataSource getDataSource(){ return ds; } &#x2F;&#x2F; 获取连接Connection对象 public static Connection getConnection() throws SQLException{ return ds.getConnection(); } } 创建dao包，创建类UserDao，提供login方法 &#x2F;&#x2F; 操作数据库中User表的类 public class UserDao{ &#x2F;&#x2F; 声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); &#x2F;&#x2F; 定义登录方法 public User login(User loginUser){ try{ &#x2F;&#x2F; 1. 编写sql String sql = &quot;select * form user where username = ? and password = ?&quot;; &#x2F;&#x2F; 2. 调用query方法,查询数据 User user = template.queryForObject(sql, new BeanPropertyRowMaper&lt;User&gt;(User.class), loginUser.getUsername(),loginUser.getPassword()); return user; &#x2F;&#x2F; 返回查询到的数据对象 }catch{DataAccessException e}{ e.printStackTrace(); &#x2F;&#x2F; 一般做记录日志文件处理 return null; } } } 编写Servelt.LoginServlet类 &#x2F;&#x2F; 主要Servlet类,负责处理登录验证操作，登录成功失败后的转发操作 @WebServlet(&quot;&#x2F;loginServlet&quot;) &#x2F;&#x2F; 设置资源路径 public class LoginServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{ &#x2F;&#x2F; 1. 设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); &#x2F;&#x2F; 2. 获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); &#x2F;&#x2F; 3. 将数据封装成user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); &#x2F;&#x2F; 4. 调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); &#x2F;&#x2F; 进行用户数据验证，返回一个User对象的完整数据 &#x2F;&#x2F; 5. 判断是否正常登录 if(user == null){ &#x2F;&#x2F; 登录失败，转发向失败页面 req.getRequestDispatcher(&quot;&#x2F;failServlet&quot;).forward(req,resp); }else{ &#x2F;&#x2F; 登录成功，跳转成功页面 &#x2F;&#x2F; 将user对象放入request域中 req.setAttribute(&quot;user&quot;,user); &#x2F;&#x2F; 转发 req.getRequestDispatcher(&quot;&#x2F;successServlet&quot;).forward(req,resp); } } @Override protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{ this.doGet(req,resp); } } 编写FailServlet和SuccessServlet类 &#x2F;&#x2F; 失败处理页面,直接返回一句话 @WebServlet(&quot;&#x2F;failServlet&quot;) public class FailServlet extends HttpServlet{ protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{ &#x2F;&#x2F; 设置编码 resp.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;); &#x2F;&#x2F; 输出 resp.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); } protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{ this.doPost(req,resp); } } &#x2F;&#x2F; 成功页面 @WebServlet(&quot;&#x2F;successServlet&quot;) public class SuccessServlet extends HttpServlet{ protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{ &#x2F;&#x2F; 获取request域中共享的user对象 User user = (User)request.getAttibute(&quot;user&quot;); if(user != null){ &#x2F;&#x2F; 设置编码 resp.setContentType(&quot;text&#x2F;html;charset=utf-8&quot;); &#x2F;&#x2F; 输出 resp.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;欢迎你&quot;); } } protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{ this.doPost(req,resp); } } 将login.html中form表单的action路径设置为虚拟目录+Servlet的资源路径 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录页面&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;form action=&quot;&#x2F;LoginDemo&#x2F;loginServlet&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 3.2.1 BeanUtilsapache提供的一个工具类，使用BeanUtils工具类，可以简化数据的封装，主要用于封装JavaBean JavaBean：标准的Java类，有以下要求 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 功能：封装数据 概念： 成员变量 属性： 方法 setProperty()：设置值 getProperty()：获取值 populate(Object obj, Map map)：将map集合的键值对信息，封装到对应的JavaBean对象中 3.2.2 简化LoginServlet将上述例子中的LoginServlet类中获取请求参数和封装User对象步骤进行简化 protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws Servlet Exception,IOException{ &#x2F;&#x2F; 1. 设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); &#x2F;&#x2F; 2. 获取所有请求参数 Map&lt;String, String[]&gt; map = req.getParameterMap(); &#x2F;&#x2F; 3. 创建User对象 User loginUser = new User(); &#x2F;&#x2F; 3.1 使用populate方法将数据封装进loginUser对象 try{ BeanUtils.populate(loginUser,map); }catch(Exception e){ e.printStackTrace(); } &#x2F;&#x2F; 4. 调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); &#x2F;&#x2F; 进行用户数据验证，返回一个User对象的完整数据 &#x2F;&#x2F; 5. 判断是否正常登录 if(user == null){ &#x2F;&#x2F; 登录失败，转发向失败页面 req.getRequestDispatcher(&quot;&#x2F;failServlet&quot;).forward(req,resp); }else{ &#x2F;&#x2F; 登录成功，跳转成功页面 &#x2F;&#x2F; 将user对象放入request域中 req.setAttribute(&quot;user&quot;,user); &#x2F;&#x2F; 转发 req.getRequestDispatcher(&quot;&#x2F;successServlet&quot;).forward(req,resp); } }","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://zero024.cn/tags/HTTP/"}]},{"title":"Servlet接口","slug":"JavaWeb/Servlet","date":"2019-06-09T14:30:00.000Z","updated":"2020-01-03T11:43:19.602Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. ServletJava Servlet是运行在服务器端的小程序，它是作为来自web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层","text":"1. ServletJava Servlet是运行在服务器端的小程序，它是作为来自web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层 1.1 创建Servlet有三种创建方式： 实现Servlet接口 继承GenericServlet类 继承HttpServlet方法 1.1.1 实现Servlet接口 &#x2F;* Servlet的生命周期：从Servlet被创建到Servlet被销毁的过程。 一次创建，到处服务 一个Servlet只会有一个对象，服务所有的请求 1. 实例化 (使用构造方法创建对象) 2. 初始化 执行init方法 3. 服务 执行service方法 4. 销毁 执行destroy方法 *&#x2F; @WebServlet(&quot;&#x2F;demo1&quot;) &#x2F;&#x2F; 添加注解，设置虚拟访问路径 public class ServletDemo1 implements Servlet{ &#x2F;&#x2F; 实现Servlet接口，重写其全部方法 &#x2F;&#x2F; 生命周期方法：当Servlet第一次被创建对象时执行该方法，该方法在整个生命周期中只执行一次 @Override public void init(ServletConfig servletConfig) throws ServletException{ System.out.println(&quot;====Servlet初始化了====&quot;); } &#x2F;&#x2F; 生命周期方法：对客户端响应的方法，该方法会被多次执行，每次请求该servlet都会执行该方法 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException{ System.out.println(&quot;====Servlet服务中====&quot;); } &#x2F;&#x2F; 生命周期方法： 当Servlet被销毁时执行该方法 @Override public void destroy(){ System.out.println(&quot;====Servlet销毁了====&quot;); } &#x2F;&#x2F; 当停止Tomcat时也就会销毁的Servlet @Override public ServletConfig getServletConfig(){ return null; } @Override public String getServletInfo(){ return null; } } 1.1.2 继承GenericServlet类GenericServlet类默认将Servlet接口中其他方法做了默认空实现，只将service()方法作为抽象方法，在定义Servlet类时，可以继承GenericeSerlvet类，实现service()方法即可。 public class ServletDemo2 extends GenericServlet{ @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException,IOException{ System.out.println(&quot;创建方法2&quot;) } } 1.1.3 继承HttpServlet方法HttpServlet是对HTTP协议的一种封装，简化操作 定义类继承HttpServlet 复写doGet/doPost方法 public class ServletDemo3 extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{ System.out.println(&quot;get方法执行&quot;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{ System.out.println(&quot;post方法执行&quot;); doGet(req,resp); } 1.1.4 配置Servlet在web.xml中配置 &lt;!--配置servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;servlet.ServletDemo1&lt;&#x2F;servlet-class&gt; &lt;!--全类名--&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;demo1&lt;&#x2F;url-pattern&gt; &lt;!--servlet访问路径--&gt; &lt;&#x2F;servlet-mapping&gt; urlpartten：Servlet访问路径 一个Servlet可以定义多个访问路径：@WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;}) 路径定义规则： /xxx：路径匹配 /xxx/xxx：多层路径，类似目录结构 *.do：扩展名匹配 Servlet执行原理： 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查询web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容 如果有，则在找到对应的&lt;servlet-class&gt;全类名 tomcat会将字节码文件加载进内存，并创建其对象 调用其方法 Notice：Servlet3.0以后可以使用注解配置，在类上使用@WebServlet(&quot;资源路径&quot;)，即可完成配置。 1.2 Servlet中的生命周期方法1.2.1. 被创建：执行init方法，只执行一次默认情况下，第一次被访问时，Servlet被创建。可以在xml中配置执行Servlet的创建时机。 在&lt;servlet&gt;标签下配置 初次访问时就创建：&lt;load-on-startup&gt;的值为负数 在服务器启动时就创建：&lt;load-on-startup&gt;的值为0或正整数 Server的init方法只被执行一次，故一个Servlet在内存中只存在一个对象，Servlet是单例的 多个用户同时访问时，可能存在线程安全问题 解决方式：尽量不要在Servlet中定义成员变量，即使定义了成员变量，也不要对其修改值。 1.2.2 提供服务：执行service方法，执行多次 每次访问Servlet时，service方法都会被调用一次 1.2.3 被销毁：执行destroy方法，只执行一次 Servlet被销毁时执行。服务器关闭时，Servlet被销毁。 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[]},{"title":"Tomcat服务器","slug":"JavaWeb/Tomcat","date":"2019-06-08T14:50:00.000Z","updated":"2020-01-03T11:43:19.603Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. Web服务器软件 安装了服务器软件的计算机就是服务器 服务器软件：接收用户的请求，处理请求，返回响应 Web服务器软件：接收用户的请求，处理请求，做出响应。在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目","text":"1. Web服务器软件 安装了服务器软件的计算机就是服务器 服务器软件：接收用户的请求，处理请求，返回响应 Web服务器软件：接收用户的请求，处理请求，做出响应。在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 1.1 常见的Java相关的Web服务器软件 WebLogic：Oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 WebSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOOS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范Servlet/jsp。开源免费的 Tips：JavaEE是Java语言在企业开发中使用的技术规范的总和，一共规定了13项大的规范。 1.2 Tomcat1.2.1 下载 前往Tomcat官网下载安装版：Windows Service Installer，也可以下载解压版。 1.2.2 安装 安装版点击安装即可，软件会自动注册服务 解压版解压即可使用 Tomcat目录结构： Notice：注意，安装或解压的路径不要有中文 1.2.3 卸载 安装版进入文件夹点击Uninstall.exe即可卸载软件 解压版直接删除文件夹即可 1.2.4 启动安装版会自动注册并启动服务，无需手动启动 解压版启动方式： 进入解压后的文件夹，进入bin目录，双击startup.bat运行该文件 访问：浏览器输入：http://localhost:8080 即可本地访问 1.2.5 关闭解压版关闭 bin/shutdows.bat，双击即可关闭服务 直接关闭窗口或者ctrl+c 根据进程PID关闭 cmd输入netstat -ano，打印当前运行进程PID等信息，找到本地地址端口号8080的，查看其PID。 打开任务管理器，进程显示PID，然后根据PID号直接结束进程。 Tips: windows下删除服务命令：sc delete 服务名称 安装参考文章 1.2.6 配置项目部署的方式 直接将项目文件夹放在webapps目录下即可，也可将项目打包成一个war包，再将war包放入wabapps目录下，war包会自动解压。 配置conf/server.xml文件完成部署，在&lt;Host&gt;标签体中配置：&lt;Context docBase=&quot;D:\\Project&quot; path=&quot;/index&quot; /&gt;；docBase：项目存放的本地路径，path：虚拟目录。 在conf\\Catalina\\localhost\\下创建任意名称(文件名称即虚拟路径)的xml文件。在文件中编写&lt;Context docBase=&quot;D:\\Project /&gt;&quot; 静态项目和动态项目 Java动态项目目录结构： -- 项目名称 -- WEB-INF -- web.xml：该项目的核心配置文件 -- classes目录：放置字节码文件 -- lib目录：放置项目依赖的jar包","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[]},{"title":"XML简单入门","slug":"JavaWeb/XML简述","date":"2019-06-07T12:30:00.000Z","updated":"2020-01-03T11:43:19.604Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. XML基础1.1 概念XML指可扩展标记语言(Extensible Markup Language)，是一种标记语言，类似HTML。xml被设计用于传输和存储数据，而不是显示数据，标签都是自定义的。","text":"1. XML基础1.1 概念XML指可扩展标记语言(Extensible Markup Language)，是一种标记语言，类似HTML。xml被设计用于传输和存储数据，而不是显示数据，标签都是自定义的。 1.2 功能 存储数据：项目配置文件 传输数据：在网络中传输 1.3 xml与html的区别 xml标签都是自定义的，html标签是预定义 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 W3C：万维网联盟，是Web技术领域最具权威和影响力的国际中立性技术标准机构 2. 语法2.1 基本语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明：&lt;?xml version=&#39;1.0&#39; ?&gt; xml文档中有且仅有一个根标签 属性值必须使用引号引起来 标签必须正确关闭 xml标签名称区分大小写 2.1.1 快速入门 &lt;?xml version=&#39;1.0&#39; ?&gt; &lt;users&gt; &lt;user id=&quot;1&quot;&gt; &lt;name&gt;张三&lt;&#x2F;name&gt; &lt;age&gt;20&lt;&#x2F;age&gt; &lt;gender&gt;男&lt;&#x2F;gender&gt; &lt;&#x2F;user&gt; &lt;user id=&quot;2&quot;&gt; &lt;name&gt;李四&lt;&#x2F;name&gt; &lt;age&gt;21&lt;&#x2F;age&gt; &lt;gender&gt;男&lt;&#x2F;gender&gt; &lt;&#x2F;user&gt; &lt;&#x2F;users&gt; 2.2 组成部分2.2.1 文档声明 格式：&lt;?xml 属性列表 ?&gt; 属性列表： version：版本号。必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值ISO-8859-1 standalone：是否独立。yes表示不依赖其他文件，no表示依赖其他文件 2.2.2 指令(了解即可)可以结合css样式，解析页面，需加入声明：&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;style.css&quot; ?&gt; 2.2.3 标签标签名称都是自定义的，不过有以下几点规则： 名称可以包含字母、数字及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母xml(或者XML、XmL等等)开始 名称不能包含空格 2.2.4 属性id属性值唯一 2.2.5 文本 CDATA区：在该区域中的数据会被原样展示，格式：&lt;![CDATA[ 数据]]&gt; 2.3 约束规定xml文档的书写规则，作为框架的使用者，我们只要能够在xml中引入约束文档，并能简单的读懂约束文档即可。 2.3.1 分类 DTO：一种简单的约束技术 Schema：一种复杂的约束技术 2.3.2 DTD引入dtd文档到xml文档中 内部dtd：将约束规则直接定义在xml文档中 外部dtd：将约束规则定义在外部的dtd文件中 引入本地dtd文档：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件位置&quot; 引入网络dtd文档：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名&quot; &quot;dtd文件URL&quot; 2.3.3 Schema引入 填写xml文档的根元素 引入xsi前缀：xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间：xsi:schemaLocation=&quot;http://www.zero.cn/xml student.xsd&quot; 为每一个xsd约束声明一个前缀，作为标识：xmlns:z1=&quot;http://www.zero.cn/xml&quot; 3. 解析操作xml文档，将文档中的数据读取到内存中 3.1 主要操作 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化存储 3.2 解析xml的方式 DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动的。 优点：不占内存 缺点：只能读取，不能增删改 3.3 xml常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：一款Java的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于JQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式。 3.4 Jsoup解析器使用步骤： 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 3.4.1 代码示例 public class DemoJsoup01 { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 1.获取Document对象，根据xml文档获取 &#x2F;&#x2F; 1.1 获取users.xml的path String path = DemoJsoup01.class.getClassLoader().getResource(&quot;Demo6_7&#x2F;users.xml&quot;).getPath(); &#x2F;&#x2F; 1.2 解析xml文档，加载文档进内存，获取dom树---&gt; Document Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); &#x2F;&#x2F; 2. 获取所有name元素对象 Elements elements = document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); &#x2F;&#x2F; 2 &#x2F;&#x2F; 2.1 获取第一个name的element对象 Element element = elements.get(0); String name = element.text(); System.out.println(name); } } 3.4.2 对象的使用 Jsoup：工具类，可以解析html或xml文档，返回document 主要方法：parse，解析html和xml文档，返回document parse(File in, String charsetName)：解析xml或html文件的，最常用方法。 parse(String html)：解析xml或html字符串 parse(URL url,int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象。 Document：文档对象。代表内存中的dom树 获取Element对象常用方法 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 代码示例： public class DemoJsoup02 { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 1. 获取users.xml的path String path = DemoJsoup02.class.getClassLoader().getResource(&quot;Demo6_7&#x2F;users.xml&quot;).getPath(); &#x2F;&#x2F; 1.1 解析xml文档，加载文档进内存，获取dom树 Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); &#x2F;&#x2F; 2. 获取所有的user元素对象 Elements users = document.getElementsByTag(&quot;user&quot;); System.out.println(users); System.out.println(&quot;----------------------------&quot;); &#x2F;&#x2F; 3.获取属性名为id的元素对象们 Elements ids = document.getElementsByAttribute(&quot;id&quot;); System.out.println(ids); System.out.println(&quot;----------------------------&quot;); &#x2F;&#x2F; 4. 获取uid属性值为1的元素对象们 Elements uid = document.getElementsByAttributeValue(&quot;uid&quot;, &quot;1&quot;); System.out.println(uid); System.out.println(&quot;----------------------------&quot;); &#x2F;&#x2F; 5. 获取id属性值为“z1”的元素对象 Element z1 = document.getElementById(&quot;z1&quot;); System.out.println(z1); } } Elements：元素Element对象的集合。可以当做ArrayList&lt;Element&gt;来使用 Element：元素对象 获取子元素对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text()：获取文本内容 String html()：获取标签体的所有内容(包括子标签的字符串内容) 代码示例: public class DemoJsoup03 { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 1. 获取student.xml的path String path = DemoJsoup03.class.getClassLoader().getResource(&quot;Demo6_7&#x2F;users.xml&quot;).getPath(); &#x2F;&#x2F; 1.1 解析xml文档，加载文档进内存，获取dom树---&gt; Document Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); &#x2F;&#x2F; 2. 获取第一个user元素对象 Element user = document.getElementsByTag(&quot;user&quot;).get(0); &#x2F;&#x2F; 2.1 根据元素对象获取下面的子元素name Elements name = user.getElementsByTag(&quot;name&quot;); &#x2F;&#x2F; 2.2 根据属性名称获取属性值 String id = name.attr(&quot;id&quot;); System.out.println(id); &#x2F;&#x2F; z1 &#x2F;&#x2F; 2.3 获取name元素的文本内容 System.out.println(name.text()); &#x2F;&#x2F; 张三 &#x2F;&#x2F; 2.4 获取第一个user元素对象下面的所有标签体内容 System.out.println(user.html()); } } Node：节点对象 是Document和Element的父类 3.4.3 快捷查询方式 selector：选择器 Elements select(String cssQuery)：语法类似CSS的元素选择器，具体使用参考Selector类中定义的语法 public class DemoJsoup04 { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 1. 获取student.xml的path String path = DemoJsoup04.class.getClassLoader().getResource(&quot;Demo6_7&#x2F;users.xml&quot;).getPath(); &#x2F;&#x2F; 2. 解析xml文档，加载文档进内存，获取dom树 Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); &#x2F;&#x2F; 3. 查询name标签 Elements names = document.select(&quot;name&quot;); System.out.println(names); &#x2F;&#x2F; 4. 查询id值为“z1”的元素 Elements ids = document.select(&quot;#z1&quot;); System.out.println(ids); &#x2F;&#x2F; 5. 获取user标签且uid属性值为1的age子标签 Elements age = document.select(&quot;user[uid=&#39;1&#39;] &gt; age&quot;); System.out.println(age); } } XPath： XPath即为XML路径语言，它是一种用来确定XML(标准通用标记语言的子集)文档中某部分位置的语言 使用Jsoup的Xpath需额外导入jar包 Xpath使用语法查询w3cshool的参考手册 代码示例： public class DemoJsoup05 { public static void main(String[] args) throws IOException, XpathSyntaxErrorException { &#x2F;&#x2F; 1. 获取student.xml的path String path = DemoJsoup05.class.getClassLoader().getResource(&quot;Demo6_7&#x2F;users.xml&quot;).getPath(); &#x2F;&#x2F; 2. 解析xml文档，加载文档进内存，获取dom树 Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); &#x2F;&#x2F; 3. 根据document，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); &#x2F;&#x2F; 4. 结合xpath语法查询 &#x2F;&#x2F; 4.1 查询所有的user标签 List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;&#x2F;&#x2F;user&quot;); for (JXNode jxNode : jxNodes) { System.out.println(jxNode); } &#x2F;&#x2F; 4.2 所有user标签下的name标签 List&lt;JXNode&gt; jxNames = jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name&quot;); for (JXNode jxName : jxNames) { System.out.println(jxName); } &#x2F;&#x2F; 4.3 查询user标签下带有id属性的name标签 List&lt;JXNode&gt; jxId = jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name[@id]&quot;); for (JXNode jxNode : jxId) { System.out.println(jxNode); } &#x2F;&#x2F; 4.4 查询user标签下id属性值为“z1”的name标签 List&lt;JXNode&gt; jxIdisz1 = jxDocument.selN(&quot;&#x2F;&#x2F;user&#x2F;name[@id=&#39;z1&#39;]&quot;); for (JXNode jxNode : jxIdisz1) { System.out.println(jxNode); } } }","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[]},{"title":"Bootstrap简单入门","slug":"JavaWeb/Bootstrap简单入门","date":"2019-06-06T14:30:00.000Z","updated":"2020-01-03T11:43:19.585Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. Bootstrap概述Bootstrap是一个前端开发框架，来自Twitter。Bootstrap是基于HTML、CSS、JavaScript的，它简洁灵活，使得Web开发更加快捷。","text":"1. Bootstrap概述Bootstrap是一个前端开发框架，来自Twitter。Bootstrap是基于HTML、CSS、JavaScript的，它简洁灵活，使得Web开发更加快捷。 框架：一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。 2. 快速入门2.1 Bootstrap环境安装 从https://v3.bootcss.com上下载Bootstrap的最新版本 将解压后的三个文件夹复制进项目 2.2 基本模板创建html页面，引入必要的资源文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;&#x2F;title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;css&#x2F;bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;js&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;&#x2F;h1&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 3. 响应式布局同一套页面能够兼容多个终端，不同分辨率的设备。其实现依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子。 3.1 使用步骤3.1.1 定义容器相当于之前的table，容器分类： container：固定宽度，两边留白 container-fluid：每一种设备都是100%宽度 3.1.2 定义行相当于之前的tr 3.1.3 定义元素指定该元素在不同设备上，所占的格子数目。样式：col-设备代号-格子数目 设备代号： xs：超小屏幕(手机，&lt;768px)：col-xs-12 sm：小屏幕(平板电脑，≥768px) md：中等屏幕(笔记本电脑，≥992px) lg：大屏幕(桌面显示器，≥1200px) Notice： 一行中如果格子数目超过12，则超出部分自动换行。 栅格类属性可以向上兼容。栅格类适用于屏幕宽度大于或等于分界点大小的设备。 如果真实设备宽度小于了设置栅格类属性的设备代码最小值，将会一个元素占满一整行。 4. CSS样式和JS插件4.1 全局CSS样式全局CSS样式可查阅网站 按钮：class=&quot;btn btn-default 图片： class=&quot;img-responsive&quot;：图片在任意尺寸都占100% 图片形状 &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt; :方形 &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; :圆形 &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; :相框 表格 为任意 &lt;table&gt; 标签添加 class=&quot;table&quot; 可以为其赋予基本的样式 添加 class=&quot;table-bordered&quot; 为表格和其中的每个单元格增加边框。 通过添加 class=&quot;table-hover&quot; 类可以让 &lt;tbody&gt; 中的每一行对鼠标悬停状态作出响应。 表单 给表单项添加class=&quot;form-control&quot;可以获得更好的表单显示效果 4.2 组件组件查阅网站 导航条 分页条 4.3 插件JS插件查阅 轮播图 综合案例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;综合案例_旅游网&lt;&#x2F;title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;css&#x2F;bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;js&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;style&gt; .paddtop{ padding-top: 15px; } .search-btn{ float: left; border: 1px solid #ffc900; width: 90px; height: 35px; background-color: #ffc900; text-align: center; line-height: 35px; margin-top: 15px; } .search-input{ float: left; border: 2px solid #ffc900; width: 400px; height: 35px; padding-left: 5px; margin-top: 15px; } .jingxuan{ border-bottom: 2px solid #ffc900; padding: 5px; } .company{ height: 40px; background-color: #ffc900; text-align: center; line-height: 40px; font-size: 8px; } &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!--1. 页眉部分--&gt; &lt;header class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;img src=&quot;img&#x2F;top_banner.jpg&quot; class=&quot;img-responsive&quot;&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;img src=&quot;img&#x2F;logo.jpg&quot; class=&quot;img-responsive&quot;&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;col-md-5&quot;&gt; &lt;input class=&quot;search-input&quot; type=&quot;text&quot; placeholder=&quot;请输入线路名称&quot;&gt; &lt;a class=&quot;search-btn&quot; href=&quot;#&quot;&gt;搜索&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;img src=&quot;img&#x2F;hotel_tel.png&quot; class=&quot;img-responsive&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;!--导航栏--&gt; &lt;div class=&quot;row&quot;&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;&#x2F;span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;!-- &#x2F;.navbar-collapse --&gt; &lt;&#x2F;div&gt;&lt;!-- &#x2F;.container-fluid --&gt; &lt;&#x2F;nav&gt; &lt;&#x2F;div&gt; &lt;!--轮播图--&gt; &lt;div class=&quot;row&quot;&gt; &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;!-- Indicators --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;&#x2F;li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;&#x2F;li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img src=&quot;img&#x2F;banner_1.jpg&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img&#x2F;banner_2.jpg&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img&#x2F;banner_3.jpg&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;!-- Controls --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;&#x2F;span&gt; &lt;&#x2F;a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;&#x2F;span&gt; &lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;header&gt; &lt;!--1. 主体部分--&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row jingxuan&quot;&gt; &lt;img src=&quot;img&#x2F;icon_5.jpg&quot; alt=&quot;&quot;&gt; &lt;span&gt;旅游精选&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img&#x2F;jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img&#x2F;jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img&#x2F;jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img&#x2F;jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;row jingxuan&quot;&gt; &lt;img src=&quot;img&#x2F;icon_6.jpg&quot; alt=&quot;&quot;&gt; &lt;span&gt;国内游&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;img src=&quot;img&#x2F;guonei_1.jpg&quot; alt=&quot;&quot;&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img&#x2F;jiangxuan_5.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;¥ 699&lt;&#x2F;font&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;!--1. 页脚部分--&gt; &lt;footer class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;img src=&quot;img&#x2F;footer_service.png&quot; alt=&quot;&quot; class=&quot;img-responsive&quot;&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;row company&quot;&gt; 浙江零度科技股份有限公司 版权所&amp;Copyright; 2026-2036, All Rights Reserved 浙ICP备16007882 &lt;&#x2F;div&gt; &lt;&#x2F;footer&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[]},{"title":"JavaScript进阶","slug":"JavaWeb/JavaScript进阶","date":"2019-06-04T08:30:00.000Z","updated":"2020-01-03T11:43:19.600Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. DOM概述DOM (Document Object Model) 译为文档对象模型，是 HTML 和 XML 文档的编程接口。HTML DOM 定义了访问和操作 HTML 文档的标准方法。","text":"1. DOM概述DOM (Document Object Model) 译为文档对象模型，是 HTML 和 XML 文档的编程接口。HTML DOM 定义了访问和操作 HTML 文档的标准方法。 功能：将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作。 获取页面标签(元素Element)对象。例：document.getElementById(&quot;id值&quot;)，通过元素id获取元素对象。 1.1 DOM的3个部分W3C的DOM标准被分为3个同的部分： 核心DOM(针对任何结构化文档的标准模型) Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 Node：节点对象，上述5个对象的父对象 XML DOM(针对XML文档的标准模型) HTML DOM(针对HTML文档的标准模型) 1.2 核心DOM模型1.2.1 Document：文档对象1.2.1.1 创建(获取)在html dom模型中可以使用window对象来获取 window.document document 1.2.1.2 方法获取Element对象： getElementById()：根据id属性值获取元素对象。id属性一般唯一 getElementByTagName()：根据元素名称获取元素对象们。返回值是一个数组 getElementByClassName()：根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName()：根据name属性值获取元素对象们。返回值是一个数组 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() 1.2.1.3 属性Element：元素对象 获取/创建：通过document来获取和创建 方法： removeAttribute()：删除属性 setAttribute()：设置属性 Node：节点对象，其他5个的父对象 特点：所有dom对象都可以被认为是一个节点 方法： appendChild()：向节点的子节点列表的结尾添加新的子节点 removeChild()：删除(并返回)当前节点的指定子节点。 replaceChild()：用新节点替换一个子节点。 属性： parentNode：返回节点的父节点 表格增删案例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;动态表格&lt;&#x2F;title&gt; &lt;style&gt; table{ border: 1px solid; margin: auto; width: 500px; } td,th{ text-align: center; border: 1px solid; } div{ text-align: center; margin: 50px; } &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div&gt; &lt;input type=&quot;text&quot; id=&quot;id&quot; placeholder=&quot;请输入编号&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;gender&quot; placeholder=&quot;请输入性别&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;btn_add&quot;&gt; &lt;&#x2F;div&gt; &lt;table&gt; &lt;caption&gt;学生信息表&lt;&#x2F;caption&gt; &lt;tr&gt; &lt;th&gt;编号&lt;&#x2F;th&gt; &lt;th&gt;姓名&lt;&#x2F;th&gt; &lt;th&gt;性别&lt;&#x2F;th&gt; &lt;th&gt;操作&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;钢铁侠&lt;&#x2F;td&gt; &lt;td&gt;男&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;deltr(this)&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;蜘蛛侠&lt;&#x2F;td&gt; &lt;td&gt;男&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;deltr(this)&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;&#x2F;td&gt; &lt;td&gt;绿巨人&lt;&#x2F;td&gt; &lt;td&gt;男&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;deltr(this)&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;script&gt; &#x2F;&#x2F; 1. 获取按钮 var btn_add = document.getElementById(&quot;btn_add&quot;); btn_add.onclick = function () { &#x2F;&#x2F; 2. 获取文本框内容 var id = document.getElementById(&quot;id&quot;).value; var name = document.getElementById(&quot;name&quot;).value; var gender = document.getElementById(&quot;gender&quot;).value; &#x2F;&#x2F; 3. 创建td，赋值td的标签体 &#x2F;&#x2F; id的td var td_id = document.createElement(&quot;td&quot;); &#x2F;&#x2F; 创建一个td元素 var text_id = document.createTextNode(id); &#x2F;&#x2F; 将获取的id标签内容字符串转换为文本节点 td_id.appendChild(text_id); &#x2F;&#x2F; 将节点添加进td中 &#x2F;&#x2F; name的td var td_name = document.createElement(&quot;td&quot;); td_name.appendChild(document.createTextNode(name)); &#x2F;&#x2F; gender的td var td_gender = document.createElement(&quot;td&quot;); td_gender.appendChild(document.createTextNode(gender)); &#x2F;&#x2F; 删除操作 var del_td = document.createElement(&quot;td&quot;); &#x2F;&#x2F; 创建td var del_a = document.createElement(&quot;a&quot;); &#x2F;&#x2F; 创建a标签 del_a.setAttribute(&quot;href&quot;,&quot;javascript:void(0);&quot;); &#x2F;&#x2F; 设置a标签属性 del_a.setAttribute(&quot;onclick&quot;,&quot;deltr(this)&quot;); &#x2F;&#x2F; 绑定onclick事件 var text_a = document.createTextNode(&quot;删除&quot;); &#x2F;&#x2F; 创建一个文本节点，并设置内容 del_a.appendChild(text_a); &#x2F;&#x2F; 将文本节点添加进a标签中 del_td.appendChild(del_a); &#x2F;&#x2F; 将a标签添加进td中 &#x2F;&#x2F; 创建tr，将td添加进去 var tr = document.createElement(&quot;tr&quot;); tr.appendChild(td_id); tr.appendChild(td_name); tr.appendChild(td_gender); tr.appendChild(del_td); &#x2F;&#x2F; 获取table，将tr添加到table中 var table = document.getElementsByTagName(&quot;table&quot;)[0]; &#x2F;&#x2F; 返回一个数组列表，故取第一个 table.appendChild(tr); } &#x2F;&#x2F; 可使用innerHTML优化上述内容 btn_add.onclick = function ·() { &#x2F;&#x2F; 2. 获取文本框内容 var id = document.getElementById(&quot;id&quot;).value; var name = document.getElementById(&quot;name&quot;).value; var gender = document.getElementById(&quot;gender&quot;).value; var table = document.getElementsByTagName(&quot;table&quot;)[0]; table.innerHTML += &quot;&lt;tr&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+id+&quot;&lt;&#x2F;td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+name+&quot;&lt;&#x2F;td&gt;\\n&quot; + &quot; &lt;td&gt;&quot;+gender+&quot;&lt;&#x2F;td&gt;\\n&quot; + &quot; &lt;td&gt;&lt;a href=\\&quot;javascript:void(0);\\&quot; onclick=\\&quot;deltr(this)\\&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;\\n&quot; + &quot; &lt;&#x2F;tr&gt;&quot; } function deltr(obj) { var table = obj.parentNode.parentNode.parentNode; &#x2F;&#x2F; 获取当前a标签的父父父级元素table var tr = obj.parentNode.parentNode; &#x2F;&#x2F; 获取父父级tr table.removeChild(tr); } &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 1.3 HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性，详见W3C参考书 控制元素样式： 使用元素的style属性来设置 div1.style.border = &quot;1px solid red&quot;; div1.style.width = &quot;200px&quot;; div1.style.fontSize = &quot;20px&quot;; &#x2F;&#x2F; font-size = fontSize 提前定义好类选择器的样式，通过元素的className属性来设置class属性值。 &lt;style&gt; .d1{ border: 1px solid red; width: 100px; height: 100px; } &lt;&#x2F;style&gt; &lt;script&gt; var div2 = document.getElementById(&quot;div2&quot;); div2.onclick = function () { div2.className = &quot;d1&quot;; } &lt;&#x2F;script&gt; 2. BOMBOM(Browser Object Model)浏览器对象模型，将浏览器的各个组成部分封装成对象 2.1 主要组成 Window：窗口对象 Navigator：浏览器对象 Screen：显示器屏幕对象 History：历史记录对象 Location：地址栏对象 主要学习窗口对象，历史记录对象和地址栏对象，属性方法可参考：W3School 2.2 Window对象2.2.1 创建window对象无需创建，可直接使用。 2.2.2 方法2.2.2.1 与弹出框有关的方法 alert()：显示带有一段信息和一个确认按钮的警告框。 confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框。返回一个布尔值。 prompt()：显示可提示用户输入的对话框。返回值是用户输入的值。 2.2.2.2 与打开关闭有关的方法 close()：关闭浏览器窗口，谁调用关闭谁。 open()：打开一个新的浏览器窗口。返回值是新的窗口对象。 2.2.2.3 与定时器有关的方法 setTimeout()：在指定的毫秒数后调用函数或计算表达式。 参数1：js代码或者方法对象 参数2：毫秒值 返回值：唯一标识，用于取消定时器 clearTimeout()：取消由setTimeout()方法设置的timeout。 setInterval()：按照指定的周期来循环调用函数或计算表达式。 clearInterval()：取消由setInterval()设置的timeout。 轮播图 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;轮播图&lt;&#x2F;title&gt; &lt;script&gt; var number = 1; function fun() { number++; var banner = document.getElementById(&quot;banner&quot;); banner.src = &quot;img&#x2F;banner_&quot;+number+&quot;.jpg&quot;; if (number==3){ number = 0; } } setInterval(fun,3000); &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;img src=&quot;img&#x2F;banner_1.jpg&quot; id=&quot;banner&quot; width=&quot;100%&quot;&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 2.2.3 属性获取其他BOM对象： window.history，window.localtion，window.Navigator，window.Screen 获取DOM对象：window.document 2.2.4 特点 Window对象不需要创建可以直接使用。例：window.方法名(); window引用可以省略。直接方法名();即可 2.3 Location对象 创建(获取)：window.location 方法：reload()：重新加载当前页面(刷新)。 属性：href：设置或返回完整的URL 地址栏对象案例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;自动跳转&lt;&#x2F;title&gt; &lt;style&gt; p{ text-align: center; } span{ color: red; } &lt;&#x2F;style&gt; &lt;script&gt; var t = 5; function fun() { t--; if (t&lt;=0){ clearInterval(); location.href = &quot;https:&#x2F;&#x2F;www.baidu.com&quot;; } var times = document.getElementById(&quot;time&quot;); times.innerHTML = t; } setInterval(fun,1000); &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;p&gt;&lt;span id=&quot;time&quot;&gt;5&lt;&#x2F;span&gt;秒之后自动跳转页面&lt;&#x2F;p&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 2.4 History对象 创建(获取)：window.histtory 方法 back()：加载历史列表中的前一个URL。 forward()：加载历史列表中的下一个URL。 go(参数)：加载历史列表中的某个具体页面。参数是正负数，代表前进/后退几个历史记录。 属性：length，返回当前窗口历史列表中的URL数量。 3. 事件监听机制3.1 概念某些组件被执行了某些操作后，触发某些代码的执行。 事件：某些操作。如单击、双击，键盘按下，鼠标移动等 事件源：组件。如按钮、文本输入框… 监听器：js代码 注册监听：将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。 3.2 常见的事件3.2.1 点击事件 onclick：单击事件 ondblclick：双击事件 3.2.2 焦点事件 onblur：失去焦点，一般用于表单校验 onfocus：元素获得焦点 3.2.3 加载事件onload：一张页面或一副图像完成加载。 3.2.4 鼠标事件 onmousedown：鼠标按钮被按下。可以定义形参接收event对象，使用event.button，返回点击的鼠标值：左键0，中键1，右键2 onmouseup：鼠标按钮被松开。 onmousemove：鼠标被移动。 onmouseover：鼠标移到某元素之上。 onmouseout：鼠标从某元素移开。 3.2.5 键盘事件 onkeydown：某个键盘按键被按下。 onkeyup：某个键盘按键被松开。 onkeypress：某个键盘按键被按下并松开。 3.2.6 选择和改变 onchange：域的内容被改变 onselect：文本被选中 3.2.7 表单事件 onsubmit：确认按钮被点击，一般用于表单校验 onreset：重置按钮被点击 3.3 表格全选案例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表格全选&lt;&#x2F;title&gt; &lt;style&gt; table{ border: 1px solid; width: 500px; margin-left: 30%; } td,th{ text-align: center; border: 1px solid; } div{ margin-top: 10px; margin-left: 30%; } .out{ background-color: white; } .over{ background-color: pink; } &lt;&#x2F;style&gt; &lt;script&gt; &#x2F;&#x2F; 在页面加载完成后绑定事件 window.onload = function () { &#x2F;&#x2F; 给全选按钮绑定单击事件 document.getElementById(&quot;selectAll&quot;).onclick = function () { &#x2F;&#x2F; 1.获取所有的checkbox var cbs = document.getElementsByName(&quot;cb&quot;); &#x2F;&#x2F; 2. 遍历 for(var i = 0; i &lt; cbs.length; i++){ &#x2F;&#x2F; 3. 设置每一个cb的状态为选中 cbs[i].checked = true; } } &#x2F;&#x2F; 给全不选绑定事件 document.getElementById(&quot;unSelectAll&quot;).onclick = function () { &#x2F;&#x2F; 1.获取所有的checkbox var cbs = document.getElementsByName(&quot;cb&quot;); &#x2F;&#x2F; 2. 遍历 for(var i = 0; i &lt; cbs.length; i++){ &#x2F;&#x2F; 3. 设置每一个cb的状态为未选中 cbs[i].checked = false; } } &#x2F;&#x2F;给反选绑定事件 document.getElementById(&quot;selectRev&quot;).onclick = function () { &#x2F;&#x2F; 1.获取所有的checkbox var cbs = document.getElementsByName(&quot;cb&quot;); &#x2F;&#x2F; 2. 遍历 for(var i = 0; i &lt; cbs.length; i++){ &#x2F;&#x2F; 3. 获取当前cb的状态，直接取反赋值 cbs[i].checked = !cbs[i].checked; } } &#x2F;&#x2F; 第一个cb document.getElementById(&quot;firstCb&quot;).onclick = function () { &#x2F;&#x2F; 1.获取所有的checkbox var cbs = document.getElementsByName(&quot;cb&quot;); &#x2F;&#x2F; 2. 遍历 for(var i = 0; i &lt; cbs.length; i++){ &#x2F;&#x2F; 3. 获取每一个cb的状态和第一个cb的状态一致 cbs[i].checked = this.checked; } } &#x2F;&#x2F; 给所有tr绑定鼠标移到元素上和移出元素事件 var trs = document.getElementsByTagName(&quot;tr&quot;); &#x2F;&#x2F; 遍历 for (var i = 0; i &lt; trs.length; i++){ &#x2F;&#x2F; 移到元素上事件 trs[i].onmouseover = function () { this.className = &quot;over&quot;; } &#x2F;&#x2F; 移出元素事件 trs[i].onmouseout = function () { this.className = &quot;out&quot;; } } } &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;table&gt; &lt;caption&gt;学生信息表&lt;&#x2F;caption&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=&quot;checkbox&quot; name=&quot;cb&quot; id=&quot;firstCb&quot;&gt;&lt;&#x2F;th&gt; &lt;th&gt;编号&lt;&#x2F;th&gt; &lt;th&gt;姓名&lt;&#x2F;th&gt; &lt;th&gt;性别&lt;&#x2F;th&gt; &lt;th&gt;操作&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;cb&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;钢铁侠&lt;&#x2F;td&gt; &lt;td&gt;男&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;cb&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;绿巨人&lt;&#x2F;td&gt; &lt;td&gt;男&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;cb&quot;&gt;&lt;&#x2F;td&gt; &lt;td&gt;3&lt;&#x2F;td&gt; &lt;td&gt;雷神&lt;&#x2F;td&gt; &lt;td&gt;?&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;div&gt; &lt;input type=&quot;button&quot; id=&quot;selectAll&quot; value=&quot;全选&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;unSelectAll&quot; value=&quot;全不选&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;selectRev&quot; value=&quot;反选&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 3.4 表单检验案例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册页面&lt;&#x2F;title&gt; &lt;style&gt; *{ margin: 0px; padding: 0px; box-sizing: border-box; } body{ background: url(&quot;img&#x2F;register_bg.png&quot;) no-repeat center; padding-top: 25px; } .rg_layout{ width: 900px; height: 500px; border: 8px solid #EEEEEE; background-color: white; &#x2F;*让div水平居中*&#x2F; margin: auto; } .rg_left{ &#x2F;*border: 1px solid red;*&#x2F; float: left; margin: 15px; } .rg_left &gt; p:first-child{ color:#FFD026; font-size: 20px; } .rg_left &gt; p:last-child{ color:#A6A6A6; font-size: 20px; } .rg_center{ float: left; &#x2F;* border: 1px solid red;*&#x2F; } .rg_right{ &#x2F;*border: 1px solid red;*&#x2F; float: right; margin: 15px; } .rg_right &gt; p:first-child{ font-size: 15px; } .rg_right p a { color:pink; } .td_left{ width: 100px; text-align: right; height: 45px; } .td_right{ padding-left: 50px ; } #username,#password,#email,#name,#tel,#birthday,#checkcode{ width: 251px; height: 32px; border: 1px solid #A6A6A6 ; &#x2F;*设置边框圆角*&#x2F; border-radius: 5px; padding-left: 10px; } #checkcode{ width: 110px; } #img_check{ height: 32px; vertical-align: middle; } #btn_sub{ width: 150px; height: 40px; background-color: #FFD026; border: 1px solid #FFD026 ; } .error{ color: red; } #td_sub{ padding-left: 150px; } &lt;&#x2F;style&gt; &lt;script&gt; &#x2F;&#x2F; 1. 给表单绑定submit事件。监听器中判断每个方法校验的结果。如果都为true中返回true,有一项false则返回false &#x2F;&#x2F; 2. 定义一些方法分别校验各个表单项 &#x2F;&#x2F; 3. 给各个表单项绑定失去焦点onblur事件 window.onload = function () { &#x2F;&#x2F; 1. 给表单绑定submit事件。 document.getElementById(&quot;form&quot;).onsubmit = function () { &#x2F;&#x2F; 调用用户名校验方法 checkName(); &#x2F;&#x2F; 调用密码校验方法 checkPwd(); return checkName() &amp;&amp; checkPwd() &amp;&amp; checkEmail() &amp;&amp; checkTname() &amp;&amp; checkPhone(); } &#x2F;&#x2F; 给各个表单项分别绑定离焦事件 document.getElementById(&quot;username&quot;).onblur = checkName; document.getElementById(&quot;password&quot;).onblur = checkPwd; document.getElementById(&quot;email&quot;).onblur = checkEmail; document.getElementById(&quot;name&quot;).onblur = checkTname; document.getElementById(&quot;tel&quot;).onblur = checkPhone; &#x2F;&#x2F; 校验用户名方法 function checkName() { &#x2F;&#x2F; 1. 获取用户名值 var username = document.getElementById(&quot;username&quot;).value; &#x2F;&#x2F; 2. 定义正则表达式 var reg_username = &#x2F;^\\w{6,12}$&#x2F;; &#x2F;&#x2F; 3. 判断值是否符合正则规则 var flag = reg_username.test(username); &#x2F;&#x2F; 4. 提示信息 var s_username = document.getElementById(&quot;s_username&quot;); if (flag){ &#x2F;&#x2F; 提示绿色对勾 s_username.innerHTML = &quot;&lt;img width=&#39;30&#39; height=&#39;20&#39; src=&#39;img&#x2F;gou.png&#39;&#x2F;&gt;&quot; } else{ &#x2F;&#x2F; 提示红色用户名错误 s_username.innerHTML = &quot;用户名格式错误！&quot; } return flag; } &#x2F;&#x2F; 校验密码 function checkPwd() { &#x2F;&#x2F; 1. 获取密码值 var password = document.getElementById(&quot;password&quot;).value; &#x2F;&#x2F; 2. 定义正则表达式 var reg_password = &#x2F;^(?![^a-zA-Z]+$)(?!\\D+$)&#x2F;; &#x2F;&#x2F; 3. 判断值是否符合正则规则 var flag = reg_password.test(password); &#x2F;&#x2F; 4. 提示信息 var s_pwd = document.getElementById(&quot;s_pwd&quot;); if (flag){ &#x2F;&#x2F; 提示绿色对勾 s_pwd.innerHTML = &quot;&lt;img width=&#39;30&#39; height=&#39;20&#39; src=&#39;img&#x2F;gou.png&#39;&#x2F;&gt;&quot; } else{ &#x2F;&#x2F; 提示红色密码错误 s_pwd.innerHTML = &quot;密码格式错误！&quot; } return flag; } &#x2F;&#x2F; 校验邮箱 function checkEmail() { var reg_email = &#x2F;^([a-zA-Z]|[0-9])(\\w|\\-)+@[a-zA-Z0-9]+\\.([a-zA-Z]{2,4})$&#x2F;; var flag = reg_email.test(document.getElementById(&quot;email&quot;).value); var s_email = document.getElementById(&quot;s_email&quot;); if (flag){ s_email.innerHTML = &quot;&lt;img width=&#39;30&#39; height=&#39;20&#39; src=&#39;img&#x2F;gou.png&#39;&#x2F;&gt;&quot;; }else{ s_email.innerHTML = &quot;邮箱格式错误&quot;; } } &#x2F;&#x2F; 校验姓名 function checkTname() { var flag = &#x2F;^[\\u4E00-\\u9FA5\\uf900-\\ufa2d]{2,4}$&#x2F;.test(document.getElementById(&quot;name&quot;).value); var s_name = document.getElementById(&quot;s_name&quot;); if (flag){ s_name.innerHTML = &quot;&lt;img width=&#39;30&#39; height=&#39;20&#39; src=&#39;img&#x2F;gou.png&#39;&#x2F;&gt;&quot;; }else{ s_name.innerHTML = &quot;姓名格式错误&quot;; } } &#x2F;&#x2F; 校验手机号 function checkPhone() { var flag = &#x2F;^1[3|4|5|8][0-9]\\d{4,8}$&#x2F;.test(document.getElementById(&quot;tel&quot;).value); var s_phone = document.getElementById(&quot;s_phone&quot;); if (flag){ s_phone.innerHTML = &quot;&lt;img width=&#39;30&#39; height=&#39;20&#39; src=&#39;img&#x2F;gou.png&#39;&#x2F;&gt;&quot;; } else{ s_phone.innerHTML = &quot;手机号码格式错误&quot; } } } &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class=&quot;rg_layout&quot;&gt; &lt;div class=&quot;rg_left&quot;&gt; &lt;p&gt;新用户注册&lt;&#x2F;p&gt; &lt;p&gt;USER REGISTER&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;rg_center&quot;&gt; &lt;div class=&quot;rg_form&quot;&gt; &lt;!--定义表单 form--&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;form&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt; &lt;span id=&quot;s_username&quot; class=&quot;error&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt; &lt;span id=&quot;s_pwd&quot; class=&quot;error&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt; &lt;span id=&quot;s_email&quot; class=&quot;error&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt; &lt;span id=&quot;s_name&quot; class=&quot;error&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt; &lt;span id=&quot;s_phone&quot; class=&quot;error&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女 &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt; &lt;img id=&quot;img_check&quot; src=&quot;img&#x2F;verify_code.jpg&quot;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; id=&quot;td_sub&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;rg_right&quot;&gt; &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;&#x2F;a&gt;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zero024.cn/tags/JavaScript/"}]},{"title":"JavaScript基础","slug":"JavaWeb/JavaScript基础","date":"2019-05-28T15:30:00.000Z","updated":"2020-01-03T11:43:19.599Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. JavaScript概述JavaScript是一种运行在浏览器中的解释型的编程语言。每一个浏览器都有JavaScript的解析引擎，不需要编译就可以直接被浏览器解析执行了。","text":"1. JavaScript概述JavaScript是一种运行在浏览器中的解释型的编程语言。每一个浏览器都有JavaScript的解析引擎，不需要编译就可以直接被浏览器解析执行了。 功能：主要用来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 2. ECMAScript1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM) 2.1 基本语法2.1.1 与html结合方式 内部JS：定义&lt;script&gt;，标签体内容就是js代码 外部JS：定义&lt;script&gt;，通过src属性引入外部的js文件 Tips: script可以定义在html页面的任何地方，但定义的文字会影响执行顺序。且可以定义多个。 2.1.2 注释 单行注释：// 注释内容 多行注释：/*注释内容*/ 2.1.3 数据类型 原始数据类型 number：JavaScript不区分整数和浮点数，统一用number表示。可以表示整数/小数/NaN(NaN表示Not a Number，当无法计算结果时用NaN表示)。 string：字符串。可以使用单双引号。 boolean：布尔值。true和false。 null：一个对象为空的占位符。 undefined：表示值未定义。 引用数据类型：对象，JavaScript的对象是一组由键-值组成的无序集合。 &lt;script&gt; var num = 123; &#x2F;&#x2F; 定义一个整数123 var float = 0.456; &#x2F;&#x2F; 定义一个浮点数0.456 var str = &quot;abc&quot;; &#x2F;&#x2F; 定义一个字符串abc var flag = true; &#x2F;&#x2F; 定义一个布尔值true var a = null; &#x2F;&#x2F; 定义对象a为空 var b = undefined; &#x2F;&#x2F; 表示值b未定义 var person = { &#x2F;&#x2F; 定义了一个person对象 name:&#39;xiaozhang&#39;, age:20, city:&#39;hangzhou&#39; } &lt;&#x2F;script&gt; 2.1.4 变量变量是一小块存储数据的内存空间。Java语言是强类型语言，而JavaScript是弱类型语言。 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 语法：var 变量名 = 初始化值; Tips: 可以使用typeof运算符获取变量的类型。null运算后得到的是object类型。 document.write(num+&quot;--&gt;&quot;+typeof(num)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 123--&gt;number document.write(str+&quot;--&gt;&quot;+typeof(str)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; abc--&gt;string document.write(flag+&quot;--&gt;&quot;+typeof(flag)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; true--&gt;boolean document.write(a+&quot;--&gt;&quot;+typeof(a)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; null--&gt;object document.write(b+&quot;--&gt;&quot;+typeof(b)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; undefined--&gt;undefined document.write(&quot;person--&gt;&quot;+typeof(person)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; person--&gt;object 2.1.5 运算符 一元运算符：只有一个运算数的运算符。例：++,-- 算数运算符：+ - * / % ... 赋值运算符：=,+=,-=... 比较运算符：&gt;,&lt;,&gt;=,&lt;=,==,===(全等于)，全等于在比较之前先判断类型，如果类型不一样，直接返回false。 逻辑运算符：&amp;&amp;,||,!。 三元运算符：表达式?值1:值2;，判断表达式的值，如果是true则取值1，反之取值2。 var a = 1; document.write(++a+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 一元运算符 var b = 2; document.write(a+b+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 二元运算符: +-*&#x2F;% document.write(b+=1+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 3, 赋值运算符 &#x2F;&#x2F; document.write(a&gt;b+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; false,比较运算符 var str = &#39;1&#39;; document.write((a==str)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; true，string类型转number，按照字面值转换为1，1==1，故true document.write(a===str+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; false,全等于会先进行类型判断，类型不同直接返回false document.write(a&gt;false); &#x2F;&#x2F; a&gt;0 , true document.write(a&gt;0?1:0); &#x2F;&#x2F; 三元运算符 &#x2F;* 在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换 * 其他类型转number： * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） * boolean转number：true转为1，false转为0 逻辑运算符类型转换： 1. number：0或NaN为假，其他都为真 2. string：除了空字符串(&quot;&quot;)，其他都是true 3. null&amp;undefined:都是false 4. 对象：所有对象都是true *&#x2F; 2.1.6 流程控制语句 if...else... switch(变量)：case 值:具体内容;break;，在JS中，switch语句可以接受任意的原始数据类型 while do...while for var a = 4; var b = 7; if (a&gt;b){ document.write(&quot;a&gt;b&quot;) } else{ document.write(&quot;b&gt;a&quot;) } var day = 3; switch (day) { case 1: document.write(&quot;Monday&quot;); break; case 2: document.write(&quot;Tuesday&quot;); break; case 3: document.write(&quot;Wednesday&quot;); break; case 4: document.write(&quot;Thursday&quot;); break; case 5: document.write(&quot;Friday&quot;); break; case 6: document.write(&quot;Saturday&quot;); break; case 7: document.write(&quot;Sunday&quot;); break; } var c = 1; while (c&lt;=5){ document.write(c+&quot;&lt;br&gt;&quot;); c++; } for (i=1;i&lt;=5;i++){ document.write(i+&quot;&lt;br&gt;&quot;) } 2.1.7 JS特殊语法 语句以;结尾，如果一行只有一条语句则可省略;(不建议) 变量的定义使用var关键字，也可以不使用。 使用：定义的变量是局部变量 不用：定义的变量是全局变量(不建议) 2.1.8 小练习：99乘法表 document.write(&quot;&lt;table&gt;&quot;) for (i=1;i&lt;=9;i++){ document.write(&quot;&lt;tr&gt;&quot;) for (j=1;j&lt;=i;j++){ document.write(&quot;&lt;td&gt;&quot;) document.write(j+&quot;*&quot;+i+&quot;=&quot;+j*i) document.write(&quot;&lt;&#x2F;td&gt;&quot;) } document.write(&quot;&lt;&#x2F;tr&gt;&quot;) } document.write(&quot;&lt;&#x2F;table&gt;&quot;) 3. 基本对象3.1 Function：函数对象 &lt;script&gt; &#x2F;* 1.创建函数对象： 1. function 方法名称(形参列表){ 方法体 } 2. var 方法名 = function(形参列表){ 方法体 } 2. 属性： length：返回形参的个数 3. 特点： 1. 方法定义时形参的类型不用写 2. 方法是一个对象，如果定义名称相同的方法，会覆盖 3. 在JS中，方法的调用只与方法名称有关 4. 在方法声明中有一个隐藏的内置关键字：argument,用于接收所有形参，封装成了一个数组 4. 调用： 方法名称(参数列表); *&#x2F; function fun(a,b) { document.write(a+b); } &#x2F;&#x2F; fun(3,4); &#x2F;&#x2F; 7 var fun2 = function (a,b) { document.write(a+b); } document.write(fun2.length); &#x2F;&#x2F; 2 fun2(3) &#x2F;&#x2F; NaN,原因b是undefined &#x2F;* 定义一个求和函数 *&#x2F; function add() { var sum = 0; for (i=0;i&lt;arguments.length;i++){ sum+=arguments[i]; } return sum; } document.write(add(1,2,3,4,5)); &#x2F;&#x2F; 15 &lt;&#x2F;script&gt; 3.2 Array：数组对象3.2.1 创建 var arr = new Array(元素列表); var arr = new Array(默认长度); var arr = [元素列表]; 3.2.2 方法 join(参数)：将数组中的元素按照指定的分隔符拼接为字符串 push()：向数组的末尾添加一个或更多元素，并返回新的长度。 3.2.3 属性length：数组长度 3.2.4 特点 在JS中，数组可以存储不同的类型元素 JS中，数组长度是可变的。 3.2.5 示例 var arr1 = new Array(1,2,3); var arr2 = new Array(5); var arr3 = [1,&quot;abc&quot;,true]; &#x2F;&#x2F; 数组可以存储不同的类型元素 document.write(arr1.join(&quot;--&gt;&quot;)); &#x2F;&#x2F; 1--&gt;2--&gt;3 arr1.push(4,5); document.write(arr1); &#x2F;&#x2F; 1,2,3,4,5 document.write(arr2.length); &#x2F;&#x2F; 5 3.3 Date：日期对象 创建：var date = new Date(); 方法： toLocaleString()：返回当前date对象对应的时间本地字符串格式。 getTime()：获取毫秒值。返回当前日期对象描述的时间到1970年1月1日零点的毫秒值差。 3.4 Math：数学对象 创建：Math对象不用创建，可以直接使用。例：Math.方法名(); 方法： random()：返回0~1之间的随机数。含0不含1 ceil(x)：对数进行上舍入(向上取整) floor(x)：对数进行下舍入(向下取整) round(x)：把数四舍五入为最接近的整数 属性：PI document.write(Math.PI+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 3.141592653589793 document.write(Math.random()+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 0.16764969291724752 document.write(Math.ceil(3.14)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 4 document.write(Math.floor(3.14)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 3 document.write(Math.round(3.14)+&quot;&lt;br&gt;&quot;); &#x2F;&#x2F; 3 &#x2F;&#x2F; 取一个0~100之间的随机整数 var number = Math.floor(Math.random()*100+1); document.write(number); 3.5 RegExp：正则表达式对象 创建： var reg = new RegExp(&quot;正则表达式&quot;); var reg = /正则表达式/; 方法：test(参数)：验证指定的字符串是否符合正则定义的规范 var reg1 = new RegExp(&quot;\\\\d&quot;); var reg2 = &#x2F;[a-z]&#x2F;; document.write(reg1.test(&quot;a&quot;)); &#x2F;&#x2F; false document.write(reg1.test(2)); &#x2F;&#x2F; true document.write(reg2.test(&quot;b&quot;)); &#x2F;&#x2F; true 3.6 Global3.6.1 特点全局对象，这个Global中封装的方法不需要对象就可以直接调用。例：方法名(); 3.6.2 方法 encodeURI()：url编码 encodeURI()：url编码 encodeURIComponent()：url编码，能编码的字符更多 decodeURIComponent()：url解码 parseInt()：将字符串转为数字。逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number类型。 isNaN()：判断一个值是否是NaN。NaN参与的==比较全部为false。 eval()：将可执行的JavaScript字符串转换为JS脚本来执行。 var str = &quot;零度科技&quot;; &#x2F;&#x2F; UTF8编码转换中文，一个中文代表3个字节,即&#39;零= %E9%9B%B6&#39; var encode = encodeURI(str); document.write(encode); &#x2F;&#x2F; %E9%9B%B6%E5%BA%A6%E7%A7%91%E6%8A%80 document.write(decodeURI(encode)); &#x2F;&#x2F; 零度科技 var number = &quot;123木头人321&quot;; document.write(parseInt(number)); &#x2F;&#x2F; 123 var a = NaN; document.write(isNaN(number)); &#x2F;&#x2F; false document.write(isNaN(a)); &#x2F;&#x2F; true var b = &quot;alert(123)&quot;; eval(b); &#x2F;&#x2F; 将会执行alert(123)这段js代码，在浏览器弹出123","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zero024.cn/tags/JavaScript/"}]},{"title":"CSS基础","slug":"JavaWeb/CSS基础","date":"2019-05-27T14:10:00.000Z","updated":"2020-01-03T11:43:19.586Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. CSS基础概念：Cascading Style Sheets(层叠样式表)。功能强大，可以将内容展示和样式控制分离。 层叠：多个样式可以作用在用一个html的元素上，同时生效","text":"1. CSS基础概念：Cascading Style Sheets(层叠样式表)。功能强大，可以将内容展示和样式控制分离。 层叠：多个样式可以作用在用一个html的元素上，同时生效 1.1 CSS的使用：CSS与HTML结合方式 内联样式：在标签内使用style属性指定css代码，例&lt;div style=&quot;color:red;&quot;&gt;this is css style&lt;/div&gt; 内部样式：在head标签内，定义style标签，style标签体内容就是css代码 &lt;style&gt; div{ color:blue; } &lt;&#x2F;style&gt; &lt;div&gt; this is inner style &lt;&#x2F;div&gt; 外部样式：定义css资源文件，在head标签内，定义link标签，引入外部的资源文件。 1. 新建一个a.css的文件，内容如下 div{ color:red; } 2. head标签内使用link标签引入 &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css&#x2F;a.css&quot;&gt; &lt;&#x2F;head&gt; &lt;div&gt; this is outer style &lt;&#x2F;div&gt; 2. CSS语法 格式如下： 选择器{ 属性名1：属性值1; 属性名2：属性值2; .... } 选择器：筛选具有相似特征的元素 Notice：每一对属性需要使用;分隔开，最后一对属性可以不加; 3. 选择器分类有：基础选择器和扩展选择器 3.1 基础选择器3.1.1 ID选择器选择具体的id属性值的元素，建议在一个html页面中id值唯一 语法：#id属性值{css} 3.1.2 元素选择器选择具有相同标签名称的元素 语法：标签名称{css} 注意：id选择器优先级高于元素选择器 3.1.3 类选择器选择具有相同的class属性值的元素 语法：.class属性值{css} 注意：类选择器优先级高于元素选择器 3.2 扩展选择器3.2.1 选择所有元素 语法： *{} 3.2.2 并集选择器 语法：选择器1,选择器2{} 3.2.3 子选择器筛选选择器1元素下的选择器2元素 语法：选择器1 选择器2{} 3.2.4 父选择器筛选选择器2的父元素选择器1 语法：选择器1&gt;选择器2{} 3.2.5 属性选择器选择元素名称，属性名=属性值的元素 语法：元素名称[属性名=“属性值”]{} 3.2.6 伪类选择器选择一些元素具体的状态 语法：元素:状态{} 例： &lt;a&gt;&lt;&#x2F;a&gt;标签 状态有： 1. link：初始化的状态 2. visited：被访问过的状态 3. active：正在访问状态 4. hover：鼠标悬浮状态 4. 属性4.1 字体、文本 font-size：字体大小 color：文本颜色 text-align：对齐方式 line-height：行高 4.2背景 background 4.3 边框 border：设置边框，符合属性 4.4 尺寸 width：宽度 height：高度 4.5 盒子模型主要用于控制布局 margin：外边距 padding：内边距 默认情况下内边距会影响整个盒子的大小 box-sizing: border-box;，设置盒子的属性，让width和height就是最终盒子的大小 float：浮动 float: left; 左浮动 float: right; 右浮动 5. 综合案例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册页面&lt;&#x2F;title&gt; &lt;style&gt; *{ margin: 0px; &#x2F;*外边距*&#x2F; padding: 0px;&#x2F;*内边距*&#x2F; box-sizing: border-box; } body{ background: url(&quot;img&#x2F;register_bg.png&quot;) no-repeat center;&#x2F;*背景图居中*&#x2F; } .rg_foreign{ width: 900px; height: 500px; border: 8px solid #EEEEEE;&#x2F;*边框颜色*&#x2F; background-color: white;&#x2F;*背景色白色*&#x2F; &#x2F;*div水平居中*&#x2F; margin: auto; margin-top: 15px; &#x2F;*外上边距*&#x2F; } .rg_left{ float: left; margin: 15px; } .rg_left &gt; p:first-child{ color: #FFD026; font-size: 22px; } .rg_left &gt; p:last-child{ color: #A6A6A6; font-size: 22px; } .rg_center{ float: left; width: 450px; } .rg_right{ float: right; margin: 15px; } .rg_right p{ font-size: 15px; } .rg_right p a{ color: pink; } .td_left{ width: 100px; text-align: right; height: 45px; } .td_right{ padding-left: 35px; } #uname,#password,#email,#name,#tel,#birthday,#checked{ width: 250px; height: 32px; border: 1px solid #A6A6A6; &#x2F;*设置边框圆角*&#x2F; border-radius: 5px; padding-left: 10px; } #checked{ width: 110px; } #img_check{ height: 32px; vertical-align: middle; &#x2F;*设置垂直居中*&#x2F; } #btn_submit{ width: 150px; height: 40px; background-color: #FFD026; border: 1px solid #FFD026; } &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class=&quot;rg_foreign&quot;&gt; &lt;div class=&quot;rg_left&quot;&gt; &lt;p&gt;新用户注册&lt;&#x2F;p&gt; &lt;p&gt;USER REGISTER&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;rg_center&quot;&gt; &lt;div class=&quot;rg_form&quot;&gt; &lt;form action=&quot;.&#x2F;login.html&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;uname&quot;&gt;用户名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;uname&quot; id=&quot;uname&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入真实姓名&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;性别&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt;女 &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checked&quot;&gt;验证码&lt;&#x2F;label&gt;&lt;&#x2F;td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;checked&quot; id=&quot;checked&quot; placeholder=&quot;请输入验证码&quot;&gt; &lt;img src=&quot;img&#x2F;verify_code.jpg&quot; alt=&quot;&quot; id=&quot;img_check&quot;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_submit&quot; value=&quot;注册&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class=&quot;rg_right&quot;&gt; &lt;p&gt;已有账号? &lt;a href=&quot;#&quot;&gt;立即登录&lt;&#x2F;a&gt;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://zero024.cn/tags/CSS/"}]},{"title":"HTML基础","slug":"JavaWeb/HTML","date":"2019-05-26T15:30:00.000Z","updated":"2020-03-08T00:51:04.490Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. Web概述1.1 软件架构主要有如下两种架构 C/S：Client/Server 客户端/服务器端 B/S：Browser/Server 浏览器/服务器端","text":"1. Web概述1.1 软件架构主要有如下两种架构 C/S：Client/Server 客户端/服务器端 B/S：Browser/Server 浏览器/服务器端 1.2 资源分类1.2.1 静态资源使用静态网页开发技术发布的资源，特点如下： 所有用户访问，得到的结果是一样的，如：文本、图片、音视频等资源 静态网页开发技术：HTML、CSS、JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源 名称 作用概述 HTML 用于搭建基础网页，展示页面的内容 CSS 用于美化页面，布局页面 JavaScript 控制页面的元素，让页面有一些动态的效果 1.2.2 动态资源使用动态网页及时发布的资源，特点： 所有用户访问，得到的结果可能不一样 动态网页开发技术：jsp/servlet，php,asp等 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 2. HTMLhtml是最基础的网页开发语言 Hyper Text Markup Language(超文本标记语言) 超文本：是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本 标记语言：由标签构成的语言。&lt;标签名称&gt; 如 html，xml Notice：标记语言不是编程语言 2.1 快速入门2.1.1 语法 1. html文档后缀名 .html 或者 .htm 2. 标签分为：围堵标签(&lt;html&gt;&lt;&#x2F;html&gt;)和自闭标签(&lt;link&#x2F;&gt;) 3. 标签可以嵌套：例&lt;a&gt;&lt;b&gt;&lt;&#x2F;b&gt;&lt;&#x2F;a&gt; 4. 在开始标签中可以定义属性。属性是由键值对构成，值需用单双引号引起来。 5. html的标签不区分大小写，但建议使用小写 特殊字符表 2.2 标签2.2.1 文件标签：构成html最基本的标签 标签类型 标签名称 标签作用 根标签 html html文档的根标签 头标签 head 用于指导html文档的一些属性，引入外部的资源 标题标签 title 该页面标题 体标签 body 写主体内容 注解标签 &lt;!DOCTYPE html&gt; html5中定义该文档是html文档 2.2.2 文本标签：和文本有关的标签 1. 注释：&lt;!-- 注释内容 --&gt; 2. &lt;h1&gt; to &lt;h6&gt; ：标题标签 3. &lt;p&gt;：段落标签 4. &lt;br&gt;：换行标签 5. &lt;hr&gt;：水平线 属性： - color：颜色 - width：宽度 - size：高度 - align：对其方式 1. center：居中 2. left：左对齐 3. right：右对齐 6. &lt;b&gt;：字体加粗 7. &lt;i&gt;：字体斜体 8. &lt;font&gt;：字体标签 9. &lt;center&gt;：文本居中 属性： - color：颜色 - size：大小 - face：字体 10. 属性定义： - color： 1. 可以使用颜色的英文单词：red、green、blue 2. rgb(值1，值2，值3)：值的范围：0~255,。例：rgb(0,0,255) 3. #值1值2值3：值的范围00~FF之间。例：#FF00FF - width： 1. 数值：width=&#39;20&#39;，数值的单位，默认是px(像素) 2. 数值%：占比相对于父元素的比例 2.2.3 图片标签：img展示图片，属性：src(指定图片的位置)2.2.4 列表标签：有序列表(ol，li)和无序列表(ul，li)2.2.5 链接标签 a标签：定义一个超链接 属性： 1. href：指定访问资源的URL 2. target：指定打开资源的方式(_self:默认值，在当前页面打开；_blank:在新页面打开) 2.2.6 div和span 类型 标签名称 作用 块级标签 div 每一个div占满一整行 行内标签 span 文本信息在一行展示 2.2.7 语义化标签：html5中为了提高程序的可读性，提供了一些标签。分别是页眉&lt;header&gt;和页脚&lt;footer&gt;2.2.8 表格标签 标签名称 标签作用 标签属性 table 定义表格 width：宽度、border：边框、cellpadding：定义内容和单元格的距离、cellspacing：定义单元格之间的距离。如为0,则单元格的线会合为一条、bgcolor：背景色、align：对齐方式 tr 定义行 bgcolor：背景色、align：对齐方式 td 定义单元格 colspan：合并列、rowspan：合并行 &lt;caption&gt; 表格标题 \\ &lt;thead&gt; 表示表格的头部分 \\ &lt;tbody&gt; 表示表格的体部分 \\ &lt;tfoot&gt; 表示表格的脚部分 \\ 演示： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表格标签&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;table border=&quot;1&quot; width=&quot;50%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; bgcolor=&quot;#faebd7&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;!-- &lt;td&gt;编号&lt;&#x2F;td&gt; &lt;td&gt;姓名&lt;&#x2F;td&gt; &lt;td&gt;成绩&lt;&#x2F;td&gt;--&gt; &lt;th&gt;编号&lt;&#x2F;th&gt; &lt;th&gt;姓名&lt;&#x2F;th&gt; &lt;th&gt;成绩&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;小龙女&lt;&#x2F;td&gt; &lt;td&gt;100&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;杨过&lt;&#x2F;td&gt; &lt;td&gt;50&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;hr&gt; &lt;table border=&quot;1&quot; width=&quot;50%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; bgcolor=&quot;#faebd7&quot; align=&quot;center&quot;&gt; &lt;thead&gt; &lt;caption&gt;学生信息表&lt;&#x2F;caption&gt; &lt;tr&gt; &lt;!-- &lt;td&gt;编号&lt;&#x2F;td&gt; &lt;td&gt;姓名&lt;&#x2F;td&gt; &lt;td&gt;成绩&lt;&#x2F;td&gt;--&gt; &lt;th&gt;编号&lt;&#x2F;th&gt; &lt;th&gt;姓名&lt;&#x2F;th&gt; &lt;th&gt;成绩&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr bgcolor=&quot;#7fffd4&quot; align=&quot;center&quot;&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;小龙女&lt;&#x2F;td&gt; &lt;td&gt;100&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;杨过&lt;&#x2F;td&gt; &lt;td&gt;50&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;3&lt;&#x2F;td&gt; &lt;td&gt;尹志平&lt;&#x2F;td&gt; &lt;td&gt;10&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tfoot&gt; &lt;&#x2F;table&gt; &lt;hr&gt; &lt;table border=&quot;1&quot; width=&quot;50%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; bgcolor=&quot;#faebd7&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;编号&lt;&#x2F;th&gt; &lt;th&gt;姓名&lt;&#x2F;th&gt; &lt;th&gt;成绩&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;小龙女&lt;&#x2F;td&gt; &lt;td&gt;100&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td colspan=&quot;2&quot;&gt;杨过&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;hr&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 2.2.9 表单标签用于采集用户输入的数据，和服务进行交互 form：用于定义表单的，可以定义一个范围(代表采集用户数据的范围)，属性如下： action：指定提交数据的URL method：指定提交方式。主要使用get和post Tips：表单项中的数据要想被提交，必须指定其name属性 表单项标签input。可以通过type属性值，改变元素展示的样式 type属性： text：文本输入框，可使用placeholder属性，指定输入框的提示信息 password：密码输入框 radio：单选框 checkbox：复选框 file：文件选择框 hidden：隐藏域 submit：提交按钮，可以提交表单 button：普通按钮 image：图片提交按钮，src属性指定图片的路径 label：指定输入项的文字描述信息 select：下拉列表。子元素：option，指定列表项 textarea：文本域 cols：指定列数，每一行有多少个字符 rows：默认多少行 2.3 综合案例演示 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;旅游网&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!--采用table来完成布局--&gt; &lt;!--最外层的table，用于整个页面的布局--&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;!--第1行--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;!--第2行--&gt; &lt;tr&gt; &lt;td&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;logo.jpg&quot; alt=&quot;&quot;&gt; &lt;&#x2F;td&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;search.png&quot; alt=&quot;&quot;&gt; &lt;&#x2F;td&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;hotel_tel.png&quot; alt=&quot;&quot;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;!--第3行--&gt; &lt;tr&gt; &lt;td&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; heigth=&quot;45&quot;&gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;首页&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt; 门票 &lt;&#x2F;td&gt; &lt;td&gt; 酒店 &lt;&#x2F;td&gt; &lt;td&gt; 香港车票 &lt;&#x2F;td&gt; &lt;td&gt; 出境游 &lt;&#x2F;td&gt; &lt;td&gt; 国内游 &lt;&#x2F;td&gt; &lt;td&gt; 港澳游 &lt;&#x2F;td&gt; &lt;td&gt; 抱团定制 &lt;&#x2F;td&gt; &lt;td&gt; 全球自由行 &lt;&#x2F;td&gt; &lt;td&gt; 收藏排行榜 &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;!--第4行--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;!--第5行:旅游精选--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;icon_5.jpg&quot; alt=&quot;&quot;&gt; 旅游精选 &lt;hr color=&quot;#ffd700&quot;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;!--第6行--&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;!--第7行：国内游--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;icon_6.jpg&quot; alt=&quot;&quot;&gt; 国内游 &lt;hr color=&quot;#ffd700&quot;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;!--第8行--&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt; &lt;img src=&quot;image&#x2F;guonei_1.jpg&quot; alt=&quot;&quot;&gt; &lt;&#x2F;td&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚5天4晚自由行(春节销售+亲子+蜜月行)&lt;&#x2F;p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;!--第9行:境外游--&gt; &lt;!--第10行--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image&#x2F;footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;!--第11行--&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt; &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt; 浙江零度科技有限公司 版权所有 Copyright 2022-2030&amp;copy; All Right Reserved &lt;&#x2F;font&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[]},{"title":"JDBC连接池","slug":"JavaWeb/JDBC连接池","date":"2019-05-25T15:59:00.000Z","updated":"2020-03-04T07:17:39.960Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. 数据库连接池其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象。当用户来访问数据库时，从容器中获取连接对象，用户访问完后，会将连接对象归还给容器。","text":"1. 数据库连接池其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象。当用户来访问数据库时，从容器中获取连接对象，用户访问完后，会将连接对象归还给容器。 1.1 好处 节约资源 用户访问高效 1.2 实现标准接口：DataSource ，javax.sql包下的，主要方法如下： 获取连接：getConnection() 归还连接：close()。 如果连接对象Connection是从连接池中获取的，那么调用close()方法，则不会关闭连接，而是归还连接。 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 2. C3P0数据库连接池技术2.1 导入Jar包官方下载地址 下载完后解压，然后导入两个包：c3p0-0.9.5.2.jar和mchange-commons-java-0.2.12.jar Notice：不要忘记导入数据库驱动Jar包 2.2 定义配置文件 名称：c3p0.properties或者c3p0-config.xml 路径：将文件放在src目录下即可。 2.3 创建核心对象 数据库连接池对象：ComboPooledDataSource 基本使用如下： public class C3P0Demo1 { public static void main(String[] args) throws SQLException { &#x2F;&#x2F; 1. 创建数据库连接池对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); &#x2F;&#x2F; 2. 获取一个连接对象 Connection conn = dataSource.getConnection(); &#x2F;&#x2F; 3. 进行具体操作 System.out.println(conn); } } 3. Druid：数据库连接池实现技术3.1 使用步骤 导入jar包：druid-1.0.9.jar 定义配置文件：properties形式的，可以叫任意名称，可以放任意目录下 加载配置文件：使用Properties对象来加载 获取数据库连接池对象：通过工厂类DruidDataSourceFactory来获取 获取连接：getConnection 3.2 基本使用示例 &#x2F;&#x2F; Druid演示 public class DruidDemo1 { public static void main(String[] args) throws Exception { &#x2F;&#x2F; 1. 定义配置文件 &#x2F;&#x2F; 2. 加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); &#x2F;&#x2F; 3. 获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#x2F;&#x2F; 4. 获取连接 Connection conn = ds.getConnection(); &#x2F;&#x2F; 5. 进行具体操作 System.out.println(conn); } } 3.3 定义工具类 定义一个类 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 代码实现 &#x2F;&#x2F; Druid连接池的工具类 public class DruidUtils { &#x2F;&#x2F; 1. 定义成员变量 private static DataSource ds; &#x2F;&#x2F; 静态初始化代码块 static{ try { Properties pro = new Properties(); pro.load(DruidUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); &#x2F;&#x2F; 获取DataSource对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (Exception e) { e.printStackTrace(); } } &#x2F;&#x2F; 获取连接 public static Connection getConnection() throws SQLException { return ds.getConnection(); } &#x2F;&#x2F; 释放资源 public static void close(Statement stmt,Connection conn){ close(null,stmt,conn); } public static void close(ResultSet rs, Statement stmt, Connection conn){ if (rs!=null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt!=null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } &#x2F;&#x2F; 获取连接池方法 public static DataSource getDataSource(){ return ds; } } &#x2F;&#x2F; 测试工具类 &#x2F;&#x2F; 使用工具类 public class DruidDemo2 { public static void main(String[] args) { &#x2F;&#x2F; 完成添加操作，给account表添加一条记录 Connection conn = null; PreparedStatement pstmt = null; try { &#x2F;&#x2F; 获取连接池对象 conn = DruidUtils.getConnection(); &#x2F;&#x2F; 定义sql String sql = &quot;insert into account values(null,?,?)&quot;; &#x2F;&#x2F; 获取执行sql对象 pstmt = conn.prepareStatement(sql); &#x2F;&#x2F; 给？赋值 pstmt.setString(1,&quot;小六&quot;); pstmt.setDouble(2,2699); &#x2F;&#x2F; 执行sql int count = pstmt.executeUpdate(); System.out.println(count); } catch (SQLException e) { e.printStackTrace(); }finally { DruidUtils.close(pstmt,conn); } } } 4. Spring JDBC是Spring框架对JDBC的简单封装，提供了一个JDBCTemplate对象简化JDBC的开发 4.1 使用步骤 导入Jar包 创建JDBCTemplate对象，该对象依赖于数据源DataSource，例：JdbcTemplate template = new JdbcTemplate(ds); 调用JDBCTemaplate的方法来完成CRUD的操作 常用方法： 方法名 作用 update() 执行DML语句。增、删、改语句 queryForMap() 查询结果，将结果集封装为Map集合。列名作key，值作value，将这条记录封装为一个Map集合返回。注：该方法查询结果集长度只能是1 queryForList() 查询结果，将结果集封装为List集合。将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 queryForObject() 查询结果，将结果封装为对象。一般用于聚合函数的查询 query() 查询结果，将结果封装为JavaBean对象。一般我们使用new BeanPropertyRowMapper&lt;类型&gt;(类型.class)来完成数据到JavaBean的自动封装。 4.2 使用示例 &#x2F;&#x2F; jdbcTemplate基础入门 public class JDBCTemplateDemo1 { public static void main(String[] args) { &#x2F;&#x2F; 创建jdbcTemplate对象 JdbcTemplate jt = new JdbcTemplate(DruidUtils.getDataSource()); &#x2F;&#x2F; 调用方法 String sql = &quot;update account set balance=3000 where id=?&quot;; int count = jt.update(sql, 6); &#x2F;&#x2F; 返回值是影响的行数 System.out.println(count); &#x2F;&#x2F; 1 } } 4.3 练习 修改6号数据的salary为10000 添加一条记录 删除刚刚添加的记录 查询id为8的记录，将其封装为Map集合 查询所有记录，将其封装为List 查询所有记录，将其封装为Emp对象的List集合 查询总记录数 public class Exercise { &#x2F;&#x2F; 获取JdbcTemplate对象 &#x2F;&#x2F; 使用Junit单元测试，让方法单独执行 private JdbcTemplate jt = new JdbcTemplate(DruidUtils.getDataSource()); &#x2F;&#x2F; 编写sql语句并执行 @Test public void test1(){ &#x2F;&#x2F; 1. 修改6号数据的salary为10000 String update = &quot;update staff set salary=10000 where id=?&quot;; jt.update(update,6); } @Test public void test2(){ &#x2F;&#x2F; 2. 添加一条记录,字段分别为id，name，性别，工资，入职时间，部门id jt.update(&quot;insert into staff(id,name,salary) values(?,?,?)&quot;,13,&quot;冬兵&quot;,7889); } @Test public void test3(){ &#x2F;&#x2F; 3. 删除刚刚添加的记录 jt.update(&quot;delete from staff where name=?&quot;,&quot;冬兵&quot;); } @Test public void test4(){ &#x2F;&#x2F; 4. 查询id为8的记录，将其封装为Map集合 &#x2F;&#x2F; 注意：这个方法查询的结果集只能是1 Map&lt;String, Object&gt; stringObjectMap = jt.queryForMap(&quot;select * from staff where id=?&quot;, 8); System.out.println(stringObjectMap); &#x2F;&#x2F; {id=8, name=美队, gender=男, salary=8000.0, join_date=2008-08-08, dept_id=2} } @Test public void test5(){ &#x2F;&#x2F; 5. 查询所有记录，将其封装为List List&lt;Map&lt;String, Object&gt;&gt; maplist = jt.queryForList(&quot;select * from staff&quot;); for (Map&lt;String, Object&gt; stringObjectMap : maplist) { System.out.println(stringObjectMap); } } @Test public void test6(){ &#x2F;&#x2F; 6. 查询所有记录，将其封装为Emp对象的List集合，自己完成实现类 String sql = &quot;select * from staff&quot;; List&lt;Emp&gt; list = jt.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet rs, int i) throws SQLException { Emp emp = new Emp(); int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String gender = rs.getString(&quot;gender&quot;); double salary = rs.getDouble(&quot;salary&quot;); Date join_date = rs.getDate(&quot;join_date&quot;); int dept_id = rs.getInt(&quot;dept_id&quot;); emp.setId(id); emp.setName(name); emp.setGender(gender); emp.setSalary(salary); emp.setJoin_date(join_date); emp.setDept_id(dept_id); return emp; } }); for (Emp emp : list) { System.out.println(emp); } } @Test public void test6_2() { &#x2F;&#x2F; 6. 查询所有记录，将其封装为Emp对象的List集合,使用jdbc提供的实现类来完成 String sql = &quot;select * from staff&quot;; List&lt;Emp&gt; list = jt.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) { System.out.println(emp); } &#x2F;* Failed to convert property value of type &#39;null&#39; to required type &#39;int&#39; for property &#39;dept_id&#39; 需要将Emp类中变量改为为引用数据类型,然后重新生成方法 *&#x2F; } @Test public void test7(){ &#x2F;&#x2F; 7. 查询总记录数 String sql = &quot;select count(id) from staff&quot;; Long count = jt.queryForObject(sql, Long.class); System.out.println(count); } }","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://zero024.cn/tags/JDBC/"}]},{"title":"JDBC","slug":"JavaWeb/JDBC","date":"2019-05-24T15:59:00.000Z","updated":"2020-03-04T07:17:43.589Z","comments":true,"path":"JavaWeb/undefined.html","link":"","permalink":"https://zero024.cn/JavaWeb/undefined.html","excerpt":"1. JDBCJava数据库连接(Java DataBase Connectivity)，简称JDBC。是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组Java语言编写的类好接口组成。","text":"1. JDBCJava数据库连接(Java DataBase Connectivity)，简称JDBC。是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组Java语言编写的类好接口组成。 1.1 客户端操作MySQL数据库的方式 使用第三方客户端访问：SQLyog、Navicat、SQLWave、MyDB Studio等等 使用MySQL自带的命令行方式 通过Java API来访问MySQL数据库 1.2 什么是JDBCJDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动jar包中的实现类。 使用JDBC的好处 如果要开发访问数据库的程序，只需会调用JDBC接口中的方法即可，不用关注类具体实现 使用同一套Java代码，进行少量的修改就可以访问其他JDBC支持的数据库了 1.3 使用JDBC开发使用到的包 使用的包 说明 java.sql 所有与JDBC访问数据库相关的接口和类 javax.sql 数据库扩展包，提供数据库额外的功能。如连接池 数据库的驱动 由各大数据库厂商提供，需要额外去下载，是对JDBC接口实现的类 1.4 JDBC的核心API 接口或类 作用 DriverManager类 1. 管理和注册数据库驱动；2. 得到数据库连接对象 Connection接口 一个连接对象，可用于创建Statement和PreparedStatement对象 Statement接口 一个SQL语句对象，用于将SQL语句发送给数据库服务器 PrepareStatement接口 一个SQL语句对象，是Statement的子接口 ResultSet接口 用于封装数据库查询的结果集，返回给客户端Java程序 1.5 导入驱动Jar包 1.6 加载和注册驱动 加载和注册驱动的方法 描述 Class.forName(数据库驱动实现类) 加载和注册数据库驱动，数据库驱动由mysql厂商提供：”com.mysql.jdbc.Driver” 从JDBC3开始，弃用了驱动类“com.mysql.jdbc.Driver”，新的驱动程序类是“com.mysql.cj.jdbc.Driver”。驱动程序是通过SPI自动注册的，通常不需要手动加载驱动程序类。 2. DriverManager类驱动管理对象类，该类的作用是管理和注册驱动，以及创建数据库的连接。 注：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2.1 获取数据库连接 Connection getConnection(String url,String user,String password)：通过连接字符串，用户名，密码来得到数据库的连接对象 Connection getConnection(String url,Properties info)：通过连接字符串，属性对象来得到连接对象 参数说明： 参数列表 说明 用户名 登录的用户名 密码 登录的密码 连接字符串URL 不同的数据库URL是不同的，MySQL的写法：jdbc:mysql://localhost:3306/数据库名[?参数名=参数值] 驱动类的字符串名 com.mysql.cj.jdbc.Driver 连接数据库URL地址格式：协议名:子协议://服务器名或IP地址:端口号/数据库名?参数=参数值&amp;参数2=值2 在本地服务器的情况下：MySQL中可简写为jdbc:mysql:///数据库名 乱码问题处理 如果数据库出现乱码，可以指定参数：?characterEncoding=utf8，表示让数据库以UTF-8编码来处理数据。 2.2 快速入门 使用用户名、密码、URL来得到连接对象 public class Demo01JDBC { public static void main(String[] args) throws Exception{ &#x2F;&#x2F; 1. 导入jar驱动包 &#x2F;&#x2F; 2.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); &#x2F;&#x2F; com.mysql.jdbc.Driver已弃用，且该语句jdbc3后可省略 &#x2F;&#x2F; 3. 使用用户名密码来获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db1?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;123456&quot;); &#x2F;&#x2F; 4. 定义sql语句 String sql = &quot;update account set balance=1000 where id=1&quot;; &#x2F;&#x2F; 5. 获取执行sql语句的对象 Statement stat = conn.createStatement(); &#x2F;&#x2F; 6. 执行sql语句 int count = stat.executeUpdate(sql); &#x2F;&#x2F; 7. 处理结果 System.out.println(count); &#x2F;&#x2F; 8. 释放资源 stat.close(); conn.close(); } } 从JDBC3开始，弃用了驱动类“com.mysql.jdbc.Driver”，新的驱动程序类是“com.mysql.cj.jdbc.Driver”。驱动程序是通过SPI自动注册的，通常不需要手动加载驱动程序类。 使用属性文件和URL得到连接对象 public class Demo02JDBC { public static void main(String[] args) throws SQLException { &#x2F;&#x2F; 1. 定义URL连接字符串 String url = &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?serverTimezone=UTC&quot;; &#x2F;&#x2F; 本地服务器且端口号3306.故省略 &#x2F;&#x2F; 2. 创建属性对象 Properties info = new Properties(); &#x2F;&#x2F; 3. 将用户名和密码放入info对象中 info.setProperty(&quot;user&quot;,&quot;root&quot;); info.setProperty(&quot;password&quot;,&quot;123456&quot;); &#x2F;&#x2F; 4. 通过属性文件来获取数据库连接对象 Connection conn = DriverManager.getConnection(url, info); System.out.println(conn); &#x2F;&#x2F; com.mysql.cj.jdbc.ConnectionImpl@51cdd8a：获取的是连接对象的内存地址值 } } 3. Connection接口Connection 接口，具体的实现类由数据库的厂商实现，代表一个连接对象。 3.1 主要方法 获取执行sql的对象： Statement createStatement(String sql) PreparedStatement preparedStatement(String sql) 管理事务： 开启事务：setAutoCommit(boolean autoCommit):调用该方法设置参数为fasle，即开启事务 提交事务：commit() 回滚事务：rollback() 4. Statement接口用于执行静态SQL语句并返回其生成的结果对象 4.1 主要方法 boolean execute(String sql)：可以执行任意的sql int executeUpdate(String sql)：执行DML(insert、update、delete)语句、DDL(create、alter、drop)语句。返回值：影响的行数，可以通过判断行数来确定语句是否执行成功。 ResultSet executeQuery(String sql)：执行DQL(select)语句。返回结果集对象 4.2 演示案例 account表中添加一条记录，使用insert语句 public class Demo03JDBC { public static void main(String[] args) { Statement stmt = null; Connection conn = null; try { &#x2F;&#x2F; 1. 注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); &#x2F;&#x2F; 2. 定义sql String sql = &quot;insert into account values(null,&#39;小王&#39;,3000)&quot;; &#x2F;&#x2F; 3. 获取连接数据库对象 conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?serverTimezone=UTC&amp;characterEncoding=gbk&quot;, &quot;root&quot;, &quot;123456&quot;); &#x2F;&#x2F; 4. 获取执行sql的对象 Statement，并传入sql语句执行 stmt = conn.createStatement(); int count = stmt.executeUpdate(sql); &#x2F;&#x2F; 返回值影响的行数 &#x2F;&#x2F; 5. 处理结果 if (count&gt;0) System.out.println(&quot;添加成功&quot;); else System.out.println(&quot;添加失败&quot;); } catch (Exception e) { e.printStackTrace(); }finally { &#x2F;&#x2F;stmt.close(); &#x2F;&#x2F; 避免空指针异常 if(stmt!=null &amp;&amp; conn!=null){ try { stmt.close(); conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 修改一条表记录 &#x2F;&#x2F; 只需在上述代码基础上改动sql语句即可 String sql = &quot;update account set balance=2000 where name=&#39;小王&#39;&quot;; conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?serverTimezone=UTC&amp;characterEncoding=gbk&quot;, &quot;root&quot;, &quot;123456&quot;); stmt = conn.createStatement(); int count = stmt.executeUpdate(sql); &#x2F;&#x2F; 返回值影响的行数 if (count&gt;0) System.out.println(&quot;修改成功&quot;); else System.out.println(&quot;修改失败&quot;); 删除一条表记录 &#x2F;&#x2F; 改动sql语句即可 public class DelJDBC { public static void main(String[] args) { Connection conn = null; Statement stmt = null; try { Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?serverTimezone=UTC&quot;,&quot;root&quot;,&quot;123456&quot;); stmt = conn.createStatement(); int count = stmt.executeUpdate(&quot;delete from account where id=3&quot;); if (count&gt;0) System.out.println(&quot;delete success!&quot;); else System.out.println(&quot;delete failed!&quot;); } catch (Exception e) { e.printStackTrace(); }finally { if (stmt!=null &amp;&amp; conn!=null) { try { stmt.close(); conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 5. ResultSet接口结果集对象，封装查询的结果 5.1 主要方法 方法 描述 boolean next() 游标向下移动1行，返回布尔类型，如果还有下一条记录返回true，反之false 数据类型 getXxx() 通过字段名或是列编号，填入参数String或是整数(1开始)，返回不同的类型。 常用数据类型转换表 5.2 方法演示 public class DQLJDBC { public static void main(String[] args) { ResultSet rs = null; Connection conn = null; Statement stmt = null; try { Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?serverTimezone=UTC&quot;,&quot;root&quot;,&quot;123456&quot;); stmt = conn.createStatement(); rs = stmt.executeQuery(&quot;select * from account&quot;); &#x2F;&#x2F; 处理结果 while (rs.next()){ &#x2F;&#x2F; 循环判断游标是否是最后一行末尾 int id = rs.getInt(1); &#x2F;&#x2F; 通过列编号获取数据 String name = rs.getString(&quot;name&quot;); &#x2F;&#x2F; 通过列名获取 double balance = rs.getDouble(3); &#x2F;&#x2F; 通过列编号获取 System.out.println(id+&quot;,&quot;+name+&quot;,&quot;+balance); } } catch (Exception e) { e.printStackTrace(); }finally { if (rs!=null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt!=null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } }if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 5.3 练习 定义一个方法：查询users表的数据将其封装为对象，然后装载集合，返回。 &#x2F;&#x2F; 定义存储数据的类 public class Users { private int id; private String name; private int age; private String site; &#x2F;&#x2F; 省略构造方法等 } &#x2F;&#x2F; 定义方法类，实现方法 public class Demo5JDBC { public static void main(String[] args) { List&lt;Users&gt; list = new Demo5JDBC().findAll(); System.out.println(list); } &#x2F;&#x2F; 创建方法，查询所有users对象，返回一个list public List&lt;Users&gt; findAll(){ Connection conn = null; Statement stmt = null; ResultSet rs = null; List&lt;Users&gt; list = null; try { &#x2F;&#x2F; 1. 注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); &#x2F;&#x2F; 2. 获取连接 conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db5?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;123456&quot;); &#x2F;&#x2F; 3. 获取执行sql对象 stmt = conn.createStatement(); &#x2F;&#x2F; 4. 执行sql rs = stmt.executeQuery(&quot;select * from users&quot;); &#x2F;&#x2F; 5. 遍历结果集，封装对象，装载集合 Users us = null; list = new ArrayList&lt;&gt;(); while (rs.next()){ &#x2F;&#x2F; 获取数据 int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); String site = rs.getString(4); &#x2F;&#x2F; 创建users对象,并赋值 us = new Users(); us.setId(id); us.setName(name); us.setAge(age); us.setSite(site); &#x2F;&#x2F; 装载集合 list.add(us); } } catch (Exception e) { e.printStackTrace(); }finally { &#x2F;&#x2F; 释放资源，rs，stmt和conn if (rs!=null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } &#x2F;&#x2F; 省略其他两个，与上方法一样 } return list; } } 6. 自定义数据库工具类JdbcUtils可以把经常用到的功能做成一个工具类，在不同的地方重用。 6.1 主要方法 可以把几个字符串定义成常量：用户名，密码，URL，驱动类 得到数据库的连接：getConnection() 关闭所有打开的资源：close(Connection conn,Statement stmt,ResultSet rs) 和close(ResultSet rs,Statement stmt, Connection conn) 6.2 使用工具类将上一个练习优化 定义工具类在项目目录下新建一个util文件夹，然后新建JDBCUtils.java文件，编写如下内容。 &#x2F;&#x2F; JDBC工具类 public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; &#x2F;&#x2F; 文件的读取，只需读取一次即可拿到这些值：使用静态代码块 static { &#x2F;&#x2F; 读取资源文件，获取配置值 try { &#x2F;&#x2F; 1. 创建Properties集合类 Properties pro = new Properties(); &#x2F;&#x2F; 获取src路径下的文件的方式--&gt;ClassLoader 类加载器,如此就可以动态的获取src的绝对路径 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL resource = classLoader.getResource(&quot;jdbc.properties&quot;); String path = resource.getPath(); System.out.println(path); &#x2F;&#x2F; 2. 加载文件 &#x2F;&#x2F; pro.load(new FileReader(&quot;src&#x2F;jdbc.properties&quot;)); pro.load(new FileReader(path)); &#x2F;&#x2F; 3. 获取属性，赋值 url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver = pro.getProperty(&quot;driver&quot;); &#x2F;&#x2F; 4. 注册驱动 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } &#x2F;&#x2F; 获取连接 public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url,user,password); } &#x2F;&#x2F; 释放资源 public static void close(Statement stmt, Connection conn){ if (stmt!=null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } &#x2F;&#x2F; 释放资源重载 public static void close(ResultSet rs,Statement stmt, Connection conn){ if (rs!=null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (stmt!=null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn!=null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } 定义配置文件在项目源文件src下新建jdbc.properties文件。 url=jdbc:mysql:&#x2F;&#x2F;&#x2F;db5?serverTimezone=UTC&amp;characterEncoding=gbk user=root password=123456 driver=com.mysql.cj.jdbc.Driver 演示用法 public class Demo6JDBCUtil { public static void main(String[] args) { List&lt;Users&gt; list = new Demo6JDBCUtil().findAll2(); System.out.println(list); } &#x2F;** * 演示JDBC工具类 * @return *&#x2F; public List&lt;Users&gt; findAll2(){ Connection conn = null; Statement stmt = null; ResultSet rs = null; List&lt;Users&gt; list = null; try { &#x2F;&#x2F; &#x2F;&#x2F; 1. 注册驱动 &#x2F;&#x2F; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); &#x2F;&#x2F; &#x2F;&#x2F; 2. 获取连接 &#x2F;&#x2F; conn = DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db5?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;123456&quot;); conn = JDBCUtils.getConnection(); &#x2F;&#x2F; 3. 获取执行sql对象 stmt = conn.createStatement(); &#x2F;&#x2F; 4. 执行sql rs = stmt.executeQuery(&quot;select * from users&quot;); &#x2F;&#x2F; 5. 遍历结果集，封装对象，装载集合 Users us = null; list = new ArrayList&lt;&gt;(); while (rs.next()){ &#x2F;&#x2F; 获取数据 int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); String site = rs.getString(4); &#x2F;&#x2F; 创建users对象,并赋值 us = new Users(); us.setId(id); us.setName(name); us.setAge(age); us.setSite(site); &#x2F;&#x2F; 装载集合 list.add(us); } } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); &#x2F;&#x2F; 直接调用方法就可以释放资源 } return list; } } 6.3 练习：登录案例 创建用户表 获取用户输入 查询数据库，与数据库中数据进行匹配 返回结果 public class LoginExercise { public static void main(String[] args) { &#x2F;&#x2F; 获取用户输入 Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入用户名：&quot;); String name = sc.nextLine(); System.out.print(&quot;请输入密码：&quot;); String pwd = sc.nextLine(); if (name==null || pwd==null) System.out.println(&quot;输入内容不能为空&quot;); login(name,pwd); sc.close(); } public static void login(String name,String pwd){ Connection conn = null; Statement stmt = null; ResultSet rs = null; try { &#x2F;&#x2F; 连接数据库，判断是否存在数据 conn = JDBCUtils.getConnection(); stmt = conn.createStatement(); rs = stmt.executeQuery(&quot;select * from users where name=&#39;&quot;+name+&quot;&#39; and pwd=&#39;&quot;+pwd+&quot;&#39;&quot;); if (rs.next()) &#x2F;&#x2F; 返回布尔值，true则存在，false则不存在 System.out.println(&quot;登录成功&quot;); else System.out.println(&quot;用户名或密码错误！&quot;); } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); } } } 7. PreparedStatement接口表示预编译的 SQL 语句的对象。 SQL 语句被预编译并存储在 PreparedStatement 对象中。然后可以使用此对象多次高效地执行该语句。 7.1 SQL注入问题在拼接sql时，如果有一些sql的特殊关键字参与字符串的拼接，会造成安全性问题。 输入密码时，如果输入以下密码，在账户和密码不正确情况下也登录成功 原因 打印了一下查询的SQL语句：select * from user where name=&#39;ehwqhwqek&#39; and pwd=&#39;a&#39; or &#39;1&#39;=&#39;1&#39;;发现当and前面为假，但是or后面为真，语句实际相当于：select * from user where true;查询了所有记录 要解决 SQL 注入就不能让用户输入的密码和我们的 SQL 语句进行简单的字符串拼接。 7.2 解决SQL注入问题使用PreparedStatement对象来解决该问题 预编译的SQL：参数使用?作为占位符,例：select * from users where name = ? and pwd = ? 给？赋值方法：setXxx(?的位置编号(1开始),?的值) 7.2.1 方法演示 &#x2F;&#x2F; 使用prepardStatement对象解决sql注入问题 public class LoginExercise2 { public static void main(String[] args) { &#x2F;&#x2F; 获取用户输入 Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入用户名：&quot;); String name = sc.nextLine(); System.out.print(&quot;请输入密码：&quot;); String pwd = sc.nextLine(); if (name==null || pwd==null) System.out.println(&quot;输入内容不能为空&quot;); login(name,pwd); sc.close(); } &#x2F;* 登录方法，使用PreparedStatement实现 *&#x2F; public static void login(String name,String pwd){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { &#x2F;&#x2F; 连接数据库，判断是否存在数据 conn = JDBCUtils.getConnection(); &#x2F;&#x2F; 定义sql语句 String sql = &quot;select * from users where name = ? and pwd = ?&quot;; &#x2F;&#x2F; 获取执行sql对象 ps = conn.prepareStatement(sql); &#x2F;&#x2F; 将sql传入，进行预编译 &#x2F;&#x2F; 给？赋值 ps.setString(1,name); ps.setString(2,pwd); rs = ps.executeQuery(); if (rs.next()) &#x2F;&#x2F; 返回布尔值，true则存在，false则不存在 System.out.println(&quot;登录成功&quot;); else System.out.println(&quot;用户名或密码错误！&quot;); } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,ps,conn); } } } 7.3 PreparedStatement原理 7.3.1 优点 prepareStatement()会先将 SQL 语句发送给数据库预编译。PreparedStatement 会引用着预编译后的结果。可以多次传入不同的参数给 PreparedStatement 对象并执行。减少 SQL 编译次数，提高效率。 安全性更高，没有SQL输入的隐患 提高了程序的可读性 后期都会使用PreparedStatement来完成增删改查的所有操作 8. JDBC的事务操作 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit):调用该方法设置参数为fasle，即开启事务 提交事务：commit() 回滚事务：rollback() 8.1 银行转账案例步骤分析： 获取连接 开启事务 获取到PreparedStatement 使用PreparedStatement执行两次更新操作 正常情况下提交事务 出现异常回滚事务 释放资源 public class EFT { public static void main(String[] args) { Connection conn = null; PreparedStatement ps1 = null; PreparedStatement ps2 = null; try { &#x2F;&#x2F; 1. 获取连接 conn = JDBCUtils.getConnection(); conn.setAutoCommit(false); &#x2F;&#x2F; 将自动提交关闭，即开启事务 &#x2F;&#x2F; 定义sql，小张-500 String sql1 = &quot;update account set balance = balance - ? where name = ?&quot;; &#x2F;&#x2F; 小李+500 String sql2 = &quot;update account set balance = balance + ? where name = ?&quot;; &#x2F;&#x2F; 获取执行sql对象 ps1 = conn.prepareStatement(sql1); ps2 = conn.prepareStatement(sql2); &#x2F;&#x2F; 给?赋值,小张-500 ps1.setDouble(1,500); ps1.setString(2,&quot;小张&quot;); ps1.executeUpdate(); &#x2F;&#x2F; 执行更新语句 &#x2F;&#x2F; 给?赋值,小李+500 ps2.setDouble(1,500); ps2.setString(2,&quot;小李&quot;); ps2.executeUpdate(); &#x2F;&#x2F; 执行更新语句 &#x2F;&#x2F; 手动制造一个异常 int i = 3&#x2F;0; &#x2F;&#x2F; 提交事务 conn.commit(); System.out.println(&quot;事务执行完毕&quot;); } catch (Exception e) { &#x2F;&#x2F; 事务的回滚 try { if (conn != null) System.out.println(&quot;事务异常！回滚中....&quot;); conn.rollback(); } catch (SQLException ex) { ex.printStackTrace(); } e.printStackTrace(); }finally { &#x2F;&#x2F; 释放资源 JDBCUtils.close(ps1,conn); if (ps2!=null){ try { ps2.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 能够理解JDBC的概念 能够使用DriverManager类 能够使用Connection接口 能够使用Statement接口 能够使用ResultSet接口 能够说出SQL注入原因和解决方案 能够通过PreparedStatement完成增、删、改、查 能够完成PreparedStatement改造登录案例 能够完成JDBC事务操作","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zero024.cn/categories/JavaWeb/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://zero024.cn/tags/JDBC/"}]},{"title":"MySQL多表查询和事务","slug":"Database/MySQL多表查询和事务","date":"2019-05-23T10:00:00.000Z","updated":"2020-03-28T08:45:53.122Z","comments":true,"path":"DataBase/MySQL-Transaction.html","link":"","permalink":"https://zero024.cn/DataBase/MySQL-Transaction.html","excerpt":"1. MySQL多表查询当我们需要查询的数据在多张表时，就需要连接多张表查询，这就是多表查询。","text":"1. MySQL多表查询当我们需要查询的数据在多张表时，就需要连接多张表查询，这就是多表查询。 1.1 表连接查询 数据准备 CREATE DATABASE IF NOT EXISTS `db5` CHARACTER SET gbk; -- 创建部门表 CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(50) ); INSERT INTO dept(NAME) VALUES(&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;); -- 创建员工表 CREATE TABLE staff( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY(dept_id) REFERENCES dept(id) -- 外键 ); INSERT INTO staff(NAME,gender,salary,join_date,dept_id) VALUES (&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1), (&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2), (&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2), (&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3), (&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1); 多表查询的作用 如果想查询孙悟空的名字和他所在的部门名字，就需要使用多表查询。 多表查询的分类 内连接：隐式内连接和显示内连接 外连接：左外连接和右外连接 1.2 笛卡尔积现象 笛卡尔积：有两个集合A、B，取这两个集合中元素的所有组成情况。 使用select * from staff,dept;就会出现该现象 如何消除笛卡尔积现象的影响 查询结果中不是所有的数据组合都是有用的，只有员工表.dept_id=部门表.id的数据才是有用的。所有需要通过设置条件过滤掉无用数据。 SELECT * FROM staff,dept WHERE staff.`dept_id`=dept.`id`; -- 查询员工和部门的名字 SELECT staff.`name`,dept.`name` FROM staff,dept WHERE staff.`dept_id`=dept.`id`; 1.3 内连接用左边表的记录去匹配右边表的记录，如果符合条件的则显示。如：从表.外键=主表.主键 1.3.1 隐式内连接 隐式内连接：不使用join关键字，条件使用where指定。 语法：select 字段名 from 左表,右表 where 条件; -- 查询两张表中，所有员工表外键等于部门表主键的数据 SELECT * FROM staff,dept WHERE staff.`dept_id`=dept.`id`; 1.3.2 显式内连接 显式内连接：使用[inner] JOIN…ON语句, ‘[ ]’表示可省略 语法：select 字段名 from 左表 [inner] join 右表 on 条件; -- 查询钢铁侠的信息，显示员工id、姓名、性别、工资和所在的部门名称 SELECT s.`id`,s.`name`,s.`gender`,s.`salary`,d.`name`部门名称 FROM staff s INNER JOIN dept d ON s.`dept_id`=d.`id` AND s.`name`=&#39;钢铁侠&#39;; &#x2F;* 内连接查询步骤： 1. 确定查询哪些表：员工表和部门表 2. 确定表连接条件：员工表.dept_id = 部门表.id 的数据才是有效的，即消除笛卡尔积现象 3. 确定查询条件：查询钢铁侠的信息，员工表.name=&#39;钢铁侠&#39; 4. 确定显示字段：显示钢铁侠的id、姓名、性别、工资和所在的部门名称 5. 可以使用别名进行优化，如staff as s *&#x2F; 1.4 外连接1.4.1 左外连接用左边表的记录去匹配右边表的记录，如果符合条件的则显示；否则，显示 NULL 语法：select 字段名 fron 左表 left[outer] join 右表 on 条件; 可以理解为：在内连接的基础上保证左表的数据全部显示(左表部门，右表员工情况下) -- 在部门表中增加一个销售部 INSERT INTO dept(NAME) VALUES(&#39;销售部&#39;); -- 使用内连接查询数据 SELECT * FROM dept d INNER JOIN staff s ON d.`id`=s.`dept_id`; -- 使用左外连接查询数据 SELECT * FROM dept d LEFT JOIN staff s ON d.`id`=s.`dept_id`; 用左表记录去匹配右表记录，当不符合条件情况下，仍会显示左表数据，但右表数据会显示为NULL。即在内连接的基础上保证左表数据全部显示。 1.4.2 右外连接用右边表的记录去匹配左边表的记录，如果符合条件的则显示；否则，显示 NULL 语法：select 字段名 from 左表 right[outer]join 右表 on 条件; 可以理解为：在内连接的基础上保证右表的数据全部显示 -- 在员工表中增加一个员工 INSERT INTO staff VALUES(NULL,&#39;蜘蛛侠&#39;,&#39;男&#39;,5880,&#39;2014-4-1&#39;,NULL); -- 使用内连接查询 SELECT * FROM dept d INNER JOIN staff s ON d.`id`=s.`dept_id`; -- 右表新添加的数据将查询不到，因为dept_id值为NULL。 -- 使用右外连接查询 SELECT * FROM dept d RIGHT JOIN staff s ON d.`id`=s.`dept_id`; -- 在内连接基础上，保证显示右表所有数据，即使条件不满足 2. 子查询2.1 子查询概念 一个查询的结果做为另一个查询的条件 有查询的嵌套，内部的查询称为子查询 子查询要使用括号 -- 查询开发部中有哪些员工 -- 通过两条语句查询 SELECT id FROM dept WHERE NAME=&#39;开发部&#39;; -- 先获取开发部门id，1 SELECT * FROM staff WHERE dept_id=1; -- 通过id去查询对应员工 -- 使用子查询语句 SELECT * FROM staff WHERE dept_id = (SELECT id FROM dept WHERE NAME=&#39;开发部&#39;); -- 注意子查询多行单列必须限定子查询字段列只有一个，不能使用* 或两个字段名 2.2 子查询结果的三种情况 子查询的结果是单行单列 子查询的结果是多行单列 子查询的结果是多行多列 2.2.1 子查询结果是一个值(单行单列)的时候 子查询结果只要是单行单列，肯定在 WHERE 后面作为条件，父查询使用：比较运算符，如：&gt; 、&lt;、&lt;&gt;、=等 语法：select 查询显示字段 from 表 where 字段=(子查询); -- 查询工资最高的员工 SELECT staff.`name` FROM staff WHERE salary = (SELECT MAX(salary) FROM staff); -- 查询工资小于平均工资的员工有哪些？ SELECT * FROM staff WHERE salary &lt; (SELECT AVG(salary) FROM staff); 2.2.2 子查询结果是多行单列的时候 子查询结果是多行单列，结果集类似于一个数组，父查询使用IN运算符 语法：select 查询字段 form 表 where 字段 in (子查询); -- 查询工资大于5000的员工，来自于哪些部门的名字 -- 先查询大于5000的员工所在的部门id SELECT dept_id FROM staff WHERE staff.`salary` &gt; 5000; -- 再查询这些部门id对应的部门名称,会报错 SELECT NAME FROM dept WHERE id = (SELECT dept_id FROM staff WHERE salary&gt;5000); -- 错误代码： 1242 Subquery returns more than 1 row -- 使用IN运算符 SELECT NAME FROM dept WHERE id IN(SELECT dept_id FROM staff WHERE salary&gt;5000); -- 查询开发部与财务部所有的员工信息 -- 先查询开发部和财务部的部门id SELECT id FROM dept WHERE NAME IN (&#39;开发部&#39;,&#39;财务部&#39;); -- 通过部门id查询对应有哪些员工 SELECT * FROM staff WHERE dept_id IN (SELECT id FROM dept WHERE NAME IN (&#39;开发部&#39;,&#39;财务部&#39;)); 2.2.3 子查询结果是多行多列子查询结果只要是多列，肯定在 FROM 后面作为表，子查询作为表需要取别名，否则这张表没有名称则无法访问表中的字段 语法：select 查询字段 from (子查询) 表别名 where 条件; -- 查询出 2011 年以后入职的员工信息，包括部门名称 -- 在员工表中查询 2011-1-1 以后入职的员工 SELECT * FROM staff WHERE join_date &gt;=&#39;2011-1-1&#39;; -- 查询所有的部门信息，与上面的虚拟表中的信息组合，找出所有部门 id 等于的 dept_id SELECT * FROM dept d, (SELECT * FROM staff WHERE join_date&gt;=&#39;2011-1-1&#39;) e WHERE d.`id`=e.dept_id; -- 也可以使用表连接查询 SELECT * FROM staff s INNER JOIN dept d ON s.`dept_id`=d.`id` WHERE join_date&gt;=&#39;2011-1-1&#39;; SELECT * FROM staff s INNER JOIN dept d ON s.`dept_id`=d.`id` AND join_date&gt;=&#39;2011-1-1&#39;; 2.2.4 子查询小结 子查询结果只要是单列，则在where后面作为条件 子查询结果只要是多列，则在from后面作为表进行二次查询 3. 事务3.1 事务概述及应用场景 概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 转账操作示例 -- 创建数据表 CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), balance DOUBLE); -- 插入数据 INSERT INTO account(NAME,balance) VALUES(&#39;小张&#39;,1000),(&#39;小李&#39;,1000); &#x2F;* 模拟小张给小李转500元钱，一个转账业务操作最少要执行下面两条语句： 小张账户-500 小李账户+500 *&#x2F; -- 小张账号-500 UPDATE account SET balance = balance-500 WHERE NAME=&#39;小张&#39;; -- 小李账号+500 UPDATE account SET balance = balance+500 WHERE NAME=&#39;小李&#39;; 假设小张账户上-500后，服务器崩溃了。小李账户并没有+500元，如此数据就出现问题了。我们需要保证其中一条SQL语句出现问题，整个转账就算失败。因此需要使用事务。 3.2 手动提交事务MySQL中可以有两种方式进行事务的操作： 手动提交事务 自动提交事务 3.2.1 手动提交事务的SQL语句 功能 SQL语句 开启事务 start transaction; or begin; 提交事务 commit; 回滚事务 rollback; 3.2.2 手动提交事务使用过程 执行成功的情况：开启事务–&gt; 执行多条SQL语句–&gt; 成功：提交事务 执行失败的情况：开启事务–&gt; 执行多条SQL语句–&gt; 失败：事务的回滚 3.2.3 案例演示 模拟小张给小李转500元钱(成功情况) 使用DOS控制台进入MySQL 执行以下SQL语句：1. 开启事务; 2. 小张账户-500; 3. 小李账户+500 使用SQLyog查看数据库，发现数据未改变 在控制台执行commit;提交事务 示意SQLyog查看数据库，发现数据已改变 模拟小张给小李转500元钱(失败情况)，两人账户都重置为1000元。 在控制台执行以下SQL语句：1. 开启事务; 2. 小张账户-500 使用SQLyog查看数据库，发现数据未改变 在控制台执行rollback回滚事务 使用SQLyog查看数据库，发现数据也未改变 小结如果事务中SQL语句没有问题，commit提交事务，会对数据库数据进行改变。如果事务中SQL语句有问题，rollback回滚事务，会回退到开启事务时的状态。 3.3 自动提交事务MySQL 默认每一条 DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执行完毕自动提交事务，MySQL 默认开始自动提交事务。 3.3.1 案例演示：自动提交事务 将金额重置为1000 更新其中某一个账户 使用SQLyog查看数据库；发现数据已改变 3.3.2 取消自动提交 查看 MySQL 是否开启自动提交事务：select @@autocommit; @ 表示全局变量，1表示开启，0关闭。 取消自动提交事务 再次执行更新语句，然后使用SQLyog查看数据库，会发现数据并没有改变 在控制台执行commit提交任务 3.4 事务原理事务开启之后，所有的操作都会临时保存到事务日志中，事务日志只有在得到commit命令才会同步到数据表中，其他任何情况都会情况事务日志(rollback,断开连接等) 3.4.1 原理图 事务的步骤： 客户端连接数据库服务器，创建连接时创建此用户临时日志文件 开启事务后，所有的操作都会先写入到临时日志文件中 所有的查询操作从表中查询，但会结果日志文件加工后才返回 如果事务提交则将日志文件中的数据写入到表中，否则情况日志文件 3.5 回滚点在某些成功的操作完成之后，后续的操作有可能成功有可能失败，但是不管成功还是失败，前面操作都已经成功，可以在当前成功的位置设置一个回滚点。可以供后续失败操作返回到该位置，而不是返回所有操作，这个点称之为回滚点。 3.5.1 回滚点操作语句 作用 语句 设置回滚点 savepoint 回滚点名字 回到回滚点 rollback to 名字 3.5.2 案例演示 将数据重置为1000 开启事务 让小张账户减3次钱，每次10元 设置回滚点：savepoint three_times; 让小张减4次钱，每次10元 回到回滚点：rollback to three_times; 查看结果，分析执行过程 小结：设置回滚点可以让我们在失败的时候回到指定回滚点，而不是回到事务开启的时候。 3.6 事务的隔离级别3.6.1 事务四大特性ACID 事务特性 含义 原子性(Atomicity) 每个事务都是一个整体，不可再拆分，事务中所有的SQL语句要么都执行成功，要么都失败。 一致性(Consistency) 事务在执行前数据库的状态与执行后数据库的状态保持一致。例：转账前两人的总金额是2000，转账后总金额也是2000 隔离性(Isolation) 事务与事务之间不应该相互影响，执行时保持隔离的状态 持久性(Durability) 一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。 3.6.2 事务的隔离级别事务在操作时的理想状态：所有的事务之间保持隔离，互不影响。因为并发操作，多个用户同时访问同一个数据，可以引发并发访问的问题 并发访问的问题 含义 脏读 一个事务读取到了另一个事务中尚未提交的数据 不可重复读 一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取时数据是一致的，这是事务update时引发的问题 幻读 一个事务中两次读取的数据的数量不一致，要求在一个事务多次读取的数据数量是一致的，这是insert或delete时引发的问题 3.6.3 MySQL数据库有四种隔离级别从上往下隔离级别依次递增。“是”表示会出现这种问题，“否”表示不会出现这种问题。 级别 名字 隔离级别 脏读 不可重复读 幻读 默认隔离级别 1 读未提交 read uncommitted 是 是 是 2 读已提交 read committed 否 是 是 Oracle和SQL Server 3 可重复读 repeatable read 否 否 是 4 串行化 serializable 否 否 否 隔离级别越高，性能越差，安全性越高。 3.6.4 MySQL事务隔离级别相关命令 查询全局事务隔离级别：select @@ tx_isolation; 设置事务隔离级别：set global transaction isolation level 级别字符串; 重新登录MySQL生效。 3.6.5 脏读的演示将余额数据重置为1000元 打开A窗口登录MySQL，设置全局隔离级别为最低(read uncommitted) 打开B窗口，AB窗口都开启事务 A窗口更新2个人的账户数据，模拟转账，未提交 B窗口查询账户数据，到账了 A窗口回滚：rollback; B窗口查询账户数据，到账的钱没了 脏读问题非常危险。比如小张向小李购买商品，小张开启事务，向小李账户转入500块钱，然后打电话给小李说钱已经转了。小李查询看钱的确到账了，发货给小张。小张收到货后回滚事务，小李再次查看钱就没了。 解决脏读问题：将全局的隔离级别进行提升 提高A窗口的隔离级别为read committed，并开启事务 重新登录B窗口MySQL，进入数据库并开启事务 A窗口模拟转账操作，更新两个账户数据，未提交 B窗口查询数据，发现没有改变(没有读取到另一个事务未提交的内容) A窗口commit;提交事务，B窗口查询，发现数据改变了(另一个事务提交后的数据才能读取到) 小结：read committed的方式可以避免脏读的发生 3.6.6 不可重复读的演示将数据重置为1000 开启A窗口，并设置全局隔离级别为read committed； 开启B窗口，B窗口开启事务并查询数据 A窗口开启事务，并更新数据 B窗口查询数据，发现两次结果不一致 两次查询输出的结果不同，无法确定哪次是对的，以哪次为准？ 解决不可重复读的问题：将全局隔离级别提升为：repeatable read 将数据重置为1000 A窗口设置隔离级别为：repeatable read B窗口重新登录MySQL，开启事务并查询数据 A窗口开启事务，更新数据 B窗口查询数据，两次查询数据一致 小结同一个事务中为了保证多次查询数据一致，必须使用repeatable read隔离级别 3.7 幻读的演示 幻读主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计)，发现结果不一致(标准档案一般指记录增多，记录的减少应该也算是幻读)。 其实对于 幻读, MySQL的InnoDB引擎默认的RR级别已经通过MVCC自动帮我们解决了, 所以该级别下, 也模拟不出幻读的场景; 退回到 RC 隔离级别的话,又容易把幻读和不可重复读搞混淆。理论上RR级别是无法解决幻读问题的，但是由于InnoDB引擎的RR级别还使用了MVCC, 所以也就避免了幻读的出现。 使用隔离性的最高隔离级别SERIALIZABLE也可以解决幻读, 在该隔离级别下，一个事务没有执行完，其他事务的SQL执行不了，可以挡住幻读。但该隔离级别在实际中很少使用！ 幻读的延伸 4. DCL(Data Control Language) DDL：create/alter/drop DML：insert/ update/delete DQL：select/show DCL：grant/ revoke 默认使用的都是root用户，超级管理员，拥有全部的权限。但是，一个公司里面的数据库服务器上面可能同时运行着很多个项目的数据库。所以，我们应该可以根据不同的项目建立不同的用户，分配不同的权限来管理和维护数据库。 mysqld是MySQL的主程序，服务器端。mysql是MySQL的命令行工具，客户端。 4.1 创建用户 语法：create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;; 关键字说明 关键字 说明 用户名 将创建用户名称 主机名 指定该用户在哪个主机上可以登录，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登录，可以使用通配符% 密码 该用户的登录密码，可以为空(则表示无需密码即可登录服务器) 操作示例 -- 创建 zero 用户，只能在 localhost 这个服务器登录 mysql 服务器，密码为 123 create user &#39;zero&#39;@&#39;%&#39; identified by &#39;123&#39;; -- 创建 zero2用户可以在任何电脑上登录 mysql 服务器，密码为 123 CREATE USER &#39;zero2&#39;@&#39;%&#39; IDENTIFIED BY &#39;123&#39;; -- 创建的用户名都在mysql数据库的user表中可以查看,密码经过了加密 select user.`Host`,user.`User`,user.`authentication_string`PASSWORD FROM USER; 4.2 用户授权用户创建之后，什么权限都没有，需要管理员手动给用户授权 语法：grant 权限1,权限2...on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;; 关键字说明 关键字 说明 grant…on…to 授权关键字 权限 授予用户的权限，如CREATE、ALTER、SELECT、INSERT、UPDATE等。如果要授予所有的权限则使用ALL 数据库名.表名 该用户可以操作哪个数据库的哪些表。如果要授予该用户对所有数据库和表的相应操作权限则可以使用*.* ‘用户名‘@’主机名’ 给哪个用户授权。注意有单引号 操作示例 -- 给 zero 用户分配对 test 这个数据库操作的权限：创建表，修改表，插入记录，更新记录，查询 GRANT CREATE,ALTER,INSERT,UPDATE,SELECT ON db1.* TO &#39;zero&#39;@&#39;localhost&#39;; -- 给 zero2 用户分配所有权限，对所有数据库的所有表 GRANT ALL ON *.* TO &#39;zero2&#39;@&#39;%&#39;; 4.3 撤销权限 语法：revoke 权限1,权限2... on 数据库.表名 from &#39;用户名&#39;@&#39;主机名&#39;; 关键字 关键字 说明 revoke…on…from 撤销授权的关键字 权限 用户的权限，如 CREATE、ALTER、SELECT、INSERT、UPDATE 等，所有的权限则使用 ALL 数据库名.表名 对哪些数据库哪些表做操作。如果要撤销该用户对所有数据库和表的相应操作权限则可以使用*.* ‘用户名‘@’主机名’ 给哪个用户撤销 操作示例 -- 撤销zero2用户对全部数据库的全部权限 REVOKE ALL ON *.* FROM &#39;zero2&#39;@&#39;%&#39;; 4.4 查看权限 语法：show grants for &#39;用户名&#39;@&#39;主机名&#39;; 操作示例 -- 查看zero用户的权限 SHOW GRANTS FOR &#39;zero&#39;@&#39;localhost&#39;; usage是指连接(登录)权限，建立一个用户，就会自动授予其usage权限，无法revoke。 4.5 删除用户 语法：drop user &#39;用户名&#39;@&#39;主机名&#39;; 操作示例 -- 删除zero用户 DROP USER &#39;zero&#39;@&#39;localhost&#39;; 4.6 修改管理员密码 语法：mysqladmin -uroot -p password 新密码 该命令在DOS控制台执行，新密码无需加上引号。 Tips: 请在DBA允许陪同下使用该命令 数据库内修改root密码需使用flush privileges;刷新权限才能生效 4.7 修改普通用户密码 语法：set password for &#39;用户名&#39;@&#39;主机名&#39;=password(&#39;newpwd&#39;); 今日目标 能够使用内连接进行多表查询 能够使用左外连接和右外连接进行多表查询 能够使用子查询进行多表查询 能够理解事务的概念 能够说出事务的特点 能够在MySQL中使用事务 能够理解脏读、不可重复读、幻读的概念及解决方法 能够使用DCL管理MySQL中的用户","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://zero024.cn/categories/DataBase/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://zero024.cn/tags/MySQL/"}]},{"title":"'2019.5.20'","slug":"Jottings/2019-5-20","date":"2019-05-20T15:35:39.000Z","updated":"2020-01-03T11:43:19.613Z","comments":true,"path":"uncategorized/undefined.html","link":"","permalink":"https://zero024.cn/uncategorized/undefined.html","excerpt":"今日随笔 :notebook:今天又是鸽子江的一天! :satisfied: 下面总结一下最近几天的问题 :mag:","text":"今日随笔 :notebook:今天又是鸽子江的一天! :satisfied: 下面总结一下最近几天的问题 :mag: :one:学习效率方面发现最近的学习效率有点问题，经常当天的学习内容都要拖很晚才能完成。也不知道是方法出了问题还是什么。 学习娱乐之间要保持平衡，要有度。 :two: 知识点遗忘学的一些以前的基础知识点，函数、方法什么的，如果不经常使用复习的话，很快就忘记了，应该解决一下这个问题。 复习以往知识点还是要提上日程 :three:关于CoreJava看CoreJava :book: ，给自己规定了每天看10页左右，要二个多月能看完，差不多还能接受，当然进度提高一点最好。且不能光看书，要结合书中知识点实践代码。 在github创建一个CoreJava仓库，将所有的例子分门别类的放进去，方便以后查看。 :four:今天发现的小cookie就是Markdown语法的emoji emoji参考传送门","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://zero024.cn/tags/随笔/"}]},{"title":"MySQL查询操作","slug":"Database/MySQL查询操作","date":"2019-05-19T15:59:00.000Z","updated":"2020-03-28T08:45:03.761Z","comments":true,"path":"DataBase/MySQL-Query.html","link":"","permalink":"https://zero024.cn/DataBase/MySQL-Query.html","excerpt":"1. DQL查询语句1.1 排序 语法：select 字段名 from 表名 order by 字段名1 [ASC|DESC],字段名2 [ASC|DESC]...; 排序方式：ASC(升序,默认值)；DESC(降序)。","text":"1. DQL查询语句1.1 排序 语法：select 字段名 from 表名 order by 字段名1 [ASC|DESC],字段名2 [ASC|DESC]...; 排序方式：ASC(升序,默认值)；DESC(降序)。 # 单列排序 SELECT * FROM student2 ORDER BY math; # 以math为条件升序排序，默认升序 SELECT * FROM student2 ORDER BY math DESC; # 以math为条件进行降序排序 # 组合排序 # 查询所有数据，在数学成绩升序排序的基础上，如果数学成绩相同在以英语成绩降序排序 SELECT * FROM student2 ORDER BY math ASC,english DESC; 注意：同时对多个字段进行排序，如果第1字段相等，则按第2字段排序，依次类推。 1.2 聚合函数将一列数据作为一个整体，进行纵向的计算，返回一个结果值。 count：统计个数，一般选择非空的列(主键) max：求最大值 min：求最小值 sum：求和 avg：求平均值 # 统计学生人数 SELECT COUNT(id) AS 总人数 FROM student2; # 对english列统计个数 SELECT COUNT(english) FROM student2; -- 7 # 对english列统计个数,如果值为NULL，替换为0 SELECT COUNT(IFNULL(english,0)) FROM student2; -- 8 # 查询年龄大于20岁的人数 SELECT COUNT(*) FROM student2 WHERE age&gt;20; # 查询数学成绩总分 SELECT SUM(math) AS 数学成绩总分 FROM student2; # 查询数学成绩平均分 SELECT AVG(math) AS 数学平均分 FROM student2; # 查询数学成绩最高分 SELECT MAX(math) AS 数学最高分 FROM student2; # 查询数学最低分 SELECT MIN(math) AS 数学最低分 FROM student2; IFNULL(列名，默认值)：如果列名不为空，返回该列值。如果为NULL，则返回默认值。 聚合函数的计算排除了NULL值,可以选择非空列进行计算或者使用IFNULL函数 1.3 分组分组查询是指使用group by 语句对查询信息进行分组，相同数据作为一组。 select 字段1,字段2... from 表名 group by 分组字段[HAVING 条件]; # 按性别进行分组，求男女生的数学平均分。 SELECT sex,AVG(math) FROM student2 GROUP BY sex; # 当我们使用某个字段分组，在查询时也需要将这个字段查询出来，否则看不大数据属于哪组的 &#x2F;* group by 将分组字段结果中相同内容作为一组，并且返回每组的第一条数据。单独分组没用，分组的目的就是为了统计，所以一般分组会跟聚合函数一起使用。 *&#x2F; # 查询男女各有多少人 SELECT sex,COUNT(*)男女各有多少人 FROM student2 GROUP BY sex; # 分组函数会先查询所有数据，按性别分组，然后统计每组人数 # 查询年龄大于25岁的人，按照性别分组，统计每组人数 SELECT sex,COUNT(*)年龄大于25岁人数 FROM student2 WHERE age&gt;25 GROUP BY sex; # 查询年龄大于25岁的人，按性别分组，统计每组的人数，并只显示性别人数大于 2 的数据(使用having条件控制) SELECT sex,COUNT(*)年龄大于25岁人数且人数大于2的 FROM student2 WHERE age&gt;25 GROUP BY sex HAVING COUNT(*)&gt;2; # 该SQL语句会先过滤掉年龄小于25岁的人，在按照性别分组，然后统计每组人数，最后显示性别人数大于2的数据 having与where的区别 子句 作用 where子句 对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据。where后面不可以使用聚合函数。 having子句 该子句的作用是筛选满足条件的组，即在分组之后过滤数据。having后面可以使用聚合函数。 1.4 limit语句limit是限制的意思，作用就是限制查询记录的条数。 语句：select 字段列表 from 表名 [where子句][group by子句][limit offset(默认0),length]; # 查询学生表中数据，从第三条开始，显示6条。 SELECT * FROM student2 LIMIT 2,6; # 使用场景：分页，一般使用在类似淘宝商品信息分页。 2. 数据库的备份和还原2.1 备份格式在DOS下，使用语句：mysqldump -u用户名 -p密码 数据库&gt;文件路径 # 备份db4数据库中数据到本地db4.sql文件中 mysqldump -uroot -p123456 db4 &gt; C:\\Java\\JavaWeb\\db4.sql 2.2 还原格式mysql中的命令，登录后使用：use 数据库; source 导入文件的路径; &#x2F;*还原步骤： 1. 删除db4数据库中的所有表 2. 登录mysql，选中数据库 3. 使用source 命令还原数据 4. 查看还原情况 *&#x2F; use db4; source C:\\Java\\JavaWeb\\db4.sql; 3. 数据库表的约束3.1 概述对表中的数据进行限制，保证数据的正确性、有效性和完整性。一个表如果添加了约束，不正确的数据将无法插入到表中。约束在创建表的时候添加比较合适。 3.2 约束种类 约束名 约束关键字 主键 primary key 唯一 unique 非空 not null 外键 foreign key 检查约束 check，注：mysql不支持 3.3 主键用来唯一标识数据库中的每一条记录。通常不用业务字段作为主键，而是单独给每张表设计一个id的字段，把id作为主键。 主键关键字：primary key 主键特点：非空(not null)且唯一 创建主键 在创建表时给字段添加主键：字段名 字段类型 PRIMARY KEY; 在已有表中添加主键：alter table 表名 add primary key(字段名); # 创建表时添加 create table student3( id int primary key; # id设为主键 name varchar(20); age int); # 删除主键 alter table student3 drop primary key; # 在已有表中添加主键 alter table student3 add primary key(id); 主键自增可以使用auto_increment将主键字段设置为自增，数据库会自动生成主键字段值。 修改自增长默认起始值默认地 AUTO_INCREMENT 的开始值是 1，如果希望修改起始值,可以使用如下SQL语句。 创建表时指定起始值 create table 表名( 列名 int primary key auto_increment, )auto_increment=起始值; 创建表后修改起始值 alter table 表名 auto_increment=10; delete和truncate对自增长的影响 delete：删除所有的记录后，自增长没有影响。 truncate：删除后，自增长初始值重新开始了。 3.4 唯一约束用以约束表中某一列不能出现重复的值 语法：字段名 字段类型 unique # 创建学生表4，包含字段(id, name),name 这一列设置唯一约束,不能出现同名的学生 CREATE TABLE student4( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(255) UNIQUE); # 添加学生 INSERT INTO student4(NAME) VALUES(&#39;xiaohua&#39;); INSERT INTO student4(NAME) VALUES(&#39;xiaohua&#39;); # 错误代码： 1062 Duplicate entry &#39;xiaohua&#39; for key &#39;name&#39; # 测试插入null INSERT INTO student4(NAME) VALUES(NULL); # 不会报错，因为null无数据 3.5 非空约束用于约束某一列不能为null 语法：字段名 字段类型 not null -- 创建表学生表5, 包含字段(id,name,gender)其中 name 不能为 NULL CREATE TABLE student5( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100) NOT NULL, gender CHAR(1)); # 添加一条记录其中姓名不赋值 INSERT INTO student5(NAME,gender) VALUES(NULL,&#39;man&#39;); # 错误代码： 1048 Column &#39;name&#39; cannot be null 默认值我们可以为字段指定默认值 语法：字段名 字段类型 default 默认值 -- 创建一个学生表6，包含字段(id,name,address)， 地址默认值是广州 CREATE TABLE student6( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), address VARCHAR(50) DEFAULT &#39;杭州&#39;); -- 添加一条记录,使用默认地址 INSERT INTO student6(NAME,address) VALUES(&#39;xiaozhang&#39;,DEFAULT); -- 添加一条记录,不使用默认地址 INSERT INTO student6(NAME,address) VALUES(&#39;xiaohua&#39;,&#39;上海&#39;); Tips: 如果一个字段设置了非空和唯一约束，那么该字段与主键有什么区别？ 主键在一个表中只能有一个。 自增长只能用在主键上。 3.6 外键约束单表的缺点： # 创建一个员工表包含如下列(id, name, age, dep_name, dep_location),id 主键并自动增长,添加 5 条数据 CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), age INT, dep_name VARCHAR(30), dep_location VARCHAR(30) ); # 添加数据 INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;张三&#39;, 20, &#39;研发部&#39;, &#39;广州&#39;); INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;李四&#39;, 21, &#39;研发部&#39;, &#39;广州&#39;); INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;王五&#39;, 20, &#39;研发部&#39;, &#39;广州&#39;); INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;老王&#39;, 20, &#39;销售部&#39;, &#39;深圳&#39;); INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;大王&#39;, 22, &#39;销售部&#39;, &#39;深圳&#39;); INSERT INTO emp (NAME, age, dep_name, dep_location) VALUES (&#39;小王&#39;, 18, &#39;销售部&#39;, &#39;深圳&#39;); 上数据表的缺点: 一是数据冗余，二是后期可能出现的增删改问题。 解决方案 # 将上述数据表分成两张表，部门表\\员工表 -- 创建部门表(id,dep_name,dep_location) -- 主表，一对多 CREATE TABLE department( id INT PRIMARY KEY AUTO_INCREMENT, dep_name VARCHAR(20), dep_location VARCHAR(20)); -- 创建员工表(id,name,age,dep_id) -- 从表,多对一 CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), age INT, dep_id INT -- 外键对应主表的主键 ); -- 添加两个部门 INSERT INTO department VALUES(NULL, &#39;研发部&#39;,&#39;广州&#39;),(NULL, &#39;销售部&#39;, &#39;深圳&#39;); -- 添加员工，dep_id 表示员工所在部门 INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;张三&#39;, 20, 1); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;李四&#39;, 21, 1); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;王五&#39;, 20, 1); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;老王&#39;, 20, 2); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;大王&#39;, 22, 2); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;小王&#39;, 18, 2); 但是如果我们在employee的dep_id里面输入不存在的部门，数据仍然可以添加，所以要规范dep_id中的数据只能是department表中存在的id。故可以使用外键约束来解决该问题 外键约束 外键：在从表中与主表主键对应的那一列，称为外键。例上从表中的dep_id 主表：一方，用来约束别人的表 从表：多方，被别人约束的表 创建约束语法： 新建表时增加外键：[CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名) 已有表增加外键：ALTER TABLE 从表 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主键字段名); DROP TABLE employee; -- 创建从表 employee 并添加外键约束 emp_depid_fk -- 多方，从表 CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), age INT, dep_id INT, -- 外键对应主表的主键 -- 创建外键约束 CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id) ); -- 正常添加数据 INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;张三&#39;, 20, 1); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;李四&#39;, 21, 1); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;王五&#39;, 20, 1); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;老王&#39;, 20, 2); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;大王&#39;, 22, 2); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;小王&#39;, 18, 2); -- 插入数据，指定一个不存在的部门值 INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;老板&#39;, 35, 6); # 错误代码： 1452 Cannot add or update a child row: a foreign key constraint fails (`db4`.`employee`, CONSTRAINT `emp_depid_fk` FOREIGN KEY (`dep_id`) REFERENCES `department` (`id`)) 删除外键 语法：ALTER TABLE 从表 drop foreign key 外键名称; -- 删除employee表的emp_depid_fk外键 ALTER TABLE employee DROP FOREIGN KEY emp_depid_fk; -- 在 employee 表存在的情况下添加外键 ALTER TABLE employee ADD CONSTRAINT emp_depid_fk FOREIGN KEY(dep_id) REFERENCES department(id); 外键的级联 级联操作：在修改和删除主表的主键时，同时更新或删除副表的外键值，称为级联操作。 级联操作语法 描述 ON UPDATE CASCADE 级联更新，只能是创建表的时候创建级联关系。更新主表中的主键，从表中的外键列也自动同步更新 ON DELETE CASCADE 级联删除 -- 删除 employee 表，重新创建 employee 表，添加级联更新和级联删除 DROP TABLE employee; CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), age INT, dep_id INT, -- 外键对应主表的主键 -- 创建外键约束 CONSTRAINT emp_depid_fk FOREIGN KEY (dep_id) REFERENCES department(id) ON UPDATE CASCADE ON DELETE CASCADE # 添加级联更新和级联删除 ); -- 再次添加数据到员工表和部门表 INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;张三&#39;, 20, 1); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;李四&#39;, 21, 1); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;王五&#39;, 20, 1); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;老王&#39;, 20, 2); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;大王&#39;, 22, 2); INSERT INTO employee (NAME, age, dep_id) VALUES (&#39;小王&#39;, 18, 2); DROP TABLE department; # Cannot delete or update a parent row: a foreign key constraint fails # 把部门表中 id 等于 1 的部门改成 id 等于 10 UPDATE department SET id=10 WHERE id=1; # 1 queries executed, 1 success, 0 errors, 0 warnings -- 删除部门号是 2 的部门 DELETE FROM department WHERE id=2; 3.7 数据约束小结 约束名 关键字 说明 主键 primary key 唯一且非空 默认 default 如果一列没有值，使用默认值 非空 not null 这一列必须有值 唯一 unique 这一列不能有重复值 外键 foreign key 主表中主键列，在从表中外键列 4. 表与表之间的关系 表与表之间的三种关系 一对多：最常用的关系 部门和员工 多对多：学生选课表 和 学生表， 一门课程可以有多个学生选择，一个学生选择多门课程 一对一：相对使用比较少。员工表 简历表， 公民表 护照表 4.1 一对多一对多(1:n) 例如：班级和学生，部门和员工，客户和订单，分类和商品 一对多建表原则: 在从表(多方)创建一个字段,字段作为外键指向主表(一方)的主键 4.2 多对多多对多(m:n) 例如：老师和学生，学生和课程，用户和角色 多对多关系建表原则: 需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主 键。 4.3 一对一一对一（1:1） 可以在任意一方添加外键指向另一方的主键。 两种建表原则： 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一 UNIQUE 外键是主键：主表的主键和从表的主键，形成主外键关系 4.4 综合案例根据途牛网的旅游分类、旅游航线等信息设计数据库表结构 SQL语句实现 &#x2F;* 1. 创建旅游线路分类表，tab_category cid 主键，自增 cname 分类名称，唯一， *&#x2F; CREATE TABLE tab_category( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) UNIQUE ); &#x2F;* 2. 创建航线route表 rid ，旅游线路主键，自增 rname 旅游线路名称，非空唯一， price 价格 rdate 上架时间， cid 外键 *&#x2F; CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) UNIQUE NOT NULL, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY(cid) REFERENCES tab_category(cid) -- 外键指向主表主键 ); &#x2F;* 3. 创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 *&#x2F; CREATE TABLE tab_user( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT &#39;男&#39;, telephone VARCHAR(11), email VARCHAR(100) ); &#x2F;* 4. 创建用户和航线的中间表，收藏表: 创建收藏表 tab_favorite rid 旅游线路id,外键 date 收藏时间 uid 用户 id,外键 rid 和 uid 不能重复,设置复合主键,同一个用户不能收藏同一个线路两次 *&#x2F; CREATE TABLE tab_favorite( rid INT, -- 旅游线路id favtime DATETIME, uid INT, -- 用户id -- 创建复合主键 PRIMARY KEY(rid,uid), FOREIGN KEY(rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid) ); 架构图 4.5 表与表之间的关系小结 表与表的关系 关系的维护 一对多 主外键的关系 多对多 中间表，两个一对多 一对一 特殊一对多，从表中的外键设为唯一；从表的主键又是外键 6. 数据库设计 范式：好的数据库设计对数据的存储性能和后期的程序开发，都会产生重要的影响。建立科学的，规范的数据库就需要满足一些规则来优化数据的设计和存储，这些规则就称为范式。 6.1 三大范式 范式概念：设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式。各种范式呈递次规范，越高的范式数据库冗余越小。 六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了 6.2 第一范式:1NF数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。简而言之，第一范式每一列不可再拆分，称为原子性。 示例：班级表 学号 姓名 班级 1 小张 103班 2 小李 102班 3 小王 203班 6.3 第二范式：2NF在INF的前提下，非码属性必须完全依赖于码(在1NF基础上消除非主属性对主码的部分函数依赖)，即让表中的非主属性字段都完全依赖于主键。所谓完全依赖是指不能存在仅依赖主键一部分的列。简而言之，第二范式就是在第一范式的基础上所有列完全依赖于主键列。 概念 学号 姓名 系名 系主任 课程名称 分数 10010 张无忌 经济系 张三丰 高等数学 95 10010 张无忌 经济系 张三丰 大学英语 87 10010 张无忌 经济系 张三丰 计算机基础 65 10011 令狐冲 法律系 任我行 法理学 77 10011 令狐冲 法律系 任我行 大学英语 87 10011 令狐冲 法律系 任我行 法律社会学 65 10012 杨过 法律系 任我行 法律社会学 95 10012 杨过 法律系 任我行 法理学 97 10012 杨过 法律系 任我行 大学英语 99 函数依赖：A–&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A。例：学号–&gt;姓名，通过学号可以确定唯一姓名值，故称姓名依赖于学号 ；(学号，课程名称) –&gt; 分数，通过学号+课程名称可以确定唯一分数值，故分数依赖于学号+课程名称。 完全函数依赖：A–&gt;B,如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。例：(学号，课程名称) –&gt; 分数，确定分数的值只能通过(学号+课程名称)属性组确定，故分数完全依赖于(学号+课程名称)。 部分函数依赖：A–&gt;B, 如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值即可。例如：(学号，课程名称) –&gt;姓名，姓名属性值可以通过学号查询，故称姓名属性值部分依赖于(学号，课程名称)属性组。 传递函数依赖：A—&gt;B, B—&gt;C, 如果通过A属性(属性组)的值，可以确定唯一的B属性值，在通过B属性值可以确定唯一C属性值，则称C传递函数依赖于A。例如：学号–&gt;系名，系名–&gt;系主任，通过学号属性值可以确定唯一系名，通过系名可以确定唯一系主任，那么就可以通过学号确定系主任，故称系主任传递依赖于学号。 码：如果在一张表中，一个属性或属性组，被其他所有属性完全依赖，则称这一属性或属性组为该表的码。例如：上表中的码为：(学号，课程名称)，通过该属性组可确定所有其他属性值，所有其他属性完全依赖于该属性组，故称为码。 主属性：码属性组中的所有属性 非主属性：除码属性组外的属性 第二范式的特点： 一张表只描述一件事情。 表中的每一列都完全依赖于主键 6.4 第三范式：3NF在2NF基础上，任何非主属性不依赖于其他非主属性(在2NF基础上消除传递依赖)，即表中每一列都直接依赖于主键，而不是通过其他的列来间接依赖于主键，任何非主列不得传递依赖于主键。 示例： 有如下学生信息表 学号 姓名 所在学院 学院地点 1 小明 计算机系 杭州校区 存在传递依赖关系：学号–&gt;所在学院–&gt;学院地点 消除依赖，拆分成两张表 学生表：| 学号 | 姓名 | 所在学院编号(外键) || —- | —- | —————— || 1 | 小明 | 1 | 学院表：| 学院编号 | 学院地点 || ——– | ——– || 1 | 杭州校区 | 6.5 三大范式总结 范式 特点 1NF 原子性：表中每列不可再拆分 2NF 不产生局部依赖，一张表只描述一件事情 3NF 不产生传递依赖，表中每一列都直接依赖于主键。而不是通过其他列间接依赖于主键。","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://zero024.cn/categories/DataBase/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://zero024.cn/tags/MySQL/"}]},{"title":"MySQL基础","slug":"Database/MySQL基础","date":"2019-05-18T15:40:00.000Z","updated":"2020-03-28T08:44:41.492Z","comments":true,"path":"DataBase/MySQL-Basic.html","link":"","permalink":"https://zero024.cn/DataBase/MySQL-Basic.html","excerpt":"1. 数据库基本概念数据库(DataBase)，简称DB，用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据。数据库其实就是一个文件系统。 方便存储和管理数据。 使用了统一的方式操作数据库。","text":"1. 数据库基本概念数据库(DataBase)，简称DB，用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据。数据库其实就是一个文件系统。 方便存储和管理数据。 使用了统一的方式操作数据库。 安装MySQL MySQL基本操作 Tips：在MySQL中，数据库等于文件夹，表等于文件，数据就是数据。 2. SQL语句Structured Query Language(结构化查询语句)，简称SQL。 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在异同的地方。 2.1 SQL通用语法 SQL语句可以单行或多行书写，以分号结尾。 可以使用空格和缩进来增强语句的可读性。 MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。 注释方式： 单行注释：– 注释内容 或 # 注释内容(MySQL特有) 多行注释：/* 注释内容 */ 2.2 SQL分类 数据定义语言(Data Definition Language)，简称DDL。用来定义数据库对象：数据库、表、列等。关键字：create、drop、alter等。 数据操作语言(Data Manipulation Language)，简称DML。用来对数据库中表的数据进行增删改。关键字：insert、delete、update等。 数据查询语言(Data Query Language)，简称DQL。用以查询数据库中表的记录(数据)。关键字：select，where等。 数据控制语言(Data Control Language)，简称DCL。用来定义数据库的访问权限和安全级别，以及创建用户。关键字：GRANT,REVOKE等。 DDL：操作数据库、表操作数据库： CRUD 1. C(Create):创建 创建数据库：create databases 数据库名称; 创建数据库，判断不存在才创建：create database if not exists 数据库名称; 创建数据库，指定字符集：create database 数据库名称 character set 字符集名; 例：创建db4数据库，判断是否存在，并指定字符集为gbk：create database if not exists db4 character set gbk; 2. R(Retrieve):查询 查询所有数据库名称：show databases; 查询某个数据库的创建语句和字符集：show create database 数据库名称; 3. U(Update):修改 修改数据库的字符集:alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 删除数据库：drop database 数据库名称; 判断数据库存在才删除：drop database if exists 数据库名称; 5. 使用数据库 查询当前正在使用的数据库名称：select database(); 使用数据库：use 数据库名称; 操作表：CRUD 1. C(Create)：创建 create table 表名( 列名1 数据类型1, 列名2 数据类型2, ... ... 列名n 数据类型n); # 注意：最后一列，不需要加逗号&#39;,&#39; &#x2F;* 常用数据库类型: 1. int：整数类型。例：`age int` 2. double：小数类型。例：`score double(5,2)` 3. date：日期(年月日)。例：`date yyyy-MM-dd` 4. datetime：日期(年月日时分秒)。例：`date yyyy-MM-dd HH:mm:ss` 5. timestamp：时间戳类型(年月日时分秒)。如不赋值，则默认使用当前系统时间，来自动赋值。 6. varchar：字符串类型。例：`name` *&#x2F; Tips: 如果想复制一张表，可以使用create table 表名 like 被复制表名; 2. R(Retrieve)：查询 查询某个数据库中所有表的名称：show tables; 查询表结构：desc 表名; 3. U(Update)：修改 修改表名：alter table 表名 rename to 新的表名; 修改表的字符集：alter table 表名 character set 字符集名称; 添加一列：alter table 表名 add 列名 数据类型; 修改列名称：alter table 表名 change 列名 新列名 新数据类型; 修改列数据类型：alter table 表名 modify 列名 新数据类型; 删除列：alter table 表名 dorp 列名; 4. D(Delete)：删除 删除表：drop table 表名; 判断表存在才删除：drop table if exists 表名; DML：增删改表中数据1. 添加数据 语法：insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); 注意事项：列名和值要一一对应；如果表名后面不定义列名，则默认给所有列添加值；除了数字类型，其他类型需要使用单双引号引起来。 2. 删除数据 语法：delete from 表名 [where 条件] 注意事项：如果不指定条件，则删除表中所有记录；如果要删除表所有记录，推荐使用TRUNCATE TABLE 表名; 3. 修改数据 语法：update 表名 set 列名1=值1,列名2=值2,...[where 条件]; 注意：如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录简单查询： 查询表所有行和列的数据：select * from 表名; 查询指定列：select 字段名1,字段名2,...from 表名; 指定列/表的别名进行查询：select 字段名1 AS 别名1,字段名2 AS 别名2,... from 表名 AS 表别名; Tips: 表使用别名一般用于多表查询操作。 清除重复值： 查询指定列并且结果不出现重复数据：select distinct 字段名 from 表名; 查询结果参与运算： 某列数据和固定值运算：select 列名1+固定值 from 表名; 某列数据和其他列数据参与运算：select 列名1+列名2 from 表名; 注意：参与运算的必须是数值类型 SQL语句示例： &#x2F;* 给student表添加数学、英语成绩列，给每条记录添加对应的数学和英语成绩，查询时将数学和英语的成绩相加显示。 *&#x2F; SELECT * FROM student; ALTER TABLE student ADD math INT; # 添加数学列 ALTER TABLE student ADD english INT; # 添加英语列 -- 两位同学添加数学英语成绩 UPDATE `student` SET `math` = &#39;86&#39; , `english` = &#39;94&#39; WHERE `age` = &#39;19&#39; AND `name` = &#39;xiaoming&#39; AND `math` IS NULL AND `english` IS NULL; UPDATE `student` SET `math` = &#39;79&#39; , `english` = &#39;88&#39; WHERE `age` = &#39;18&#39; AND `name` = &#39;xiaohua&#39; AND `math` IS NULL AND `english` IS NULL; -- 给所有数学加5分 SELECT math+5 FROM student; -- 查询math+english的和 SELECT math+english FROM student; -- 查询总成绩，并使用别名显示 SELECT *,(math+english) AS 总成绩 FROM student; 条件查询： 根据指定查询条件，对信息进行过滤显示，语句：select 字段名 from 表名 where 条件; SQL语句示例 -- 创建一个学生表，包含如下列： CREATE TABLE student2( id INT, -- 编号 NAME VARCHAR(20), # 姓名 age INT, -- 年龄 sex VARCHAR(5), # 性别 address VARCHAR(100), -- 地址 math INT, # 数学 english INT -- 英语 ); INSERT INTO student2(id,NAME,age,sex,address,math,english) VALUES(1,&#39;马云&#39;,55,&#39;男&#39;,&#39; 杭州&#39;,66,78),(2,&#39;马化腾&#39;,45,&#39;女&#39;,&#39;深圳&#39;,98,87),(3,&#39;马景涛&#39;,55,&#39;男&#39;,&#39;香港&#39;,56,77),(4,&#39;柳岩 &#39;,20,&#39;女&#39;,&#39;湖南&#39;,76,65),(5,&#39;柳青&#39;,20,&#39;男&#39;,&#39;湖南&#39;,86,NULL),(6,&#39;刘德华&#39;,57,&#39;男&#39;,&#39;香港 &#39;,99,99),(7,&#39;马德&#39;,22,&#39;女&#39;,&#39;香港&#39;,99,99),(8,&#39;德玛西亚&#39;,18,&#39;男&#39;,&#39;南京&#39;,56,65); 运算符 比较运算符 说明 &gt;、&lt;、&lt;=、&gt;=、=、&lt;&gt; &lt;&gt;在SQL中表示不等于，在sql中也可以使用!=，没有== BETWEEN…AND 在一个范围之内，如：between 100 and 200 相当于条件在100到200之间。 IN(集合) 集合表示多个值，使用逗号分隔 LIKE’张%’ 模糊查询 IS NULL 查询某一列为NULL的值，注：不能写=NULL 操作示例 # 查询math分数大于80分的学生 SELECT * FROM student2 WHERE math&gt;80; # 查询english分数小于或等于80分的学生 SELECT * FROM student2 WHERE english &lt;=80; # 查询age等于20岁的学生 SELECT * FROM student2 WHERE age=20; # 查询age不等于20岁的学生，注：不等于有两种写法 SELECT * FROM student2 WHERE age&lt;&gt;20; SELECT * FROM student2 WHERE age!=20; 逻辑运算符 逻辑运算符 说明 and 或 &amp;&amp; 与，SQL中建议使用前者，后者不通用。 or 或 x 或 not 或 ! 非 x ： || 操作示例 # 查询age大于35且性别为男的学生 SELECT * FROM student2 WHERE age&gt;35 AND sex=&#39;男&#39;; # 查询age大于35或性别为男的学生 SELECT * FROM student2 WHERE age&gt;35 OR sex=&#39;男&#39;; # 查询id是1或3或5的学生 SELECT * FROM student2 WHERE id=1 OR id=3 OR id=5; in 关键字 in里面的每个数据都会作为一次条件，只要满足条件就会显示：select 字段名 from 表名 where 字段 in(数据1，数据2,...); # 查询id是1或3或5的学生，使用in SELECT * FROM student2 WHERE id IN(1,3,5); # 查询id不是1或3或5的学生 SELECT * FROM student2 WHERE id NOT IN(1,3,5); 范围查询 表示从值1到值2范围，全部包含：between 值1 and 值2 # 查询english成绩大于等于75，且小于等于90的学生 SELECT * FROM student2 WHERE english BETWEEN 75 AND 90; like关键字 表示模糊查询:select * from 表名 where 字段名 like &#39;通配符字符串;&#39; 通配符：%,匹配任意多个字符串; _,匹配单个字符 # 查询姓马的学生 SELECT * FROM student2 WHERE NAME LIKE &#39;马%&#39;; # 查询姓名中包含&#39;德&#39;字的学生 SELECT * FROM student2 WHERE NAME LIKE &#39;%德%&#39;; # 查询姓马，且姓名有两个字的学生 SELECT * FROM student2 WHERE NAME LIKE &#39;马_&#39;;","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://zero024.cn/categories/DataBase/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://zero024.cn/tags/MySQL/"}]},{"title":"Junit单元测试，反射和注解","slug":"JavaBasics/Junit单元测试和反射","date":"2019-05-16T15:59:00.000Z","updated":"2020-03-08T02:32:11.706Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. Junit单元测试测试的分类： 黑盒测试：不需要写代码，给输入值，看输出值是否达到预期值。 白盒测试：要写代码。关注程序具体的执行流程。","text":"1. Junit单元测试测试的分类： 黑盒测试：不需要写代码，给输入值，看输出值是否达到预期值。 白盒测试：要写代码。关注程序具体的执行流程。 Junit使用步骤 创建测试包(创建一个与被测试包同级的文件夹) 包内定义测试类(命名规范：被测试类名称+Test) 在测试类里面定义测试方法，如下图所示： 参考资料：Junit5基本使用 部分断言方法 代码示例： &#x2F;&#x2F; 定义计算类 public class Calculator { public int add(int a, int b){ &#x2F;&#x2F; int i = 3&#x2F;0; return a - b; &#x2F;&#x2F; 故意写错，以测试accertEquals方法 } public int sub(int a, int b){ return a - b; } } &#x2F;&#x2F; 定义测试类 import Junit.Calculator; import org.junit.jupiter.api.Test; &#x2F;&#x2F; Junit5改进后，所有方法都在jupiter.api下 import org.junit.jupiter.api.Assertions; public class CalculatorTest { @BeforeAll &#x2F;&#x2F; 一般用于资源的申请 public void init(){ System.out.println(&quot;所有测试方法执行前自动执行&quot;); } @AfterAll &#x2F;&#x2F; 用于资源的释放 public void close(){ System.out.println(&quot;所有测试方法结束后自动执行&quot;); } @Test public void testAdd(){ Calculator c = new Calculator(); int add = c.add(1, 2); &#x2F;&#x2F; 断言，我断言这个结果是3 Assertions.assertEquals(3,add); &#x2F;&#x2F; 不通过，报错，并显示红色 } @Test public void testSub(){ Calculator c = new Calculator(); int sub = c.sub(1, 2); Assertions.assertEquals(-1,sub); &#x2F;&#x2F; 通过，显示绿色 } } 2. 反射：框架设计的灵魂框架被称为半成品软件。我们可以在框架的基础上进行软件开发，简化编码。 反射：将类的各个组成部分封装为其他对象，这就是反射机制 反射的好处： 可以在程序运行过程中，操作这些对象。 可以解耦，提高程序的可扩展性。 2.1 获取Class对象的方式 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。多用于配置文件，将类名定义在配置文件中。来读取文件，加载类。 类名.class：通过类名的属性class获取。多用于参数的传递。 对象.getClass()：getClass()方法在Object类中定义，所以可以直接使用。多用于对象获取字节码的方式。 代码示例 public class ReflectDemoGetClass { public static void main(String[] args) throws Exception { &#x2F;&#x2F; 1.Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象。 Class cls1 = Class.forName(&quot;Demo5_16.reflect.Person&quot;); System.out.println(cls1); &#x2F;&#x2F; 2.类名.class：通过类名的属性class获取 Class cls2 = Person.class; System.out.println(cls2); &#x2F;&#x2F; 3. 对象.getClass()：`getClass()`方法在`Object`类中定义，所以可以直接使用 Class cls3 = new Person().getClass(); System.out.println(cls3); &#x2F;&#x2F; 使用==比较对象内存地址 System.out.println(cls1 == cls2); &#x2F;&#x2F; true System.out.println(cls2 == cls3); &#x2F;&#x2F; true } } Tips ：同一字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 2.2 Class对象的功能： 获取成员变量 &#x2F;&#x2F; 四种方式获取成员变量 Filed[] getFields() &#x2F;&#x2F; 获取所有public修饰的成员变量 Filed getFiled(String name) &#x2F;&#x2F; 获取public修饰的指定名称的成员变量 Field[] getDeclaredFields() &#x2F;&#x2F; 获取所有的成员变量,不考虑修饰符 Filed getDeclaredField(String name) &#x2F;&#x2F; 获取指定名称的成员变量,如果不是public修饰的成员变量，可以使用暴力反射获取 &#x2F;&#x2F; 示例代码如下: &#x2F;&#x2F; Person类 public class Person { private String name; private int age; public String a; protected String b; public String c; private String d; &#x2F;&#x2F; 忽略get\\set等方法 } public class ReflectDemo01 { public static void main(String[] args) throws Exception{ &#x2F;&#x2F; 获取Person的Class对象 Class&lt;Person&gt; personClass = Person.class; &#x2F;&#x2F; 获取成员变量 &#x2F;&#x2F; 1. Field[] getFields() 获取所有public修饰的成员变量 Field[] fields = personClass.getFields(); for (Field f:fields) System.out.println(f); &#x2F;&#x2F; public java.lang.String reflect.Person.a &#x2F;&#x2F; 2.Field getFiled(String name) &#x2F;&#x2F; 获取public修饰的指定名称的成员变量 Field a = personClass.getField(&quot;a&quot;); &#x2F;&#x2F; 获取成员变量a的值 Person p = new Person(); Object value = a.get(p); System.out.println(value); &#x2F;&#x2F; null &#x2F;&#x2F; 设置a的值 a.set(p,&quot;小明&quot;); System.out.println(p); &#x2F;&#x2F; 3. Field[] getDeclaredFields() : 获取所有的成员变量,不考虑修饰符 Field[] declaredFields = personClass.getDeclaredFields(); for (Field f:declaredFields) System.out.println(f); &#x2F;&#x2F; 4. Filed getDeclaredField(String name) : 获取指定名称的成员变量 Field d = personClass.getDeclaredField(&quot;d&quot;); &#x2F;&#x2F; 忽略访问权限修饰符的安全检查 d.setAccessible(true); &#x2F;&#x2F; 暴力反射 System.out.println(d.get(p)); &#x2F;&#x2F; null } } 获取构造方法 &#x2F;&#x2F; 四种方式获取构造方法 Constructor&lt;?&gt;[] getConstructors() &#x2F;&#x2F; 获取所有的public修饰的构造方法 Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 获取指定的public修饰的构造方法 Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 获取所有的构造方法，忽略修饰符 Constructor&lt;?&gt;[] getDeclaredConstructor() &#x2F;&#x2F; 获取指定名称的构造方法，非public修饰的可使用暴力反射获取 &#x2F;&#x2F; 代码举例 public class ReflectDemo02 { public static void main(String[] args) throws Exception{ &#x2F;&#x2F; 获取Person的Class对象 Class&lt;Person&gt; personClass = Person.class; &#x2F;&#x2F; 1. Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 获取构造器 Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, int.class); &#x2F;&#x2F; System.out.println(constructor); &#x2F;&#x2F; public reflect.Person(java.lang.String,int) &#x2F;&#x2F; 使用构造器创建对象实例 Person person = constructor.newInstance(&quot;小明&quot;,22); System.out.println(person); &#x2F;&#x2F; 如果使用空参数构造方法创建对象，操作可以简化为如下： Person o = personClass.newInstance(); &#x2F;&#x2F; 不推荐使用 System.out.println(o); } } 获取成员方法 &#x2F;&#x2F; 四种方式获取成员方法 Method[] getMethods() &#x2F;&#x2F; 获取所有public修饰的方法 Method getMethod(String name,类&lt;?&gt;... parameterTypes) &#x2F;&#x2F; 获取指定名称的public修饰的方法 Method[] getDeclaredMethods() &#x2F;&#x2F; 获取所有的成员方法，不考虑修饰符 Method getDeclaredMethod(String name,类&lt;?&gt;... parameterTypes) &#x2F;&#x2F; &#x2F;&#x2F; 获取指定名称的成员方法,如果不是public修饰的成员变量，可以使用暴力反射获取 &#x2F;&#x2F; 代码示例 public class ReflectDemo03 { public static void main(String[] args) throws Exception{ &#x2F;&#x2F; 获取Person的Class对象 Class&lt;Person&gt; personClass = Person.class; &#x2F;&#x2F; 1. Method getMethod(String name,类&lt;?&gt;... parameterTypes): 获取指定名称的public修饰的方法 Method eat = personClass.getMethod(&quot;eat&quot;); &#x2F;&#x2F; 执行无参方法 eat.invoke(new Person()); &#x2F;&#x2F; 执行有参方法，需传递参数列表 personClass.getMethod(&quot;eat&quot;,String.class).invoke(new Person(),&quot;food&quot;); &#x2F;&#x2F; 2. Method[] getDeclaredMethods(): 获取所有public修饰的方法 Method[] methods = personClass.getMethods(); for (Method method:methods) System.out.println(method); &#x2F;&#x2F; 3. Method[] getDeclaredMethods(): 获取所有的成员方法，不考虑修饰符 Method[] declaredMethods = personClass.getDeclaredMethods(); for (Method method:declaredMethods) { System.out.println(method); System.out.println(method.getName()); &#x2F;&#x2F; 获取方法名称 } &#x2F;&#x2F; 获取类名称 System.out.println(personClass.getName()); &#x2F;&#x2F; reflect.Person } } 获取类名 ：String getName() Field：成员变量 设置值：void set(Object obj,Object value) 获取值：get(Object obj) 忽略访问权限修饰符的安全检查(又称暴力反射)：setAccessible(true) Constructor：构造方法创建对象：T newInstance(Object... initargs) 如果使用空参数构造方法创建对象，操作可以简化为：直接使用Class对象的newInstance方法 Method：方法对象执行方法：Object invoke(Object obj, Object... args) 获取方法名称：String getName() 2.3 练习案例创建一个”框架”(类)，不改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并执行其中的任意方法。 实现步骤： 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载类文件进内存 创建对象 执行方法 代码实例 public class MyReflectFrame { public static void main(String[] args) throws Exception { &#x2F;&#x2F; 可以创建任意类的对象，可以执行任意方法 &#x2F;&#x2F; 前提：不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 &#x2F;&#x2F; new Student().sleep(); &#x2F;&#x2F; 1. 加载配置文件 &#x2F;&#x2F; 1.1 创建Properties对象 Properties pro = new Properties(); &#x2F;&#x2F; 1.2 加载配置文件，转换一个集合 &#x2F;&#x2F; 1.2.1 获取class目录下的配置文件 ClassLoader classLoader = MyReflectFrame.class.getClassLoader();&#x2F;&#x2F; 获取这个字节码文件的类加载器 InputStream is = classLoader.getResourceAsStream(&quot;D:\\\\IDEA_WorkSpace\\\\JavaWeb\\\\src\\\\Demo5_16\\\\pro.properties&quot;); &#x2F;&#x2F; 返回用于读取指定资源的输入流 pro.load(is); &#x2F;&#x2F; NullPointerException: inStream parameter is null!!! (后续回来解决) &#x2F;&#x2F; 2. 获取配置文件中定义的数据 String className = pro.getProperty(&quot;className&quot;); &#x2F;&#x2F; 获取配置文件中的类名 String methodName = pro.getProperty(&quot;methodName&quot;); &#x2F;&#x2F; 获取配置文件中的方法名 &#x2F;&#x2F; 3.加载该类进内存 Class cls = Class.forName(className); &#x2F;&#x2F; 4. 创建对象 Object obj = cls.newInstance(); &#x2F;&#x2F; 5. 获取方法对象 Method method = cls.getMethod(methodName); &#x2F;&#x2F; 6. 执行方法 method.invoke(obj); } } 3. 注解注解：说明程序的，给计算机看的。 注释：用文字描述程序的，给程序员看的。 定义注解(Annotation)，也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 概念描述 JDK1.5 之后的新特性 代码级别的说明，用以说明程序的 使用注解：@注解名称 作用分类： 编写文档：通过代码里标识的注解生成文档[生成文档doc文档] 代码分析：通过代码里标识的注解对代码进行分析[使用反射] 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查[Override] 3.1 JDK中预定义的一些注解 @Override：检测被该注解标注的方法是否是继承自父类(接口)的 @Deprecated：该注解标注的内容，表示已过时 @SuppressWarnings：压制警告。一般传递参数all，@SuppressWarnings(&quot;all&quot;) 代码示例 @SuppressWarnings(&quot;all&quot;) &#x2F;&#x2F; 压制全部警告 public class AnnoDemo2 { @Override public String toString(){ return super.toString(); } @Deprecated public void show1(){ &#x2F;&#x2F;有缺陷 } public void show2(){ &#x2F;&#x2F; 优化版show2 } public void demo(){ show1(); } } 3.2 自定义注解基本定义格式 public @interface 注解名称{ 属性列表; } 其本质就是一个接口，该接口默认继承Annotation接口public interface MyAnno extends java.lang.annotation.Annotation{...} 属性接口中的抽象方法被称为属性，定义属性有以下要求： 属性的返回值类型有这些取值：基本数据类型、String、枚举、注解、以上类型的数组。 &#x2F;&#x2F; 代码示例 public @interface MyAnno { int age(); &#x2F;&#x2F; 八种基本数据类型 String name() default &quot;zhangsan&quot;; &#x2F;&#x2F; String类型 Person per(); &#x2F;&#x2F; 枚举类型 MyAnno2 anno2(); &#x2F;&#x2F; 注解类型 String[] strarr(); &#x2F;&#x2F; 以上类型数组均可 } 定义了属性，在使用时需给属性赋值 &#x2F;&#x2F; 赋值示例 @MyAnno(age = 12,per = Person.P1,anno2 = @MyAnno2,strarr = {&quot;a&quot;,&quot;b&quot;}) public class Worker { } 小总结： 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 如果只有一个属性需要赋值，且属性名称是value，则名称value可省略，直接写值。 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可省略。 元注解(用于描述注解的注解) @Target：描述注解能够作用的位置，默认value值有ElementType枚举类型，常用取值有如下三个： TYPE：可以作用于类上 METHOD：可以作用于方法上 FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到。 @Documented：描述注解是否被抽取到api文档中 @Inherited：描述注解是否被子类继承 3.3 在程序中使用(解析)注解就是获取注解中定义的属性值 使用步骤： 获取注解定义的位置的对象(Class，Method，Field) 获取指定的注解：getAnnotation(Class) &#x2F;&#x2F; 其实就是在内存中生成了一个该注解接口的子类实现对象 public class ProImpl implements Pro{ public String className(){ return &quot;Demo5_16.annotation.Demo1&quot;; } public String methodName(){ return &quot;show&quot; } } 调用注解中的抽象方法获取配置的属性值 代码示例 &#x2F;&#x2F; 自定义的注解Pro @Target(ElementType.TYPE) &#x2F;&#x2F; 可作用于类上 @Retention(RetentionPolicy.RUNTIME) &#x2F;&#x2F; 保留在runtime阶段 public @interface Pro { String className(); String methodName(); } &#x2F;&#x2F; 方法类 public class Demo01 { public void show(){ System.out.println(&quot;demo1...show....&quot;); } } &#x2F;&#x2F; 测试类 @Pro(className = &quot;Demo5_16.annotation.Demo01&quot;,methodName = &quot;show&quot;) public class MyReflectFrame { public static void main(String[] args) throws Exception { &#x2F;&#x2F; 可以创建任意类的对象，可以执行任意方法 &#x2F;&#x2F; 前提：不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 &#x2F;&#x2F; 解析注解 &#x2F;&#x2F; 1.1 获取该类的字节码文件对象 Class&lt;MyReflectFrame&gt; myreflect = MyReflectFrame.class; &#x2F;&#x2F; 2. 获取上边的注解对象(其实就是在内存中生成了一个该注解接口的子类实现对象) Pro an = myreflect.getAnnotation(Pro.class); &#x2F;&#x2F; 3. 调用注解对象中定义的抽象方法，获取返回值 String className = an.className(); String methodName = an.methodName(); System.out.println(className); System.out.println(methodName); &#x2F;&#x2F; 4. 加载该类进内存 Class cls = Class.forName(className); &#x2F;&#x2F; ClassNotFoundException: Demo5_16.annotation.Demo1 ?!!! &#x2F;&#x2F; 5. 创建对象 Object obj = cls.newInstance(); &#x2F;&#x2F; 6. 获取方法对象 Method method = cls.getMethod(methodName); &#x2F;&#x2F; 7. 执行方法 method.invoke(obj); } } 3.4 综合案例 &#x2F;&#x2F; 定义简单的计算类，使用@Check注解 public class Calculator { @Check public void add(){ String str = null; System.out.println(str.toString()); &#x2F;&#x2F; 会报空指针异常 System.out.println(&quot;1 + 0 =&quot; + (1 + 0)); } @Check public void sub(){ System.out.println(&quot;1 - 0 =&quot; + (1 - 0)); } @Check public void mul(){ System.out.println(&quot;1 * 0 =&quot; + (1 * 0)); } @Check public void div(){ System.out.println(&quot;1 &#x2F; 0 =&quot; + (1 &#x2F; 0)); } } &#x2F;&#x2F; 定义Check注解类 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Check { } &#x2F;&#x2F; 定义测试框架类TestCheck &#x2F;&#x2F; 当主方法执行后，会自动地运行被检测的所有方法(加了Check注解的方法)，判断方法是否有异常，记录到文件中 public class TestCheck { public static void main(String[] args) throws IOException { Calculator calc = new Calculator(); &#x2F;&#x2F; 2. 获取字节码文件对象 Class cls = calc.getClass(); &#x2F;&#x2F; 3. 获取所有方法 Method[] methods = cls.getMethods(); int count = 0; &#x2F;&#x2F; 出现异常次数 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\JavaWeb\\\\src\\\\Demo5_16\\\\Check\\\\bug&quot; + System.currentTimeMillis() + &quot;txt&quot;,true)); for (Method method : methods) { &#x2F;&#x2F; 4. 判断方法上是否有Check注解 if (method.isAnnotationPresent(Check.class)){ &#x2F;&#x2F; 判断该方法的注解对象是否为输入的注解对象，返回布尔值，true则是。 &#x2F;&#x2F; 5. 有，则执行方法 try { method.invoke(calc); &#x2F;&#x2F; 调用方法 } catch (Exception e) { &#x2F;&#x2F; 6. 捕获异常,将异常记录到文件中 count ++; bw.write(method.getName() + &quot;方法出异常了&quot;); &#x2F;&#x2F; 获取方法名称 bw.newLine(); bw.write(&quot;异常的名称：&quot;+e.getCause()); bw.newLine(); bw.write(&quot;异常的原因：&quot;+e.getCause().getMessage()); bw.newLine(); bw.write(&quot;---------------------------&quot;); bw.newLine(); } } } bw.write(&quot;本次测试一共出现&quot; + count + &quot;次异常&quot;); bw.flush(); bw.close(); } } &#x2F;* 输出文件： div方法出异常了 异常的名称：java.lang.ArithmeticException: &#x2F; by zero 异常的原因：&#x2F; by zero --------------------------- add方法出异常了 异常的名称：java.lang.NullPointerException 异常的原因：null --------------------------- 本次测试一共出现2次异常 *&#x2F; 小结 大多数时候，我们会使用注解，而不是自定义注解 注解给谁用？一般给编译器和解析程序(TestCheck就是解析程序)用 注解不是程序的一部分，可以理解为注解就是一个标签","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://zero024.cn/tags/反射/"},{"name":"注解","slug":"注解","permalink":"https://zero024.cn/tags/注解/"}]},{"title":"Stream流的简单使用","slug":"JavaBasics/Stream流和方法引用","date":"2019-05-15T14:40:00.000Z","updated":"2020-03-08T00:48:08.669Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. Stream流说到Stream便容易想到I/O流，实际上，在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。","text":"1. Stream流说到Stream便容易想到I/O流，实际上，在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。 1.1 引言传统集合的多步遍历代码几乎所有的集合(如Collection接口或Map接口等)都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。 public class DemoForEach{ public static void main(String[] agrs){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;xiaozhang&quot;); list.add(&quot;xiaoming&quot;); list.add(&quot;xiaoli&quot;); list.add(&quot;xiaowang&quot;); for(String name:list){ System.out.println(name); } } } 循环遍历的弊端Java 8的Lambda让我们可以更加专注于做什么(What)，而不是怎么做(How)。现在我们看一下上例代码，可以发现： for循环的语法就是“怎么做” for循环的循环体才是”做什么“ 为什么使用循环？因为要进行遍历。循环是遍历的唯一方式么？遍历是指对每一个元素逐一进行处理，而并不是从第一个到最后一个顺次处理的循环。前者是目的，后者是方式。 试想一下，如果希望对集合中的元素进行筛选过滤： 将集合A根据条件一过滤为子集B 然后在根据条件二过滤为子集C 在Java 8之前的做法可能为： public class DemoNormalFilter { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张无忌&quot;); list.add(&quot;周芷若&quot;); list.add(&quot;赵敏&quot;); list.add(&quot;张强&quot;); list.add(&quot;张三丰&quot;); List&lt;String&gt; zhangList = new ArrayList&lt;&gt;(); for (String name:list) if (name.startsWith(&quot;张&quot;)) &#x2F;&#x2F; startsWith:测试此字符串是否以指定的前缀开始。 zhangList.add(name); List&lt;String&gt; shortList = new ArrayList&lt;&gt;(); for (String name:zhangList) if (name.length() == 3) shortList.add(name); for (String name:shortList) System.out.println(name); } } 上述代码含有三个循环，作用不同： 首先筛选所以姓张的人； 然后筛选名字是三个字的人； 最后对筛选结果进行打印输出。 每当我们需要对集合中的元素进行操作时，总是需要进行循环遍历。我们可以使用Lambda的衍生物Stream带来更加优雅的写法。 Stream的更优写法下面来看使用Java 8的Stream API后的代码： public class DemoStreamFilter { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张无忌&quot;); list.add(&quot;周芷若&quot;); list.add(&quot;赵敏&quot;); list.add(&quot;张强&quot;); list.add(&quot;张三丰&quot;); list.stream() .filter(s -&gt; s.startsWith(&quot;张&quot;)) .filter(s -&gt; s.length() == 3) .forEach(System.out::println); } } 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。 1.2 流式思想概述注意：请暂时忘记对传统IO流的固有印象！ 整体来看，流式思想类似于工厂车间的“生产流水线” 当需要对多个元素进行操作(特别是多步操作)时，考虑到性能及便利性，我们应该首先拼好一个”模型”步骤方案，然后再按照方案去执行它。 这张图展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种”函数模型”。图中的每一个方框都是一个”流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。 这里的filter、map、skip都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法count执行时，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。 备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。 Stream(流)是一个来自数据源的元素队列 元素是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算。 数据源流的来源。可以是集合、数组等。 和以前的Collection操作不同，Stream操作还有两个基础的特征： Pipelinling：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格(fluent style)。这样做可以对操作进行优化，比如延迟执行(laziness)和短路(short-circuiting)。 内部迭代：以前对集合遍历都是通过Iterator或者增强for的方式，显式的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，流可以直接调用遍历方法。 当使用一个流时，通常包括三个基本步骤：获取一个数据源(source) –&gt; 数据转换 –&gt; 执行操作获取想要的结果。每次转换原有Stream对象不变，返回一个新的Stream对象(可以有多次转换)，这就允许对其的操作可以像链条一样排列，变成一个管道。 1.3 获取流java.util.stream.Stream&lt;T&gt; 是Java 8 新加入的最常用的流接口(该接口不是函数式接口)。 获取流的方式： 所有的Collection集合都可以通过stream默认方法获取流； Stream接口的静态方法of可以获取数组对应的流。 根据Collection获取流首先，java.util.Collection接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流。 public class DemoGetStream { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream1 = list.stream(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); Stream&lt;String&gt; stream2 = set.stream(); } } 根据Map获取流java.util.Map接口不是Collection的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况： public class DemoMapGetStream { public static void main(String[] args) { Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); &#x2F;&#x2F; 获取键流 Stream&lt;String&gt; valueStream = map.values().stream(); &#x2F;&#x2F; 获取值流 Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream(); &#x2F;&#x2F; 获取键值对流 } } 根据数组获取流如果使用的是数组，由于数组对象不可添加默认方法，所以Stream接口中提供了静态方法of,使用实例如下： public class DemoArrGetStream { public static void main(String[] args) { String[] arr = {&quot;张&quot;,&quot;李&quot;,&quot;王&quot;}; Stream&lt;String&gt; stream = Stream.of(arr); } } &#x2F;&#x2F; of方法的参数是一个可变参数，所以支持数组 1.4 常用方法 流模型的操作很丰富，下面介绍一些常用的API。这些方法可以被分成两种： 延迟方法：返回值类型仍然是Stream接口本身类型的方法，因此支持链式调用。(除了终结方法外，其余方法均为延迟方法) 终结方法：返回值类型不再是Stream接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调用。这里介绍的终结方法包括count和forEach方法。 逐一处理：forEach​ 虽然方法名字叫forEach，但是与for循环中的”for-each”昵称不同。方法签名如下： void forEach(Consumer&lt;? super T&gt; action); ​ 该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理。 Tips: 方法名和形参列表共同组成方法签名。 复习Consumer接口java,util.function.Consumer&lt;T&gt;接口是一个消费型接口。 Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。 基本使用 public class DemoStreamForEach { public static void main(String[] args) { Stream&lt;String&gt; stream = Stream.of(&quot;张&quot;, &quot;李&quot;, &quot;王&quot;); stream.forEach(name-&gt; System.out.println(name)); } } 过滤：filter可以通过filter方法将一个流转换成另一个子集流。方法签名： Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 该接口接收一个Predicate函数式接口参数作为筛选条件。 复习Predicate接口java.util.stream.Predicate函数式接口，其中唯一的抽象方法为boolean test(T t); 该方法将会产生一个boolean值结果，代表指定条件是否满足。结果为true则保留元素，反之不保留。 基本使用 public class Demo2Filter { public static void main(String[] args) { Stream&lt;String&gt; stream = Stream.of(&quot;张三丰&quot;, &quot;张翠山&quot;, &quot;赵敏&quot;, &quot;周芷若&quot;, &quot;张无忌&quot;); &#x2F;&#x2F; 对Stream流中的元素进行过滤，只要姓张的 Stream&lt;String&gt; stream2 = stream.filter(name -&gt; name.startsWith(&quot;张&quot;)); &#x2F;&#x2F; 遍历stream2流 stream2.forEach(name-&gt; System.out.println(name)); } } 映射：map如果需要将流中的元素映射到另一个流中，可以使用map方法。方法签名： &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 复习Function接口此前我们已经学习过java.util.stream.Function函数式接口，其中唯一的抽象方法为： R apply(T t); 这可以将一种T类型转换成为R类型，而这种转换的动作，就称为”映射“。 基本使用Stream流中的map方法基本使用的代码如下： public class StreamMap { public static void main(String[] args) { Stream&lt;String&gt; stream = Stream.of(&quot;10&quot;, &quot;15&quot;, &quot;17&quot;); Stream&lt;Integer&gt; result = stream.map(str -&gt; Integer.parseInt(str)); result.forEach(str-&gt; System.out.println(str)); } } 上述代码中，map方法的参数通过方法引用，将字符串类型转换为了int类型(并自动装箱为Integer类对象)。 统计个数：count正如集合Collection当中的size方法一样，流提供count方法来统计元素个数 该方法返回一个long值代表元素个数。基本使用如下： public class DemoStreamCount { public static void main(String[] args) { Stream&lt;String&gt; stream = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;); System.out.println(stream.count()); &#x2F;&#x2F; 4 } } 取用前几个：limitlimit方法可以对流进行截取，只取用前n个。方法签名： Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用： public class DemoStreamLimit { public static void main(String[] args) { Stream&lt;String&gt; stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;); Stream&lt;String&gt; limit = stream.limit(3); &#x2F;&#x2F; 截取流的前两个元素 limit.forEach(s-&gt; System.out.println(s)); &#x2F;&#x2F; a,b,c } } 跳过前几个：skip如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流： Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。 public class DemoStreamSkip { public static void main(String[] args) { Stream&lt;String&gt; stream = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;); Stream&lt;String&gt; skip = stream.skip(3); skip.forEach(s-&gt; System.out.println(s)); &#x2F;&#x2F; 4,5,6 } } 组合：concat如果有两个流，希望合并成为一个流，那么可以使用Stream接口的静态方法concat。方法签名： static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b); 注：这是一个静态方法，与java.lang.String中的concat方法是不同的。 代码示例 public class DemoStreamConcat { public static void main(String[] args) { Stream&lt;String&gt; h = Stream.of(&quot;hello&quot;); Stream&lt;String&gt; w = Stream.of(&quot;world!&quot;); Stream&lt;String&gt; result = Stream.concat(h, w); result.forEach(s-&gt; System.out.println(s)); } } 1.5 练习：集合元素的处理现在有两个ArrayList集合存储队伍当中多个成员姓名，要去使用循环依次进行以下若干步骤： 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。 第一个队伍筛选之后只要前3个人；存储到一个新集合中。 第二个队伍只要姓张的成员姓名；存储到一个新集合中。 第二个队伍筛选之后不要前2个人；存储到一个新集合中。 将两个队伍合并为一个队伍；存储到一个新集合中。 根据姓名创建 Person 对象；存储到一个新集合中。 打印整个队伍的Person对象信息。 代码实现(传统方式) public class ExerciseOldFor { public static void main(String[] args) { ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;(); &#x2F;&#x2F; .... &#x2F;&#x2F;队伍2 ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;(); &#x2F;&#x2F; .... &#x2F;&#x2F; 1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。 List&lt;String&gt; oneA = new ArrayList&lt;&gt;(); for (String name:one){ if (name.length()==3){ oneA.add(name); } } &#x2F;&#x2F; 2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。 List&lt;String&gt; oneB = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { oneB.add(oneA.get(i)); } &#x2F;&#x2F; 3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。 List&lt;String&gt; twoA = new ArrayList&lt;&gt;(); for (String name:two){ if (name.startsWith(&quot;张&quot;)){ twoA.add(name); } } &#x2F;&#x2F; 4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。 List&lt;String&gt; twoB = new ArrayList&lt;&gt;(); for (int i = 2; i &lt; twoA.size(); i++) { twoB.add(twoA.get(i)); } &#x2F;&#x2F; 5. 将两个队伍合并为一个队伍；存储到一个新集合中。 List&lt;String&gt; totalNames = new ArrayList&lt;&gt;(); totalNames.addAll(oneB); totalNames.addAll(twoB); &#x2F;&#x2F; 6. 根据姓名创建 Person 对象；存储到一个新集合中。 List&lt;Person&gt; personList = new ArrayList&lt;&gt;(); for (String name:totalNames){ personList.add(new Person(name)); } &#x2F;&#x2F; 7. 打印整个队伍的Person对象信息。 for (Person p:personList){ System.out.println(p); } } } Stream流方式实现 public class ExerciseStream { public static void main(String[] args) { &#x2F;&#x2F; 队伍1 ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;(); one.add(&quot;迪丽热巴&quot;); one.add(&quot;宋远桥&quot;); one.add(&quot;苏星河&quot;); one.add(&quot;石破天&quot;); one.add(&quot;石中玉&quot;); one.add(&quot;老子&quot;); one.add(&quot;庄子&quot;); one.add(&quot;洪七公&quot;); &#x2F;&#x2F;队伍2 ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;(); two.add(&quot;古力娜扎&quot;); two.add(&quot;张无忌&quot;); two.add(&quot;赵丽颖&quot;); two.add(&quot;张三丰&quot;); two.add(&quot;尼古拉斯赵四&quot;); two.add(&quot;张天爱&quot;); two.add(&quot;张二狗&quot;); &#x2F;&#x2F; 1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。 Stream&lt;String&gt; threeName = one.stream().filter(n -&gt; n.length() == 3); &#x2F;&#x2F; 2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。 Stream&lt;String&gt; firstThreePeople = threeName.limit(3); &#x2F;&#x2F; 3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。 Stream&lt;String&gt; firstNameZhang = two.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)); &#x2F;&#x2F; 4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。 Stream&lt;String&gt; skipTwoPeople = firstNameZhang.skip(2); &#x2F;&#x2F; 5. 将两个队伍合并为一个队伍；存储到一个新集合中。 Stream&lt;String&gt; concat = Stream.concat(firstThreePeople, skipTwoPeople); &#x2F;&#x2F; 6. 根据姓名创建 Person 对象；存储到一个新集合中。 List&lt;Person&gt; people = new ArrayList&lt;&gt;(); concat.forEach(s -&gt; people.add(new Person(s))); &#x2F;&#x2F; 7. 打印整个队伍的Person对象信息。 people.forEach(p-&gt; System.out.println(p)); &#x2F;&#x2F; 以上3步合并写法 Stream.concat(firstThreePeople,skipTwoPeople).map(Person::new).forEach(System.out::println); } } 2. 方法引用在使用Lambda表达式时，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要写重复逻辑？ 2.1 冗余的Lambda场景下面是一个简单的函数式接口以便应用Lambda表达式： public interface Printable{ void print(String str); } 在Printable接口当中唯一的抽象方法print接收一个字符串参数，目的就是为了打印显示它。那么下面通过Lambda来实现一下： public class DemoPrintImpl { private static void printString(String s,Printable data){ data.print(s); } public static void main(String[] args) { printString(&quot;hello&quot;,s-&gt; System.out.println(s)); } } 其中printString方法只管调用Printable接口的print方法，并不管该方法的具体实现逻辑会将字符串如何操作。而main方法通过Lambda表达式指定了函数式接口Printable的具体操作方案为：拿到一个String数据后，在控制台中输出它。 2.2 问题分析这段代码的问题在于，对字符串进行控制台打印输出的操作方案，已经有了现成的实现，那就是System.out对象中的println(String)方法。既然Lambda希望做到的事情就是调用println(String)方法，那何必自己手动调用呢。 2.3 用方法引用改进代码 public class Demo02PrintRef { private static void printString(Printable data){ data.print(&quot;hello&quot;); } public static void main(String[] args) { &#x2F;&#x2F; printString(s-&gt; System.out.println(s)); &#x2F;* 分析： Lambda表达式的目的，打印参数传递的字符串 把参数s，传递给了System.out对象，调用out对象中的方法println对字符串进行了输出 注意： 1. System.out对象是已经存在的 2. println方法也是已经存在的 所以我们可以使用方法引用来优化Lambda表达式 可以使用System.out方法直接引用(调用)println方法 *&#x2F; printString(System.out::println); } } 其中双冒号::写法，这被称为“方法引用”，而双冒号是一种新的语法。 2.4 方法引用符双冒号::为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 语义分析如上例中，System.out对象中有一个重载的println(String)方法恰好就是我们所需要的。那么对于printString方法的函数式接口参数，对比下面两种写法，完全等效： Lambda表达式写法：s -&gt; System.out.println(s); 方法引用写法：System.out::println 第一种语义是指：拿到参数之后经Lambda之手，继而传递给System.out.println方法去处理。 第二种等效写法的语义是指：直接让System.out中的println方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。 注：Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常 推导与省略如果使用Lambda，那么根据“可推导即可省略”的原则，无需指定参数类型，也无需指定重载形式—-它们都将被自动推导，而如果使用方法引用，也是同样可以根据上下文进行推导。 函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。 2.5 通过对象名引用成员方法这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法： public class MethodRefObject { public void printUpperCase(String str){ System.out.println(str.toUpperCase()); } } 函数式接口定义不变，那么当需要使用这个printUpperCase成员方法来替代Printable接口的Lambda时，已经具有了MethodRefObject类的对象实例，则可以通过对象名引用成员方法，如下： public class Demo04MethodRef { private static void printString(Printable p){ p.print(&quot;hello&quot;); } public static void main(String[] args) { MethodRefObject obj = new MethodRefObject(); printString(obj::printUpperCase); &#x2F;&#x2F; HELLO } } 2.6 通过类名称引用静态方法由于在java.lang.Math类中已经存在了静态方法abs，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口： @FunctionalInterface public interface Calcable { int calc(int num); } 两种写法调用： public class Demo05CalcLambda { private static void method(int num,Calcable ca){ System.out.println(ca.calc(num)); } public static void main(String[] args) { &#x2F;&#x2F; Lambda表达式写法 method(-10,n -&gt; Math.abs(n)); &#x2F;&#x2F; 10 &#x2F;&#x2F; 通过类名称引用静态方法 method(-10,Math::abs); &#x2F;&#x2F; 10 } } 上述例子中，两种写法是完全等效的： Lambda表达式：n-&gt;Math.abs(n) 方法引用：Math::abs 2.7 通过super引用成员方法如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。代码示例如下： &#x2F;&#x2F; 首先是函数式接口： @FunctionalInterface public interface Greetable { void greet(); } &#x2F;&#x2F; 定义父类 public class Human { public void sayHello(){ System.out.println(&quot;Hello!&quot;); } } &#x2F;&#x2F; 定义子类继承父类 public class Man extends Human { &#x2F;&#x2F; 子类重写父类sayHello方法 @Override public void sayHello(){ System.out.println(&quot;大家好，我是Man！&quot;); } &#x2F;&#x2F; 定义方法method，参数传递Greetable接口 public void method(Greetable g){ g.greet(); } public void show(){ &#x2F;&#x2F; 调用method方法，使用Lambda表达式 method(()-&gt;new Human().sayHello()); &#x2F;&#x2F; 创建父类human对象，调用父类的sayHello方法 &#x2F;&#x2F; 因为有子父类关系，所以存在一个关键字super，代表父类；所以我们可以直接使用super，调用父类的成员方法 &#x2F;&#x2F; 使用super关键字引用父类的成员方法 method(super::sayHello); } public static void main(String[] args) { new Man().show(); &#x2F;&#x2F; 调用show方法 } } 2.8 通过this引用成员方法this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用this::成员方法的格式来使用方法引用。 &#x2F;&#x2F; 定义简单的函数式接口 @FunctionalInterface public interface Richable { void buy(); } &#x2F;&#x2F; 定义使用类 public class Child { private void buyGame(){ System.out.println(&quot;买了游戏&quot;); } private void computer(Richable r){ r.buy(); } public void soHappy(){ &#x2F;&#x2F; 使用lambda表达式 computer(()-&gt;System.out.println(&quot;买了游戏&quot;))； &#x2F;&#x2F; 使用this关键字，调用本类中已经存在的方法 computer(()-&gt;this.buyGame()) &#x2F;&#x2F; 使用方法引用 computer(this::buyGame); &#x2F;&#x2F; 上述三种方法完全等效 } public static void main(String[] args) { new Child().soHappy(); &#x2F;&#x2F; 买了游戏 } } 2.9 类的构造器引用由于构造器的名称和类名完全一样，并不固定。所以构造器引用使用类名称::new的格式表示。 代码示例: &#x2F;&#x2F; Person类 public class Person { private String name; public Person() { } public Person(String name) { this.name = name; } &#x2F;&#x2F; .... } &#x2F;&#x2F; 定义一个车间Person对象的函数式接口 @FunctionalInterface public interface PersonBuilder { &#x2F;&#x2F; 定义一个方法，根据传递的姓名，创建Person对象返回 Person builderPerson(String name); } &#x2F;&#x2F; 类的构造器引用 public class DemoBuilderPerson { &#x2F;&#x2F; 定义一个方法，参数传递姓名和PersonBuilder接口，方法中通过姓名创建Person对象 public static void printName(String name,PersonBuilder pb){ Person person = pb.builderPerson(name); System.out.println(person.getName()); } public static void main(String[] args) { &#x2F;&#x2F; 调用printName方法，方法的参数PersonBuilder接口是函数式接口，故可以使用Lambda表达式 printName(&quot;小张&quot;,name -&gt; new Person(name)); &#x2F;* 使用方法引用优化lambda表达式 构造方法new Person(String name) 已知 创建对象已知 new 就可以使用Person引用new创建对象 *&#x2F; printName(&quot;小明&quot;,Person::new); &#x2F;&#x2F; 使用Person类的带参构造方法，通过传递的姓名创建对象 } } 2.10 数组的构造器引用数组也是Object的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，示例代码如下： &#x2F;&#x2F; 定义一个创建是数组的函数式接口 @FunctionalInterface public interface ArrayBuilder { &#x2F;&#x2F; 定义一个创建int类型数组的方法，参数传递数组的长度，返回创建好的int类型数组 int[] builderArray(int length); } &#x2F;&#x2F; 数组的构造器引用 public class DemoArrayBuilder { &#x2F;* 定义一个方法 方法的参数传递创建数组的长度和ArrayBuilder接口 方法内部根据传递的长度使用ArrayBuilder中的方法创建数组并返回 *&#x2F; public static int[] createArray(int length,ArrayBuilder ab){ return ab.builderArray(length); } public static void main(String[] args) { &#x2F;&#x2F; 调用createArray方法，传递数组的长度和Lambda表达式 int[] arr = createArray(10,(len)-&gt;new int[len]); System.out.println(arr.length); &#x2F;&#x2F; 10 &#x2F;* 使用方法引用优化lambda表达式 已知创建的就是int[]数组 数组的长度也是已知的 就可以使用方法引用 int[]引用new，根据参数传递的长度来创建数组 *&#x2F; int[] arr2 = createArray(10,int[]::new); System.out.println(arr2.length); &#x2F;&#x2F; 10 } } 今日目标 能够理解流与集合相比的优点。让我们专注于做什么，而不是怎么做 能够理解流的延迟执行特点。Stream可以按需计算，只有当终结方法执行时，整个模型才会按照指定策略执行操作。 能够通过集合、映射或数组获取流。实现类.stream();Stream.of(数组)。 能够掌握常用的流操作。forEach,filter,map,count,limit,skip,concat 能够使用输出语句的方法引用。System.out::println？ 能够通过4种方式使用方法引用 能够使用类和数组的构造器引用。类名称::new;数组[]::new","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Stream","slug":"Stream","permalink":"https://zero024.cn/tags/Stream/"}]},{"title":"函数式接口","slug":"JavaBasics/函数式接口","date":"2019-05-14T14:00:00.000Z","updated":"2020-03-08T00:49:43.180Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. 函数式接口函数式接口在Java中是指：有且仅有一个抽象方法的接口。 函数式接口，也称为SAM(Single Abstract Method interfaces)接口，即适用于函数式编程场景的接口。而java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，java中的Lambda才能顺利地进行推导。","text":"1. 函数式接口函数式接口在Java中是指：有且仅有一个抽象方法的接口。 函数式接口，也称为SAM(Single Abstract Method interfaces)接口，即适用于函数式编程场景的接口。而java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，java中的Lambda才能顺利地进行推导。 注：“语法糖“是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。 1.1 格式​ 只要确保接口中有且仅有一个抽象方法即可： 修饰符 interface 接口名称{ public abstract 返回值类型 方法名称(可选参数信息); &#x2F;&#x2F; 其他非抽象方法内容 } ​ 由于接口当中抽象方法的public abstract是可以省略的，所以定义一个函数式接口很简单： public interface MyFun{ void MyMethod(); } 1.2 @FunctionalInterface注解​ 与@Override注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface。该注解可用于一个接口的定义上： @FunctionalInterface public interface MyFun{ void MyMethod(); } ​ 一旦使用该注解来定义接口，编译器将会强制检查该接口是否确定有且仅有一个抽象方法，否则将会报错。 1.3 自定义函数式接口对于刚刚定义好的MyFun函数式接口，典型使用场景就是作为方法的参数： public class DemoFunInterface { public static void main(String[] args) { &#x2F;&#x2F; 使用lambda调用函数式接口中的方法 doSomething(()-&gt; System.out.println(&quot;Lambda执行了！&quot;)); } &#x2F;&#x2F; 使用自定义的函数式接口作为方法参数 private static void doSomething(MyFun inter){ inter.MyMethod(); &#x2F;&#x2F; 调用自定义的函数式接口方法 } } 2. 函数式编程在兼顾面向对象特性的基础上，Java语言通过Lambda表达式与方法引用等，打开了函数式编程的大门。 &#x2F;&#x2F; 函数式接口的使用：一般可以作为方法的参数和返回值类型 public class Demo { &#x2F;&#x2F; 定义一个方法，参数使用函数式接口MyFun public static void show(MyFun myFun){ myFun.MyMethod(); } public static void main(String[] args) { &#x2F;&#x2F; 调用show方法，方法的参数是一个接口，所以可以传递接口的实现类对象 show(new MyFunImpl()); &#x2F;&#x2F; 调用show方法，方法的参数是一个接口,所以我们可以传递接口的匿名内部类 show(new MyFun() { @Override public void MyMethod() { System.out.println(&quot;使用匿名内部类重写接口中的抽象方法&quot;); } }); &#x2F;&#x2F; 调用show方法，方法的参数是一个函数式接口,所以我们可以传递lambda表达式 show(()-&gt; System.out.println(&quot;使用Lambda表达式重写接口中的抽象方法&quot;)); } } &#x2F;&#x2F; result: &#x2F;* 使用实现类重写MyFun接口抽象方法 使用匿名内部类重写接口中的抽象方法 使用Lambda表达式重写接口中的抽象方法 *&#x2F; 2.1 Lambda的延迟执行有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。 性能浪费的日志注：日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。 一种典型场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件情况下进行打印输出： public class Demo02Logger { public static void main(String[] args) { &#x2F;&#x2F; 定义三个日志信息 String msg1 = &quot;hello&quot;; String msg2 = &quot;world&quot;; String msg3 = &quot;java&quot;; &#x2F;&#x2F; 调用方法，传递日志级别和日志信息 log(1,msg1+msg2+msg3); } &#x2F;&#x2F; 定义一个根据日志的级别，显示日志信息的方法 private static void log(int level, String msg){ &#x2F;&#x2F; 对日志等级进行判断，如果是1级别，那么输出日志信息 if (level == 1){ System.out.println(msg); } } } 上述代码仍存在问题：无论级别是否满足要求，作为log方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如级别不符合要求，那么字符串拼接操作就白做了，浪费性能。 备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。例如：LOGGER.debug(&quot;变量{}的取值为{}。&quot;, &quot;os&quot;, &quot;macOS&quot;)，其中的大括号{}为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字符串拼接。这也是一种可行解决方案，但Lambda可以做到更好。 Lambda优化写法使用Lambda必然需要一个函数式接口： @FunctionalInterface public interface MessageInter { String Message(); } 对log方法进行改造： public class DemoLogLambda { public static void main(String[] args) { String msg1 = &quot;hello&quot;; String msg2 = &quot;world&quot;; String msg3 = &quot;java&quot;; log(1,() -&gt; msg1 + msg2 + msg3); } private static void log(int level,MessageInter msg){ if (level == 1){ System.out.println(msg.Message()); &#x2F;&#x2F; 只有当条件满足时，才会去调用字符串拼接方法，不满足不会拼接 } } } 如此，只有当级别满足要求时，才会进行三个字符串拼接，不会造成性能浪费。 证明Lambda的延迟 public class DemoLoggerDelay { private static void log(int level,MessageInter msg){ if (level == 1){ System.out.println(msg.Message()); } } public static void main(String[] args) { String msg1 = &quot;hello&quot;; String msg2 = &quot;world&quot;; String msg3 = &quot;java&quot;; log(2,() -&gt;{ System.out.println(&quot;满足条件Lambda执行！&quot;); return msg1 + msg2 + msg3; }); } } 从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。 实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。 2.2 使用Lambda作为参数和返回值抛开实现原理不说，Java中的Lambda表达式可以被看做是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式接口作为方法参数。 例如java.lang.Runnable接口就是一个函数式接口，假设有一个startThread方法使用该接口作为参数，那么就可以使用Lambda进行传参。这种情况其实和Thread类的构造方法参数为Runnable没有本质区别。 &#x2F;&#x2F; 使用lambda作为方法参数 public class DemoRunnable { public static void main(String[] args) { &#x2F;&#x2F; 调用方法，参数是接口，我们可以传递匿名内部类，实现类接口lambda等。 startThread(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + &quot;线程启动了&quot;); } }); &#x2F;&#x2F; 调用方法，参数是一个函数式接口，我们可以传递lambda startThread(() -&gt; System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + &quot;线程启动了&quot;)); } &#x2F;&#x2F; 定义一个方法，方法参数使用函数式接口Runnable public static void startThread(Runnable run){ &#x2F;&#x2F; 开启多线程 new Thread(run).start(); } } 类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一个方法来获取一个java.util.Comparator接口类型的对象作为排序器时，就可以调用该方法获取。 &#x2F;&#x2F; 使用Lambda作为返回值类型 public class DemoComparator { &#x2F;&#x2F; 定义一个方法，方法返回值类型使用函数式接口Comparator public static Comparator&lt;String&gt; getComparator(){ &#x2F;&#x2F; 方法的返回值类型是一个接口，那么我们可以返回这个接口的匿名内部类 &#x2F;&#x2F; return new Comparator&lt;String&gt;() { &#x2F;&#x2F; @Override &#x2F;&#x2F; public int compare(String o1, String o2) { &#x2F;&#x2F; return o2.length() - o1.length(); &#x2F;&#x2F; } &#x2F;&#x2F; }; &#x2F;&#x2F; 方法的返回值类型是一个函数式接口，所以我们可以返回一个Lambda表达式 return (String o1,String o2) -&gt; o2.length() - o1.length(); } public static void main(String[] args) { &#x2F;&#x2F; 创建一个字符串数组 String[] arr = {&quot;aaa&quot;,&quot;b&quot;,&quot;cccc&quot;,&quot;dddddd&quot;}; System.out.println(Arrays.toString(arr)); &#x2F;&#x2F; 调用Arrays中的sort方法，对字符串数组进行排序 Arrays.sort(arr,getComparator()); System.out.println(Arrays.toString(arr)); } } 3. 常用函数式接口JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，它们主要在java.util.function包中被提供。 3.1 Supplier接口java.util.funtion.Supplier&lt;T&gt;接口仅包含一个无参的方法：T get()。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，也就意味着对应的Lambda表达式需要”对外提供“一个符合泛型类型的对象数据。 public class DemoSupplier { &#x2F;&#x2F; 定义一个方法，方法的参数传递Supplier&lt;T&gt;接口，泛型执行get方法就会返回一个String public static String getString(Supplier&lt;String&gt; sup){ return sup.get(); } public static void main(String[] args) { &#x2F;&#x2F; 调用getString方法，方法的参数Supplier是一个函数式接口，所以可以传递Lambda表达式 String s = getString(() -&gt; &quot;你好呀&quot;); System.out.println(s); } } &#x2F;&#x2F; Supplier&lt;T&gt;接口被称之为生成型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型数据 3.2 练习：求数组元素最大值使用Supplier接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。 代码实现 public class DemoMaxArray { &#x2F;&#x2F; 定义一个方法，用于获取int类型数组中元素的最大值，方法的参数传递Supplier接口，泛型使用Integer public static int getMax(Supplier&lt;Integer&gt; sup){ return sup.get(); } public static void main(String[] args) { int[] arr = {99,35,72,956,12,-3}; int maxValue = getMax(()-&gt;{ int max = arr[0]; for (int i : arr) { if (i&gt;max) max = i; } return max; }); System.out.println(&quot;数组中最大值元素为：&quot; + maxValue); } } 3.3 Consumer接口java.util.function.Consumer&lt;T&gt;接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。 抽象方法：acceptConsumer接口中包含抽象方法void accept(T t),意为消费一个指定泛型的数据。 public class DemoConsumer { &#x2F;* 定义一个方法 方法的参数传递一个字符串的姓名 方法的参数传递Consumer接口，泛型使用String 可以使用Consumer接口消费字符串的姓名 *&#x2F; public static void method(String name,Consumer&lt;String&gt; con){ con.accept(name); } public static void main(String[] args) { &#x2F;&#x2F; 调用method方法，传递字符串姓名，方法的另一个参数是Consumer接口，是一个函数式接口，可以使用Lambda表达式 method(&quot;上海&quot;,(String name)-&gt;{ &#x2F;&#x2F; 对传递的字符串进行消费 &#x2F;&#x2F; 消费方式：直接输出字符串 System.out.println(name); &#x2F;&#x2F; 消费方式：对字符串进行反转输出 String reName = new StringBuffer(name).reverse().toString(); System.out.println(reName); }); } } &#x2F;&#x2F; result: 上海 海上 默认方法: andThen如果一个方法的参数和返回值全都是Consumer类型，那么就可以实现效果：消费数据的时候，先做一个操作，然后在做另一个操作，实现组合。而这个方法就是Consumer接口中的default方法andThen。 &#x2F;* Consumer接口的默认方法andThen 作用：需要两个Consumer接口，可以把两个Consumer接口组合到一起，在对数据进行消费 例如： Consumer&lt;String&gt; con1 Consumer&lt;String&gt; con2 String s= &quot;hello&quot;; con1.accept(s); con2.accept(s); 连接两个Consumer接口，再进行消费 con1.andThen(con2).accept(s); 谁写前面谁先消费 *&#x2F; public class DemoAndThen { private static void consumerString(String s,Consumer&lt;String&gt; one,Consumer&lt;String&gt; two){ &#x2F;&#x2F; one.accept(s); &#x2F;&#x2F; two.accept(s); &#x2F;&#x2F; 使用andThen方法，把两个Consumer接口连接到一起消费数据,等效于上面 one.andThen(two).accept(s); } public static void main(String[] args) { &#x2F;&#x2F; 因为有两个Consumer接口，所以要传递两个Lambda进去 consumerString(&quot;Hello&quot;, s -&gt; System.out.println(s.toUpperCase()), s -&gt; System.out.println(s.toLowerCase())); } } 3.4 练习：格式化打印信息将下面字符串数组中的信息，按照格式姓名：xxx，性别：x。的格式将信息打印出来。要求将打印姓名的动作作为第一个Consumer接口的Lambda实例，将打印性别作为第二个Consumer接口的Lambda实例，将两个Consumer接口按照顺序拼接到一起。 &#x2F;&#x2F; 字符串数组 String[] arr = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;}; 代码实现 public class ConsumerExercise { public static void main(String[] args) { String[] arr = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;}; printInfo(arr,s -&gt; System.out.print(&quot;姓名：&quot;+s.split(&quot;,&quot;)[0]), &#x2F;&#x2F; 消费方式：对info进行切割，读取姓名，按照指定格式输出 s -&gt; System.out.println(&quot;,性别：&quot;+s.split(&quot;,&quot;)[1]+&quot;。&quot;)); &#x2F;&#x2F; 对info进行切割，读取年龄，按照指定格式输出 } private static void printInfo(String[] arr, Consumer&lt;String&gt; one, Consumer&lt;String&gt; two){ for (String info:arr) one.andThen(two).accept(info); } } &#x2F;* result： 姓名：迪丽热巴,性别：女。 姓名：古力娜扎,性别：女。 姓名：马尔扎哈,性别：男。 *&#x2F; 3.5 Predicate接口有时我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用java.util.function.Predicate&lt;T&gt;接口。 抽象方法：testPredicate接口中包含一个抽象方法：boolean test(T t)。用于条件判断场景： public class DemoPredicate { public static boolean checkString(String s,Predicate&lt;String&gt; pre){ return pre.test(s); } public static void main(String[] args) { String s = &quot;helloworld&quot;; boolean b = checkString(s, str -&gt; str.length() &gt; 5);&#x2F;&#x2F; 对参数传递的字符串进行判断，判断字符串长度是否大于5，并把判断的结果返回 System.out.println(b); } } 默认方法：and既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个Predicate条件使用“与”逻辑连接起来实现“并且”的效果时，可以使用default方法and。 ​ 如果要判断一个字符串既包含大写”H”，又要包含大写”W”，示例代码如下： public class DemoPredicateAnd { public static void method(String s, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two){ boolean isValid = one.and(two).test(s); System.out.println(&quot;字符串符合要求吗：&quot; + isValid); } &#x2F;* contains(String str) 当且仅当该字符串包含str时，返回true，反之返回false *&#x2F; public static void main(String[] args) { method(&quot;Helloworld&quot;,s-&gt;s.contains(&quot;H&quot;),s-&gt;s.contains(&quot;W&quot;)); } } &#x2F;&#x2F; result:false 默认方法：or与and类似的，默认方法or实现逻辑关系中的”或“。 如果希望实现逻辑”字符串包含大写H或者大写W”，那么只需要将上个例子代码and修改为or即可实现。 public class DemoPredicateAnd { public static void method(String s, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two){ &#x2F;&#x2F; 只需修改and--&gt;or即可 boolean isValid = one.or(two).test(s); System.out.println(&quot;字符串符合要求吗：&quot; + isValid); } public static void main(String[] args) { method(&quot;Helloworld&quot;,s-&gt;s.contains(&quot;H&quot;),s-&gt;s.contains(&quot;W&quot;)); } } 默认方法：negate“非”(取反)。源码中只是对结果boolean值进行”!”取反而已。调用方法跟and和or一样。 public class DemoPredicateNegate { public static void method(Predicate&lt;String&gt; pre){ boolean isLong = pre.negate().test(&quot;helloworld&quot;); System.out.println(&quot;字符串很长吗：&quot;+isLong); } public static void main(String[] args) { method(s-&gt;s.length()&lt;5); &#x2F;&#x2F; true } } 3.6 练习：集合信息筛选数组当中有多条”姓名+性别”格式的信息，通过Predicate接口的方法将符合要求的字符串筛选到集合ArrayList中，需同时满足以下两个条件： 1. 必须为女生 2. 姓名必须是4个字 &#x2F;&#x2F;数组 String[] array = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; }; 代码实现： public class ExercisePredicate { public static boolean FilterArray(String s, Predicate&lt;String&gt; one,Predicate&lt;String&gt; two){ return one.and(two).test(s); } public static void main(String[] args) { String[] array = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; }; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); for (String s:array){ boolean b = FilterArray(s, str -&gt; str.split(&quot;,&quot;)[0].length() == 4, str -&gt; str.contains(&quot;女&quot;)); if (b==true) arrayList.add(s); } System.out.println(arrayList); } } 3.7 Function接口java.util.function.Function&lt;T,R&gt;接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。 抽象方法：applyFunction接口中最主要的抽象方法为：R apply(T t)，根据类型T的参数获取类型R的结果。 ​ 使用的场景例如：将String类型转换为Integer类型。 public class DemoFunctionApply { &#x2F;* 定义一个方法 方法的参数传递 一个字符串类型的整数 方法的参数传递以Function接口，泛型使用&lt;String,Integer&gt; 使用Function接口中的方法apply，把字符串类型的整数，转换为Integer类型的整数 *&#x2F; public static void change(String s, Function&lt;String,Integer&gt; fun){ int in = fun.apply(s); &#x2F;&#x2F; 自动拆箱，Integer-&gt;int System.out.println(in); } public static void main(String[] args) { change(&quot;10&quot;,str-&gt;Integer.parseInt(str)); } } 默认方法：andThenFunction接口中有一个默认的andThen方法，用来进行组合操作。 ​ 该方法同样用于“先做什么，再做什么”的场景，和Consumer中的andThen差不多 &#x2F;* 分析： 转换了两次 第一次是把String类型转换为了Integer类型 所以我们可以使用Function&lt;String,Integer&gt; fun1 Integer i = fun1.apply(&quot;123&quot;)+10; 第二次是把Integer类型转换为String类型 所以我们可以使用Function&lt;Integer,String&gt; fun2 String s = fun2.apply(i); 我们可以使用andThen方法，把两次转换组合在一起使用 String s = fun1.andThen(fun2).apply(&quot;123&quot;); fun1先调用apply方法，把字符串转换为Integer fun2再调用apply方法，把Integer转换为字符串 *&#x2F; public class DemoFunctionAndThen { public static void MySwitch(String s, Function&lt;String,Integer&gt; fun1,Function&lt;Integer,String&gt; fun2){ String str = fun1.andThen(fun2).apply(s); System.out.println(str); &#x2F;&#x2F; 133 } public static void main(String[] args) { String s = &quot;123&quot;; MySwitch(s,str-&gt;Integer.parseInt(str)+10,i-&gt;i+&quot;&quot;);&#x2F;&#x2F; 字符串转换为整数并+10，然后再转换回字符串 } } 3.8 练习：自定义函数模型拼接使用Function进行函数模型的拼接，按照顺序需要执行的多个函数操作如下： 1. 将字符串截取数字年龄部分，得到字符串 2. 将年龄字符串转换为int类型的数字 3. 将int数字累加100，得到结果int数字 代码实现 public class ExerciseFunction { public static int change(String s, Function&lt;String,String&gt; one,Function&lt;String,Integer&gt; two,Function&lt;Integer,Integer&gt; three){ return one.andThen(two).andThen(three).apply(s); } public static void main(String[] args) { String str = &quot;赵丽颖,20&quot;; int n = change(str, s -&gt; s.split(&quot;,&quot;)[1], s -&gt; Integer.parseInt(s), i -&gt; i += 100); System.out.println(n); &#x2F;&#x2F; 120 } } 今日目标 能够使用@FunctionalInterface注解 能够自定义无参无返回函数式接口 能够自定义有参有返回函数式接口 能够理解Lambda延迟执行的特点 能够使用Lambda作为方法的参数 能够使用Lambda作为方法的返回值 能够使用Supplier函数式接口 能够使用Consumer函数式接口 能够使用Function函数式接口 能够使用Predicate函数式接口","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"网络编程","slug":"JavaBasics/网络编程","date":"2019-05-13T14:00:00.000Z","updated":"2020-03-08T00:49:49.870Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. 网络编程基础概念1.1 软件结构 C/S结构：全称为Client/Server结构，是指客户端和服务器结构。常见程序如QQ、迅雷等。 B/S结构：全称为Brower/Server结构，是指浏览器和服务器结构。常见浏览器如谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。","text":"1. 网络编程基础概念1.1 软件结构 C/S结构：全称为Client/Server结构，是指客户端和服务器结构。常见程序如QQ、迅雷等。 B/S结构：全称为Brower/Server结构，是指浏览器和服务器结构。常见浏览器如谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 1.2 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。 链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 1.3 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： UDP：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。 特点：数据被限制在64KB以内，超出这个范围就不能发送了。 数据报(Datagram):网络传输的基本单位 TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 1.4 网络编程三要素协议 协议：计算机网络通信必须遵守的规则。 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 常用命令 查看本机IP地址，在控制台输入：ipconfig 检查网络是否连通，在控制台输入：ping IP地址，ping 220.181.57.216 特殊IP地址：本机IP地址127.0.0.1 or localhost 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 2. TCP通信程序2.1 概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端(Client)与服务端(Server)。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 2.2 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 Tips: 回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 代码示例: Socket client = new Socket(&quot;127.0.0.1&quot;,8888); 成员方法 public InputStream getInputStream() ： 返回此套接字的输入流。 如果此Socket具有相关联的通道，则生成的InputStream的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() ： 返回此套接字的输出流。 如果此Socket具有相关联的通道，则生成的OutputStream的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() ：关闭此套接字。 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流。 2.3 ServerSocket类ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 代码举例： ServerSocket = server = new ServerSocket(8888); 成员方法 public Socket accept() ：监听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 2.4 简单的TCP网络程序TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Socket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Socket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 客户端与服务器数据收发代码示例 &#x2F;&#x2F; 客户端实现 public class ClientTCP { public static void main(String[] args) throws IOException { System.out.println(&quot;客户端，发送数据&quot;); &#x2F;&#x2F; 1.1. 创建一个客户端对象Socket，构造方法绑定服务器的IP和端口号 Socket client = new Socket(&quot;localhost&quot;,8888); &#x2F;&#x2F; 2.使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象 OutputStream os= client.getOutputStream(); &#x2F;&#x2F; 3.使用网络字节输出流对象中的方法write，给服务器发送数据 os.write(&quot;测试传输数据....&quot;.getBytes()); &#x2F;&#x2F; 4. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象 InputStream is = client.getInputStream(); &#x2F;&#x2F; 5. 使用网络字节输入流对象中的方法read，读取服务器回写的数据 byte[] b = new byte[1024]; int len = is.read(b); System.out.println(new String(b,0,len)); &#x2F;&#x2F; 6. 释放资源 client.close(); } } &#x2F;&#x2F; 服务器端实现 public class ServerTCP { public static void main(String[] args) throws IOException { System.out.println(&quot;服务端启动，等待客户端连接.....&quot;); &#x2F;&#x2F; 1. 创建服务器ServerSocket对象和系统要指定的端口号 ServerSocket server = new ServerSocket(8888); &#x2F;&#x2F; 2. 使用ServerSocket对象中的accept方法，获取请求的客户端对象Socket Socket socket = server.accept(); &#x2F;&#x2F; 3. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); &#x2F;&#x2F; 4. 使用网络字节输入流对象中的方法read，读取客户端发送的数据 byte[] bytes = new byte[1024]; int len = is.read(bytes); String msg = new String(bytes,0,len); System.out.println(msg); &#x2F;&#x2F; 5. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象 OutputStream os = socket.getOutputStream(); &#x2F;&#x2F; 6. 使用网络字节输出流对象中的方法write，给客户端回写数据 os.write(&quot;服务端已接收到数据....&quot;.getBytes()); &#x2F;&#x2F; 7. 释放资源 server.close(); socket.close(); } } 3. 文件传输案例3.1 案例分析 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 代码实现 &#x2F;&#x2F; 客户端 public class FileUpload_Client { public static void main(String[] args) throws IOException { System.out.println(&quot;客户端开始发送文件...&quot;); &#x2F;&#x2F; 1. 创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(&quot;C:\\\\Users\\\\14908\\\\Desktop\\\\upload.jpg&quot;); &#x2F;&#x2F; 2. 创建一个客户端Socket对象，构造方法中绑定服务器IP和端口号 Socket client = new Socket(&quot;localhost&quot;,8888); &#x2F;&#x2F; 3. 使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象 OutputStream os = client.getOutputStream(); &#x2F;&#x2F; 4. 使用本地字节输入流FileInputStream对象中的方法read，读取本地文件 byte[] b = new byte[1024]; int len; while ((len = fis.read(b)) != -1){ &#x2F;&#x2F; 5. 使用网络字节输出流OutputStream对象中的write方法，把读取的文件上传到服务器 os.write(b,0,len); } &#x2F;* 解决阻塞问题：上传完文件，给服务器写一个结束标记 void shutdownOutPut() 禁用此套接字的输出流 对于TCP套接字，任何此前写入的数据都将被发送，并且后跟TCP的正常连接终止序列 *&#x2F; client.shutdownOutput(); &#x2F;&#x2F; 6. 使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象 InputStream is = client.getInputStream(); &#x2F;&#x2F; 7. 使用网络字节输入流流InputStream对象中的方法read，读取服务器回写的数据 while (((len = is.read(b))!=-1)){ System.out.println(new String(b,0,len)); } &#x2F;&#x2F; 8. 释放资源(FileInputStream,Socket) fis.close(); client.close(); } } &#x2F;&#x2F; 服务器端 public class FileUpload_Server { public static void main(String[] args) throws IOException { System.out.println(&quot;服务器启动，等待连接...&quot;); &#x2F;&#x2F; 1. 创建一个本地字节输出流FileOutputStream对象，构造方法中绑定目的地 FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_13\\\\download.jpg&quot;); &#x2F;&#x2F; 2. 创建一个服务端ServerSocket对象，构造方法中绑定侦听的端口号 ServerSocket server = new ServerSocket(8888); &#x2F;&#x2F; 3. 使用ServerSocket对象的accept方法，接收客户端的socket对象 Socket socket = server.accept(); &#x2F;&#x2F; 4. 使用socket中的方法getInputStream，获取网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); byte[] bytes = new byte[1024]; &#x2F;&#x2F; 5. 使用网络字节输入流InputStream对象中的read方法，读取客户端传输过来的数据 int len; while ((len = is.read(bytes)) != -1){ &#x2F;&#x2F; 6. 使用本地字节输出流FileOutputStream对象中的方法write，将文件写出到硬盘 fos.write(bytes,0,len); fos.flush(); } &#x2F;&#x2F; 7. 使用socket中的方法getOutputStream，获取网络字节输出流对象，使用write方法回写数据 socket.getOutputStream().write(&quot;上传成功!&quot;.getBytes()); &#x2F;&#x2F; 8. 释放资源 fos.close(); socket.close(); server.close(); } } 文件上传优化 文件名写死问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，可以使用系统时间优化文件名称，保证文件名称唯一。 FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_13\\\\&quot;+System.currentTimeMillis()+&quot;.jpg&quot;); 服务器端循环接收的问题 服务器端应该保持运行，持续接收来自不同用户的文件，使用循环改进即可。 &#x2F;&#x2F; 每次接收新的连接，创建一个Socket while(true){ Socket socket = server.accept(); ..... } 效率问题 服务端在接收大文件时，可能要耗费更多的时间，此时不能接收其他用户上传的文件，所以使用多线程技术优化。 while(true){ Socket socket = server.accept(); &#x2F;&#x2F; 新的socket交给子线程处理 new Thread(() -&gt; { &#x2F;&#x2F; 处理文件保存代码 }).start(); } 优化代码实现 &#x2F;&#x2F; 客户端 public class FileUpload_Client { public static void main(String[] args) throws IOException { System.out.println(&quot;客户端开始发送文件...&quot;); &#x2F;&#x2F; 1. 创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(&quot;C:\\\\Users\\\\14908\\\\Desktop\\\\upload.jpg&quot;); &#x2F;&#x2F; 2. 创建一个客户端Socket对象，构造方法中绑定服务器IP和端口号 Socket client = new Socket(&quot;localhost&quot;,8888); &#x2F;&#x2F; 3. 使用Socket中的方法getOutputStream，获取网络字节输出流OutputStream对象 OutputStream os = client.getOutputStream(); &#x2F;&#x2F; 4. 使用本地字节输入流FileInputStream对象中的方法read，读取本地文件 byte[] b = new byte[1024]; int len; while ((len = fis.read(b)) != -1){ &#x2F;&#x2F; 5. 使用网络字节输出流OutputStream对象中的write方法，把读取的文件上传到服务器 os.write(b,0,len); } &#x2F;* 解决阻塞问题：上传完文件，给服务器写一个结束标记 void shutdownOutPut() 禁用此套接字的输出流 对于TCP套接字，任何此前写入的数据都将被发送，并且后跟TCP的正常连接终止序列 *&#x2F; client.shutdownOutput(); &#x2F;&#x2F; 6. 使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象 InputStream is = client.getInputStream(); &#x2F;&#x2F; 7. 使用网络字节输入流流InputStream对象中的方法read，读取服务器回写的数据 while (((len = is.read(b))!=-1)){ System.out.println(new String(b,0,len)); } &#x2F;&#x2F; 8. 释放资源(FileInputStream,Socket) fis.close(); client.close(); } } &#x2F;&#x2F; 服务器端 public class FileUpload_Server { public static void main(String[] args) throws IOException { System.out.println(&quot;服务器启动，等待连接...&quot;); &#x2F;&#x2F; 2. 创建一个服务端ServerSocket对象，构造方法中绑定侦听的端口号 ServerSocket server = new ServerSocket(8888); &#x2F;&#x2F; 3. 使用ServerSocket对象的accept方法，接收客户端的socket对象 while (true) { &#x2F;&#x2F; 循环接收socket对象 Socket socket = server.accept(); new Thread(() -&gt; { &#x2F;&#x2F; 线程优化多用户访问 try{ &#x2F;&#x2F; 4. 使用socket中的方法getInputStream，获取网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); &#x2F;&#x2F; 1. 创建一个本地字节输出流FileOutputStream对象，构造方法中绑定目的地 FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_13\\\\&quot;+System.currentTimeMillis()+&quot;.jpg&quot;); byte[] bytes = new byte[1024]; &#x2F;&#x2F; 5. 使用网络字节输入流InputStream对象中的read方法，读取客户端传输过来的数据 int len; while ((len = is.read(bytes)) != -1) { &#x2F;&#x2F; 6. 使用本地字节输出流FileOutputStream对象中的方法write，将文件写出到硬盘 fos.write(bytes, 0, len); fos.flush(); } &#x2F;&#x2F; 7. 使用socket中的方法getOutputStream，获取网络字节输出流对象，使用write方法回写数据 socket.getOutputStream().write(&quot;上传成功!&quot;.getBytes()); &#x2F;&#x2F; 8. 释放资源 fos.close(); socket.close(); }catch (IOException e) { e.printStackTrace(); } }).start(); } &#x2F;&#x2F; 服务器就不用关闭了 &#x2F;&#x2F; server.close(); } } 3.2 模拟B\\S服务器模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 &#x2F;* BS版本TCP服务器 *&#x2F; public class BServer { public static void main(String[] args) throws IOException { ServerSocket server = new ServerSocket(8088); &#x2F;* 浏览器解析服务器回写的html页面，页面中如果有图片，那么浏览器就会单独开启一个线程，读取服务器的图片 我们需要让服务器一直处于监听状态，客户端请求一次，服务器端回写一次。 *&#x2F; while (true){ Socket socket = server.accept(); new Thread(()-&gt;{ try{ InputStream is = socket.getInputStream(); &#x2F;&#x2F; 网络字节输入流 &#x2F;&#x2F; 把is网络字节输入流对象，转换为字符缓冲输入流 BufferedReader br = new BufferedReader(new InputStreamReader(is)); &#x2F;&#x2F; 把客户端请求信息的第一行读取出来 String line = br.readLine(); System.out.println(line); &#x2F;&#x2F; 输出请求的路径 &#x2F;&#x2F; 把读取的信息以空格进行分离，只要中间部分 String[] arr = line.split(&quot; &quot;); &#x2F;&#x2F; 把路径前面的&#x2F;去除,获取Demo5_13\\web\\index.html String htmlpath = arr[1].substring(1); &#x2F;&#x2F; 创建一个本地字节输入流，构造方法中绑定要读取的html路径 FileInputStream fis = new FileInputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\&quot;+htmlpath); &#x2F;&#x2F; 使用Socket中的getOutputStream方法，获取网络字节输出流对象 OutputStream os = socket.getOutputStream(); &#x2F;&#x2F; 写入html协议响应头，固定写法 os.write(&quot;HTTP&#x2F;1.1 200 OK\\r\\n&quot;.getBytes()); os.write(&quot;Content-Type:text&#x2F;html\\r\\n&quot;.getBytes()); &#x2F;&#x2F;必须写入空行，否则浏览器不解析 os.write(&quot;\\r\\n&quot;.getBytes()); &#x2F;&#x2F; 一读一写复制文件，把服务器读取的html文件回写到客户端 int len; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes)) != -1) { os.write(bytes,0,len); } &#x2F;&#x2F; 释放资源 fis.close(); socket.close(); }catch (IOException E){ E.printStackTrace(); } }).start(); } &#x2F;&#x2F;server.close(); } } 今日目标 能够辨别UDP和TCP协议特点。无连接和有连接，传输数据安全和传输效率高 能够说出TCP协议下两个常用类名称。Socket，ServerSocket。 能够编写TCP协议下字符串数据传输程序。OutputStream.write(“hello”.getBytes()); 能够理解TCP协议下文件上传案例。本地字节输入流读取数据，通过网络字节输出流发送到服务器，服务器通过网络字节输入流循环读取数据，使用本地字节输入流写出到硬盘中。","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"缓冲流、转换流、序列化流、打印流","slug":"JavaBasics/4种IO流的增强","date":"2019-05-10T15:00:00.000Z","updated":"2020-03-08T00:49:51.247Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. 缓冲流缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter","text":"1. 缓冲流缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 1.1 字节缓冲流构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 效率测试缓冲流读写方法与基本流是一致的，通过复制大文件(560MB)，来测试一下效率。 基本流代码 public class BufferedDemo01 { public static void main(String[] args) { long start = System.currentTimeMillis(); &#x2F;&#x2F; 记录开始时间 &#x2F;&#x2F; 创建流对象 try( FileInputStream fis = new FileInputStream(&quot;D:\\\\chrome\\\\IdeaInstall.exe&quot;); FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\copy.exe&quot;); ){ &#x2F;&#x2F;读写数据 int b; while ((b = fis.read())!=-1){ fos.write(b); } }catch (IOException e) { e.printStackTrace(); } long end = System.currentTimeMillis();&#x2F;&#x2F; 记录结束时间 System.out.println(&quot;普通流复制560MB所需时间：&quot;+(end-start)+&quot;毫秒&quot;); } } &#x2F;&#x2F; result: long long time 缓冲流代码 public class ButteredDemo02 { public static void main(String[] args) { long start = System.currentTimeMillis(); &#x2F;&#x2F; 记录开始时间 try(&#x2F;&#x2F; 创建缓冲流对象 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;D:\\\\chrome\\\\IdeaInstall.exe&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\copy2.exe&quot;)) ){ &#x2F;&#x2F;读写数据 int b; while ((b = bis.read())!=-1){ bos.write(b); } } catch (IOException e) { e.printStackTrace(); } long end = System.currentTimeMillis(); &#x2F;&#x2F; 记录结束时间 System.out.println(&quot;缓冲流复制560MB所需时间：&quot;+(end-start)+&quot;毫秒&quot;); } } &#x2F;&#x2F; result：缓冲流复制560MB所需时间：40171毫秒 使用数组优化 public class ButteredDemo02 { public static void main(String[] args) { long start = System.currentTimeMillis(); &#x2F;&#x2F; 记录开始时间 try(&#x2F;&#x2F; 创建缓冲流对象 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;D:\\\\chrome\\\\IdeaInstall.exe&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\copy2.exe&quot;)) ){ &#x2F;&#x2F;读写数据 int len; byte[] bytes = new byte[8*1024]; &#x2F;&#x2F; 使用数组对象优化 while ((len = bis.read(bytes))!=-1){ bos.write(bytes,0,len); &#x2F;&#x2F; 只写入有效字节数据 } } catch (IOException e) { e.printStackTrace(); } long end = System.currentTimeMillis(); &#x2F;&#x2F; 记录结束时间 System.out.println(&quot;缓冲流使用数组复制560MB所需时间：&quot;+(end-start)+&quot;毫秒&quot;); } } &#x2F;&#x2F; result: 缓冲流使用数组复制560MB所需时间：2847毫秒 1.2 字符缓冲流构造方法 public BufferedReader(Reader in) ：创建一个新的字符缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的字符缓冲输出流。 特有方法字符缓冲流的基本方法与普通字符流调用方式一致，但它具备特有的方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 readLine方法演示： public class BufferedReaderDemo01 { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 创建流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\read.txt&quot;)); &#x2F;&#x2F; 定义字符串，保存读取的一行文字 String line; &#x2F;&#x2F; 循环读取，直到读取到null while ((line = br.readLine())!=null){ System.out.print(line); System.out.println(&quot;，&quot;); } br.close(); &#x2F;&#x2F; 释放资源 } } newLine方法演示： public class BufferedWriterDemo02 { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\out.txt&quot;)); &#x2F;&#x2F; 写出数据 bw.write(&quot;你好&quot;); bw.newLine(); &#x2F;&#x2F; 写出换行 bw.write(&quot;世界&quot;); bw.newLine(); bw.close(); } } &#x2F;&#x2F; result: 你好 世界 1.3 练习：文本排序 3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。 8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。 4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。 2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。 1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。 9.今当远离，临表涕零，不知所言。 6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。 7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。 5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 案例分析 逐行读取文本信息。 解析文本信息到集合中。 遍历集合，按顺序，写出文本信息。 代码实现 public class BufferedExercise { public static void main(String[] args) { &#x2F;&#x2F; 创建map集合，保存文本数据，键为序号，值为文字 HashMap&lt;String,String&gt; lineMap = new HashMap&lt;&gt;(); &#x2F;&#x2F; 创建流对象 try( BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\出师表.txt&quot;)); BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\sort.txt&quot;)) ){ &#x2F;&#x2F; 循环读取数据，解析存入map中 String line; while((line = br.readLine())!=null){ &#x2F;&#x2F; 解析文本 String[] split = line.split(&quot;\\\\.&quot;); &#x2F;&#x2F; 以&quot;.&quot;作为分隔符，将一行分为序号和文字两部分 lineMap.put(split[0],split[1]);&#x2F;&#x2F; 序号为键，文字为值，存入集合中 } &#x2F;&#x2F; 遍历map集合 for (int i = 1; i &lt;= lineMap.size(); i++) { String key = String.valueOf(i); &#x2F;&#x2F; 获取键名为i的键 &#x2F;&#x2F; 获取map中的文本 String value = lineMap.get(key); &#x2F;&#x2F; 获取键名为key的对应值 &#x2F;&#x2F; 拼接字符串，并写出 bw.write(key + &quot;.&quot; + value); bw.newLine(); &#x2F;&#x2F; 写出换行 } }catch (IOException e){ e.printStackTrace(); } } } 2. 转换流2.1 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 编码:字符(能看懂的)–字节(看不懂的) 解码:字节(看不懂的)–&gt;字符(能看懂的) 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 字符集 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 2.2 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 2.3 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。` 指定编码读取Demo public class ReaderDemo { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 定义文件路径 String FilePath = &quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\file_gbk.txt&quot;; &#x2F;&#x2F; 创建流对象，默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FilePath)); &#x2F;&#x2F; 创建流对象，指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FilePath),&quot;GBK&quot;); &#x2F;&#x2F; 定义变量，保存字符 int read; &#x2F;&#x2F; 使用默认编码字符流读取，乱码 while ((read = isr.read())!=-1){ System.out.print((char)read); &#x2F;&#x2F; ��Һ� } isr.close(); &#x2F;&#x2F; 使用指定GBK编码字符流读取 while ((read = isr2.read())!=-1){ System.out.println((char)read); &#x2F;&#x2F; 大家好 } isr2.close(); } } 2.4 OutPutStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 指定编码写出Demo public class OutPutDemo { public static void main(String[] args) throws IOException { String FilePath = &quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\&quot;; &#x2F;&#x2F; 创建流对象，默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FilePath + &quot;out2.txt&quot;)); &#x2F;&#x2F; 写出数据 osw.write(&quot;你好&quot;); &#x2F;&#x2F; 保存为6个字节 osw.close(); &#x2F;&#x2F; 创建流对象，指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FilePath + &quot;out3.txt&quot;),&quot;GBK&quot;); &#x2F;&#x2F; 写出数据 osw2.write(&quot;你好&quot;); &#x2F;&#x2F; 保存为4个字节 osw2.close(); } } 转换流图解转换流是字节与字符间的桥梁！ 2.5 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 代码实现 public class CodeSwitchDemo { public static void main(String[] args) { try( &#x2F;&#x2F; 1. 指定GBK编码的转换流，读取文本文件。 InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\file_gbk.txt&quot;),&quot;GBK&quot;); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\codeswitch.txt&quot;)) &#x2F;&#x2F; 默认就是utf8 ){ &#x2F;&#x2F; 读取文件 char[] chars = new char[1024]; &#x2F;&#x2F; 定义字符数组 int len; while ((len = isr.read(chars))!=-1){ &#x2F;&#x2F; 使用字符数组优化读取 osw.write(chars,0,len); &#x2F;&#x2F; 写出 } }catch (IOException e){ e.printStackTrace(); } } } 3. 序列化Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： 3.1 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out)：创建一个指定OutputStream的ObjectOutputStream。 对象序列化操作(写对象操作) 一个对象要想序列化，必须满足两个条件 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 public class Employee implements java.io.Serializable { public String name; public String address; public transient int age; &#x2F;&#x2F; transient瞬态修饰成员,不会被序列化 public void addressCheck() { System.out.println(&quot;Address check : &quot; + name + &quot; -- &quot; + address); } } 写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 代码示例 &#x2F;&#x2F; 测试类 &#x2F;* java.io.ObjectOutputStream extends OutputStream ObjectOutputStream: 对象序列化流 作用：把对象以流的方式写入到文件中保存 构造方法： ObjectOutputStream(OutputStream out): 创建写入指定OutputStream的ObjectOutputStream 参数：OutputStream out：字节输出流 特有成员方法： void writeObject(Object obj):将指定对象写入ObjectOutputStream *&#x2F; public class Demo01ObjectOutputStream { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 1. 创建ObjectOutputStream，构造方法中传递字节输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\person.txt&quot;)); &#x2F;&#x2F; 2. 使用ObjectOutputStream对象中的方法writeObject()，把对象写入到文件中 oos.writeObject(new Person(&quot;小张&quot;,11)); &#x2F;&#x2F; 3. 释放资源 oos.close(); } } &#x2F;&#x2F; Person类 &#x2F;* 序列化和反序列化时，会抛出NotSerializableException(没有序列化异常) 类通过实现 Java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其进行任何状态序列化或反序列化。 Serializable接口也叫标记型接口 要进行序列化和反序列化的类必须实现Serializable接口，就会给类添加一个标记 当我们进行序列化和反序列化时，就会检测该类是否有这个标记 有：就可以进行序列化和反序列化操作 无：就会抛出NotSerializableException异常 *&#x2F; public class Person implements Serializable { private String name; private int age; public Person() { } &#x2F;&#x2F; 省略get&#x2F;set等方法 } 3.2 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1(读对象操作)如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 代码示例 &#x2F;* java.io.ObjectInputStream extends InputStream ObjectInputStream:对象的反序列化流 作用：把文件中保存的对象，以流的方式读取出来使用 构造方法： ObjectInputStream(InputStream in)：创建从指定InputStream中读取的ObjectInputStream 参数：InputStream in：字节输入流 特有成员方法： Object readObject(): 从ObjectInputStream 读取对象 *&#x2F; public class Demo01InputStream { public static void main(String[] args) throws IOException, ClassNotFoundException { &#x2F;&#x2F; 1. 创建ObjectInputStream对象，构造方法中传递字节输入流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\person.txt&quot;)); &#x2F;&#x2F; 2. 使用ObjectInputStream对象的方法readObject() 读取保存对象的文件 Object obj = ois.readObject(); &#x2F;* readObject()方法声明抛出了ClassNotFoundException(class文件找不到异常) 当不存在对象的class文件时抛出此异常 反序列化前提： 1. 类必须实现Serializable 2. 必须存在类对应的class文件 *&#x2F; &#x2F;&#x2F; 3. 释放资源 ois.close(); &#x2F;&#x2F; 4. 使用读取出来的对象 System.out.println(obj); &#x2F;&#x2F; Person{name=&#39;小张&#39;, age=11} } } Tips: 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。 serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 public class Person implements Serializable { private static final long serialVersionUID = 1L; &#x2F;&#x2F; 加入固定序列版本号 private String name; public int age; &#x2F;&#x2F; 省略构造方法，get&#x2F;set等 } 3.3 练习：序列化集合 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt ，并遍历集合，打印对象信息。 案例分析 把若干学生对象 ，保存到集合中。 把集合序列化。 反序列化读取时，只需要读取一次，转换为集合类型。 遍历集合，可以打印所有的学生信息 代码实现 &#x2F;&#x2F; 序列化操作 public class StudentSerializableDemo { public static void main(String[] args) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\students.txt&quot;)); ArrayList&lt;Person&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(new Person(&quot;xiaoming&quot;,12)); arrayList.add(new Person(&quot;xiaohua&quot;,17)); arrayList.add(new Person(&quot;xiaoli&quot;,15)); oos.writeObject(arrayList); oos.close(); } } &#x2F;&#x2F; 反序列化操作 public class StudentDemo2 { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\students.txt&quot;)); &#x2F;&#x2F; 读取，强转为ArrayList类型 ArrayList&lt;Person&gt; stuobj = (ArrayList&lt;Person&gt;) ois.readObject(); &#x2F;&#x2F; 遍历打印 for (Person p:stuobj){ System.out.println(p); } ois.close(); } } 4. 打印流我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 4.1 PringStream类构造方法 public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。 改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以改变它的流向。 public class PrintDemo { public static void main(String[] args) throws FileNotFoundException { System.out.println(97); &#x2F;&#x2F; 创建打印流，指定文件名称 PrintStream ps = new PrintStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_10\\\\print.txt&quot;); &#x2F;&#x2F; 设置系统的打印流向，输出到print.txt中 System.setOut(ps); &#x2F;&#x2F; 调用系统打印里，就会在print.txt中输出97 System.out.println(97); } } 今日目标 能够使用字节缓冲流读取数据到程序。FileInputStream 能够使用字节缓冲流写出数据到文件。FileOutPutStream 能够明确字符缓冲流的作用和基本用法。FileReader，FileWriter 能够使用缓冲流的特殊功能。数组优化 能够阐述编码表的意义 能够使用转换流读取指定编码的文本文件。 InputStreamReader 能够使用转换流写入指定编码的文本文件。 OutputStreamWriter 能够说出打印流的特点。 可以改变打印流向，输出到文件中 能够使用序列化流写出对象到文件。ObjectOutputStream 能够使用反序列化流读取文件到程序中。ObjectInputStream","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"},{"name":"IO流","slug":"IO流","permalink":"https://zero024.cn/tags/IO流/"}]},{"title":"Java中的字节流和字符流","slug":"JavaBasics/字节流、字符流","date":"2019-05-07T13:40:00.000Z","updated":"2020-03-08T00:49:47.629Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. IO概述我们把数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。 Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出(写入)数据。","text":"1. IO概述我们把数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。 Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出(写入)数据。 1.1 IO的分类根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 根据数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 1.2 顶级父类 2. 字节流一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 2.1 字节输出流[OutputStream]java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 Tips: close方法，当完成流的操作时，必须调用此方法，释放系统资源。 2.2 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称路径写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 构造举例，代码如下： public class FileOutPutDemo01 { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 使用File对象创建流对象 File file = new File(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\a.txt&quot;); FileOutputStream fos = new FileOutputStream(file); &#x2F;&#x2F; 使用文件名称路径创建流对象 FileOutputStream fos2 = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\b.txt&quot;); } } 写出字节数据 写出字节：write(int b) 方法，每次可以写出一个字节数据，代码使用演示： public class FOSWrite { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo&quot; + &quot;\\\\Demo5_6\\\\fos.txt&quot;); &#x2F;&#x2F; 写入数据 fos.write(97); fos.write(98); fos.write(99); &#x2F;&#x2F; 关闭 fos.close(); } } &#x2F;&#x2F; result: abc Tips: 1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示： public class FOSWriteDemo02 { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo&quot; + &quot;\\\\Demo5_6\\\\fos2.txt&quot;); &#x2F;&#x2F; 将字符串转换为字节数组 byte[] bytes = &quot;测试写入&quot;.getBytes(); &#x2F;&#x2F; 写出字节数组数据 fos.write(bytes); &#x2F;&#x2F; 测试写入 fos.close(); } } 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示： public class FosWriteDemo03 { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\fos3.txt&quot;); byte[] bytes = &quot;abcdef&quot;.getBytes(); &#x2F;&#x2F; 字符串转换为字节数组 fos.write(bytes,2,2); &#x2F;&#x2F; result：cd fos.close(); } } 数据追加续写 public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 以上两个构造方法，参数中都需要传入一个boolean类型的值，true表示追加数据，false表示清空原有数据。代码示例如下： public class FOSAppendWrite { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo&quot; + &quot;\\\\Demo5_6\\\\fos2.txt&quot;,true); &#x2F;&#x2F; 创建流对象，设置数据追加 fos.write(&quot;，测试追加。&quot;.getBytes()); &#x2F;&#x2F; result = 测试写入，测试追加。 fos.close(); } } 写出换行Windows中换行符号是\\r\\n。以下代码示例具体使用： public class FOSWriteDemo04 { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\c.txt&quot;); byte[] words = {97,98,99,100,101}; &#x2F;&#x2F; abcde for (byte i:words){ fos.write(i); fos.write(&quot;\\r\\n&quot;.getBytes()); &#x2F;&#x2F; 写出一个换行，将换行符号转为数组写出 } fos.close(); } } &#x2F;* result: a b c d e *&#x2F; Tips： 回车符\\r和换行符\\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r\\n； Unix系统里，每行结尾只有 换行 ，即\\n； Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。 2.3 字节输入流[InputStream]java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 2.4 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 代码示例如下： public class FileInputStreamDemo01 { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 使用File对象创建流对象 FileInputStream fis = new FileInputStream(new File(&quot;Demo5_6\\\\fos2.txt&quot;)); &#x2F;&#x2F; 使用文件名创建流对象 FileInputStream fis2 = new FileInputStream(&quot;Demo5_6\\\\fos.txt&quot;); } } 读取字节数据 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码演示如下： public class FISRead { public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\read.txt&quot;); byte[] bytes = {97,98,99,100,101}; for (byte b:bytes){ fos.write(b); fos.write(&quot;\\n&quot;.getBytes()); } fos.close(); &#x2F;&#x2F; 创建字节输入流对象，指向文件 FileInputStream fis = new FileInputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\read.txt&quot;); int b; while ((b = fis.read())!=-1){ &#x2F;&#x2F; 判断从数据中读取的值不等于-1 System.out.println((char)b); &#x2F;&#x2F; byte字节型转换为char字符型 } fis.close(); } } Tips:虽然读取了一个字节，但是会自动提示为int类型。操作完毕后，一定要close()。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示： public class FISReadDemo02 { public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\read.txt&quot;); int len; &#x2F;&#x2F; 定义变量，作为有效个数 byte[] bytes = new byte[2]; &#x2F;&#x2F; 定义字节数组，作为放字节数据的容器，存储2个字节 while ((len = fis.read(bytes))!=-1){ &#x2F;&#x2F; 这样每次可以读取2个字节 System.out.println(new String(bytes,0,len)); &#x2F;&#x2F; 每次读取后，将数组变成字符串打印 } fis.close(); } } 2.5 字节流练习：图片复制复制原理图解 代码示例 public class CopyImg { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 创建流对象，指定数据源 FileInputStream fis = new FileInputStream(&quot;C:\\\\Users\\\\14908\\\\Desktop\\\\Java\\\\img\\\\2_copy.jpg&quot;); &#x2F;&#x2F; 指定目的地 FileOutputStream fos = new FileOutputStream(&quot;D:\\\\IDEA_WorkSpace\\\\Demo&quot; + &quot;\\\\Demo5_6\\\\copy.jpg&quot;); &#x2F;&#x2F; 定义长度 int len; &#x2F;&#x2F; 定义数组 byte[] b = new byte[1024]; &#x2F;&#x2F; 循环读取 while ((len = fis.read(b))!=-1){ fos.write(b,0,len); } fos.close(); fis.close(); } } Tips： 流的关闭原则：先开后关，后开先关。 3. 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 3.1 字符输入流[Reader]java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 3.2 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 Tips: 1. 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表(IDEA中是UTF-8) 2. 字节缓冲区：一个字节数组，用来临时存储字节数据 构造方法FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 代码示例如下： public class FileReaderDemo throws IOException{ public static void main(String[] args){ &#x2F;&#x2F; 使用File对象创建流对象 FileReader fr = new FileReader(new File(&quot;Demo5_6\\\\a.txt&quot;))； &#x2F;&#x2F; 使用文件名称创建流对象 FileReader fr2 = new FileReader(&quot;Demo5_6\\\\a.txt&quot;)； } } 读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码演示如下： public class FRReadDemo01 { public static void main(String[] args) throws IOException { FileReader fr = new FileReader(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\d.txt&quot;); int w; while ((w = fr.read())!=-1){ System.out.print((char)w); } fr.close(); } } Tips：虽然读取了一个字符，但是会自动提升为int类型。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码演示如下： public class FRReadDemo02 { public static void main(String[] args) throws IOException { FileReader fr = new FileReader(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\d.txt&quot;); int len; char[] cbuf = new char[2]; &#x2F;&#x2F; 定义字符数组，作为放字符数据的容器 while ((len = fr.read(cbuf))!=-1){ System.out.print(new String(cbuf,0,len)); &#x2F;&#x2F; 转换为字符串输出 } fr.close(); } } 3.3 字符输出流[Writer]java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 3.4 FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 基本写出数据写出字符：write(int b) 方法，每次可以写出一个字符数据，代码示例如下： public class FWWrite { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\fw.txt&quot;); &#x2F;&#x2F; 写出数据 fw.write(97); fw.write(&#39;b&#39;); fw.write(&#39;c&#39;); fw.write(30000); fw.close(); &#x2F;&#x2F; result: abc田 } } Tips: 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 代码示例： public class FWWriteDemo02 { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\fw02.txt&quot;); &#x2F;&#x2F; 写出数据,通过flush fw.write(&#39;刷&#39;); fw.flush(); fw.write(&#39;新&#39;); fw.flush(); &#x2F;&#x2F; 写出数据，通过close fw.write(&#39;关&#39;); fw.close(); fw.write(&#39;闭&#39;); &#x2F;&#x2F; [报错] java.io.IOException: Stream closed fw.close(); } } Tips：即使使用了flush方法写出了数据，操作到最后还是要调用close方法，释放系统资源。 写出其他数据 写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，实例如下： public class FWCharWrite { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\fw03.txt&quot;); char[] chars = &quot;测试写出字符数组&quot;.toCharArray(); &#x2F;&#x2F; 将字符串转换为字符数组 fw.write(chars); &#x2F;&#x2F; 测试写出字符数组 fw.write(chars,4,2); &#x2F;&#x2F; 写出从索引2开始的2个字节，即&quot;字符&quot;2字 fw.close(); } } 写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，示例如下： public class FWWriteString { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\fw04.txt&quot;); fw.write(&quot;测试字符串写出&quot;); &#x2F;&#x2F; 测试字符串写出 fw.write(&quot;测试写出指定字符&quot;,2,2); &#x2F;&#x2F; 写出 fw.close(); } } 续写和换行：操作类似于FileOutputStream。 public class FWWriteString { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\fw04.txt&quot;); fw.write(&quot;测试字符串写出&quot;); &#x2F;&#x2F; 测试字符串写出 fw.write(&quot;\\r\\n&quot;); &#x2F;&#x2F; 写出换行符 fw.write(&quot;测试写出指定字符&quot;,2,2); &#x2F;&#x2F; 写出 fw.close(); } } 4. IO异常的处理JDK7前的处理之前的练习中，一直把异常直接抛出，实际开发中建议使用try...catch...finally 代码块，处理异常部分，代码示例如下： public class HandleException01 { public static void main(String[] args) { &#x2F;&#x2F; 声明一个Fw对象，指向空 FileWriter fw = null; try { &#x2F;&#x2F; 创建一个流对象，将fw指向该对象 fw = new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\fw05.txt&quot;); &#x2F;&#x2F; 写出数据 fw.write(&quot;异常的处理测试&quot;); } catch (IOException e) { e.printStackTrace(); }finally{ try{ if (fw != null){ fw.close(); } }catch (IOException e){ e.printStackTrace(); } } } } JDK7的处理可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。格式： try(创建流对象语句，如多个，使用&#39;;&#39;隔开){ &#x2F;&#x2F; 读写语句 }catch(IOException e){ e.printStackTrace(); } 代码示例： public class FWJDK7Dispose { public static void main(String[] args) { try(FileWriter fw = new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\fw06.txt&quot;);){ fw.write(&quot;测试JDK7后优化的try...catch&quot;); } catch (IOException e) { e.printStackTrace(); } } } JDK9的改进JDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，格式如下。改进前格式： &#x2F;&#x2F; 被final修饰的对象 final Resource resource1 = new Resource(&quot;resource1&quot;); &#x2F;&#x2F; 普通对象 Resource resource2 = new Resource(&quot;resource2&quot;); &#x2F;&#x2F; 引入方式：创建新的变量保存 try (Resource r1 = resource1; Resource r2 = resource2) { &#x2F;&#x2F; 使用对象 } 改进后的格式： &#x2F;&#x2F; 被final修饰的对象 final Resource resource1 = new Resource(&quot;resource1&quot;); &#x2F;&#x2F; 普通对象 Resource resource2 = new Resource(&quot;resource2&quot;); &#x2F;&#x2F; 引入方式：直接引入 try (resource1; resource2) { &#x2F;&#x2F; 使用对象 } 改进后的代码实例： public class TryDemo { public static void main(String[] args) throws IOException{ final FileReader fr = new FileReader(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\read.txt&quot;); FileWriter fw = new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\out.txt&quot;); try(fr;fw){ int b; while ((b = fr.read())!=-1){ fw.write(b); } } catch (IOException e) { e.printStackTrace(); } } } 5. 属性集5.1 概述java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 5.2 Properties类构造方法public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值，返回搜索到的值 public Set&lt;String&gt; stringPropertyNames() ：返回所有键名称的集合。 public class ProDemo { public static void main(String[] args) { &#x2F;&#x2F; 创建属性集对象 Properties pt = new Properties(); &#x2F;&#x2F; 添加键值对元素 pt.setProperty(&quot;小梦&quot;,&quot;168&quot;); pt.setProperty(&quot;小明&quot;,&quot;175&quot;); pt.setProperty(&quot;小张&quot;,&quot;178&quot;); &#x2F;&#x2F; 打印属性集对象 System.out.println(pt); &#x2F;&#x2F; 通过键获取值 Set&lt;String&gt; set = pt.stringPropertyNames(); &#x2F;&#x2F; 获取所以键，放入集合中 for (String key:set){ System.out.println(key+&quot;--&gt;&quot;+pt.getProperty(key)); } } } &#x2F;&#x2F; result {小明=175, 小张=178, 小梦=168} 小明--&gt;175 小张--&gt;178 小梦--&gt;168 store方法Properties集合中的方法store；用于把集合中的临时数据，持久化写入到硬盘中存储。 构造方法 void store(OutPutStream out,String comments); 字节输出流，不能写入中文 void store(Write write,String comments); 字符输出流，可以写中文 String comments: 注释，用来解释说明保存的文件是做什么的，不能中文注释 代码示例： public class ProDemo02 { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 1. 创建Properties集合对象，添加数据 Properties pro = new Properties(); pro.setProperty(&quot;小明&quot;,&quot;177&quot;); pro.setProperty(&quot;小立&quot;,&quot;181&quot;); pro.setProperty(&quot;小化&quot;,&quot;173&quot;); &#x2F;&#x2F; 2. 创建字节输出流&#x2F;字符输出流对象，绑定输出目的地。 FileWriter fw = new FileWriter(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\prop.txt&quot;); &#x2F;&#x2F; 3. 使用Properties集合中的方法store，把集合中的临时数据，写入到硬盘中 pro.store(fw,&quot;save data&quot;); &#x2F;&#x2F; 4. 释放资源 fw.close(); &#x2F;* prop.txt #save data #Tue May 07 20:47:14 CST 2019 小明=177 小立=181 小化=173 *&#x2F; } } load方法可以使用Properties集合中的方法load，把硬盘中保存的文件(键值对形式的)，读取到集合中使用。 构造方法： void load(InputStream inStream); 字节输入流，不能读取含有中文的键值对 void load(Reader reader); 字符输入流，可以读取中文 注意： 存储键值对的文件中，键与值的默认连接符号可以使用=，空格(其他符号)，一般使用= 存储键值对的文件中，可以使用# 做注释，注释的内容不会被读取 存储键值对的文件中，键值默认都是字符串，不需要再加引号 代码示例： public class ProLoadMethod { public static void main(String[] args) throws IOException { &#x2F;&#x2F; 1. 创建Properties集合对象 Properties pro = new Properties(); &#x2F;&#x2F; 2. 使用Properties集合对象中的load方法来读取保存键值对的文件 pro.load(new FileReader(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_6\\\\prop.txt&quot;)); &#x2F;&#x2F; 3.遍历Properties集合 Set&lt;String&gt; set = pro.stringPropertyNames(); for (String key:set){ System.out.println(key + &quot;--&gt;&quot; + pro.getProperty(key)); } } } 今日总结： IO的概述 IO的分类：根据数据流向：输入流和输出流，根据数据类型：字节流和字符流。 字节输出流OutPutStream类的子类FileFileOutputStream类构造方法创建流对象的方式 FileFileOutputStream类的基本方法write的三种使用方式 数据的追加续写：FileFileOutputStream类的第二个参数布尔值，true追加，false清空。 关于换行符的写入 字节输入流InputStream类的子类FileInputStream类 FileInputStream类构造方法创建流对象的方式 FileInputStream类的基本方法read的2种使用方式，读取字节和读取字节数组。 字符输入流Reader类的子类FileReader类 FileReader类构造方法创建流对象的方式 读取字符数据的两种方式，读取字符和读取字符数据 字符输出流Write类的子类FileWrite类构造方法创建流对象的方式 使用write写出数据的方法：写出字符、写出字符数组写出字符串 关闭close()和刷新flush方法 IO异常处理的优化方案 属性集的概述和使用 Properties类的构造方法创建流对象 基本存储方法:setProperty(),getProperty(),stringPropertyNames() 读取load()和写入store()方法","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"},{"name":"IO流","slug":"IO流","permalink":"https://zero024.cn/tags/IO流/"}]},{"title":"Java中File类和递归","slug":"JavaBasics/File类和递归","date":"2019-05-05T15:59:00.000Z","updated":"2020-03-08T00:49:34.999Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. File类java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。","text":"1. File类java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 1.1 构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 代码举例如下： public class DemoFileClass { public static void main(String[] args) { &#x2F;&#x2F; 通过文件绝对路径 String pathname = &quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5\\\\testfile.txt&quot;; File file1 = new File(pathname); &#x2F;&#x2F; System.out.println(file1); &#x2F;&#x2F; 通过父路径和子路径字符串 String parent = &quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5&quot;; String child = &quot;testfile.txt&quot;; File file2 = new File(parent,child); &#x2F;&#x2F; System.out.println(file2); &#x2F;&#x2F; 通过父级File对象和子路径字符串 File parentDir = new File(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5&quot;); File file3 = new File(parentDir,child); System.out.println(file3); } } 一个File对象代表硬盘中实际存在的一个文件或者目录；无论该路径下是否存在文件或者目录，都不影响File对象的创建。 1.2 常用方法获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 实例代码如下： public class GetFileDemo { public static void main(String[] args) { File file = new File(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5\\\\testfile.txt&quot;); System.out.println(&quot;文件绝对路径:&quot; + file.getAbsolutePath()); System.out.println(&quot;文件构造路径:&quot; + file.getPath()); System.out.println(&quot;文件名称:&quot; + file.getName()); System.out.println(&quot;文件长度:&quot; + file.length()+&quot;字节&quot;); File fileDir = new File(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5&quot;); System.out.println(&quot;目录绝对路径：&quot; + fileDir.getAbsolutePath()); System.out.println(&quot;目录构造路径：&quot; + fileDir.getPath()); System.out.println(&quot;目录名称：&quot; + fileDir.getName()); System.out.println(&quot;目录长度：&quot; + fileDir.length()); } } &#x2F;&#x2F; 上述输出结果： 文件绝对路径:D:\\IDEA_WorkSpace\\Demo\\Demo5_5\\testfile.txt 文件构造路径:D:\\IDEA_WorkSpace\\Demo\\Demo5_5\\testfile.txt 文件名称:testfile.txt 文件长度:32字节 目录绝对路径：D:\\IDEA_WorkSpace\\Demo\\Demo5_5 目录构造路径：D:\\IDEA_WorkSpace\\Demo\\Demo5_5 目录名称：Demo5_5 目录长度：4096 API中说明：length(), 表示文件的长度。但是File对象表示目录，则返回值未指定。 绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 public class FilePath { public static void main(String[] args) { System.out.println(new File(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\&quot; + &quot;Demo5_5\\\\testfile.txt&quot;).getAbsolutePath()); System.out.println(new File(&quot;testfile.txt&quot;).getAbsolutePath()); } } &#x2F;&#x2F; output result D:\\IDEA_WorkSpace\\Demo\\Demo5_5\\testfile.txt D:\\IDEA_WorkSpace\\testfile.txt 判定功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 示例代码如下： public class FileIs { public static void main(String[] args) { File file = new File(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5\\\\testfile.txt&quot;); File dir = new File(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5&quot;); &#x2F;&#x2F; 判断是否存在文件或者目录,返回布尔值 System.out.println(file.exists()); &#x2F;&#x2F; true System.out.println(dir.exists()); &#x2F;&#x2F; true System.out.println(new File(&quot;A:\\\\testDir&quot;).exists()); &#x2F;&#x2F; false &#x2F;&#x2F; 判断是文件还是目录 &#x2F;&#x2F; System.out.println(&quot;is file?: &quot; + file.isFile()); &#x2F;&#x2F; true &#x2F;&#x2F; System.out.println(&quot;is file?: &quot; + dir.isFile()); &#x2F;&#x2F; false &#x2F;&#x2F; System.out.println(&quot;is directory?: &quot; + file.isDirectory()); &#x2F;&#x2F; false &#x2F;&#x2F; System.out.println(&quot;is directory?: &quot; + dir.isDirectory()); &#x2F;&#x2F; true Judge(file); Judge(dir); } public static void Judge(File file){ if (file.isFile()) System.out.println(file + &quot; 是文件&quot;); if (file.isDirectory()) System.out.println(file + &quot; 是目录&quot;); } } 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir() ：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 示例如下： public class FileCreDel{ final static String rootpath = &quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5\\\\&quot;; public static void main (String[] args) throws IOException { System.out.println(&quot;创建文件:1\\n创建文件夹：2\\n删除文件或文件夹：3\\n退出：4&quot;); Scanner sc = new Scanner(System.in); while (true) { int pattern = sc.nextInt(); switch (pattern) { case 1: System.out.println(&quot;输入需要创建的文件名:&quot;); CreFile(sc.next()); break; case 2: System.out.println(&quot;输入需要创建的文件夹名:&quot;); MkDir(sc.next()); break; case 3: System.out.println(&quot;输入需要删除的文件或文件夹名称:&quot;); Del(sc.next()); break; case 4: System.exit(0); } } } public static void CreFile(String name) throws IOException { File file = new File(rootpath + name); if (file.exists() == false) { file.createNewFile(); System.out.println(name + &quot;文件创建成功&quot;); } else{ System.out.println(name + &quot;文件已经存在，创建失败！&quot;); } } public static void MkDir(String name) throws IOException{ File dir = new File(rootpath + name); if (dir.exists() == false){ dir.mkdirs(); System.out.println(name + &quot;文件夹创建成功&quot;); }else{ System.out.println(name + &quot;文件夹已存在，创建失败！&quot;); } } public static void Del(String name){ if (new File(rootpath + name).delete() == true){ System.out.println(&quot;删除成功！&quot;); }else { System.out.println(&quot;删除失败，文件或文件夹不存在！&quot;); } } } API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。 1.3 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 public class FileFor { public static void main(String[] args) { File dir = new File(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5\\\\&quot;); &#x2F;&#x2F; 获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name:names){ System.out.println(name); } &#x2F;&#x2F; 获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息。 File[] files = dir.listFiles(); for (File file:files){ System.out.println(file); } } } Tips:调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 2. 递归2.1 概述 递归：指在当前方法内调用自己的这种现象。 递归的分类: 递归分为两种，直接递归和间接递归。 直接递归称为方法自身调用自己。 间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。 注意事项： 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。 构造方法,禁止递归。 2.2 递归累加求和计算1~n的和分析：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。 实例如下： public class DemoRecursion02 { public static void main(String[] args) { int num = 5; System.out.println(getSum(num)); } public static int getSum(int num){ if (num == 1) return 1; return num+getSum(--num); &#x2F;&#x2F; 为什么num--会报错？ num--：num先参与运算，在减一，这样传递过去的一直是5，故--num才行，先自减1在参与运算。 } } 2.3 递归求阶乘 阶乘：所有小于及等于该数的正整数的积。 n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1 分析：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。 推理得出：n! = n * (n-1)! 代码实现如下： public class DemoRecursion03 { public static void main(String[] args) { int n = 5; System.out.println(n + &quot;的阶乘为：&quot; + getValue(n)); } public static int getValue(int n){ if (n == 1) return 1; return n * getValue(--n); } } 2.4 递归打印多级目录分析：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。 示例代码： public class RecursionPrintDir { public static void main(String[] args) { File dir = new File(&quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\&quot;); printDir(dir); } public static void printDir(File dir){ File[] files = dir.listFiles(); &#x2F;&#x2F; 获取文件或目录file对象 for (File file:files){ if (file.isFile()){ System.out.println(&quot;文件名：&quot; + file.getAbsolutePath()); &#x2F;&#x2F;如果是文件则打印绝对路径 }else{ System.out.println(&quot;目录：&quot; + file.getAbsolutePath()); printDir(file); &#x2F;&#x2F; 继续遍历，调用printdir，形成递归 } } } } 3. 综合案例3.1 文件搜索输入文件名称，输出文件路径分析： 目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。 遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。 代码实现： public class SearchFile { static String rootpath = &quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5\\\\&quot;; &#x2F;&#x2F; final static String filename = &quot;FileFor.java&quot;; public static void main(String[] args) { System.out.println(&quot;输入你要搜索的文件名：&quot;); searchfile(new File(rootpath),new Scanner(System.in).next()); } public static void searchfile(File dir,String filename){ File[] files = dir.listFiles(); for (File file:files){ if(file.isFile()){ if (file.getName().equals(filename) == true){ System.out.println(file.getAbsolutePath()); } }else{ searchfile(file,filename); } } } } 注意：==和equals的区别！！！ 3.2 文件过滤器的优化java.io.FileFilter是一个接口，是File的过滤器。 该接口的对象可以传递给File类的listFiles(FileFilter) 作为参数， 接口中只有一个方法。 boolean accept(File pathname) ：测试pathname是否应该包含在当前File目录中，符合则返回true。 分析： 接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。 accept方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则： 要么是.java文件。 要么是目录，用于继续遍历。 通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印。 代码实现： public class DemoFileFilter { static String rootpath = &quot;D:\\\\IDEA_WorkSpace\\\\Demo\\\\Demo5_5\\\\&quot;; public static void main(String[] args) { printDir(new File(rootpath)); } public static void printDir(File dir){ &#x2F;&#x2F; 匿名内部类方式,创建过滤器子类对象 File[] files = dir.listFiles(new FileFilter() { @Override public boolean accept(File pathname) { return pathname.getName().endsWith(&quot;.java&quot;)||pathname.isDirectory();&#x2F;&#x2F; 过滤掉除了.java文件和目录以外的所有东西 } }); &#x2F;&#x2F; 循环打印过滤后的数据 for (File file:files){ if (file.isFile()){ System.out.println(&quot;文件名：&quot;+file.getAbsolutePath()); }else{ printDir(file); } } } } 3.3 Lambda优化代码示例如下： public static void printDir2(File dir){ File[] files = dir.listFiles(f-&gt;{return f.getName().endsWith(&quot;.java&quot;) || f.isDirectory();}); for (File file:files){ if (file.isFile()){ System.out.println(&quot;文件名：&quot;+file.getAbsolutePath()); }else{ printDir2(file); } } } 今日总结 Java中的File类 文件和目录的创建和删除操作 File类的一些方法 递归的概念以及使用遇到的问题： ==与equals的区别，使用过程中的注意事项 Lambda表达式还不熟练 时间管理","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Java中的线程池与Lambda表达式","slug":"JavaBasics/线程池与Lambda表达式","date":"2019-05-03T15:59:00.000Z","updated":"2020-03-08T00:40:03.203Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. 等待唤醒机制概念：多个线程在处理同一个资源，但处理的动作(线程的任务)却不相同。 比如：线程A用来生产包子，线程B用来吃包子，包子可以理解为同一资源。线程A与线程B的处理动作，一个是生产，一个是消费。那么线程A与线程B之间就存在线程通信问题。","text":"1. 等待唤醒机制概念：多个线程在处理同一个资源，但处理的动作(线程的任务)却不相同。 比如：线程A用来生产包子，线程B用来吃包子，包子可以理解为同一资源。线程A与线程B的处理动作，一个是生产，一个是消费。那么线程A与线程B之间就存在线程通信问题。 为什么要处理线程间通信： 多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 如何保证线程间通信有效利用资源： 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。 1.1 等待唤醒机制什么是等待唤醒机制 这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 就是在一个线程进行了规定操作后，就进入等待状态wait()， 等待其他线程执行完他们的指定代码过后 再将其唤醒notify() ;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 wait/notify 就是线程间的一种协作机制。 等待唤醒中的方法 等待唤醒机制就是用于解决线程间通信的问题，使用的3个方法含义如下： wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。 notifyAll：则释放所通知对象的 wait set 上的全部线程。 注意：哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不在持有锁，所以它需要再次尝试获取锁(可能会面临其他线程的竞争),成功后才能在当初调用wait方法之后的地方恢复执行。 总结：如果能获取锁，线程就从waiting状态变成Runnable状态；否则，从wait set出来，又会进入entry set，线程就从waiting状态变成了Blocked状态。 调用wait和notify方法需要注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 1.2 生成者与消费者问题等待唤醒机制其实就是经典的”生产者与消费者”的问题。 拿生产包子消费包子来说等待唤醒机制如何有效利用资源： 包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。 代码实例如下： &#x2F;&#x2F; 资源类 public class Baozi { &#x2F;&#x2F; 设置包子的属性 String pier; &#x2F;&#x2F; 皮 String xianer; &#x2F;&#x2F; 陷 boolean flag = false; &#x2F;&#x2F; 包子的状态：有就true，没有就false } &#x2F;&#x2F; 生产者类 public class BaoZiPu extends Thread{ &#x2F;&#x2F; 生成者(包子铺)类：是一个线程类，可以继承Thread &#x2F;&#x2F; 1.需要在成员位置创建一个包子变量 private Baozi bz; &#x2F;&#x2F; 2.使用带参构造方法，为包子变量赋值 public BaoZiPu(String name, Baozi bz){ super(name); this.bz = bz; } &#x2F;&#x2F; 设置线程任务(run)：生成包子 &#x2F;* 包子铺线程和包子线程关系---&gt;通信(互斥) 必须使用同步技术保证两个线程只能有一个在执行 锁对象必须保持唯一，可以使用包子对象作为锁对象 包子铺类和吃货的类就需要把包子对象作为参数传递进来 1.需要在成员位置创建一个包子变量 2.使用带参构造方法，为包子变量赋值 *&#x2F; @Override public void run(){ int count = 0; &#x2F;&#x2F; 造包子 while (true){ &#x2F;&#x2F; 必须使用同步技术保证两个线程只能有一个在执行 synchronized (bz) { if (bz.flag == true) { &#x2F;&#x2F; 对包子状态进行判断 try { bz.wait(); &#x2F;&#x2F; true：有包子,包子铺调用wait方法进入等待状态 } catch (InterruptedException e) { e.printStackTrace(); } } &#x2F;&#x2F; 没有包子，包子铺生产包子 System.out.println(&quot;包子铺开始做包子&quot;); if (count % 2 == 0) { bz.pier = &quot;面皮&quot;; bz.xianer = &quot;五花肉&quot;; } else { bz.pier = &quot;薄皮&quot;; bz.xianer = &quot;韭菜鸡蛋&quot;; } count++; try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } &#x2F;&#x2F; 包子铺生成好了包子 bz.flag = true; &#x2F;&#x2F; 修改包子的状态为true System.out.println(&quot;包子造好了：&quot; + bz.pier + bz.xianer+&quot;,吃货来吃吧!&quot;); bz.notify(); &#x2F;&#x2F; 唤醒吃货线程，起来吃包子了 } } } } &#x2F;&#x2F; 消费者类 public class BaoZiPu extends Thread{ &#x2F;&#x2F; 生成者(包子铺)类：是一个线程类，可以继承Thread &#x2F;&#x2F; 1.需要在成员位置创建一个包子变量 private Baozi bz; &#x2F;&#x2F; 2.使用带参构造方法，为包子变量赋值 public BaoZiPu(String name, Baozi bz){ super(name); this.bz = bz; } &#x2F;&#x2F; 设置线程任务(run)：生成包子 &#x2F;* 包子铺线程和包子线程关系---&gt;通信(互斥) 必须使用同步技术保证两个线程只能有一个在执行 锁对象必须保持唯一，可以使用包子对象作为锁对象 包子铺类和吃货的类就需要把包子对象作为参数传递进来 1.需要在成员位置创建一个包子变量 2.使用带参构造方法，为包子变量赋值 *&#x2F; @Override public void run(){ int count = 0; &#x2F;&#x2F; 造包子 while (true){ &#x2F;&#x2F; 必须使用同步技术保证两个线程只能有一个在执行 synchronized (bz) { if (bz.flag == true) { &#x2F;&#x2F; 对包子状态进行判断 try { bz.wait(); &#x2F;&#x2F; true：有包子,包子铺调用wait方法进入等待状态 } catch (InterruptedException e) { e.printStackTrace(); } } &#x2F;&#x2F; 没有包子，包子铺生产包子 System.out.println(&quot;包子铺开始做包子&quot;); if (count % 2 == 0) { bz.pier = &quot;面皮&quot;; bz.xianer = &quot;五花肉&quot;; } else { bz.pier = &quot;薄皮&quot;; bz.xianer = &quot;韭菜鸡蛋&quot;; } count++; try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } &#x2F;&#x2F; 包子铺生成好了包子 bz.flag = true; &#x2F;&#x2F; 修改包子的状态为true System.out.println(&quot;包子造好了：&quot; + bz.pier + bz.xianer+&quot;,吃货来吃吧!&quot;); bz.notify(); &#x2F;&#x2F; 唤醒吃货线程，起来吃包子了 } } } } &#x2F;&#x2F; 测试类 public class TestDemo { public static void main(String[] args) { Baozi bz = new Baozi(); &#x2F;&#x2F; 创建包子对象 new BaoZiPu(&quot;包子铺&quot;,bz).start(); &#x2F;&#x2F; 创建包子铺线程，开启，生产包子 new Chihuo(&quot;吃货&quot;,bz).start(); &#x2F;&#x2F; 创建吃货线程，开启，吃包子 } } 2. 线程池2.1 线程池思想概述如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。下面就详细讲解一下Java的线程池。 2.2 线程池概念 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。下图描述线程池的工作原理： 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 2.3 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的,因此java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int n Threads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。 使用线程池中线程对象的步骤： 创建线程池对象。 创建Runnable接口子类对象。(task) 提交Runnable接口子类对象。(take task) 关闭线程池(一般不做)。 Runnable实现类实例如下： &#x2F;&#x2F; 实现类 public class MyRunnable implements Runnable{ @Override public void run() { System.out.println(&quot;我要一个教练&quot;); try{ Thread.sleep(2000); }catch(InterruptedException e){ e.printStackTrace(); } System.out.println(&quot;教练来了：&quot;+Thread.currentThread().getName()); System.out.println(&quot;教我游泳,教完后，教练回到了游泳池&quot;); } } &#x2F;&#x2F; 线程池测试类 public class ThreadPoolDemo { public static void main(String[] args) { &#x2F;&#x2F; 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2); &#x2F;&#x2F; 创建了包含2个线程对象的线程池 &#x2F;&#x2F; 创建Runnable实例对象 MyRunnable r = new MyRunnable(); &#x2F;&#x2F; new Thread(r).start(); &#x2F;&#x2F; 使用传统方式，自己创建线程对象 service.submit(r); &#x2F;&#x2F; 从线程池中获取线程对象，然后会自动调用MyRunnable中的run() service.submit(r); &#x2F;&#x2F; 再次获取一个线程对象 service.submit(r); &#x2F;&#x2F; again &#x2F;* 注意：submit方法调用结束后，程序并没终止，是因为线程池控制了线程的关闭 将使用完的线程又归还到了线程池中 *&#x2F; service.shutdown(); } } 3. Lambda表达式3.1 函数式编程思想概述在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做 面向对象的思想:做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情。 函数式编程思想:只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程 3.2 冗余的Runnable代码传统写法当需要启动一个线程去完成任务是，通常会通过java.lang.Runnable接口来定义任务内容，并使java.lang.Thread类来启动该线程。如下所示： public class Demo01Runnable { public static void main(String[] args) { &#x2F;&#x2F; 匿名内部类 Runnable task = new Runnable() { @Override public void run() { &#x2F;&#x2F; 覆盖重写抽象方法 System.out.println(&quot;多线程任务具体执行内容！&quot;); } }; new Thread(task).start(); &#x2F;&#x2F; 启动线程 } } 本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个Runnable接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。 代码分析对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 3.3 编程思想转换专注于具体做什么，而不是这么做很多时候我们为了做具体的事情而不得不创建了一个匿名内部类对象来完成，这是非必要的。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码 –这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了Lambda表达式的重量级新特性，为我们打开了新世界的大门。 3.4 体验Lambda的更优写法借助Java 8的全新语法，上述Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： public class DemoLambdaRunnable { public static void main(String[] args) { new Thread(() -&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); &#x2F;&#x2F; 启动线程 } } 这段代码同上一段执行效果完全一样。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。 3.5 回顾匿名内部类使用实现类要启动一个线程，需要创建一Thread类的对象调用start方法。而为了指定线程执行的内容，需要调用Thread类的构造方法： public Thread(Runnable target)为了获取Runnable接口的实现对象，还要为该接口定义一个实现类RunnableImpl： public class RunnableImpl implements Runnable{ @Override public void run(){ System.out.println(&quot;多线程任务执行！&quot;) } } 然后创建该实现类的对象作为Thread类的构造参数： public class ThreadInitParam{ public static void main(String[] args){ Runnable task = new RunnableImpl(); new Thread(task).start(); } } 使用匿名内部类这个RunnableImpl类只是为了实现Runnable接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类： public class ThreadNameless { public static void main(String[] args) { new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;多线程任务执行！&quot;); } }).start(); } } 匿名内部类的好处与弊端一方面，匿名内部类可以帮我们省去实现类的定义；另一方面，匿名内部类的语法——确实太复杂了！ 语义分析仔细分析该代码中的语义，Runnable接口只有一个run方法的定义： public abstract void run();即制定了一种做事情的方案（其实就是一个函数）： 无参数：不需要任何条件即可执行该方案。 无返回值：该方案不产生任何结果。 代码块（方法体）：该方案的具体执行步骤。 同样的语义体现在Lambda语法中，要更加简单： () -&gt; System.out.println(&quot;多线程任务执行！&quot;) 前面的一对小括号即run方法的参数（无），代表不需要任何条件； 中间的一个箭头代表将前面的参数传递给后面的代码； 后面的输出语句即业务逻辑代码。 3.6 Lambda标准格式Lambda省去面向对象的条条框框，格式由3个部分组成： 一些参数 一个箭头 一段代码Lambda表达式的标准格式为：(参数类型 参数名称) -&gt; { 代码语句 }格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 3.7 Lambda的参数和返回值// Todo 使用数组存储多个Person对象。 // Todo 对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序。 下面举例演示java.util.Comparator&lt;T&gt;接口的使用场景代码，其中的抽象方法定义为： public abstract int compare(T o1, T o2); 当需要对一个对象数组进行排序时，Arrays.sort方法需要一个Comparator接口实例来指定排序的规则。假设有一个Person类，含有String name和int age两个成员变量： public class Person{ private String name; private int age; &#x2F;&#x2F; 省略构造器、toString方法与Getter Setter } 传统写法使用传统代码对Person[]数组进行排序 public class DemoComparator { public static void main(String[] args) { &#x2F;&#x2F; 创建一个Person数组 Person[] array = { new Person(&quot;xiaom&quot;,13), new Person(&quot;xiaoz&quot;,17), new Person(&quot;xiaol&quot;,15)}; &#x2F;&#x2F; Comparator接口的实例（使用了匿名内部类）重写了compare方法，制定了&quot;按照年龄从小到大升序(前-后)&quot;的排序规则。 Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { return o1.getAge() - o2.getAge(); } }; Arrays.sort(array,comp); &#x2F;&#x2F; 第二个参数为排序规则，即Comparator接口实例 for(Person person:array){ System.out.println(person); } } } 代码分析 为了排序，Arrays.sort方法需要排序规则，即Comparator接口的实例，抽象方法compare是关键； 为了指定compare的方法体，不得不需要Comparator接口的实现类； 为了省去定义一个ComparatorImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象compare方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 实际上，只有参数和方法体才是关键。 Lambda写法 public class DemoComparatorLambda { public static void main(String[] args) { &#x2F;&#x2F; 创建一个Person数组 Person[] array = { new Person(&quot;xiaom&quot;,13), new Person(&quot;xiaoz&quot;,17), new Person(&quot;xiaol&quot;,15)}; Arrays.sort(array,(Person a,Person b) -&gt; {return a.getAge() - b.getAge();}); for(Person person:array){ System.out.println(person); } } } 3.8 练习给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值： &#x2F;&#x2F; 定义接口类 public interface Calculator { public abstract int calc(int a,int b); } &#x2F;&#x2F; 定义测试类 public class DemoInvokeCalc { public static void main(String[] args) { &#x2F;&#x2F; 使用匿名内部类实现 invokeCalc(10, 20, new Calculator() { @Override public int calc(int a, int b) { return a + b; } }); &#x2F;&#x2F; TODO 请在此使用Lambda[标准格式]调用invokeCalc方法来计算120+130的结果 invokeCalc(120,130,(int a,int b)-&gt; {return a+b;}); &#x2F;&#x2F; 使用Lambda表达式实现 invokeCalc(20,30,(a, b) -&gt; a + b); &#x2F;&#x2F; Lambda表达式省略格式写法 } private static void invokeCalc(int a,int b,Calculator calculator){&#x2F;&#x2F; 三个参数，2个int类型整数，1个接口 int result = calculator.calc(a, b); System.out.println(&quot;结果是：&quot;+result); } } 3.9 Lambda省略格式可推导即可省略Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法： public static void main(String[] args){ invokeCalc(120,130,(a,b)-&gt;a+b); } 省略规则在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 3.10 Lambda的使用前提Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 注：有且仅有一个抽象方法的接口，称为“函数式接口”。","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://zero024.cn/tags/线程/"},{"name":"Lambda","slug":"Lambda","permalink":"https://zero024.cn/tags/Lambda/"}]},{"title":"Java中的线程详解和同步方法","slug":"JavaBasics/线程与同步","date":"2019-04-28T15:30:00.000Z","updated":"2020-03-08T00:49:48.935Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. 线程线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。","text":"1. 线程线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 1.1 多线程原理代码示例： &#x2F;&#x2F; 定义线程类 public class MyThread extends Thread{ &#x2F;&#x2F; 定义指定线程名称的构造方法 public MyThread(String name) { &#x2F;&#x2F; 调用父类的String参数的构造方法，指定线程的名称 super(name); } &#x2F;&#x2F; 重写run方法，完成该线程的执行逻辑 @Override public void run(){ for(int i = 0;i &lt; 10;i++){ System.out.println(getName()+&quot;正在执行第&quot;+i+&quot;次&quot;);&#x2F;&#x2F; getName获取当前线程名称 } } } &#x2F;&#x2F; 测试类 public class TestThread { public static void main(String[] args) { &#x2F;&#x2F; 创建线程对象 MyThread mt = new MyThread(&quot;小强&quot;); &#x2F;&#x2F; 启动线程 mt.start(); &#x2F;&#x2F; 在主方法中执行for循环 for(int i = 0;i &lt; 10;i++){ System.out.println(&quot;旺财&quot;+i); } } } 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。 1.2 Thread类java.lang.Thread类中定义了有关线程的一些方法: 构造方法： public Thread() ：分配一个新的线程对象。 public Thread(String name) :分配一个指定名字的新的线程对象。 public Thread(Runnable target) :分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。 常用方法: public String getName():获取当前线程名称。 public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run():此线程要执行的任务在此处定义代码。 public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread():返回对当前正在执行的线程对象的引用 1.3 创建线程方式二采用 java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可。步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动线程。 代码示例如下： &#x2F;&#x2F; 实现类 public class MyRunnable implements Runnable{ @Override public void run() { &#x2F;&#x2F; 重写run方法 for (int i = 0;i &lt; 10; i++){ System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); } } } &#x2F;&#x2F; 测试类 public class RunnableDemo { public static void main(String[] args) { &#x2F;&#x2F; 创建类对象，线程任务对象 MyRunnable mr = new MyRunnable(); &#x2F;&#x2F; 创建线程对象 Thread r = new Thread(mr,&quot;小强&quot;); r.start(); for (int i = 0;i &lt; 10;i++){ System.out.println(&quot;旺财&quot;+i); } } } 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 Tips::Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 1.4 Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 实现Runnable接口创建多线程程序的好处： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类 在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。 1.5 匿名内部类方法实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。 使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法： public class NoNameInnerClassThread { public static void main(String[] args) { Runnable r = new Runnable() { @Override public void run() { for(int i = 0;i&lt;10;i++){ System.out.println(&quot;小张&quot;+i); } } }; new Thread(r).start(); for (int i = 0; i &lt; 10; i++) { System.out.println(&quot;小李&quot;+i); } } } 2. 线程安全如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 举例演示线程的安全问题：电影院要卖票，模拟电影院的卖票过程。假设要播放的电影是“复联4”，本次电影的座位共100个(本场电影只能卖100张票)。 我们模拟电影院的售票窗口，实现多个窗口同时卖“复联4”这场电影票(多个窗口一起卖这100张票) 需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟 代码示例如下： &#x2F;&#x2F; 实现类 public class Ticket implements Runnable{ private int ticket = 100; &#x2F;&#x2F; 执行卖票流程 @Override public void run() { &#x2F;&#x2F; 每个窗口的卖票操作 while (true){ if (ticket&gt;0){ try{ Thread.sleep(100); }catch (InterruptedException e){ e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot;正在卖&quot;+ticket--); } } } } &#x2F;&#x2F; 测试类 public class TicketDemo { public static void main(String[] args) { Ticket tk = new Ticket(); &#x2F;&#x2F; 创建线程任务对象 &#x2F;&#x2F; 创建3个窗口对象 Thread t1 = new Thread(tk,&quot;窗口1&quot;); Thread t2 = new Thread(tk,&quot;窗口2&quot;); Thread t3 = new Thread(tk,&quot;窗口3&quot;); &#x2F;&#x2F; 同时进行卖票操作 t1.start(); t2.start(); t3.start(); } } 结果有一部分会出现如下情况：发现程序出现了两个问题： 有部分相同的票数被卖了两回。 不存在的票，比如0票与-1票，是不存在的。 这种几个窗口(线程)票数不同步了，这种问题称为线程不安全。 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作,一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 2.1 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。根据案例简述： 窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。有三种方式完成同步操作： 同步代码块。 同步方法。 锁机制。 2.2 同步代码块 同步代码块：synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。格式：synchronized(同步锁){需要同步操作的代码} 同步锁：对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁。 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 注意： 在任何时候候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 使用同步代码块解决线程同步问题实例： public class Ticket implements Runnable{ private int ticket = 100; Object lock = new Object(); &#x2F;&#x2F; 创建锁对象 &#x2F;&#x2F; 执行卖票流程 @Override public void run() { &#x2F;&#x2F; 每个窗口的卖票操作 while (true){ synchronized (lock) { &#x2F;&#x2F; 加锁 if (ticket &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;正在卖&quot; + ticket--); }else{ break; } } } } } &#x2F;&#x2F; 当使用了同步代码块后，上述的线程的安全问题就解决了。 2.3 同步方法 同步方法：使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。格式：public synchroized void method(){可能会产生线程问题的代码} 同步锁是谁？对于非static方法，同步锁就是this。对于static方法，使用当前方法所在类的字节码对象(类名.class) 使用同步方法解决线程安全问题代码示例： public class Ticket implements Runnable{ private int ticket = 100; Object lock = new Object(); &#x2F;&#x2F; 创建锁对象 &#x2F;&#x2F; 执行卖票流程 @Override public void run() { &#x2F;&#x2F; 每个窗口的卖票操作 while (true){ sellTicket(); if (ticket==0) break; } } public synchronized void sellTicket(){ &#x2F;&#x2F; 使用synchronized修饰方法 &#x2F;&#x2F; 卖票操作 if (ticket &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;正在卖&quot; + ticket--); } } } 2.4 Lock锁java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock() :加同步锁。 public void unlock() :释放同步锁。 使用Lock锁解决线程安全问题代码示例： public class Ticket implements Runnable{ private int ticket = 100; Lock lock = new ReentrantLock(); &#x2F;&#x2F; 执行卖票流程 @Override public void run() { &#x2F;&#x2F; 每个窗口的卖票操作 while (true){ lock.lock(); &#x2F;&#x2F; 上锁 if (ticket &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;正在卖&quot; + ticket--); } lock.unlock(); &#x2F;&#x2F; 解锁 if (ticket == 0) break; } } } 3, 线程状态3.1线程状态概述当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态： 这里先列出各个线程状态发生的条件，下面对每种状态进行详细解析： 3.2 Timed Waiting(计时等待)Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。 在前面写的卖票案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，以下通过案例加深理解。 实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串 public class TimeWaitingDemo extends Thread{ public void run(){ for (int i = 0; i &lt; 100; i++) { if (i%10==0) System.out.println(&quot;------&quot;+i); System.out.print(i); try { Thread.sleep(1000); System.out.print(&quot;线程睡眠1s！\\n&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args){ new TimeWaitingDemo().start(); } } sleep方法的使用还是很简单的,需要注意下面几点： 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠 sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。 Timed Waiting 线程状态图： 3.3 BLOCKED(锁阻塞)Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。 在学完同步机制后，这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，如下图示： 3.4 Wating(无限等待)Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。代码示例： public class WaitingDemo { public static Object obj = new Object(); public static void main(String[] args){ &#x2F;&#x2F; 演示waiting new Thread(new Runnable() { &#x2F;&#x2F; 匿名内部类 @Override public void run() { while (true){ synchronized (obj){ try { System.out.println(Thread.currentThread().getName()+&quot;=== 获取到锁对&quot; + &quot;象，调用wait方法，进入waiting状态，释放锁对象&quot;); obj.wait();&#x2F;&#x2F; 进入无限等待状态 &#x2F;&#x2F; obj.wait(5); &#x2F;&#x2F; 5s后自动醒来 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot;=== 从waiting状态&quot; + &quot;醒来，获取到锁对象，继续执行&quot;); } } } },&quot;等待线程&quot;).start(); new Thread(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName()+&quot;------- 等待3秒&quot;); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (obj){ System.out.println(Thread.currentThread().getName()+&quot;------ 获取到锁对象&quot; + &quot;，调用notify方法，释放锁对象&quot;); obj.notify(); &#x2F;&#x2F; 释放锁对象 } } },&quot;唤醒线程&quot;).start(); } } &#x2F;&#x2F; 输出结果： 等待线程=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象 唤醒线程------- 等待3秒 唤醒线程------ 获取到锁对象，调用notify方法，释放锁对象 等待线程=== 从waiting状态醒来，获取到锁对象，继续执行 等待线程=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象 .....阻塞等待中 通过上述案例可以发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。 其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。 3.5 补充知识点 我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。 今日总结 多线程原理解析 Thread类构造方法和常用方法的使用 Runnable类的使用 线程安全问题 线程同步的三种方法 线程六种状态概述","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"},{"name":"线程","slug":"线程","permalink":"https://zero024.cn/tags/线程/"}]},{"title":"Java中的异常处理和进程线程概念","slug":"JavaBasics/Java中的异常处理和进程线程概念 ","date":"2019-04-27T15:40:00.000Z","updated":"2020-03-08T00:49:19.497Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. 异常 异常：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产出异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的不是语法错误，语法错误是不会编译通过的。","text":"1. 异常 异常：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产出异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的不是语法错误，语法错误是不会编译通过的。 1.2 异常体系异常机制就是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error和java.lang.Exception，平常所说的异常指的是java.lang.Exception Throwable体系 Error：严重错误Error，无法通过处理的错误，只能事先避免。好比绝症。 Exception：表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。类似感冒之类的。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型，异常的原因，还有异常出现的位置，在开发和调试阶段，都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候，就提示错误原因。 public String toString(): 获取异常的类型和异常描述信息(不用)。 出现异常后，可以把异常的简单类名，复制到API中去查询。 1.3 异常分类一般的异常指的就是Exception，因为这类异常一旦出现，我们就需要对代码进行更正，修复程序。 异常的分类：根据在编译时期还是运行时期去检查异常 编译时期的异常： checked异常。在编译时期，就会检查，如果没有处理异常，则编译失败。 运行时期异常：runtime异常。在运行时期，检查异常，在编译时期，运行异常不会编译器检测(不会报错)。 1.4 异常的产生过程解析运行下面程序，程序会产生义工数组索引越界异常ArrayIndexOutOfBoundsException。 &#x2F;&#x2F; 工具类 public class ArrayTools { &#x2F;&#x2F; 对给定的数组通过给定的索引获取元素 public static int getElement(int[] arr, int index){ int element = arr[index]; return element; } } &#x2F;&#x2F; 测试类 public class ExceptionDemo { public static void main(String[] args) { int[] arr = {34,12,67}; int num = ArrayTools.getElement(arr,4); System.out.println(&quot;num=&quot;+num); System.out.println(&quot;over&quot;); } } 上述程序执行过程图解： 2. 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 2.1 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在Java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。具体操作如下： 创建一个异常对象，封装一些提示信息。 通过关键字thro将这个异常对象告知给调用者。throw异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： throw new 异常类名(参数) 例如： throw new NullPointerException(&quot;要访问的arr数组不存在&quot;); throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;) 以下为程序实例： public class ThrowDemo { public static void main(String[] args) { &#x2F;&#x2F; 创建一个数组 int[] arr = {2,4,35,2}; &#x2F;&#x2F; 根据索引找对应的元素 int index = 4; int element = getElement(arr,index); System.out.println(element); System.out.println(&quot;over&quot;); } &#x2F;&#x2F; 根据 索引找到数组中对应的元素 public static int getElement(int[] arr,int index){ &#x2F;&#x2F; 判断 索引是否越界 if(index&lt;0 || index &gt; arr.length-1){ &#x2F;* 判断条件如果满足，当执行完throw抛出异常对象后，方法已无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需通过异常来解决。 *&#x2F; throw new ArrayIndexOutOfBoundsException(&quot;小老弟，索引越界了！！！&quot;); } int element = arr[index]; return element; } } 注意：如果产生了问题，throw就会将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，有两种方式处理，一种是进行捕获处理，另一种就是继续将问题声明出去，使用throws声明处理。 2.2 Objects非空判断我们学习过一个类Objects， 里面有提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; requireNonNull(T obj):查看指定引用对象不是null。 查看源码可以发现这里对null对象进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } 2.3 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理，那么必须通过throws进行声明，让调用者去处理。关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常)。 声明异常格式：修饰符 返回值类型 方法名(参数) throws 异常类名1，异常类名2...{ } 代码实例： public class ThrowDemo02 { public static void main(String[] args) throws IOException{ read(&quot;a.txt&quot;); } &#x2F;&#x2F; 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 &#x2F;&#x2F; 假如该方法可能有多种异常情况产生，那么throws后面可以写多个异常类，用逗号隔开。 public static void read(String path) throws FileNotFoundException, IOException { if(!path.equals(&quot;a.txt&quot;)) &#x2F;&#x2F; 如果不是a.txt这个字符串 throw new FileNotFoundException(&quot;文件不存在&quot;); &#x2F;&#x2F; 则生成一个异常类返回给调用者 if(!path.equals(&quot;b.txt&quot;)) throw new IOException(); } } 2.4 捕获异常try…catch如果异常出现的话，会立即终止程序，所以我们得处理异常： 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： try{ 编写可能会出现异常的代码 }catch(异常类型 e){ 处理异常的代码 &#x2F;&#x2F; 记录日志&#x2F;打印异常信息&#x2F;继续抛出异常 } try： 该代码块中编写可能产生异常的代码。catch： 用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意：try和catch都不能单独使用，必须一起用。 代码实例: public class TryCatchDemo { public static void main(String[] args) { try{ &#x2F;&#x2F; 当产生异常时，必须有处理方式，要么捕获，要么声明。 read(&quot;b.txt&quot;); }catch (FileNotFoundException e){ &#x2F;&#x2F; try中抛出的是什么异常，在括号中就定义什么异常 System.out.println(e); } System.out.println(&quot;over&quot;); } public static void read(String path) throws FileNotFoundException{ if(!path.equals(&quot;a.txt&quot;)) throw new FileNotFoundException(&quot;文件不存在&quot;); } } 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。​ 2.4 finally代码块 finally：当遇到某些代码是无论是否发生异常，都要执行的，那么可以放在finally代码块中，在finally代码块中存放的代码都是一定会被执行的。 有哪些时候的代码必须最终执行？当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 语法：try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意：finally不能单独使用。 代码示例： public class FinallyDemo { public static void main(String[] args) { try{ read(&quot;a.txt&quot;); }catch (FileNotFoundException e){ &#x2F;&#x2F;捕获编译期报错信息，在运行期抛出去。 throw new RuntimeException(e); }finally { System.out.println(&quot;这里的代码必定执行&quot;); } System.out.println(&quot;over&quot;); } &#x2F;&#x2F; 因为我们当前的read方法中有异常，所以编译期会报错。 public static void read(String path) throws FileNotFoundException{ if(!path.equals(&quot;a.txt&quot;)) throw new FileNotFoundException(&quot;文件不存在&quot;); } } 当只有在try或者catch中调用退出JVM的相关方法时，finally才不会执行，否则必定执行。 2.5 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般使用一次捕获多次处理方式，格式如下： try{ 编写可能会出现异常的代码 }catch(异常类型A e){ 当try中出现A类型异常时，就用该catch来捕获。 处理异常代码 }catch(异常类型B e){当try中出现B类型异常时，就用该catch来捕获。 处理异常代码 } 注意：这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 3. 自定义异常3.1 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述示例中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题。我们就需要自己定义异常。 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义的异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 3.2 自定义异常的练习模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 代码实例如下： &#x2F;&#x2F; 首先定义一个登录异常类RegisterException: public class RegisterException extends Exception{ public RegisterException() { &#x2F;&#x2F; 空参构造 } public RegisterException(String message){ super(message); &#x2F;&#x2F; @param message 表示异常提示 } } &#x2F;&#x2F; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 public class TestDemo { &#x2F;&#x2F; 模拟数据库中已存在的账号 private static String[] names = {&quot;xiaowang&quot;,&quot;xiaozhang&quot;,&quot;xiaoming&quot;}; public static void main(String[] args) { &#x2F;&#x2F; 调用方法 try{ &#x2F;&#x2F; 可能出现异常的代码块 checkUsername(&quot;xiaowang&quot;); System.out.println(&quot;注册成功&quot;); }catch(RegisterException e){ e.printStackTrace(); } catch (LoginException e) { e.printStackTrace(); } } public static boolean checkUsername(String uname) throws LoginException, RegisterException { for(String name:names){ if(name.equals(uname)) throw new RegisterException(&quot;亲&quot;+name+&quot;已经被注册了！&quot;); } return true; } } 4. 多线程4.1 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 4.2 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。 打开任务管理器，可以查看当前任务的进程： 进程 线程 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着”. 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 4.3 创建线程类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码实例如下： &#x2F;&#x2F; 自定义线程类 public class MyThread extends Thread{ &#x2F;&#x2F; 定义指定线程名称的构造方法 public MyThread(String name) { &#x2F;&#x2F; 调用父类的String参数的构造方法，指定线程的名称 super(name); } &#x2F;&#x2F; 重写run方法，完成该线程的执行逻辑 @Override public void run(){ for(int i = 0;i &lt; 10;i++){ System.out.println(getName()+&quot;正在执行第&quot;+i+&quot;次&quot;); } } } &#x2F;&#x2F; 测试类 public class TestThread { public static void main(String[] args) { &#x2F;&#x2F; 创建线程对象 MyThread mt = new MyThread(&quot;新的线程！&quot;); &#x2F;&#x2F; 启动线程 mt.start(); &#x2F;&#x2F; 在主方法中执行for循环 for(int i = 0;i &lt; 10;i++){ System.out.println(&quot;main线程&quot;+i); } } } 今日总结 Java中的异常体系 异常处理5个关键字：try、catch、finally、throw、throws 异常处理的使用方法 自定义异常类 并发与并行的概念 进程线程的概念 线程调度的各种方式 Java中的线程类Thread，以及基本使用方式","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Exception","slug":"Exception","permalink":"https://zero024.cn/tags/Exception/"}]},{"title":"Map集合和Debug跟踪","slug":"JavaBasics/Map集合和Debug跟踪","date":"2019-04-26T15:59:00.000Z","updated":"2020-03-08T00:49:13.325Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. Map集合生活中我们常会看到一种集合：IP地址与主机名，身份证号与个人等，这种一一对应的关系，叫做映射。Java中的java.util.Map接口是专门用来存放这种映射关系的集合类。","text":"1. Map集合生活中我们常会看到一种集合：IP地址与主机名，身份证号与个人等，这种一一对应的关系，叫做映射。Java中的java.util.Map接口是专门用来存放这种映射关系的集合类。 1.1 概述通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。 Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的。每个元素由键值对组成，通过键可以找对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 1.2 Map常用子类Map有多个子类，这里主要讲解常用的HashMap集合、LinkedHashMap集合。 HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不一致。由于要保证键的唯一、不重复，需要重写键的hashCode()和equals()方法。 LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证键的唯一性，需要重写键的hashCode和equals方法。 Tips:Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，需为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可不同。 1.3 Map接口中的常用方法Map接口中定义了多种方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map接口的方法示例： public class MapDemo { public static void main(String[] args) { &#x2F;&#x2F; 创建Map对象 HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); &#x2F;&#x2F; put(键,值)添加元素 System.out.println(map.put(&quot;小明&quot;,15)); &#x2F;&#x2F; 如果添加的元素对键名没有在集合中，会返回一个null，并添加元素 System.out.println(map.put(&quot;小明&quot;,11)); &#x2F;&#x2F; 如果添加的元素对键名在集合中存在，则返回该键对应的值，然后替换为新值 map.put(&quot;小张&quot;,18); map.put(&quot;李小&quot;,16); System.out.println(map); &#x2F;&#x2F; {小明=15, 小张=18, 李小=16} &#x2F;&#x2F; remove(键名)删除指定元素 System.out.println(map.remove(&quot;李小&quot;)); System.out.println(map); &#x2F;&#x2F; {小明=15, 小张=18} &#x2F;&#x2F; 通过键名查询对应的值 System.out.println(map.get(&quot;小明&quot;)); &#x2F;&#x2F; 15 System.out.println(map.get(&quot;小张&quot;)); &#x2F;&#x2F; 18 } } Tips: 使用put方法时，若指定的键(key)在集合中没有，则表示没有这个键值对，返回null，并把指定键值添加到集合中。 若指定的键(key)在集合中存在，则返回值为集合中键对应的值，并把指定键所对应的值，替换为新值。 1.4 Map集合遍历键找值的方式遍历方式：即通过元素中的键名，获取键所对应的值。 public class DemoGetValue { public static void main(String[] args) { HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;小明&quot;,16); map.put(&quot;小李&quot;,19); map.put(&quot;小张&quot;,17); map.put(&quot;小德&quot;,12); &#x2F;&#x2F; 获取所以键，存储到set集合中 Set&lt;String&gt; keys = map.keySet(); for(String key:keys){ System.out.println(key+&quot;的年龄是：&quot;+map.get(key)+&quot;岁&quot;); } } } 1.5 Entry键值对对象Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们遍历Map集合时，就可以从每一个键值对(Entry)对象中获取对应的键与对应的值。 Entry同样提供了获取对应键和对应值的方法： public K getKey(): 获取Entry对象中的键。 public V getValue():获取Entry对象中的值。 在Map集合中也提供了获取所以Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():获取Map集合中所有的键值对对象的集合(Set集合)。 1.6 Map集合遍历键值对方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。操作步骤： 获取Map集合中，所以键值对(Entry)对象，以Set集合形式返回。方法提示：entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() public class EntryDemo { public static void main(String[] args) { HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;小米&quot;,32); map.put(&quot;小花&quot;,25); map.put(&quot;小马&quot;,52); Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrys = map.entrySet(); for (Map.Entry&lt;String,Integer&gt; entry:entrys){ String key = entry.getKey(); int value = entry.getValue(); System.out.println(key+&quot;的年龄是:&quot;+value+&quot;岁&quot;); } } } Tips: Map集合不能直接使用迭代器或foreach进行遍历。但是转Set之后就可以使用了。 1.7 HashMap存储自定义类型键值练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。 &#x2F;&#x2F; 学生类 public class Student { private String name; private int age; &#x2F;&#x2F; ... 省略get&#x2F;set方法，初始化构造方法等 } &#x2F;&#x2F; 测试类 public class HashMapTest { public static void main(String[] args) { &#x2F;&#x2F; 创建HashMap集合对象 Map&lt;Student, String&gt; map = new HashMap&lt;&gt;(); map.put(new Student(&quot;张三&quot;,25),&quot;上海&quot;); map.put(new Student(&quot;李四&quot;,28),&quot;北京&quot;); map.put(new Student(&quot;王五&quot;,20),&quot;广州&quot;); map.put(new Student(&quot;赵六&quot;,19),&quot;深圳&quot;); map.put(new Student(&quot;孙钱&quot;,24),&quot;杭州&quot;); &#x2F;&#x2F; 取出元素 Set&lt;Student&gt; keys = map.keySet(); &#x2F;&#x2F; 获取所以键名放入set中 for (Student key:keys){ System.out.println(key.toString() + &quot;.....&quot; + map.get(key)); &#x2F;&#x2F; 注意Student类要重写toString方法 } } } 1.8 LinkedHashMapHashMap可以保证成对元素唯一性，且查询速度很快，可存入的顺序是无序的，如果要保证有序，可以使用HashMap下的一个子类LinkedHashMap，它是链表和哈希表组成的一个数据存储结构。 public class LinkedHashMapDemo { public static void main(String[] args) { LinkedHashMap&lt;String,Integer&gt; linkMap = new LinkedHashMap&lt;&gt;(); linkMap.put(&quot;小米&quot;,11); linkMap.put(&quot;小花&quot;,15); linkMap.put(&quot;小中&quot;,19); Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrys = linkMap.entrySet(); for(Map.Entry&lt;String,Integer&gt; entry:entrys){ System.out.println(entry.getKey() + &quot;的年龄是：&quot; + entry.getValue() + &quot;岁&quot;); } } } &#x2F;&#x2F; 如此就保证了存入元素的有序性 1.9 Map集合练习计算一个字符串中每个字符出现次数。 public class MapTest { public static void main(String[] args) { System.out.println(&quot;请输入一个字符串:&quot;); String line = new Scanner(System.in).nextLine(); findChar(line); } public static void findChar(String line){ &#x2F;&#x2F; 创建一个集合，存储字符及出现次数 HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0;i &lt; line.length();i++){ char c = line.charAt(i); &#x2F;&#x2F; 返回指定索引处字符 if(!map.containsKey(c)){ &#x2F;&#x2F; 判断字符 是否在键集中,不在则执行下面语句 map.put(c,1); &#x2F;&#x2F; 第一次出现，添加该字符，并计数1 }else{ &#x2F;&#x2F; 则说明字符键名在键集中了，就是出现过 Integer count = map.get(c); &#x2F;&#x2F; 获取前一次值 map.put(c,++count); &#x2F;&#x2F; 再次存入，并更新值 } } System.out.println(map); } } 2. 知识点补充2.1 JDK9对集合添加的优化Java 9，添加了几种集合工厂方法，更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。示例如下： public class JDK9NewMethod { public static void main(String[] args) { Set&lt;String&gt; str = Set.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); &#x2F;&#x2F; str1.add(&quot;d&quot;); &#x2F;&#x2F; 这里使用add方法，编译不会报错，执行会报错，因为是不可变集合。 System.out.println(str); List&lt;String&gt; list = List.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); System.out.println(list); Map&lt;String,Integer&gt; map = Map.of(&quot;a&quot;,1,&quot;b&quot;,2); System.out.println(map); } } 注意事项： of()方法只是Map,List,Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，如HashSet，ArrayList等。2.返回的集合是不可变的。 2.2 Debug跟踪使用IDEA的断点调试功能，查看程序的运行过程下图为调试窗口基本功能。 3. 斗地主Map实现需求分析： 准备牌：完成数字与纸牌的映射关系：使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 洗牌：通过数字完成洗牌发牌 发牌：将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。存放的过程中要求数字大小与斗地主规则的大小对应。将代表不同纸牌的数字分配给不同的玩家与底牌。 看牌：通过Map集合找到对应字符展示。通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 public class Poker { public static void main(String[] args) { &#x2F;&#x2F; 准备牌 List&lt;String&gt; colors = List.of(&quot;♥&quot;,&quot;♦&quot;,&quot;♠&quot;,&quot;♣&quot;); List&lt;String&gt; numbers = List.of(&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;); HashMap&lt;Integer,String&gt; pokerMap = new HashMap&lt;&gt;(); int cardID = 0; for (String color:colors){ for (String num:numbers){ pokerMap.put(cardID,color+num); cardID++; } } pokerMap.put(52,&quot;小☺&quot;); pokerMap.put(53,&quot;大☠&quot;); &#x2F;&#x2F; System.out.println(pokerMap); ArrayList&lt;Integer&gt; cardKeys = new ArrayList&lt;&gt;(); cardKeys.addAll(pokerMap.keySet());&#x2F;&#x2F; 获取map的键名集合，并转换为List集合，方便打乱。 &#x2F;&#x2F; 打乱顺序，洗牌 Collections.shuffle(cardKeys); &#x2F;&#x2F; 牌编号集合 &#x2F;&#x2F; 创建3个玩家集合和底牌集合。 ArrayList&lt;String&gt; bottomCard = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 底牌 ArrayList&lt;String&gt; player1 = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 玩家1 ArrayList&lt;String&gt; player2 = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 玩家2 ArrayList&lt;String&gt; player3 = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 玩家3 &#x2F;&#x2F; 发牌的编号 for (int i = 0;i &lt; cardKeys.size();i++){ if (i &gt;= 51){ bottomCard.add(pokerMap.get(cardKeys.get(i))); &#x2F;&#x2F; 根据牌编号，获取对应在牌盒中的牌，放入底牌 }else if (i % 3 == 0){ player1.add(pokerMap.get(cardKeys.get(i))); &#x2F;&#x2F; 根据牌编号，获取对应在牌盒中的牌，放入玩家1手中 }else if (i % 3 == 1){ player2.add(pokerMap.get(cardKeys.get(i))); &#x2F;&#x2F; 根据牌编号，获取对应在牌盒中的牌，放入玩家2手中 }else{ player3.add(pokerMap.get(cardKeys.get(i))); &#x2F;&#x2F; 根据牌编号，获取对应在牌盒中的牌，放入玩家3手中 } } &#x2F;&#x2F; 根据花色排序，后续可改进为根据数字排序 Collections.sort(bottomCard); Collections.sort(player1); Collections.sort(player2); Collections.sort(player3); &#x2F;&#x2F; 看牌 System.out.println(player1); System.out.println(player2); System.out.println(player3); System.out.println(bottomCard); } } 今日总结 Map集合中的子类和常用方法 Debug跟踪的使用 使用Map实现斗地主案例","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://zero024.cn/tags/集合/"}]},{"title":"数据结构概述和List/Set集合","slug":"JavaBasics/数据结构简述和List,Set集合","date":"2019-04-25T15:59:00.000Z","updated":"2020-03-08T00:39:11.223Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. 数据结构常见的数据结构数据存储的常用结构有：栈、队列、数组、链表和红黑树。下面分别了解一下： 栈 栈：stack，又称堆栈，它是运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表；又被称为后进先出(Last In First Out)的线性表，简称LIFO结构。","text":"1. 数据结构常见的数据结构数据存储的常用结构有：栈、队列、数组、链表和红黑树。下面分别了解一下： 栈 栈：stack，又称堆栈，它是运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表；又被称为后进先出(Last In First Out)的线性表，简称LIFO结构。 简单的说：采用该结构的集合，对元素的存取有以下特点： 先进后出(即，先存进去的元素，要在后它存进去的元素依次取出后，才能取出该元素)。 栈的入口、出口都是栈的顶端位置。 压栈：就是存元素。即、把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即、把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列 队列：queue，简称队，它同堆栈一样，也是一种运算受限的线性表，只允许在一端进行插入操作，而在另一端进行删除操作的线性表，又被称为先进先出(First In First Out)的线性表，简称FIFO结构。采用该结构的集合，对元素的存取有如下特点： 先进先出(即，先存进去的元素，会比后它进来的元素先出去)。 队列的入口、出口各占一侧。如下图示： 数组 数组：Array是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。数据结构特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素： 需要创建一个新数组，将指定新元素存储在指定索引位置，在把原数组元素根据索引，复制到新数组对应索引的位置。如下图： 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引位置，原数组中指定索引位置元素不复制到新数组中。 链表 链表：linked list由一系列结点node(链表中每一个元素称为结点)组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域(每一个节点包含指向下一个节点的指针)。链表结构有单向链表与双向链表，这里介绍的是单向链表。采用该数据结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。例如多个人手拉手，每个人使用自己的右手拉住下一个人的左手，依次类推，这样多个人就连在一起了。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。 增删元素快：只需修改连接下个元素的地址即可。 红黑树 二叉树:binary tree,是每个节点不超过2的有序树(tree)。即每个节点最多只有两个分支(不存在分支度大于2的节点)的数结构。通常分支被称作”左子树”和”右子树”。二叉树的分支具有左右次序，不能颠倒。二叉树有一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也意味着，树的键值仍然有序的。红黑树的约束： 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同红黑树特点：速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍红黑树详解 2. List集合2.1 List接口java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特定就是元素有序，即元素的存入顺序和取出顺序一致。 List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33.那么集合中，元素的存储就是按照11、22、33的顺序完成的。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素(与数组的索引是一个道理) 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 2.2 List接口中常用的方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法。 public void add(int index, E element):将指定的元素，添加到该集合中的指定位置上。 public E get(int index): 返回集合中指定位置的元素 public E remove(int index):移除列表中指定位置的元素，返回的是被移除的元素 public E set(int index,E element):用指定元素替换集合中指定位置的元素，返回值是更新前的元素。 List集合特有的方法都是跟索引相关的，代码如下： import java.util.ArrayList; import java.util.List; public class Demo01List { public static void main(String[] args) { &#x2F;&#x2F; 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); &#x2F;&#x2F;往 尾部添加 元素 list.add(&quot;小米&quot;); list.add(&quot;小天&quot;); list.add(&quot;小风&quot;); System.out.println(list); &#x2F;&#x2F; [小米, 小天, 小风] &#x2F;&#x2F; add(int index,String s) 往指定位置添加元素 list.add(1,&quot;小洪&quot;); System.out.println(list); &#x2F;&#x2F; [小米, 小洪, 小天, 小风] &#x2F;&#x2F; remove(int index) 删除指定位置元素，返回被删除元素 System.out.println(&quot;删除索引位置为2的元素&quot;+list.remove(2)); &#x2F;&#x2F; 删除索引位置为2的元素小天 &#x2F;&#x2F; set(int index, String s) 将指定位置的元素进行替换(修改) System.out.println(list.set(1,&quot;小华&quot;)); &#x2F;&#x2F; 返回的是被替换的元素， 小洪 for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); &#x2F;&#x2F; get(int index) 获取指定索引位置的元素 } } } 3. List的子类java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，因日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是常用的集合。 3.1 LinkedList集合java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，如下图就是一个双向链表。 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用的。方法演示： import java.util.LinkedList; public class Demo02LinkedList { public static void main(String[] args) { LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.addFirst(0); list.addLast(1); list.addLast(2); list.addLast(3); System.out.println(list); &#x2F;&#x2F; [0,1,2,3] System.out.println(&quot;返回此列表第一个元素:&quot;+list.getFirst()); &#x2F;&#x2F; 0 System.out.println(&quot;返回此列表最后一个元素:&quot;+list.getLast()); &#x2F;&#x2F; 3 System.out.println(&quot;删除第一个元素并返回它:&quot;+list.removeFirst()); &#x2F;&#x2F; 0 System.out.println(&quot;删除最后一个元素并返回它:&quot;+list.removeLast()); &#x2F;&#x2F; 3 System.out.println(list.pop()); &#x2F;&#x2F; 弹出，就是移除元素,栈在列表左侧 list.push(3); System.out.println(list); System.out.println(list.isEmpty()); &#x2F;&#x2F; 判断列表是否为空，空则返回true } } 4. Set接口java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对该接口进行功能上的扩充，只是比Collection接口更加严格了。与List接口不同的是，Set接口中元素无序，并且有规则保证存入元素不出现重复。 Set集合有多个子类，这里主要介绍其中的java.util.HashSet、java.util.LinkedHashSet这两个集合。 Tips：Set集合取出元素的方式可以采用：迭代器、增强for。 4.1 HashSet集合介绍java.util.HashSet是Set接口的一个实现类，它存储的元素是不可重复的，并且元素都是无序的。它的底层实现其实是一个java.util.HashMap支持。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖与：hashCode与equals方法。以下代码示意使用Set集合存储： import java.util.HashSet; public class Demo03HashSet { public static void main(String[] args) { &#x2F;&#x2F; 创建 Set集合 HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); &#x2F;&#x2F; 添加元素 set.add(new String(&quot;cba&quot;)); set.add(&quot;abc&quot;); set.add(&quot;bac&quot;); set.add(&quot;cba&quot;); &#x2F;&#x2F; 遍历 for (String s:set){ System.out.println(s); &#x2F;&#x2F; cba,abc,bac 自动去重了 } } } hashCode方法hashCode方法返回对象的哈希值 &#x2F;* 哈希值：是一个十进制的整数，由系统随机给出(就是对象的地址值，是一个逻辑地址，不是数据实际存储的物理地址) 在Object类有一个方法，可以获取对象的哈希值 int hashCode() 返回该对象的哈希码值 hashCode()方法的源码： public native int hashCode(); native:代办该方法调用的是本地操作系统的方法。 *&#x2F; public class DemoHashCode { public static void main(String[] args) { &#x2F;&#x2F; Person类继承了Object类，所以可以使用Object类的hashCode方法 Person p1 = new Person(); System.out.println(p1.hashCode()); &#x2F;&#x2F; 1072408673 System.out.println(new Person().hashCode()); &#x2F;&#x2F; 1531448569 System.out.println(&quot;abc&quot;.hashCode()); &#x2F;&#x2F; 96354 &#x2F;&#x2F; 以下两个为特殊情况，内容不同hash值相同 System.out.println(&quot;重地&quot;.hashCode()); &#x2F;&#x2F; 1179395 System.out.println(&quot;通话&quot;.hashCode()); &#x2F;&#x2F; 1179395 } } Set集合去重原理： 4.2 HashSet集合存储数据的结构(哈希表)什么是哈希表？在JDK 1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过Key值依次查找的效率较低。而JDK 1.8中，哈希表存储采用数组+链表+红黑树实现，而链表长度超过阈值(8)时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树(JDK1.8增加了红黑树部分)实现的，如下图示。哈希表存储流程图： JDK1.8引入红黑树大程度优化了HashMap性能，而保证HashSet集合元素的唯一是根据对象的hashCode和equals方法决定的。如果我们往集合中存放自定义的对象，那么为了保证其唯一，就必须重写hashCode和equals方法建立当前对象的比较方式。 4.3 HashSet存储自定义类型元素给HashSet存放自定义类型的元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashCode集合中对象的唯一性。以下代码示例： import java.util.HashSet; &#x2F;* HashSet存储自定义类型元素 set集合保存元素唯一： 存储的元素(String,Integer,....student,Person),必须重写hashCode方法和equals方法 要求： 同名同年龄的人，视为同一人，只能存储一次 *&#x2F; public class Demo04MyHashSet { public static void main(String[] args) { &#x2F;&#x2F; 创建hashSet集合，存储Person HashSet&lt;Person&gt; set = new HashSet&lt;&gt;(); Person p1 = new Person(&quot;小米&quot;,11); Person p2 = new Person(&quot;小米&quot;,11); Person p3 = new Person(&quot;小米&quot;,12); System.out.println(p1.hashCode()); &#x2F;&#x2F; 1072408673 System.out.println(p2.hashCode()); &#x2F;&#x2F; 1531448569 &#x2F;&#x2F; 因为hashcode值不一样，所以认为是不同元素，没有起到去重效果。 System.out.println(p1==p2); &#x2F;&#x2F; false 比较对象地址值不同，也认定是两个不同元素 System.out.println(p1.equals(p2)); set.add(p1); set.add(p2); set.add(p3); System.out.println(set); } } 4.4 LinkedHashSetHashSet可以保证元素唯一，可是元素存放进去是没有顺序的，如果要保证允许，可以使用HashSet的一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。示例如下： import java.util.Iterator; import java.util.LinkedHashSet; import java.util.Set; public class DemoLinkedHashSet { public static void main(String[] args) { Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;(); set.add(&quot;aaa&quot;); set.add(&quot;ccc&quot;); set.add(&quot;bbb&quot;); set.add(&quot;ddd&quot;); for(String s:set){ System.out.println(s); } } } 4.5 可变参数如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式： 修饰符 返回值类型 方法名(参数类型... 形参名){ } …用在参数上，我们称之为可变参数，这个写法完全等价与 修饰符 返回值类型 方法名(参数类型[] 形参名){ } 后面的这种定义，在调用时必须传递数组，而前者可以直接传递数据。 同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单方便之处),直接将数组中的元素作为实际参数进行传递。其实是编译成的class文件，先将这些元素封装到一个数组中，再进行传递。这些动作在编译.class文件时，就自动完成了。代码示例如下： public class ChangeArgs { public static void main(String[] args) { int[] arr = {1,3,65,491,5}; int sum = getSum(arr); System.out.println(sum); int sum2 = getSum(6,7,2,63,737); &#x2F;&#x2F; 使用了可变参数写法，可以传递多个数据 System.out.println(sum2); } &#x2F;&#x2F; 原始写法 &#x2F;&#x2F; public static int getSum(int[] arr){ &#x2F;&#x2F; int sum = 0; &#x2F;&#x2F; for(int a : arr){ &#x2F;&#x2F; sum += a; &#x2F;&#x2F; } &#x2F;&#x2F; &#x2F;&#x2F; return sum; &#x2F;&#x2F; } &#x2F;&#x2F; 使用可变参数写法 public static int getSum(int... arr){ int sum = 0; for (int a:arr){ sum += a; } return sum; } } 5. Collections5.1 常用功能 java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 代码示例： public class DemoCollections { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 原写法 &#x2F;&#x2F; list.add(1); &#x2F;&#x2F; list.add(2); &#x2F;&#x2F; list.add(43); &#x2F;&#x2F; list.add(675); &#x2F;&#x2F; 使用工具类添加元素 Collections.addAll(list,64,267,1242,5); System.out.println(list); &#x2F;&#x2F; [64, 267, 1242, 5] &#x2F;&#x2F; 排序 Collections.sort(list); System.out.println(list); &#x2F;&#x2F; [5, 64, 267, 1242] } } 5.2 Comparator比较器public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 代码示例： public class Demo02 { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;cba&quot;); list.add(&quot;aba&quot;); list.add(&quot;sba&quot;); list.add(&quot;nba&quot;); &#x2F;&#x2F;排序方法 Collections.sort(list); System.out.println(list); &#x2F;&#x2F; [aba, cba, nba, sba] } } 排序方式，简单的就是比较两个对象之间的大小，在Java中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵活的当我需要做排序的时候在去选择的java.util.Comparator接口完成。 我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { } String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，如果要实现一些别的操作，可以使用public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )方法灵活的完成。这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是： public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数） 如果要按照降序排序，则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） public class Demo03 { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;cba&quot;); list.add(&quot;aba&quot;); list.add(&quot;sba&quot;); list.add(&quot;nba&quot;); &#x2F;&#x2F;排序方法 按照第一个单词的降序 Collections.sort(list, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o2.charAt(0) - o1.charAt(0); } }); System.out.println(list); &#x2F;&#x2F; [sba, nba, cba, aba] } } 5.3 简述Comparable和Comparator两个接口的区别。Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 5.4 Exercise创建一个学生类，存储到ArrayList集合中完成指定排序操作。 &#x2F;&#x2F; Student类 public class Student implements Comparable&lt;Student&gt;{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return &quot;Student{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &#39;}&#39;; } public String getName() { return name; } public int getAge() { return age; } public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @Override public int compareTo(Student o) { return this.age-o.age; &#x2F;&#x2F; 升序 } } &#x2F;&#x2F; 测试类 public class Demo04 { public static void main(String[] args) { ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(&quot;小明&quot;,11)); list.add(new Student(&quot;小李&quot;,14)); list.add(new Student(&quot;小张&quot;,17)); list.add(new Student(&quot;小化&quot;,16)); &#x2F;&#x2F; 升序操作 Collections.sort(list);&#x2F;&#x2F; 报错，要求 该list中元素类型 必须实现比较器Comparable接口 for (Student sd:list){ System.out.println(sd); } } } 必须实现Comparable接口，重写compareTo方法，才能进行升序操作。 今日总结 基本数据结构简述 List集合的相关操作方法 LinkedList集合的方法 Set，HashSet，LinkedHashSet等集合的使用方法，自定义元素等 哈希表定义 可变参数的使用 Collections工具类的使用方法 Comparator比较器 Comparable和Comparator两个接口的区别","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://zero024.cn/tags/集合/"}]},{"title":"Collction集合和泛型","slug":"JavaBasics/Collection和泛型","date":"2019-04-24T14:00:00.000Z","updated":"2020-03-08T00:49:35.749Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. Collection集合 集合:集合是java中提供的一种容器，可以用来存储多个数据。集合和数组的区别 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致。当对象多的时候，使用集合进行存储。","text":"1. Collection集合 集合:集合是java中提供的一种容器，可以用来存储多个数据。集合和数组的区别 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致。当对象多的时候，使用集合进行存储。 1.1 集合框架JavaSE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分成两大类，分别是单列集合java.util.Collection和双列集合java.util.Map，今天我们主要学习Collction集合，后续学习Map集合。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。如图描述集合类的继承体系： 1.2 Collection常用功能Coollection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。代码示例： import java.util.ArrayList; import java.util.Collection; public class DemoCollection { public static void main(String[] args) { Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); &#x2F;&#x2F; 创建集合对象，多态写法 &#x2F;&#x2F; 使用添加功能，add(String s)； coll.add(&quot;小米&quot;); coll.add(&quot;小洪&quot;); coll.add(&quot;小丽&quot;); System.out.println(coll); &#x2F;&#x2F; [小米, 小洪, 小丽] &#x2F;&#x2F; 使用判断功能 contains(String s); System.out.println(coll.contains(&quot;小张&quot;)); &#x2F;&#x2F; false System.out.println(coll.contains(&quot;小米&quot;)); &#x2F;&#x2F; true System.out.println(coll.size()); &#x2F;&#x2F; 返回集合中元素个数 System.out.println(coll.remove(&quot;小洪&quot;)); System.out.println(coll); Object[] obj = coll.toArray(); &#x2F;&#x2F; 转换成一个Object数组 for (int i = 0; i &lt; obj.length; i++) { System.out.println(obj[i]); } coll.clear(); &#x2F;&#x2F; 清空集合 System.out.println(coll.isEmpty()); &#x2F;&#x2F; 判断集合是否为空 } } 2. Iterator迭代器2.1 Iterator接口java.util.Iterator接口主要用于迭代访问Collection中的元素，因此Iterator对象也被称为迭代器。 public Iterator iterator():获取集合对应的迭代器，用来遍历集合中的元素。 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有就把这个元素取出来，然后继续判断。直到把集合中所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口常用的方法如下： public E next(): 返回迭代的下一个元素。 public boolean hasNext(): 如果仍有元素可以迭代，则返回true。 E ：代表泛型的意思，指的是迭代出元素的数据类型 public class DemoIterator { public static void main(String[] args) { Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 添加元素 coll.add(&quot;盖伦&quot;); coll.add(&quot;艾希&quot;); coll.add(&quot;剑圣&quot;); Iterator&lt;String&gt; it = coll.iterator(); &#x2F;&#x2F; 每个集合对象都有自己的迭代器。 while (it.hasNext()){&#x2F;&#x2F;判断是否仍然有迭代元素 System.out.println(it.next()); &#x2F;&#x2F; 获取迭代出的元素 } } } 2.2 迭代器的实现原理上面的案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用it集合的iterator()方法获取迭代器对象，然后使用hasNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出来，反之则说明达到了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。如下图例演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.3 增强for增强for循环(也称for each循环)是JDK 1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。内部原理是一个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。格式如下： for(元素数据类型 变量：Collection集合or数组){ &#x2F;&#x2F; 操作代码 } 它能用于遍历Collection和数组。通常只进行遍历元素，不能在遍历过程中对集合进行增删操作。 遍历示例 import java.util.ArrayList; import java.util.Collection; public class DemoSuperFor { public static void main(String[] args) { int[] arr = {3,4,5,6,7}; for(int a:arr){&#x2F;&#x2F; a代表数组中的每个元素 System.out.println(a); } &#x2F;&#x2F; 进行元素遍历 Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); coll.add(&quot;蛮王&quot;); coll.add(&quot;剑圣&quot;); coll.add(&quot;赵信&quot;); &#x2F;&#x2F; 使用增强for遍历 for(String s:coll){ &#x2F;&#x2F; 变量s代表被遍历到的集合园 System.out.println(s); } } } Tips:增强for循环必须有被遍历的目标。且目标只能是Collection或是数组。新式for仅仅用作遍历操作出现。 3. 泛型集合中是可以存放任意对象的，只要把对象存储集合后，那么这时它们都会被提升成Object类型。当我们在取出每一个对象并进行相应操作时，必须采用类型转换。 观察一下代码： public class DemoGeneric { public static void main(String[] args) { Collection coll = new ArrayList(); coll.add(&quot;abc&quot;); coll.add(&quot;itcast&quot;); coll.add(5); &#x2F;&#x2F; 由于集合没有做泛型限定，任何类型都可以存放 Iterator it = coll.iterator(); while (it.hasNext()){ System.out.println(((String)it.next()).length()); } } } 当程序运行到最后时会抛出java.lang.ClassCastException错误。因为集合中有一个int类型存在，所以发生了类型转换异常。Collection虽然可以存储各种对象，但实际上通常只存储同一类型对象。 泛型：可以在类或方法中预支地使用未知的类型。 Tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Objec类型。 3.1 使用泛型的好处 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 代码示例： import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class DemoGeneric02 { public static void main(String[] args) { Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;abc&quot;); list.add(&quot;itcast&quot;); &#x2F;&#x2F;list.add(5); &#x2F;&#x2F; 编译不通过，类型不同 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ String str = it.next(); &#x2F;&#x2F; 当使用了Iterator&lt;String&gt;控制元素类型后，就不用强转了。 System.out.println(str.length()); } } } Tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看作数据类型。 3.2 泛型的定义与使用在集合中会大量使用到泛型，这里来完整地学习泛型知识。泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 修饰符 class 类名&lt;代表泛型的变量&gt;{ } 例如，API中的ArrayList集合： class ArrayList&lt;E&gt;{ public boolean add(E e){ } public E get(int index){ } } 在创建对象的时候确定泛型例如：ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 以下举例自定义泛型类 public class DemoTestE { public static void main(String[] args) { &#x2F;&#x2F; 创建一个泛型为String的类 DemoE&lt;String&gt; mye = new DemoE&lt;String&gt;(); &#x2F;&#x2F; 调用set方法 mye.setMvp(&quot;我是一个字符串&quot;); &#x2F;&#x2F; 调用get方法 String str = mye.getMvp(); System.out.println(str); &#x2F;&#x2F; 创建一个泛型为Integer的类 DemoE&lt;Integer&gt; my2 = new DemoE&lt;&gt;(); my2.setMvp(123); System.out.println(my2.getMvp()); } } 含有泛型的方法格式： 修饰符&lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ }代码举例： &#x2F;&#x2F; 自定义一个含有泛型的方法 public class MyGenericMethod { public &lt;MVP&gt; void show(MVP mvp){ System.out.println(mvp.getClass()); &#x2F;&#x2F; 获取当前类对象 } public &lt;MVP&gt; MVP show2(MVP mvp){ return mvp; } } &#x2F;&#x2F; 使用该类方法，任意输入数据类型 public class GenericMethodDemo { public static void main(String[] args) { &#x2F;&#x2F; 创建对象 MyGenericMethod mgm = new MyGenericMethod(); &#x2F;&#x2F; 调用方法 mgm.show(&quot;aaa&quot;); mgm.show(123); mgm.show(&#39;A&#39;); mgm.show(1.30); } } 含有泛型的接口格式：修饰符 interface名称&lt;代表泛型的变量&gt;{ }使用方法基本和类的一致，代码如下： &#x2F;&#x2F; 含有泛型的接口类 public interface MyGenericInterface&lt;E&gt; { public abstract void add(E e); public abstract E getE(); } &#x2F;&#x2F; 使用格式1： 定义类时确定泛型的类型 public class MyGenericInterfaceImpl implements MyGenericInterface&lt;String&gt; { @Override public void add(String e){ System.out.println(&quot;接口使用泛型&quot;); } @Override public String getE(){ return null; } } &#x2F;&#x2F; 此时，泛型E的是就是String类型 &#x2F;&#x2F; 使用格式2：始终不确定泛型的类型，直到创建对象时，确定泛型的类型 public class MyImpl2&lt;E&gt; implements MyGenericInterface&lt;E&gt;{ @Override public void add(E e) { System.out.println(&quot;在创建对象时会确认泛型的类型&quot;); } @Override public E getE() { return null; } } &#x2F;&#x2F; 测试 public class GenericTest { public static void main(String[] args) { MyImpl2&lt;String&gt; my = new MyImpl2&lt;String&gt;(); &#x2F;&#x2F; 在创建对象时指定泛型类型 my.add(&quot;aa&quot;); MyImpl2&lt;Integer&gt; my2 = new MyImpl2&lt;Integer&gt;(); my2.add(1); } } 3.4 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符的基本使用泛型的通配符：不知道使用什么类型来接收时，可以使用？(？表示未知通配符)。 import java.util.ArrayList; import java.util.Collection; public class TestWildCard { public static void main(String[] args) { Collection&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(123); getElement(list); &#x2F;&#x2F; 可以接受任意类型数据 Collection&lt;String&gt; str = new ArrayList&lt;String&gt;(); str.add(&quot;str&quot;); getElement(str); } public static void getElement(Collection&lt;?&gt; coll){ &#x2F;&#x2F; 不知道会传入什么类型数据，可以用？ System.out.println(coll); } } Tips:泛型不存在继承关系，例如Collection list = new ArrayList();这种是错误的。 通配符高级使用–受限泛型前面设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在Java的泛型中可以指定一个泛型上限和下限。 泛型的上限： 格式：类型名称&lt;？extends类&gt;对象名称 意义：只能接收该类型及其子类 泛型的下限： 格式:类型名称&lt;?super类&gt;对象名称 意义：只能接收该类型及其父类型 比如：现已知Object，String类，Number类，Integer类，其中Number是Integer的父类。 &#x2F;* 泛型的上限限定：? extends E 代表使用的泛型只能是E类型的子类&#x2F;本身 泛型的下线限定：? super E 代表使用的泛型只能是E类型的父类&#x2F;本身 *&#x2F; import java.util.ArrayList; import java.util.Collection; public class Demo01 { public static void main(String[] args) { Collection&lt;Integer&gt; ints = new ArrayList&lt;&gt;(); Collection&lt;String&gt; str = new ArrayList&lt;&gt;(); Collection&lt;Number&gt; num = new ArrayList&lt;&gt;(); Collection&lt;Object&gt; obj = new ArrayList&lt;&gt;(); getElement1(ints); getElement1(str); &#x2F;&#x2F; 报错 不是Number子类或本身 getElement1(num); getElement1(obj); &#x2F;&#x2F; 报错 是Number父类，不符合 getElement2(ints); &#x2F;&#x2F; 报错 getElement2(str); &#x2F;&#x2F; 报错 getElement2(num); getElement2(obj); &#x2F;* 类与类之间的继承关系 Integer extends Number extends Object String extends Object *&#x2F; } &#x2F;&#x2F; 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类 public static void getElement1(Collection&lt;? extends Number&gt; coll){} &#x2F;&#x2F; 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类 public static void getElement2(Collection&lt;? super Number&gt; coll){} } 4 综合案例按照斗地主的规则，完成洗牌发牌的动作。具体规则：使用54张牌打乱顺序，三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留底牌。 4.1 案例分析 准备牌： 牌可以设计为一个ArrayList,每个字符串为一张牌。每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。牌由Collection类的shuffle方法进行随机排序。 发牌 将每个人以底牌设计为ArrayList，将最后3张牌直接存于底牌，剩余牌通过对3取模依次发牌。 看牌 直接打印每个集合。 代码实现 import java.util.ArrayList; import java.util.Collections; &#x2F;* 1. 准备牌：54张牌，存到一个集合中 特殊牌：大小王 其余52张牌： 定义一个数组&#x2F;集合，存储4种花色 定义一个数组&#x2F;集合，存储13个序号:2AKQJ....3 循环嵌套遍历两个数组&#x2F;集合，组装52张牌 2. 洗牌 使用集合工具类Collection的方法 static void shuffle(List&lt;?&gt; list) 使用指定的随机源对指定列表进行置换 会随机打乱集合中的元素顺序。 3. 发牌 要求：1人17张牌，剩余3张作为底牌，1人以张轮流发牌，集合索引(0-53)%3 定义4个集合，存储3位玩家的牌和底牌 索引%2，有两值(0,1) 0%2=0,1%2=1,2%2=0,3%2=1 索引%3，有三值(0,1,2) 0%3=0,1%3=1,2%3=2,3%3=0 4. 看牌 直接打印集合即可。 *&#x2F; public class Poker { public static void main(String[] args) { ArrayList&lt;String&gt; flowerColor = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 花色 ArrayList&lt;String&gt; cardNumber = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 牌数字 ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;&gt;(); &#x2F;&#x2F; 牌盒 &#x2F;&#x2F; 添加花色 flowerColor.add(&quot;♥&quot;); flowerColor.add(&quot;♦&quot;); flowerColor.add(&quot;♠&quot;); flowerColor.add(&quot;♣&quot;); &#x2F;&#x2F; 添加牌数字 for (int i = 2; i &lt;= 10; i++) { cardNumber.add(i + &quot;&quot;); &#x2F;&#x2F; 将int数字字符串化 } cardNumber.add(&quot;J&quot;); cardNumber.add(&quot;Q&quot;); cardNumber.add(&quot;K&quot;); cardNumber.add(&quot;A&quot;); &#x2F;&#x2F; 组装牌 for (String color:flowerColor){ for(String numbers:cardNumber){ pokerBox.add(color+numbers); &#x2F;&#x2F; System.out.println(color+numbers); } } &#x2F;&#x2F; 大小王 pokerBox.add(&quot;小☺&quot;); pokerBox.add(&quot;大☠&quot;); &#x2F;&#x2F; System.out.println(pokerBox); &#x2F;&#x2F; Collection类的shuffle方法进行随机排序。 Collections.shuffle(pokerBox); &#x2F;&#x2F; 创建玩家集合和底牌集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); &#x2F;&#x2F; 遍历牌盒 for (int i = 0; i &lt; pokerBox.size(); i++) { String card = pokerBox.get(i); &#x2F;&#x2F; 获取一张牌 &#x2F;&#x2F; 留三张底牌，放入底牌盒中 if(i &gt;= 51){ dipai.add(card); }else{ if(i%3==0){ player1.add(card); }else if(i%3==1){ player2.add(card); }else { player3.add(card); } } } System.out.println(player1); System.out.println(player2); System.out.println(player3); } }","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://zero024.cn/tags/集合/"}]},{"title":"Java中的Object类和常用API","slug":"JavaBasics/Object类和常用API","date":"2019-04-23T15:59:00.000Z","updated":"2020-03-08T00:49:16.361Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. Object类java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找到的父类就是Object。根据JDK源码及Object类的API文档，Object类中包含的方法有11个。本章主要学习其中的2个： public String toString(); 返回该对象的字符串表示。 public boolean equals(Object obj):指示其他某个对象是否与此对象”相等”。","text":"1. Object类java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找到的父类就是Object。根据JDK源码及Object类的API文档，Object类中包含的方法有11个。本章主要学习其中的2个： public String toString(); 返回该对象的字符串表示。 public boolean equals(Object obj):指示其他某个对象是否与此对象”相等”。 1.2 toString方法toString方法返回该对象的字符串表示，其实返回的字符串内容就是对象的类型+@+内存地址值。Person@3feba861由于该方法返回的是内存地址，所以一般要重写它以获取对象属性。 public class Person { private String name; private int age; @Override public String toString() { &#x2F;&#x2F; 重写toString方法 return &quot;Person{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &#39;}&#39;; } 省略get&#x2F;set } 在IntelliJ IDEA中，可以使用快捷键ALT+Insert,点击toString()选项，自动生成该方法。 1.3 equals方法 public boolean equals(Object obj):比较两个对象是否“相等”，返回布尔值。默认地址比较如果没有覆盖重写equals方法，那么object类默认进行==运算符的对象地址比较，只要不同就返回false。 对象内容比较如果希望进行对象的内容比较，可以重写equals方法。 @Override public boolean equals(Object o) { if (this == o) return true; &#x2F;&#x2F; 如果o不等于空并且o不等于Person类型，返回false。 getClass() != o.getClass() 使用反射技术，判断o是否是Person类型， 等效于 obj instanceof Person if (o == null || getClass() != o.getClass()) return false; &#x2F;&#x2F; 向下转型 Person person = (Person) o; &#x2F;* Object.equals(Object a, Object b); equals方法重载解析： Objects.equals(name, person.name); &#x2F;&#x2F; 传入两个对象参数 public static boolean equals(Object a, Object b) { &#x2F;&#x2F; 判断a==b 或者 a不等于空，并且a与b的内存地址相同才返回true，反之false return (a == b) || (a != null &amp;&amp; a.equals(b)); } *&#x2F; return age == person.age &amp;&amp; Objects.equals(name, person.name); } 使用快捷键ALT+Insert可以自动生成该代码。 1.4 Oebjects类在JDK7添加了一个Objects工具类，它提供了一些方来操作对象，它由一些静态的实用方法组成，这些方法是null-save(空指针安全的)或null-tolerant(容忍空指针的),用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象时，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Objects a,Objects b):判断两个对象是否相等。源码解析： Object.equals(Object a, Object b); &#x2F;&#x2F; 对传入的两个对象进行比较，可防止空指针异常。 Objects.equals(name, person.name); &#x2F;&#x2F; 传入两个对象参数 public static boolean equals(Object a, Object b) { &#x2F;&#x2F; 判断a==b 或者 a不等于空，并且a与b的内存地址相同,才能返回true，反之false。 return (a == b) || (a != null &amp;&amp; a.equals(b)); } 2. 日期时间类2.1 Date类java.util.Date类表示特点的瞬间，精确到毫秒。Date中拥有多个构造方法，部分已过时，其中有未过时的构造方法可以把毫秒值转成日期对象。 public Date():分配Date对象并初始化此对象，以表示分配它的时间(精确到毫秒)。获取当前系统的日期和时间。 public Date(long date):传递毫秒值，把毫秒值转换为Date日期，以表示自从标准基准时间(称为”历元(epoch)”，即1970年1月1日00:00:00 GMT)以来的指定毫秒数。 public long getTime()：把日期对象转换成对应的时间毫秒值。 Tips:由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 import java.util.Date; public class Demo01Date { public static void main(String[] args) { System.out.println(&quot;当前系统时间&quot;+new Date()); System.out.println(&quot;将传入的毫秒值转换为日期时间格式&quot;+new Date(0L)); &#x2F;&#x2F; Tue Apr 23 20:39:00 CST 2019 System.out.print(&quot;把日期转换为毫秒值&quot;+new Date().getTime()); &#x2F;&#x2F; 相当于System.currenTimeMillis()方法 } } Tips:在使用println方法时，会自动调用Date类中的toString方法。Date类重写了toString方法，所以结果为指定格式的字符串。 2.2 DateFormat类java.text.DateFormat是日期/时间格式子类的抽象类，通过这个类可以帮我们完成日期和文本之间的转换，也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一默认(格式)来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern):用指定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用格式规则为： 更详细的格式规则，可参考SimpleDateFormat类的API文档。创建一个SimpleDateFormat对象代码如下： import java.text.DateFormat; import java.text.SimpleDateFormat; public class Demo03DateFormat { public static void main(String[] args) { DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); } } 常用方法 public String format(Date date):将Date对象格式化为字符串。 public Date parse(String source):将字符串解析为Date对象。 format方法使用DateFormat类中的方法format，将日期格式化为文本，使用步骤如下。 创建SimpleDateFormat对象，构造方法中传入指定模式 调用SimpleDateFormat对象中的方法format，按照构造方法中的模式，把Date日期格式转换为符合格式的字符串 &#x2F;&#x2F; 1. 创建SimpleDateFormat对象，构造方法中传入指定模式 DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); &#x2F;&#x2F; 2. 调用SimpleDateFormat对象中的方法format String a = format.format(new Date()); System.out.println(a); &#x2F;&#x2F; 2019-04-23 22:04:11 parse方法使用DateFormat类中的方法parse，把文本解析为日期，使用步骤如下： 创建SimpleDateFormat对象，构造方法中传入指定模式 调用SimpleDateFormat对象中的方法parse，把符合构造方法中模式的字符串，解析为Date日期 DateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date date = sdf.parse(&quot;1996-06-03 11:45:03&quot;); System.out.println(date); &#x2F;* 注意： public Date parse(String source) throws ParseException parse方法声明了一个异常叫ParseException,如果字符串和构造方法的模式不一致，那么程序就会抛出异常。 调用了一个抛出异常的方法，就必须处理这个异常，要么throws继续抛出这个异常，要么try catch自己处理。 *&#x2F; 2.3 练习使用日期时间相关API，计算一个人出生了多少天 import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Scanner; public class Demo02Test { public static void main(String[] args) throws ParseException { Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你的出生日期，格式：年-月-日&quot;); String Birthday = sc.next(); long CurrentTime = new Date().getTime(); &#x2F;&#x2F; 现在时间 DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); &#x2F;&#x2F; 设置时间格式 long liveTime = CurrentTime - format.parse(Birthday).getTime(); &#x2F;&#x2F; 使用parse把文本解析为日期格式在转换为毫秒值 &#x2F;&#x2F; System.out.println(liveTime); System.out.println(&quot;出生了&quot;+liveTime&#x2F;1000&#x2F;60&#x2F;60&#x2F;24+&quot;天&quot;); &#x2F;&#x2F; liveTime&#x2F;1000&#x2F;60&#x2F;60&#x2F;24 把毫秒值转换为天 } } 2.4 Calendar类java.util.Calendar是日历类，在Date后出现，替换掉了许多Date方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calenday为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：Calendar静态方法 public static Calendar getInstance():使用默认时区和语言环境获取一个日历。示例代码： import java.util.Calendar; public class Demo04Calendar { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); &#x2F;&#x2F; 多态 } } 常用方法根据Calendar类的API文档，常用方法有： public int get(int field):返回给定日历字段的值。 public void set(int field, int value):将给定的日历字段设置为给定值。 public abstract void add(int field,int amount):根据日历规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime():返回一个表示此Calendar时间值的Date对象,返回从历元到现在的毫秒偏移量。 Calendar类中提供很多成员常量，代表给定的日历字段： get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，演示代码如下： import java.util.Calendar; public class Demo04Calendar { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); &#x2F;&#x2F; 多态 int year = cal.get(Calendar.YEAR); &#x2F;&#x2F; 获取当前年份 int month = cal.get(Calendar.MONTH)+1; &#x2F;&#x2F;因为国外月份是0~11，我们是1~12. int day = cal.get(Calendar.DAY_OF_MONTH); &#x2F;&#x2F; 当前天数 &#x2F;&#x2F; System.out.println(day); &#x2F;&#x2F; System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;号&quot;); cal.set(Calendar.YEAR,2020); &#x2F;&#x2F;自定义日期 cal.set(Calendar.MONTH,06); cal.set(Calendar.DAY_OF_MONTH,03); int year1 = cal.get(Calendar.YEAR); int month1 = cal.get(Calendar.MONTH); int day1 = cal.get(Calendar.DAY_OF_MONTH); System.out.println(year1+&quot;年&quot;+month1+&quot;月&quot;+day1+&quot;号&quot;); } } add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为整数则加上偏移量，负数则减去偏移量，演示代码如下： import java.util.Calendar; public class Demo05CalendarAddMethod { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); int year = cal.get(Calendar.YEAR); int month = cal.get(Calendar.MONTH)+1; int day = cal.get(Calendar.DAY_OF_MONTH); System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;号&quot;); &#x2F;&#x2F; 使用add方法 cal.add(Calendar.YEAR,1); &#x2F;&#x2F; 当前年份+1 cal.add(Calendar.MONTH,2); cal.add(Calendar.DAY_OF_MONTH,-20); &#x2F;&#x2F; 天数-20天 int year1 = cal.get(Calendar.YEAR); int month1 = cal.get(Calendar.MONTH)+1; int day1 = cal.get(Calendar.DAY_OF_MONTH); System.out.println(year1+&quot;年&quot;+month1+&quot;月&quot;+day1+&quot;号&quot;); } } getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 import java.util.Calendar; import java.util.Date; public class Demo06CalendarGetTime { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); &#x2F;&#x2F; 获取的是Date对象 System.out.println(date); &#x2F;&#x2F; Tue Apr 23 22:52:25 CST 2019 } } 3. System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或者系统级操作，常用方法有： public static long currentTimeMillis():返回以毫秒为单位的当前时间。 public static void arraycopy(Object src,int srcPos,Object dest, int destPos, int length):将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法currentTimeMillis方法获取的是当前系统时间与1970年01月01日00:00(计算机元年)之间的毫秒差值。 public class Demo07CurrentTime { public static void main(String[] args) { System.out.println(System.currentTimeMillis()); } } 小练习1计算for循环打印数字1~9999所需的时间(毫秒)。 public class Demo08SystemTest { public static void main(String[] args) { long CurrentTime = System.currentTimeMillis(); for(int i = 1;i &lt; 10000;i++){ System.out.println(i); } System.out.println(&quot;打印1~9999花费&quot;+(System.currentTimeMillis() - CurrentTime)+&quot;毫秒&quot;); } } 3.2 arraycopy方法该方法将数组指定数据拷贝到另一个数组中，数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 小练习2将src数组中前3个元素，复制到dest数组的前3个位置上。复制元素前：src[1,2,3,4,5]，dest[6,7,8,9,10]复制元素后：src[1,2,3,4,5], dest[1,2,3,9,10] arraycopy(源数组，源数组索引起始位置，目标数组，目标数组索引起始位置，复制元素个数) *&#x2F; public class Demo09SystemArrayCopy { public static void main(String[] args) { int[] src = {1,2,3,4,5}; int[] dest = {6,7,8,9,10}; System.arraycopy(src,0,dest,0,3); for (int i = 0; i &lt; dest.length; i++) { System.out.print(dest[i]+&quot;,&quot;); &#x2F;&#x2F; 123910 } } } 4. StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可变，所以每当进行字符串拼接时，都会在内存中创建一新的对象。字符串是常量，它们的值在创建后不能被更改。如果字符串进行拼接操作，每次拼接时都会创建一个新的String对象，耗时又浪费空间。可以使用java.lang.StringBuilder类。 4.2 StringBuilder类概述StringBuilder又称为可变字符序列,它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 4.3 构造方法常用的构造方法有2个： public StringBuilder():构造一个空的StringBuilder容器。 public StringBuilder(String str):构造一个容器同时将一个字符串添加进去。 public class Demo10StringBuilder { public static void main(String[] args) { StringBuilder strb = new StringBuilder(); &#x2F;&#x2F; 创建一个空容器对象 StringBuilder strb2 = new StringBuilder(&quot;Hello&quot;); &#x2F;&#x2F; 带参构造方法 } } 4.4 常用方法StringBuilder中常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。示例如下： public class Demo10StringBuilder { public static void main(String[] args) { StringBuilder builder = new StringBuilder(); &#x2F;&#x2F; 创建一个空容器对象 StringBuilder result = builder.append(&quot;hello&quot;); &#x2F;&#x2F;向容器中添加一个字符串类型 System.out.println(builder); &#x2F;&#x2F; hello System.out.println(result); &#x2F;&#x2F; hello if(builder == result){ System.out.println(&quot;它们是同一个容器对象&quot;); } &#x2F;&#x2F; 可以添加任意类型,且可以往容器中连续放入 builder.append(100).append(true).append(10.0).append(&#39;A&#39;); System.out.println(builder); &#x2F;&#x2F; hello100true10.0A &#x2F;* 如果在开发中，遇到调用一个对象后，返回一个对象的情况，可以使用返回的对象继续调用方法。 如上情况，可以把它们连在一起，这叫做链式编程。 *&#x2F; } } toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如下： public class Demo11StringToString { public static void main(String[] args) { StringBuilder builder = new StringBuilder(&quot;hello&quot;).append(&quot;world&quot;); String str = builder.toString(); &#x2F;&#x2F; 将builder容器转换为字符串类型。 System.out.println(str); } } 5. 包装类Java提供了两个类型系统，基本类型与引用类型。使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 5.1 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱” 与 “拆箱”： 装箱:从基本类型转换为对应的包装类对象。 拆箱:从包装类对象转换为对应的基本类型。 用Integer与int为例： public class Demo12PackClass { public static void main(String[] args) { &#x2F;&#x2F; 基本数值 --&gt; 包装对象 Integer i = new Integer(4); &#x2F;&#x2F; 使用构造方法 Integer iii = Integer.valueOf(4); &#x2F;&#x2F; &#x2F;使用包装类中的valueOf方法 &#x2F;&#x2F; 包装对象 --&gt; 基本数值 int num = i.intValue(); } } 5.2 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5开始，基本类型与包装类的装箱、拆箱动作可以自动完成。示例如下： Integer i = 4;&#x2F;&#x2F;自动装箱。相当于Integer i = Integer.valueOf(4); i = i + 5;&#x2F;&#x2F;等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5; &#x2F;&#x2F;加法运算完成后，再次装箱，把基本数值转成对象。 5.3 基本类型与字符串之间的转换基本类型转换为String基本类型转换String总共有三种方法，这里只讲解最简单一种方式：基本类型直接与””连接即可，如34+””。 String转换成对应的基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Java的final关键字及内部类","slug":"JavaBasics/Java中的final关键字","date":"2019-04-22T14:00:00.000Z","updated":"2020-03-08T00:49:17.517Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. final关键字继承中子类可以在父类的继承上改写父类内容，比如方法重写。但如果我们随意的继承API中提供的类，改写其内容，显示不合适。为了避免这种随意改写的起来，Java提供了final关键字，用于修改不可改变内容。","text":"1. final关键字继承中子类可以在父类的继承上改写父类内容，比如方法重写。但如果我们随意的继承API中提供的类，改写其内容，显示不合适。为了避免这种随意改写的起来，Java提供了final关键字，用于修改不可改变内容。 final：不可改变。可用于修饰类、方法和变量。 类：被修改的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，不能被重新赋值。 1.1 使用方式 修饰类：final class 类名{} 修饰方法：修饰符 final 返回值类型 方法名(参数列表){方法体} 修饰变量有以下三种情况： 局部变量–基本类型：基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。 局部变量–引用类型：引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部成员变量值的修改。 成员变量：成员变量涉及到初始化的问题，初始化方式有两种，显式初始化和构造方法初始化。 代码示例如下： public class FinalDemo01 { public static void main(String[] args) { &#x2F;&#x2F; 1. 以下示意局部变量基本类型使用final关键字修饰。 final int a; &#x2F;&#x2F; 使用final修饰，声明变量。 a = 10; &#x2F;&#x2F; 第一次赋值，编译通过 &#x2F;&#x2F; a = 20; &#x2F;&#x2F; 第二次赋值，报错。 final int b = 10; &#x2F;&#x2F; 申明变量同时直接赋值，使用final修饰 &#x2F;&#x2F; b = 20; &#x2F;&#x2F; 报错,不可重新赋值 for(int i = 0; i &lt; 10;i++){ final int c = i; System.out.print(c); } &#x2F;&#x2F; 2. 以下示例局部变量引用类型使用final关键字修饰。 final TestFinal tf = new TestFinal(&quot;张三&quot;,11); &#x2F;&#x2F; 创建一个测试对象。 &#x2F;&#x2F; tf = new TestFinal(); &#x2F;&#x2F; 新创建一个对象，把tf指向该对象。报错，使用final修饰后无法改变地址值。 } } &#x2F;&#x2F; 成员变量initialize public class TestFinal { &#x2F;&#x2F; 创建类时直接初始化，并用final修饰。 &#x2F;* final String USERNAME = &quot;张山&quot;; private int age; *&#x2F; final String USERNAME; private int age; &#x2F;&#x2F; 使用构造方法initialize public TestFinal(String USERNAME, int age) { this.USERNAME = USERNAME; this.age = age; } } 2. 权限修饰符在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。 public：公共的 protected：受保护的 default：默认的 private：私有的 2.1 不同权限的访问能力public具有最大权限。private则是最小权限。故编写代码时，如果没有特殊的考虑，应该这样使用权限： 成员变量使用private，隐藏细节。 构造方法使用public，方便创建对象。 成员方法使用public，方便调用方法。 不加权限修饰符的，其访问能力与default修饰符相同。 3. 内部类如果一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 成员内部类：定义在类中方法外的类。在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类Car中包含发动机类Engine，这个Engine类就可以使用内部类来描述，定义在成员位置。 class Car{ &#x2F;&#x2F;外部类 ... class Engine{ &#x2F;&#x2F;成员内部类 ... } } 内部类可以直接访问外部类的成员，包括私有成员。 访问重名的成员变量，使用格式：外部类名称.this.外部类成员变量名如何使用成员内部类？两种方式： 间接方式：在外部类的方法中，使用内部类；然后通过调用外部类方法来间接调用内部类。 直接方式：[外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();] &#x2F;&#x2F; 成员内部类示例 public class Body { &#x2F;&#x2F; 内部类 public class Heart{ &#x2F;&#x2F; 成员内部类 &#x2F;&#x2F; 内部类方法 public void beat(){ System.out.println(&quot;心脏跳动：砰砰砰！&quot;); System.out.println(&quot;我叫：&quot; + name); &#x2F;&#x2F; 内部类可以直接访问外部类成员变量 } } private String name; &#x2F;&#x2F; 外部类成员变量 &#x2F;&#x2F; 外部类方法 public void methodBody(){ System.out.println(&quot;外部类的方法&quot;); new Heart().beat(); &#x2F;&#x2F; 匿名对象 } public String getName() { return name; } public void setName(String name) { this.name = name; } } &#x2F;&#x2F; 成员内部类示例测试类 public class InnerClassDemo02 { public static void main(String[] args) { Body body = new Body(); body.methodBody(); &#x2F;&#x2F; 间接通过外部类方法访问内部类 System.out.println(&quot;下面使用直接访问方式访问内部类&quot;); Body.Heart heart = new Body().new Heart(); heart.beat(); } } &#x2F;&#x2F; 访问重名的成员变量示例 public class Other { int num = 10; &#x2F;&#x2F; 外部类的成员变量 public class Inner{ int num = 20; &#x2F;&#x2F; 内部类的成员变量 public void methodInner(){ int num = 30; &#x2F;&#x2F; 内部类方法的局部变量 System.out.println(num); &#x2F;&#x2F; 局部变量，就近原则 System.out.println(this.num); &#x2F;&#x2F; 内部类成员变量 System.out.println(Other.this.num); &#x2F;&#x2F; 外部类成员变量 } } } &#x2F;&#x2F; 访问重名的成员变量示例测试类 public class InnerClassDemo03 { public static void main(String[] args) { Other.Inner obj = new Other().new Inner(); obj.methodInner(); } } 局部内部类如果一个类是定义在一个方法内部的，那么这就是一个局部内部类“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 &#x2F;&#x2F; 局部内部类 public class Outer { public void methodOuter(){ class Inner{ &#x2F;&#x2F; 局部内部类 int num = 10; public void methodInner(){ System.out.println(num); } } Inner inner = new Inner(); &#x2F;&#x2F; 创建局部内部类对象 inner.methodInner(); &#x2F;&#x2F; 调用内部类方法,将打印10 } } &#x2F;&#x2F; 测试类 public class DemoMain { public static void main(String[] args) { Outer outer = new Outer(); outer.methodOuter(); } } 小结类的权限修饰符：public &gt; protected &gt; (default) &gt; private定义一个类时，权限修饰符规则： 外部类：public / (default) 成员内部类：public / protected / (default) / private 局部内部类：什么都不能写 注意事项：局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是[有效的final的]备注：从Java 8+开始，只要局部变量属实不变，那么final关键字可省略原因： new出来的对象在堆内存中。 局部变量是跟着方法走的，在栈内存当中。 方法运行结束之后，立即出栈，局部变量就会立即消失。 但new出来的对象会在堆中持续存在，直到垃圾回收消失。 匿名内部类(重点) 匿名内部类：是内部类的简化写法。它本质是一个带具体实现的父类或者父接口的匿名的子类对象。开发中，最常用的内部类就是匿名内部类。以接口为例，当使用一个接口时，得做如下几步操作： 定义子类 重写接口中的方法 创建子类对象 调用重写后的方法我们最终的目的只是为了调用方法，那么该如何简化。匿名内部类就可以处理这种情况。 &#x2F;&#x2F; 接口类 public interface MyInterface { void method(); void method2(); } &#x2F;* 匿名内部类的定义格式： 接口名称 对象名 = new 接口名称(){ &#x2F;&#x2F; 覆盖重写所有抽象方法 } 对格式 “new 接口名称() {...}” 进行解析： 1. new代表创建对象的动作 2. 接口名称就是匿名内部类需要实现哪个接口 3. {...} 这是匿名内部类的内容 另外还有注意几点问题： 1. 匿名内部类，在创建对象时，只能使用唯一一次。 如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。 2. 匿名对象，在[调用方法]时，只能调用唯一一次，如果希望同一对象调用多次方法，那么必须给对象起名。 3. 匿名内部类是省略了[实现类&#x2F;子类名称]，但匿名对象是省略了[对象名称]。匿名内部类和匿名对象不是一回事！ *&#x2F; &#x2F;&#x2F; 主方法测试类 public class DemoMain { public static void main(String[] args) { &#x2F;&#x2F; 使用匿名内部类 MyInterface obj = new MyInterface() { @Override public void method() { System.out.println(&quot;使用匿名内部类实现了方法1！&quot;); } @Override public void method2() { System.out.println(&quot;匿名内部类实现方法2&quot;); } }; obj.method(); obj.method2(); &#x2F;&#x2F; 使用了匿名内部类，而且省略了对象名称，也是匿名对象 new MyInterface(){ @Override public void method() { System.out.println(&quot;使用匿名对象方式，该内部类方法只能调用一次&quot;); } @Override public void method2() { } }.method(); &#x2F;&#x2F; 因为匿名对象无法调用第二次方法，所以需要再创建一个匿名内部类的匿名对象才能二次调用。 } } 4. 引用类型用法总结实际开发中，引用类型的使用非常重要且普遍。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么引用类型也是可以的。 4.1 class作为成员变量具体代码示例如下： &#x2F;&#x2F; 定义一个英雄类 public class Hero { private String name; &#x2F;&#x2F; 名称 private int blood; &#x2F;&#x2F; 生命值 private Weapon weapon; &#x2F;&#x2F; 添加武器属性 public Hero() { } public Hero(String name, int blood, Weapon weapon) { this.name = name; this.blood = blood; this.weapon = weapon; } public void attack(){ System.out.println(name+&quot;使用了&quot;+weapon.getName()+&quot;攻击敌方&quot;); } ... 省略get&#x2F;set方法 } &#x2F;&#x2F; 定义一个武器类 public class Weapon { private String name; &#x2F;&#x2F; 武器名称 public Weapon(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } &#x2F;&#x2F; 测试类 public class DemoMain { public static void main(String[] args) { &#x2F;&#x2F; 创建英雄对象 Hero hero = new Hero(); &#x2F;&#x2F; 创建武器对象 Weapon wp = new Weapon(&quot;霜之哀伤&quot;); hero.setName(&quot;伊利丹&quot;); &#x2F;&#x2F; 设置英雄名字 hero.setWeapon(wp); &#x2F;&#x2F; 将武器交给英雄 hero.attack(); &#x2F;&#x2F; 攻击 } } 4.2 interface作为方法参数和返回值类型以下示意接口作为方法参数： &#x2F;&#x2F; 接口类 public interface Skill { void use(); &#x2F;&#x2F; 释放技能 } &#x2F;&#x2F; 实现类 public class SkillImpl implements Skill { @Override public void use() { System.out.println(&quot;biubiubiu&quot;); } } &#x2F;&#x2F; 英雄类 public class Hero { private String name; &#x2F;&#x2F; 英雄名称 private Skill skill; &#x2F;&#x2F; 英雄技能 public Hero() { } public Hero(String name, Skill skill) { this.name = name; this.skill = skill; } public void attack(){ System.out.println(&quot;我叫&quot;+name+&quot;，开始释放技能：&quot;); skill.use(); &#x2F;&#x2F;调用接口中的抽象方法 System.out.println(&quot;释放技能完成。&quot;); } ....省略get&#x2F;set方法 } &#x2F;&#x2F; 测试类 public class DemoGame { public static void main(String[] args) { Hero hero = new Hero(); hero.setName(&quot;艾希&quot;); &#x2F;&#x2F; 设置英雄名称 &#x2F;&#x2F; 设置英雄技能 &#x2F;&#x2F; 使用实现类作为参数传递 &#x2F;&#x2F; hero.setSkill(new SkillImpl()); &#x2F;&#x2F; hero.attack(); &#x2F;&#x2F; 使用匿名内部类作为参数 &#x2F;&#x2F; Skill skill = new Skill() { &#x2F;&#x2F; @Override &#x2F;&#x2F; public void use() { &#x2F;&#x2F; System.out.println(&quot;pia~~pia~~pia~~&quot;); &#x2F;&#x2F; } &#x2F;&#x2F; }; &#x2F;&#x2F; 使用匿名内部类和匿名对象 hero.setSkill(new Skill() { @Override public void use() { System.out.println(&quot;da~da~da~&quot;); } }); hero.attack(); } } 以下示例接口作为方法的返回值类型 public class DemoInterface { public static void main(String[] args) { &#x2F;&#x2F; 左边是接口名称，右边是实现类名称，这就是多态写法 List&lt;String&gt; list = new ArrayList&lt;&gt;(); &#x2F;&#x2F; List&lt;String&gt; result = addNames(list); for (int i = 0; i &lt; result.size(); i++) { System.out.println(result.get(i)); } } public static List&lt;String&gt; addNumbers(List&lt;String&gt; list){ list.add(&quot;1&quot;); list.add(&quot;2&quot;); list.add(&quot;3&quot;); return list; } } &#x2F;&#x2F; 用一个接口或是自定义类作为方法的参数或者返回值都是可以的 5. 综合案例–发红包[界面版]完整代码见：SendRedPacket 手气红包算法思路解析： 案例总结通过发红包案例，你都学到了什么？请思考如下问题： 基础语法，你是否清晰？ 一些基本的类的方法，你是否能够调用 案例中哪里体现了继承，继承的作用是什么？ 接口作为参数，如何使用？ 接口作为成员变量，如何使用? 如何简化接口的使用方式？ 今日总结 使用final关键字修饰类、方法和变量。 Java中的权限修饰符。 成员内部类、局部内部类、匿名内部类、匿名对象的基本使用格式。 引用类型作为参数，返回值类型的使用方式。 综合案例发红包代码理解。","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Java三大特性之多态","slug":"JavaBasics/Java三大特性之--多态","date":"2019-04-21T15:00:00.000Z","updated":"2020-03-08T00:49:30.714Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. 接口1.1 概述接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法，默认方法和静态方法，私有方法。","text":"1. 接口1.1 概述接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法，默认方法和静态方法，私有方法。 接口的定义，它与定义类方式相似，但是使用interface关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。接口的使用，它不能创建对象，但是可以被实现(implements，类似于被继承)。一个实现接口的类(可以看做是接口的子类),需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。 1.2 定义格式 含有抽象方法 抽象方法：使用abstract关键字修饰，可以省略，没有方法体。该方法供子类实现使用。代码如下： public interface InterFaceName{ public abstract void method(); } 含有默认方法和静态方法 默认方法：使用default修饰，不可省略，供子类调用或者子类重写。 静态方法：使用static修饰，供接口直接调用。 代码如下： public interface InterFaceName{ public default void method(){ &#x2F;&#x2F; 执行语句 } public static void method2(){ &#x2F;&#x2F; 执行语句 } } 含有私有方法和私有静态方法 私有方法：使用private修饰，供接口中的默认方法或者静态方法调用。 代码如下： public interface InterFaceName{ private void method(){ &#x2F;&#x2F; 执行语句 } } 1.3 基本的实现类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相似，只是关键字不同，实现使用implements关键字。 非抽象子类实现接口： 必须重写接口中所有抽象方法。 继承了接口的默认方法，即可以直接调用，也可以重写。格式如下： 代码示例： &#x2F;&#x2F; 定义接口类 public interface LiveAble { &#x2F;&#x2F; 定义抽象方法 public abstract void eat(); public abstract void sleep(); } &#x2F;&#x2F; 定义实现类 public class Animal implements LiveAble{ @Override public void eat(){ System.out.println(&quot;吃东西&quot;); } @Override public void sleep(){ System.out.println(&quot;睡觉&quot;); } } &#x2F;&#x2F; 定义测试类 public class InterfaceDemo { public static void main(String[] args) { &#x2F;&#x2F; 创建子类对象 Animal a = new Animal(); a.eat(); a.sleep(); } } 默认方法的使用可以继承，可以重写，但只能通过实现类的对象来调用。接口当中的默认方法，可以解决接口升级的问题。 实现类可以继承接口类的默认方法，也可以自己重写默认方法。 代码示例如下： &#x2F;&#x2F; 定义接口类 public interface LiveAble { &#x2F;&#x2F; 定义抽象方法 public abstract void eat(); public abstract void sleep(); public default void fly(){ &#x2F;&#x2F; 定义默认方法 System.out.println(&quot;飞行&quot;); } } &#x2F;&#x2F; 定义实现类 public class Animal implements LiveAble{ @Override public void fly(){ &#x2F;&#x2F; 重写接口中的默认方法，也可以不重写，继承接口类中的默认方法 System.out.println(&quot;自由自在的飞！&quot;); } } &#x2F;&#x2F; 定义测试类 public class InterfaceDemo { public static void main(String[] args) { &#x2F;&#x2F; 创建子类对象 Animal a = new Animal(); a.eat(); a.sleep(); a.fly(); &#x2F;&#x2F; 如果实现类没有重写默认方法，则执行的是继承自接口类的默认方法，重写则执行实现类重写后的方法 } } 静态方法的使用静态与.class文件相关，只能使用接口名调用，不能通过实现类的类名或者实现类的对象调用 示例如下： &#x2F;&#x2F; 接口类 public interface LiveAble { public static void run(){ System.out.println(&quot;这是静态方法，只能通过接口类调用&quot;); } } &#x2F;&#x2F; 实现类无法继承或重写接口类静态方法 &#x2F;&#x2F; 测试类 public class InterfaceDemo { public static void main(String[] args) { &#x2F;&#x2F; 创建子类对象 Animal a = new Animal(); &#x2F;&#x2F; a.run(); 报错，无法通过实现类调用静态方法 LiveAble.run(); &#x2F;&#x2F; 接口类的静态方法只能通过接口类来调用 } } 私有方法的使用 私有方法：只有默认方法可以调用 私有静态方法：默认方法和静态方法可以调用。如果一个接口中有多个默认方法且方法中有代码重复内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。私有方法是对默认方法和静态方法的辅助。 public interface LiveAble { default void func(){ func1(); func2(); } private void func1(){ System.out.println(&quot;跑起来~~~&quot;); } private void func2(){ System.out.println(&quot;跑起来~~~&quot;); } } 接口的常量定义和使用接口当中也可可以定义”成员变量”，但是必须使用public static final三个关键字进行修饰。可以认为就是接口的[常量]。格式：public static final 数据类型 常量名称 = 数据值; 一旦使用final关键字进行修饰，说明不可改变。注意事项： 接口中的常量，可以省略public static final。 接口中的常量，必须进行赋值，不能不赋值。 接口中常量的名称规则：使用完全大写的字母，单词间用下划线进行分隔。 接口内容小结在Java 9+版本中，接口的内容可以有： 成员变量其实是常量。 格式：[public] [sttaic] [final] 数据类型 常量名称 = 数据值; 注意：常量必须进行赋值，且一旦赋值不能改变。常量名称完全大写，用下划线分隔。 接口中最重要的就是抽象方法。 格式：[public] [abstract] 返回值类型 方法名称(参数列表); 注意：实现类必须覆盖重写接口的所有抽象方法，除非实现类是抽象类。 从Java 8开始，接口里允许定义默认方法。 格式：[public] default 返回值类型 方法名称(参数列表){方法体} 注意：默认方法也可以被覆盖重写 从Java 8开始，接口里允许定义静态方法。 格式：[public] static 返回值类型 方法名称(参数列表){方法体} 注意：应该通过接口名称进行调用，无法通过实现类对象调用接口静态方法。 从Java 9开始，接口里允许定义私有方法。 普通私有方法：private 返回值类型 方法名称(参数列表){方法体} 静态私有方法：private static 返回值类型 方法名称(参数列表){方法体} 注意：private方法只要接口自己才能调用，无法被实现类或者别人使用。 接口的多实现在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。格式如下：使用接口的时候，需注意： 接口是没有静态代码块或者构造方法的。 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口的。格式：public class MyIntfaceImpl implements MyInterfaceA,MyInterfaceB{ // 覆盖重写所有抽象方法} 如果实现类实现的多个接口中，存在重复的抽象方法，只需覆盖重写一次即可。 如果实现类没有覆盖重写所以接口的所有抽象方法，那么实现类必须是抽象类。 如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，子类优先用父类当中的方法。 接口的多继承一个接口能继承另一个或者多个接口。接口的继承使用extends关键字，子接口继承父接口的方法。如果父接口中的默认方法有重名，那么子接口需要重写一次。 &#x2F;&#x2F; 父接口A public interface MyInterfaceA { public abstract void methodA(); public abstract void methodCommon(); public default void methodDefault(){ System.out.println(&quot;接口A默认方法&quot;); } } &#x2F;&#x2F; 父接口B public interface MyInterfaceB { public abstract void methodB(); public abstract void methodCommon(); public default void methodDefault(){ System.out.println(&quot;接口B默认方法&quot;); } } &#x2F;&#x2F; 子接口 public interface MyInterface extends MyInterfaceA,MyInterfaceB{ public abstract void method(); @Override default void methodDefault() { &#x2F;&#x2F; 重写父接口的默认方法 } } 类与类之间是单继承的。直接父类只有一个 类与接口之间是多实现的。一个类可以实现多个接口。 接口与接口之间是多继承的。 注意事项： 多个父接口当中的抽象方法如果重复，没关系 多个父接口中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，[而且带着default关键字 2.多态 多态：是指同一行为，具有多个不同表现形式。 2.1多态的体现多态的体现格式：父类名称 对象名 = new 子类名称();代码中体现多态性，其实就是一句话：父类引用指向子类对象 成员变量在多态中的规则 &#x2F;&#x2F; 父类 public class Fu { int num = 10; public void showNum(){ System.out.println(num); } } &#x2F;&#x2F; 子类 public class Zi extends Fu { int num = 20; @Override public void showNum(){ System.out.println(num); } } &#x2F;&#x2F; 测试类 public class DemoMulti01 { public static void main(String[] args) { Fu obj = new Zi(); System.out.println(obj.num); &#x2F;&#x2F; 直接访问成员变量时，左边是谁就先访问谁的 &#x2F;&#x2F; 子类没有覆盖重写，就是父：10 &#x2F;&#x2F; 子类如果覆盖重写，就是子：20 obj.showNum(); } } 注意事项： 直接通过对象名称访问成员变量：看等号左边是谁优先访问谁，没有则向上查找。 间接通过成员方法来访问成员变量：看该方法属于谁优先访问谁，没有则向上找。 多态中成员方法的使用特点当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。 &#x2F;&#x2F; 父类 public class Fu { int num = 10; public void showNum(){ System.out.println(num); } public void method(){ System.out.println(&quot;父类方法&quot;); } public void methodFu(){ System.out.println(&quot;父类特有方法&quot;); } } &#x2F;&#x2F; 子类 public class Zi extends Fu { int num = 20; @Override public void showNum(){ System.out.println(num); } @Override public void method(){ System.out.println(&quot;子类方法&quot;); } public void methodZi(){ System.out.println(&quot;子类特有方法&quot;); } } &#x2F;&#x2F; 测试类 &#x2F;* 在多态的代码中，成员方法的访问规则是： 看new的是谁，就优先用谁，没有则向上找。 成员方法口诀：编译看左边，运行看右边。 对比一下： 成员变量：编译看左边，运行还看左边。 成员方法：编译看左边，运行看右边。 *&#x2F; public class Demo02MultiMethod { public static void main(String[] args) { Fu obj = new Zi(); &#x2F;&#x2F; 多态 &#x2F;&#x2F; 运行看右边：左边是Fu，Fu有method方法，所以编译通过，但是运行时看右边是Zi，故运行子类方法。 obj.method(); &#x2F;&#x2F; 父子都有，优先用子 &#x2F;&#x2F; 运行看右：左边是Fu，Fu有methodFu方法，编译通过，但运行是看右Zi，子类没有该方法，就向上找到父类，然后执行。 obj.methodFu(); &#x2F;&#x2F; 子类没有，向上找到父类有 &#x2F;&#x2F; 编译看左边：左边是Fu，Fu中没有methodZi方法，所以编译报错。 &#x2F;&#x2F; obj.methodZi(); 错误写法！ } } 2.2 多态的好处可以使程序编写的更简单，并且有良好的扩展性。 2.3 引用类型转换多态的转型分为向上转型和向下转型两种： 向上转型 概述：多态本身就子类类型向父类类型向上转换的过程，这个过程是默认的。 使用格式：父类名称 变量名 = new 子类类型(); 如 Animal a = new Cat(); 含义：右侧创建一个子类对象，把它当做父类来看待使用。如上创建了一只猫，当做动物看待，没问题。 注意事项：向上转型一定是安全的，从小范围转向了大范围，从小范围的猫，向上转换成为更大范围的动物。 类似于：double num = 100; // 正确， int–&gt; double， 自动类型转换。 向下转型 概述：父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 格式：子类名称 对象名 = (子类名称)父类对象；如 Cat cat = (Cat)a; 含义：将父类对象，[还原]成为本来的子类对象。 注意事项： 必须保证对象本来创建的时候，就是猫，才能向下转型成为猫。 如果对象创建时本来就不是猫，现在非要向下转型为猫，会报错ClassCastException 类似于： int num = (int)10.0; // 可以 int num = (int)10.5 //不可以，精度损失。 instanceof关键字为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验。格式：变量名 instanceof 数据类型; 如果变量属于该数据类型，返回true，反之返回false。 &#x2F;&#x2F; 父类 public abstract class Animal { public abstract void eat(); } &#x2F;&#x2F; 子类1 public class Cat extends Animal{ @Override public void eat() { System.out.println(&quot;猫吃鱼&quot;); } public void jump(){ System.out.println(&quot;猫跳跳&quot;); } } &#x2F;&#x2F; 子类2 public class Dog extends Animal{ @Override public void eat() { System.out.println(&quot;狗吃shit&quot;); } public void watchHouse(){ System.out.println(&quot;看家&quot;); } } &#x2F;&#x2F; 测试类 public class MainMethod { public static void main(String[] args) { Animal animal = new Dog(); animal.eat(); getAnimal(new Cat()); } public static void getAnimal(Animal animal){ if(animal instanceof Dog){ Dog dog = (Dog)animal; dog.watchHouse(); } if(animal instanceof Cat){ Cat cat = (Cat)animal; cat.jump(); } } } 3. 接口多态的综合案例定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。 3.1 案例分析进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘 USB接口，包含开启功能、关闭功能 笔记本类，包含运行功能、关机功能、使用USB设备功能 鼠标类，要实现USB接口，并具备点击的方法 键盘类，要实现USB接口，具备敲击的方法 具体代码实现如下： &#x2F;&#x2F; 接口类 public interface USB { public abstract void open(); &#x2F;&#x2F; 打开设备 public abstract void close(); &#x2F;&#x2F; 关闭设备 } &#x2F;&#x2F; 笔记本类 public class Laptop { public void powerOn(){ System.out.println(&quot;笔记本电脑开机&quot;); } public void powerOff(){ System.out.println(&quot;笔记本电脑关机&quot;); } &#x2F;&#x2F; 使用USB设备的方法，使用接口作为方法参数 public void usbDevice(USB usb){ usb.open(); if(usb instanceof Mouse){ Mouse mouse = (Mouse)usb; &#x2F;&#x2F; 向下转型 mouse.click(); }else if (usb instanceof Keyboard){ Keyboard keyboard = (Keyboard)usb; keyboard.click(); } usb.close(); } } &#x2F;&#x2F; 鼠标类 &#x2F;&#x2F; 鼠标就是一个USB设备 public class Mouse implements USB{ @Override public void open() { System.out.println(&quot;打开鼠标&quot;); } @Override public void close() { System.out.println(&quot;关闭鼠标&quot;); } public void click(){ System.out.println(&quot;鼠标点击&quot;); } } &#x2F;&#x2F; 键盘类 &#x2F;&#x2F; 键盘也是一个USB设备 public class Keyboard implements USB{ @Override public void open() { System.out.println(&quot;打开键盘&quot;); } @Override public void close() { System.out.println(&quot;关闭键盘&quot;); } public void click(){ System.out.println(&quot;键盘输入&quot;); } } &#x2F;&#x2F; 测试类 public class DemoMain { public static void main(String[] args) { &#x2F;&#x2F; 首先创建一个电脑 Laptop laptop = new Laptop(); laptop.powerOn(); &#x2F;&#x2F; 准备一个鼠标,供电脑使用 USB usbMouse = new Mouse(); &#x2F;&#x2F; 首先向上转型 laptop.usbDevice(usbMouse); &#x2F;&#x2F; 创建一个USB键盘 Keyboard keyboard = new Keyboard(); &#x2F;&#x2F;没有使用多态写法 &#x2F;&#x2F; 方法参数是USB类型，传递进去的是实现类对象 laptop.usbDevice(keyboard); &#x2F;&#x2F; 正确写法！ 自动发生了向上转型！ laptop.powerOff(); } } 该案例主要练习对接口的基本使用，对象的上下转型以及接口作为对象参数的使用。 今日总结 接口的概述以及定义格式，以及实现接口的格式。interface关键字，implements关键字 接口中的抽象方法，默认方法和静态方法，私有方法和私有静态方法的各自使用特点。 接口中成员方法，成员变量的特点。 接口的多继承。 多态的概念以及前提。 多态中的向上向下转型格式以及实际使用方法。 instanceof关键字。","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"三大特性","slug":"三大特性","permalink":"https://zero024.cn/tags/三大特性/"}]},{"title":"Java三大特性之继承","slug":"JavaBasics/Java三大特性之--继承","date":"2019-04-20T08:00:00.000Z","updated":"2020-03-08T00:49:29.707Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"概述多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。其中，多个类可以称为子类，单独那个类称为父类、超类或者基类。","text":"概述多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。其中，多个类可以称为子类，单独那个类称为父类、超类或者基类。 1. 继承 定义：继承就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 优点：提高了代码的复用性，类与类之间产生了关系，是多态的前提。 1.1 继承的格式通过extends关键字，可以声明一个子类继承另外一个父类，实例如下： &#x2F;&#x2F;定义父类 public class Employee { String name; public void work(){ System.out.println(&quot;努力工作&quot;); } } &#x2F;&#x2F; 定义子类继承父类 class Teacher extends Employee{ public void printName(){ System.out.println(&quot;name:&quot; + name); } } &#x2F;&#x2F; 测试 public class Demo01Extends { public static void main(String[] args) { Teacher t = new Teacher(); t.name = &quot;小明&quot;; t.printName(); t.work(); } } 1.2 继承后的成员变量 如果子类父类中成员变量未重名，访问没有影响。 如果成员变量有重名的，访问会有影响，需要使用super关键字修饰父类成员变量。实例如下： public class Demo02Super { public static void main(String[] args) { Zi z = new Zi(); z.show(); } } class Fu{ int num = 5; } class Zi extends Fu{ int num = 6; public void show(){ &#x2F;&#x2F; 访问父类中的num System.out.println(&quot;父类num：&quot; + super.num); &#x2F;&#x2F;使用super关键字即可访问父类成员变量 &#x2F;&#x2F;访问子类中的num System.out.println(&quot;子类num：&quot; + this.num); } } 注意： 父类中的成员变量是非私有时，子类可以直接访问。若父类成员变量私有了，子类是不能直接访问的，可以通过父类设置的getxxx/setxxx方法间接访问。 1.3 继承后的成员方法。 如果子类父类中成员方法不重名，这时调用是没有影响的。对象在调用方法时，会现在子类寻找对应方法，若子类存在就执行子类中的方法，若子类不存在该方法就会执行父类中对应的方法。 如果子类父类中成员方法重名，这时访问会造成一种特殊情况，叫做方法重写。 重写(Override)：子类中出现与父类一模一样的方法时(返回值类型，方法名和参数列表都相同)，会出现覆盖效果，也称为覆盖或者覆写。声明不变，重新实现。 重写的应用子类可以根据需要，定义属于自己的行为。即沿袭了父类的功能名称，有根据子类需要重新实现父类方法，从而进行扩展。 &#x2F;&#x2F; 父类 public class Phone { public void call(){ System.out.println(&quot;打电话&quot;); } public void sendMessage(){ System.out.println(&quot;发短信&quot;); } public void showNum(){ System.out.println(&quot;来电显示号码&quot;); } } &#x2F;&#x2F; 子类继承父类，并重写父类方法，扩展自己功能 public class NewPhone extends Phone{ public void showNum(){ super.showNum(); System.out.println(&quot;来电显示姓名&quot;); System.out.println(&quot;来电显示头像&quot;); } } &#x2F;&#x2F; 实例类 public class Demo04Extends { public static void main(String[] args) { NewPhone ph = new NewPhone(); ph.call(); ph.sendMessage(); ph.showNum(); } } 方法覆盖重写的注意事项： 必须保证父子类之间方法的名称相同，参数列表也相同。@Override:写在方法前面,检测是否是有效的正确覆盖重写，可选 子类方法的返回值必须小于等于父类方法的返回值范围。扩展：java.lang.Object类是所有类的公共最高父类(祖宗类),String是Object的子类。 子类方法的权限必须大于等于父类方法的权限修饰符。扩展：public &gt; protected &gt; (default) &gt; private 注：(default)不是关键字default，而是什么都不写，留空。 1.4 继承关系中构造方法的访问特点 子类构造方法当中有一个默认隐含的”super()” 调用，所以一定是先调用父类构造，后执行的子类构造。 子类构造可以通过super关键字来调用父类重载构造 super的父类构造调用，必须是子类构造方法的第一个语句。子类构造不能调用多次super构造。小结：子类必须调用父类构造方法，不写则赠送super(); 写了则用写的super调用，super有且只能有一个，还必须是第一个。 1.5 super和this关键字用法小结super关键字三种用法： 在子类的成员方法中，访问父类的成员变量。super.父类成员变量; 在子类的成员方法中，访问父类的成员方法。super.父类成员方法(); 在子类的构造方法中，访问父类的构造方法。super();this关键字三种用法： 在本类的成员方法中，访问本类的成员变量。this.本类成员变量; 在本类的成员方法中，访问本类的另一个成员方法。this.本类成员方法(); 在本类的构造方法中，访问本类的另一个构造方法。this(…);注意：A. this(…) 调用也必须是构造方法的第一个语句，且唯一一个。B. super和this两种构造调用，不能同时使用。 public class Zi extends Fu{ int num = 20; public Zi(){ this(8); &#x2F;&#x2F; 本类的无参构造，调用本类的有参构造 } public Zi(int n){ } public void showNum(){ int num = 10; System.out.println(num); &#x2F;&#x2F; 局部变量 System.out.println(this.num); &#x2F;&#x2F; 本类成员变量 System.out.println(super.num); &#x2F;&#x2F; 父类成员变量 } public void methodA(){ System.out.println(&quot;AAA&quot;); } public void methodB(){ this.methodA(); &#x2F;&#x2F; 调用本类成员方法 System.out.println(&quot;BBB&quot;); } } super和this内存图 1.6 Java继承的三个特点 Java语言只支持单继承，一个类的直接父类只能有唯一个 Java支持多层继承(继承体系) 子类和父类是一种相对的概念 2. 抽象类父类中的方法，被它的子类覆盖重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。 抽象方法：没有方法体的方法。 抽象类：包含抽象方法的类。 2.1 abstract使用格式2.2 抽象方法 使用abstract关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。 定义格式：修饰符 abstract 返回值类型 方法名(参数列表); 代码示例：public abstract void run();2.3 抽象类 如果一个类包含抽象方法，那么该类必须是抽象类。 定义格式： abstract class 类名称{ ... } 代码示例： public abstract class Animal{ &#x2F;&#x2F; 抽象类 public abstract void run(); &#x2F;&#x2F; 抽象方法 } 2.4 抽象的使用 不能使用new来直接创建抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。覆盖重写(实现方法)：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使用。 &#x2F;&#x2F; 抽象类 public abstract class Animal { public abstract void eat(); &#x2F;&#x2F; 抽象方法 } &#x2F;&#x2F; 子类继承抽象类 public class Cat extends Animal{ @Override public void eat(){ &#x2F;&#x2F; 重写抽象方法，并补上大括号和具体实现 System.out.println(&quot;猫吃鱼&quot;); } } &#x2F;&#x2F; 实例 public class DemoMain { public static void main(String[] args) { Cat cat = new Cat(); &#x2F;&#x2F; 创建子类对象 cat.eat(); &#x2F;&#x2F; 调用方法 } } 2.5 注意事项关于抽象类的使用，注意事项总结： 抽象类不能创建对象。只能创建其非抽象子类的对象。原因：抽象类的抽象方法没有具体方法体，没有意义 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。因为子类的构造方法中，有默认的super(); 会调用父类构造方法。 抽象类中，不一定包含抽象方法，但有抽象方法的类必定是抽象类。未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写父类中所有的抽象方法，否则会报错。除非该子类也是抽象类。 3. 继承的综合案例群主发普通红包。某群有多名成员，群主发红包。规则： 群主有一笔金额，从群主余额扣除，平均分为n份，让成员领取。 成员领取红包后，保存到成员余额中。根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。 分析案例根据描述分析，得出如下继承体系：代码实现： &#x2F;&#x2F; 定义父类Users public class Users { private String name; private double money; public Users() { } public Users(String name, double money) { this.name = name; this.money = money; } public void show(){ System.out.println(&quot;我叫&quot;+name+&quot;，我有&quot;+money+&quot;块钱&quot;); } ... ...省略get&#x2F;set方法 } &#x2F;&#x2F; 定义群主类 &#x2F;&#x2F; 群主类 public class Manager extends Users{ public Manager(){ &#x2F;&#x2F; 无参构造方法 } public Manager(String name, double money) { &#x2F;&#x2F; 全参构造方法 super(name, money); &#x2F;&#x2F; 调用了父类的构造方法，并初始化值 } &#x2F;&#x2F; 定义群主发红包方法，参数为发红包金额和份数 public ArrayList&lt;Double&gt; send(double totalMoney, int count){ &#x2F;&#x2F; 首先需要一个集合，用来存储若干个红包的金额 ArrayList&lt;Double&gt; redList = new ArrayList&lt;&gt;(); &#x2F;&#x2F;首先看一下群主有多少钱 double leftMoney = super.getMoney(); &#x2F;&#x2F; 群主当前余额 if(totalMoney &gt; leftMoney){ System.out.println(&quot;余额不足&quot;); return redList; &#x2F;&#x2F; 返回空集合 } &#x2F;&#x2F;扣钱，其实就是重置余额 super.setMoney(leftMoney - totalMoney); &#x2F;&#x2F;发红包需平均拆分为count份 double avg = (int)totalMoney &#x2F; count; &#x2F;&#x2F; int化后丢失精度,如何把零头单独拿出来？ double mod = totalMoney - avg * count;&#x2F;&#x2F;余数，也就是甩下的零头 &#x2F;&#x2F; 除不来的零头，包在最后一个红包里 &#x2F;&#x2F; 下面把红包一个一个放到集合中 for (int i = 0; i &lt; count - 1; i++) { redList.add(avg); } double last = avg + mod; &#x2F;&#x2F;最后一个红包 redList.add(last); return redList; &#x2F;&#x2F; 返回的是一个红包数组集合 } } &#x2F;&#x2F;定义群员类 &#x2F;&#x2F; 成员类 public class Member extends Users{ public Member(){ } public Member(String name, double money) { super(name, money); } public void receive(ArrayList&lt;Double&gt; list){ &#x2F;&#x2F; 从多个红包当中随机抽取一个，给我自己。 &#x2F;&#x2F; 随机获取一个集和当中的索引编号 int index = new Random().nextInt(list.size()); &#x2F;&#x2F; 根据索引，从集合中删除，并且得到被删除的红包值，给自己钱 double delta = list.remove(index); &#x2F;&#x2F; 成员查看一下自己的余额 double money = super.getMoney(); &#x2F;&#x2F; 将得到的红包金额加入自己的余额 super.setMoney(delta + money); } } &#x2F;&#x2F; 定义主方法实例 public class MainRedPacket { public static void main(String[] args) { Manager manager = new Manager(&quot;群主&quot;,100.765); Member one = new Member(&quot;成员A&quot;,0); Member two = new Member(&quot;成员B&quot;,0); Member three = new Member(&quot;成员C&quot;,0); manager.show(); one.show(); two.show(); three.show(); System.out.println(&quot;===================&quot;); ArrayList&lt;Double&gt; redList = manager.send(55.687,3); one.receive(redList); two.receive(redList); three.receive(redList); manager.show(); one.show(); two.show(); three.show(); } } 总结 Java继承的概念，特点 extends关键字的使用 继承后成员变量成员方法构造方法的访问特点 方法的覆盖重写 super和this关键字的使用 抽象类，抽象方法的概念 abstract关键字的使用 综合案例练习","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"三大特性","slug":"三大特性","permalink":"https://zero024.cn/tags/三大特性/"}]},{"title":"Java中的常用工具类","slug":"JavaBasics/Java中的常用类","date":"2019-04-19T15:00:00.000Z","updated":"2020-03-08T00:49:25.696Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. String类概述java.lang.String 类代表字符串。Java程序中所有的字符串文字都可以被看作是实现此类的实例。类String中包括用于检查各个字符串的方法，比如用于比较字符串、搜索字符串、提取子字符串以及创建具有翻译为大写或者小写的所有字符的字符串副本。","text":"1. String类概述java.lang.String 类代表字符串。Java程序中所有的字符串文字都可以被看作是实现此类的实例。类String中包括用于检查各个字符串的方法，比如用于比较字符串、搜索字符串、提取子字符串以及创建具有翻译为大写或者小写的所有字符的字符串副本。 1.1 字符串的特点 字符串的内容永不可变。 因为不可变，所以字符串是可以共享的 字符串效果上相当于是char[]字符数组，但底层原理是byte[]字节数组。 1.2 创建字符串的常见3+1种方式三种构造方法 public String(): 创建一个空白字符串，不含有任何内容。 public String(char[] array)：根据字符数组的内容，来创建对应的字符串。 public String(byte[] array): 根据字节数组的内容，来创建对应的字符串。一种直接创建：String str = &quot;Hello&quot;; public class Demo02StringTwo { public static void main(String[] args) { String str1 = &quot;abc&quot;; String str2 = &quot;abc&quot;; char[] charArray = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}; String str3 = new String(charArray); } } 1.3 常用方法判断功能的方法 public boolean equals(Object Obj):参数可以是任何对象，只有参数是一个字符串且内容相同时返回true，反之false。 public class Demo03StringEquals { public static void main(String[] args) { String str1 = &quot;Hello&quot;; String str2 = &quot;Hello&quot;; char[] charArray = {&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;}; String str3 = new String(charArray); System.out.println(str1.equals(str2)); System.out.println(str2.equals(str3)); System.out.println(str3.equals(&quot;Hello&quot;)); System.out.println(&quot;Hello&quot;.equals(str3)); String str4 = null; System.out.println(&quot;abc&quot;.equals(str4)); &#x2F;&#x2F; false 推荐写法 System.out.println(str4.equals(&quot;abc&quot;)); &#x2F;&#x2F; 报错，NullPointerException } } 注意事项： 1. 任何对象都能用Object进行接收。 2. equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果是一样的。 3. 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。&lt;br&gt;推荐：&quot;abc&quot;.equals(str),不推荐:str.equals(&quot;abc&quot;)。 public boolean equalsIgnoreCase(String anotherString):将此字符串与指定对象进行比较，忽略大小写。 String当中与获取相关的常用方法 public int lenght(); 获取字符串当中含有的字符个数，拿到字符串长度。 public String concat(String str); 将指定的字符串连接到该字符串的末尾。 public char charAt(int index); 获取指定索引位置的单个字符。 public int indexOf(String str); 查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。 举例代码如下： public class Demo04StringGet { public static void main(String[] args) { int length = &quot;abcdefghijklmnobqrstuvwxyz&quot;.length(); System.out.println(&quot;字符串长度为：&quot; + length); &#x2F;&#x2F;拼接字符串 String str1 = &quot;Hello&quot;; String str2 = &quot;World&quot;; String str3 = str1.concat(str2); System.out.println(str1); &#x2F;&#x2F; Hello System.out.println(str2); &#x2F;&#x2F; World System.out.println(str3); &#x2F;&#x2F; HelloWorld System.out.println(&quot;Hello&quot;.charAt(0)); &#x2F;&#x2F; H String str4 = str3; System.out.println(str4.indexOf(&quot;llo&quot;)); &#x2F;&#x2F;返回索引位置，即2 } } public String substring(int index):截取从参数位置一直到字符串末尾，返回新字符串 public String substring(int begin,int end):截取从begin开始，一直到end结束，中间的字符串。[begin,end)，包含左边，不包含右边。 举例代码如下： public class Demo05SubString { public static void main(String[] args) { String str1 = &quot;HelloWorld&quot;; System.out.println(str1.substring(5)); &#x2F;&#x2F; 返回World System.out.println(str1.substring(4,7)); &#x2F;&#x2F; owo , 4~6不含7 } } String当中与转换相关的常用方法 public char[] toCharArray(); 将当前字符串拆分成为字符数组作为返回值。 public byte[] getBytes(); 获取当前字符串底层的字节数组。 public String replace(CharSequence oldString, CharSequence newString);将所有出现的老字符串替换为新的字符串，返回替换后的结果新字符串。 例子： public class Demo06StringConvert { public static void main(String[] args) { char[] chars = &quot;Hello&quot;.toCharArray(); System.out.println(chars); &#x2F;&#x2F; Hello System.out.println(chars[0]); &#x2F;&#x2F; H System.out.println(chars.length); &#x2F;&#x2F; 5 System.out.println(&quot;=========================&quot;); String str = &quot;abc&quot;; byte[] bytes = str.getBytes(); System.out.println(bytes); &#x2F;&#x2F;指向内存地址中abc对应的byte值 System.out.println(bytes[0]); &#x2F;&#x2F; [0] = 97,[1] = 98,[2] = 99 String str2 = &quot;你怎么回事小老弟，会不会玩啊，fuck&quot;; System.out.println(str2.replace(&quot;fuck&quot;,&quot;儒雅随和&quot;)); } } Tips：CharSequence意思是说可以接受字符串类型。是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中。 String中分割字符串的方法public String[] split(String regex); 按照参数的规则，将字符串切分为若干部分。 public class Demo07StringSplit { public static void main(String[] args) { String str1 = &quot;a,b,c&quot;; String[] array1 = str1.split(&quot;,&quot;); for(int i = 0;i&lt;array1.length;i++){ System.out.println(array1[i]); } String str2 = &quot;a b c&quot;; String[] array2 = str2.split(&quot; &quot;); for(int i=0;i&lt;array2.length;i++){ System.out.println(array2[i]); } String str3 = &quot;XXX.YYY.ZZZ&quot;; String[] array3 = str3.split(&quot;\\\\.&quot;); &#x2F;&#x2F;注意转义 for (int i=0;i&lt;array3.length;i++){ System.out.print(array3[i]); } } } 小练习拼接字符串练习，输入数组{1,2,3}，返回[1#2#3]。 public class Demo08StringExercise { public static void main(String[] args) { int[] arr = {1,2,3,4}; System.out.println(arrayToString(arr)); } public static String arrayToString(int[] arr){ String str = &quot;[&quot;; for (int i=0;i&lt;arr.length;i++){ if(i != arr.length-1){ str += (arr[i]+&quot;#&quot;); }else{ str += (arr[i]+&quot;]&quot;); } } return str; } } 统计字符个数：键盘录入一个字符，统计字符串中大小写字母及数字字符个数 import java.util.Scanner; &#x2F;* 键盘输入一个字符串，统计其中各种字符出现次数，返回次数。 字符种类：大写字母，小写字母，数字，其他 *&#x2F; public class Demo09StringExercise02 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入字符串：&quot;); String input = sc.next(); &#x2F;&#x2F; 获取键盘输入的字符串 System.out.println(stringCount(input)); } public static String stringCount(String input){ int countUpper = 0; int countLower = 0; int countNumber = 0; int countOther = 0; char[] chars = input.toCharArray(); for(int i = 0;i &lt; chars.length;i++){ char ch = chars[i]; &#x2F;&#x2F; 单个字符，底层表示为byte[]数值 if(ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;){ countUpper++; }else if (ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;){ countLower++; }else if (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;){ countNumber++; }else{ countOther++; } } return &quot;大写字母：&quot;+countUpper+&quot;\\n小写字母：&quot;+countLower+&quot;\\n数字:&quot;+countNumber+&quot;\\n其他类型：&quot;+countOther; } } 2. static关键字2.1 概述关于static关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就不可以靠创建对象来调用了。 2.2定义和使用格式当static修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类对象的情况下对类变量进行操作。 类变量 类变量：使用static关键字修饰的成员变量。格式：static 数据类型 变量名。 实例： &#x2F;&#x2F;定义学生类 public class Student { private int sid; &#x2F;&#x2F;学号 private String name; private int age; static String room; public static int idCount = 0; &#x2F;&#x2F;自动分配学号 public Student() { this.sid = ++idCount; } public Student(String name, int age) { this.name = name; this.age = age; this.sid = ++idCount; } ......省略get&#x2F;set方法 } &#x2F;&#x2F;实例使用 public class Demo10Class { public static void main(String[] args) { Student stu = new Student(&quot;法师&quot;,11); stu.room = &quot;101号教室&quot;; System.out.println(&quot;姓名：&quot;+stu.getName()+&quot;,年龄:&quot;+stu.getAge()+&quot;岁,教室：&quot;+stu.getRoom()+&quot;,学号：&quot;+stu.getSid()); Student stu2 = new Student(&quot;盗贼&quot;,15); System.out.println(&quot;姓名：&quot;+stu2.getName()+&quot;,年龄:&quot;+stu2.getAge()+&quot;岁,教室：&quot;+stu2.getRoom()+&quot;,学号：&quot;+stu2.getSid()); } } 静态方法当static修饰成员方法时，该方法称为类方法。静态方法在声明中有static，建议使用类名来调用，而不需要创建类的对象。 类方法：使用static关键字修饰的成员方法，一般称为静态方法。格式如下： 实例： &#x2F;&#x2F;MyClass public class MyClass { int num; &#x2F;&#x2F; 成员变量 static int numStatic; &#x2F;&#x2F;静态变量 public void method(){ System.out.println(&quot;这是一个成员方法！&quot;); System.out.println(num); &#x2F;&#x2F;成员方法可以访问成员变量 System.out.println(numStatic); &#x2F;&#x2F; 成员方法可以访问静态变量 } public static void methodStatic(){ System.out.print(&quot;这是一个静态方法！&quot;); System.out.println(numStatic); &#x2F;&#x2F;静态方法可以访问静态变量 &#x2F;&#x2F;System.out.println(num); &#x2F;&#x2F;静态方法无法访问成员变量 } } &#x2F;&#x2F;实例类 public class Demo01StaticMethod { public static void main(String[] args) { MyClass obj = new MyClass(); &#x2F;&#x2F; 首先创建对象 obj.method(); &#x2F;&#x2F; 才能使用没有static关键字的内容 &#x2F;&#x2F;对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。 obj.methodStatic(); &#x2F;&#x2F; 不推荐写法，编译器编译时会自动优化为下面方法。 MyClass.methodStatic(); &#x2F;&#x2F; 推荐写法，类名称.静态方法。 &#x2F;&#x2F; 对于本类当中的静态方法，可以省略名称 myMethod(); Demo01StaticMethod.myMethod(); &#x2F;&#x2F; 完全等效于上面 } public static void myMethod(){ System.out.println(&quot;自己的方法!&quot;); } } 静态方法调用总结： 静态方法可以直接访问类变量和静态方法。 静态方法不能直接访问普通成员变量或成员方法。原因：因为在内存中是[先]有的静态内容，[后]有的非静态内容,”前人不知后事，后人尽知前史”。 静态方法中，不能使用this关键字。 无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。静态变量：类名称.静态变量；静态方法：类名称.静态方法(); 2.3 静态原理图解static修饰的内容： 是随着类的加载而加载的，且只加载一次。 存储于一块固定的内存区域(静态区),所以，可以直接被类名调用。 它优先于对象存在，所以，可以被所有对象共享。 静态代码块 静态代码块：定义在成员位置，使用static修饰的代码块{}。 位置：类中方法外。 执行：随着类的加载而执行且只执行一次，优先于main方法和构造方法的执行。 格式： 作用：用来一次性地对静态成员变量进行赋值。 3. Arrays类java.util.Arrays此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 3.1 操作数组的方法 public static String toString(int[] a): 返回指定数组内容的字符串表示形式。 public static void sort(int[] a): 对指定的int型数组按数字升序进行排序。 举例： import java.util.Arrays; public class Demo03Arrays { public static void main(String[] args) { int[] arr = {1,3,54,86,37,28}; System.out.println(arr); &#x2F;&#x2F; 打印数组内存地址 String str = Arrays.toString(arr); &#x2F;&#x2F;将指定数组内容变成字符串返回。 System.out.println(str); int[] arr2 = {2,5,3,8,4,9,1}; Arrays.sort(arr2); &#x2F;&#x2F; 升序排序 System.out.println(Arrays.toString(arr2)); &#x2F;&#x2F; [1, 2, 3, 4, 5, 8, 9] } } 小练习对一个随机字符串进行升序排序，然后倒序输出 import java.util.Arrays; public class Demo04ArraysExercise { public static void main(String[] args) { String str = &quot;ehiaroaklcmbzhywqiem&quot;; char[] chars = str.toCharArray(); Arrays.sort(chars); &#x2F;&#x2F; 对字符串进行升序排序 System.out.println(chars); for (int i = chars.length - 1; i &gt;= 0; i--) { &#x2F;&#x2F;快捷键:[chars.forr] , 对chars对象进行倒序遍历; [fori],正序遍历 System.out.print(chars[i]); } } } 4. Math类java.lang.Math类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，里面提供了大量的静态方法，完成与数学运算的操作。 4.1 基本运算的方法 public static double abs(double num): 返回绝对值。 public static double ceil(double num): 向上取整。 public static double floor(double num): 向下取整。 public static double round(double num): 四舍五入。 实例： public class Demo05Math { public static void main(String[] args) { System.out.println(&quot;以下示例abs用法&quot;); System.out.println(Math.abs(3.14)); &#x2F;&#x2F; 3.14 System.out.println(Math.abs(-2.5)); &#x2F;&#x2F; 2.5 System.out.println(Math.abs(0)); &#x2F;&#x2F; 0 System.out.println(&quot;以下示例ceil用法&quot;); System.out.println(Math.ceil(3.9)); &#x2F;&#x2F; 4.0 System.out.println(Math.ceil(3.1)); &#x2F;&#x2F; 4.0 System.out.println(Math.ceil(3.0)); &#x2F;&#x2F; 3.0 System.out.println(&quot;以下示例floor用法&quot;); System.out.println(Math.floor(30.9)); &#x2F;&#x2F; 30.0 System.out.println(Math.floor(30.1)); &#x2F;&#x2F; 30.0 System.out.println(Math.floor(31.0)); &#x2F;&#x2F; 31.0 System.out.println(&quot;以下示例round用法&quot;); System.out.println(Math.round(20.4)); &#x2F;&#x2F;20 System.out.println(Math.round(20.5)); &#x2F;&#x2F;21 System.out.println(&quot;圆周率：&quot; + Math.PI); } } 小练习请使用 Math 相关的API，计算在 -10.8 到 5.9 之间，绝对值大于 6 或者小于 2.1 的整数有多少个？ public class Demo06mathExercise { public static void main(String[] args) { double min = -10.8; double max = 5.9; int num = 0; for (int i = (int)min; i &lt; max; i++) { int abs = Math.abs(i); &#x2F;&#x2F; 绝对值化 if(abs &gt; 6 || abs &lt;2.1){ num++; } } System.out.println(num); } } 总结字符串类及常用方法API public String(): 创建一个空白字符串，不含有任何内容。 public String(char[] array)：根据字符数组的内容，来创建对应的字符串。 public String(byte[] array): 根据字节数组的内容，来创建对应的字符串 public boolean equals(Object Obj):参数可以是任何对象，只有参数是一个字符串且内容相同时返回true，反之false。 public boolean equalsIgnoreCase(String anotherString):将此字符串与指定对象进行比较，忽略大小写。 public int lenght(); 获取字符串当中含有的字符个数，拿到字符串长度。 public String concat(String str); 将指定的字符串连接到该字符串的末尾。 public char charAt(int index); 获取指定索引位置的单个字符。 public int indexOf(String str); 查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。 public String substring(int index):截取从参数位置一直到字符串末尾，返回新字符串。 public String substring(int begin,int end):截取从begin开始，一直到end结束，中间的字符串。[begin,end)，包含左边，不包含右边。 public char[] toCharArray(); 将当前字符串拆分成为字符数组作为返回值。 public byte[] getBytes(); 获取当前字符串底层的字节数组。 public String replace(CharSequence oldString, CharSequence newString);将所有出现的老字符串替换为新的字符串，返回替换后的结果新字符串。 public String[] split(String regex); 按照参数的规则，将字符串切分为若干部分。 static关键字及常用方法 类变量：使用static关键字修饰的成员变量。格式：static 数据类型 变量名； 类方法：使用static关键字修饰的成员方法，一般称为静态方法。 Arrays类操作数组的常用方法 public static String toString(int[] a): 返回指定数组内容的字符串表示形式。 public static void sort(int[] a): 对指定的int型数组按数字升序进行排序。 Math类常用方法 public static double abs(double num): 返回绝对值。 public static double ceil(double num): 向上取整。 public static double floor(double num): 向下取整。 public static double round(double num): 四舍五入。","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"API概述","slug":"JavaBasics/API概述","date":"2019-04-18T14:00:00.000Z","updated":"2020-03-08T00:49:40.760Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. 概述API(Application Programming Interface)，应用程序编程接口。Java API是一本API字典，是JDK中提供给我们使用类的说明文档。这些类将底层的代码实现封装了起来，我们不用关心类是如何实现的，只需学习这些类如何使用即可。","text":"1. 概述API(Application Programming Interface)，应用程序编程接口。Java API是一本API字典，是JDK中提供给我们使用类的说明文档。这些类将底层的代码实现封装了起来，我们不用关心类是如何实现的，只需学习这些类如何使用即可。 API使用步骤 打开帮助文档。 点击显示，找到索引，看到输入框。 输入你要查询的类名。 看包。java.lang下的类不需要导包，其他都要import 看类的解释和说明。 学习构造方法。 使用成员方法。 2. Scanner类2.1 什么是Scanner类？一个可以解析基本类型和字符串的简单文本扫描器。如下代码能够使用户从System.in中获取数据：System.in系统输入指的是通过键盘录入数据。 2.2 引用类型使用步骤导包使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。格式：import 包名.类名; 创建对象使用该类的构造方法，创建一个该类的对象。格式：数据类型 变量名 = new 数据类型(参数列表); 调用方法调用该类的成员方法，完成指定功能。格式：变量名.方法名(); 2.3 Scanner使用步骤 java.util.Scanner:该类需要import导入后使用。 public Scanner(InputStream source):构造一个新的Scanner，它生成的值是从指定的输入流扫描的。 public int nextInt():将输入信息的下一个标记扫描为一个int值。 举例： import java.util.Scanner; public class Demo03ScannerMax { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int Max = 0; for(int i = 1;i &lt; 4;i++){ System.out.println(&quot;请输入第&quot; + i + &quot;个数字：&quot;); int temp = sc.nextInt(); if(temp &gt; Max){ Max = temp; } } System.out.println(&quot;最大数是：&quot; + Max); } } 2.4 匿名对象匿名对象就是创建对象时，只有创建对象的语句，却没有把对象地址赋值给某个变量。没有变量名的对象就是匿名对象。 格式：new 类名(参数列表);应用场景 创建匿名对象直接调用方法，没有变量名。举例：new Scanner(System.in).nextInt(); 一旦调用两次方法，就是创建了两个对象，语句执行完毕即对象销毁。 匿名对象可以作为方法的参数和返回值。作为参数： class Test { public static void main(String[] args) { &#x2F;&#x2F; 普通方式 Scanner sc = new Scanner(System.in); input(sc); &#x2F;&#x2F;匿名对象作为方法接收的参数 input(new Scanner(System.in)); } public static void input(Scanner sc){ System.out.println(sc); } } 作为返回值： public static Scanner getScanner(){ return new Scanner(System.in); } 3. Random类3.1 什么是Random类此类的实例用于生产伪随机数。如下代码使用户能够得到一个随机数： 3.2 Random使用三步骤 导包：import java.util.Random; 创建:Random r = new Random(); 使用:获取一个随机的int数字(范围是int所有范围，有正负两种),int num = r.nextInt(); 举例如下： public class Demo05Random { public static void main(String[] args) { int a = 0; while(a &lt; 100){ System.out.println(&quot;随机数是：&quot; + new Random().nextInt()); a++; } } } 获取一个随机的int数字(参数代表了范围，左闭右开区间):int num = r.nextInt(3)实际含义是：[0,3),也就是0~2。 猜数字小游戏 import java.util.Random; import java.util.Scanner; public class Demo06guessNumber { public static void main(String[] args) { int number = new Random().nextInt(100) + 1; int count = 0; while (true){ System.out.println(&quot;请输入你要猜的数字(1-100)：&quot;); int guessNumber = new Scanner(System.in).nextInt(); if(guessNumber &gt; number){ System.out.println(&quot;You enter number is big , again! &quot;); }else if(guessNumber &lt; number){ System.out.println(&quot;You enter number is small , again!&quot;); }else{ System.out.println(&quot;Bin1go！你使用了&quot; + count + &quot;次。&quot;); break; } count++; } } } 3. ArrayList类3.1 什么是ArrayList类？java.util.ArrayList是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。Array中可不断添加元素，其大小也自动增长。 3.2 ArrayList使用步骤 java.util.ArrayList:该类需要import导入后使用。,表示一种指定的数据类型，叫做泛型。E，取自Element(元素)的首字母。在出现E的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素。 基本格式：ArrayList list = new ArrayList();JDK7以后，右边泛型的尖括号可以留空，但&lt;&gt;仍要写。ArrayList list = new ArrayList&lt;&gt;();3.3 常用方法和遍历对于元素的操作，基本体现在增、删、查。常用方法如下： public boolean add(E e);向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。 public E get(int index);从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。 public E remove(int index);从集合中删除元素，参数是索引，返回值就是被删除的元素。 public int size();获取集合的尺寸长度，返回值是集合中包含的元素个数。 3.4 存储基本数据类型ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似不能写，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据，&lt;&gt;中的数据类型，必须转换后才能编写。转换写法如下：可以发现，只有Integer和Character需要特殊记忆，其他基本类型只是首字母大写即可。那么存储基本类型数据，代码如下： 自定义格式打印集合内容 import java.util.ArrayList; public class DemoPrintArrayList { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;盗贼&quot;); list.add(&quot;法师&quot;); list.add(&quot;术士&quot;); list.add(&quot;战士&quot;); print(list); } public static void print(ArrayList&lt;String&gt; list){ System.out.print(&quot;{&quot;); for (int i = 0;i &lt; list.size();i++){ if (i != list.size()-1){ System.out.print(list.get(i)+ &quot;@&quot;); }else { System.out.print( list.get(i)+ &quot;}&quot;); } } } } 定义获取偶数元素集合方法 import java.util.ArrayList; import java.util.Random; &#x2F;* 定义获取所有偶数元素集合的方法(ArrayList类型作为返回值) *&#x2F; public class DemoGetEvenNumber { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0;i &lt; 20;i++){ list.add(new Random().nextInt(1000)+1); } System.out.println(list); System.out.print(getEvenNumber(list)); } public static ArrayList&lt;Integer&gt; getEvenNumber(ArrayList&lt;Integer&gt; list){ ArrayList&lt;Integer&gt; Even = new ArrayList&lt;&gt;(); for(int i = 0;i &lt; list.size();i++){ if(list.get(i) %2 == 0){ Even.add(list.get(i)); } } return Even; } }","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Java类和对象","slug":"JavaBasics/Java类和对象","date":"2019-04-17T09:45:00.000Z","updated":"2020-03-08T00:49:32.246Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"1. 面向对象思想1.1 面向对象思想概述Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计，开发计算机程序。这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。","text":"1. 面向对象思想1.1 面向对象思想概述Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计，开发计算机程序。这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。 举例 洗衣服： 面向过程：把衣服脱下来–&gt;找一个盆–&gt;放点洗衣粉–&gt;加点水–&gt;浸泡10分钟–&gt;揉一揉–&gt;清洗衣服–&gt;拧干–&gt;晾起来 面向对象：把衣服脱下来–&gt;打开全自动洗衣机–&gt;放衣服–&gt;开启洗衣机–&gt;晾起来 区别： 面向过程：强调步骤 面向对象：强调对象，这里对象指洗衣机特点面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。面向对象的语言中，包含了三大基本特征，即封装、继承和多态。 1.2 类和对象什么是类？ 类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。 属性：就是该类事物的状态信息 行为：就是该类事物能够做什么事 举例：小猫。属性：名字，颜色，年龄，体重。行为：走，跳，叫，吃。什么是对象？ 对象：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为。 现实中，一类事物(猫类)的一个实例:一只小猫。 举例：一只小猫。属性：tom，5kg，2years，yellow。行为：反复横跳，喵喵叫，吃饭。类和对象的关系 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的，实际存在的。 类是对象的模板，对象是类的实体。 1.3 类的定义事物与类的对比现实世界的一类事物： 属性：事物的状态信息。 行为：事物能够做什么。Java中用class描述事物也是如此： 成员变量：对应事物的属性。 成员方法：对应事物的行为。类的定义格式 定义类：就是定义类的成员，包括成员变量和成员方法。 成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。 成员方法：和以前定义方法几乎一样的。只不过把static去掉。举例： public class Student { &#x2F;&#x2F;成员变量; String name; &#x2F;&#x2F; 姓名 int age; &#x2F;&#x2F;年龄 &#x2F;&#x2F;成员方法 public void eat(){ System.out.println(&quot;吃饭饭&quot;); } public void sleep(){ System.out.println(&quot;睡觉觉&quot;); } public void study() { System.out.println(&quot;学习&quot;); } } 1.4 对象的使用对象的使用格式 使用步骤1，导包：也就是指出需要使用的类，在什么位置，同一包下可省略导包步骤。import 包名称.类名称;import com.zero.demo.demo03_Class.Student; 步骤2，创建对象：类名 对象名 = new 类名(); 步骤3，使用对象访问类中成员: 举例： public class Demo03Student { public static void main(String[] args){ Student stu = new Student(); System.out.println(stu.name = &quot;校长&quot;); System.out.println(stu.age = 55); stu.eat(); stu.sleep(); stu.study(); } } 注意：如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样。 成员变量的默认值 1.5 对象内存图一个对象，调用一个方法内存图：两个对象，调用一个方法内存图：两个引用指向同一个对象的内存图：使用对象类型作为方法的参数： 1.6 成员变量和局部变量的区别变量根据定义位置的不同，变量有不同的名字 在类中的位置不同重点 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形参) 作用范围不一样重点 成员变量：类中 局部变量：方法中 初始化值的不同重点 成员变量：有默认值 局部变量：无默认值。必须先定义，赋值，才能使用。 在内存中的位置不同(了解) 成员变量：堆内存 局部变量：栈内存 生命周期不同(了解) 成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失 局部变量：随着方法进栈而诞生，随着方法出栈而消失2. 三大特征之一：封装2.1 封装概述面向对象编程语言是对象客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。原则将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。2.2 封装的步骤 使用private关键字来修饰成员变量。 对需要访问的成员变量，提供对应的一对getxxx方法、setxxx方法。 2.3 封装的操作–private关键字private的含义 private是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被private修饰后的成员变量和成员方法，只能在本类中才能访问。private的使用格式 举例： public class Student { private String name; &#x2F;&#x2F; 使用private修饰成员变量 private int age; } &#x2F;&#x2F; 定义getxxx方法和setxxx方法，提供对外接口 public class Student { private String name; private int age; public void setName(String n) { name = n; } public String getName() { return name; } public void setAge(int a) { age = a; } public int getAge() { return age; } } 2.4 封装优化–this关键字如果方法形参和成员变量名一致，会导致成员变量赋值失败。 这是由于形参变量名与成员变量名重名，导致成员变量名被隐藏，方法中的变量名，无法访问到成员变量，从而赋值失败。我们需使用this关键字，来解决这个重名问题。 this的含义this代表所在类的当前对象的引用(地址值)，即对象自己的引用。 使用格式：this.成员变量名; 举例: 2.5 封装优化–构造方法当一个对象被创建时，构造方法用来初始化该对象，给对象的成员变量赋初始值。 构造方法的定义格式构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，也不需要void。举例如下： public class Student { private String name; private int age; &#x2F;&#x2F; 无参数构造方法 public Student() {} &#x2F;&#x2F; 有参数构造方法 public Student(String name,int age) { this.name = name; this.age = age; } } 注意事项： 构造方法的名称必须和所在的类名称完全一模一样。 构造方法不要写返回值类型，连void都不写。 构造方法不能return一个具体的返回值。 如果没有编写任何构造方法，那么编译器会默认生成一个，没有参数，方法体也为空。public Student(){}； 一般编写了至少一个构造方法，那么编译器将不再生成。 2.6 标准代码–JavaBeanJavaBean是Java语言编写类的一种标志规范。符合JavaBean的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的set和get方法。所以一个标准类通常要拥有下面四个组成部分： 所有的成员变量都要使用private关键字修饰。 为每个成员变量编写一对getxxx/setxxx方法。 编写一个无参数的构造方法。 编写一个全参数的构造方法。 public class ClassName{ &#x2F;&#x2F;成员变量 &#x2F;&#x2F;构造方法 &#x2F;&#x2F;无参构造方法【必须】 &#x2F;&#x2F;有参构造方法【建议】 &#x2F;&#x2F;成员方法 &#x2F;&#x2F;getXxx() &#x2F;&#x2F;setXxx() } 编写符合JavaBean规范的类，以学生类为例，标准代码如下： public class JavaBeanStudent { private String name; private int age; public JavaBeanStudent() { } public JavaBeanStudent(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 以上代码可以通过Code-&gt;Generate功能自动生成：","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Java数组","slug":"JavaBasics/Java数组","date":"2019-04-16T08:00:00.000Z","updated":"2020-03-08T00:49:28.876Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"数组概念 数组的基本概念：数组就是存储数据长度固定的容器，包装多个数据的数据类型要一致。 容器：是将多个数据存储在一起，每个数据称为该容器的元素。 数组的特点： 数组是一种引用数据类型。 数组当中的多个数据，类型必须统一。 数组的长度在程序运行期间不可改变。","text":"数组概念 数组的基本概念：数组就是存储数据长度固定的容器，包装多个数据的数据类型要一致。 容器：是将多个数据存储在一起，每个数据称为该容器的元素。 数组的特点： 数组是一种引用数据类型。 数组当中的多个数据，类型必须统一。 数组的长度在程序运行期间不可改变。 1. 数组的定义和访问1.1 数组的定义 数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。 两种常见的初始化方式： 动态初始化（指定长度） 静态初始化（指定内容） 动态初始化格式： 数组定义格式详解： 数组存储的数据类型：创建的数组容器可以存储什么数据类型。 []:表示数组。 数组的名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。 new：关键字，创建数组使用的关键字。 数组存储的数据类型：创建的数组容器可以存储什么数据类型。 [长度]：数组的长度，表示数组容器中可以存储多少个元素。 注意：数组有定长特性，长度一旦指定，不可更改。类似你买一个水杯，买了一个1升的水杯，总容量就是1升，不多不少。 举例：定义可以存储3个整数的数组容器，代码如下： int[] arr = new int[3]; 静态初始化标准格式： 举例：定义存储1,2,3,4,5整数的数组容器。 int[] arr = new int[]{1,2,3,4,5}; 静态初始化省略格式： 举例：定义存储1,2，3整数的数组容器： int[] arr = {1,2,3}; 注意： 静态初始化没有直接指定长度，但仍然会自动推算得到长度。 静态初始化标准格式可以拆分为两个步骤。 动态初始化也可以拆分成为两个步骤。 静态初始化一旦使用省略格式，就不能拆分成为两个步骤了。 不确定数组当中具体内容，使用动态初始化；确认了具体内容，用静态初始化。 &#x2F;&#x2F;静态初始化的标准格式拆分： int[] arrayA; arrayA = new int[]{1,2,3}; &#x2F;&#x2F;动态初始化的拆分步骤： int[] arrayB; arrayB = new intp[3]; 1.2 数组的访问 索引：每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引(index),可以通过数组的索引访问到数组中的元素。 格式：数组名[索引] 数组长度属性：每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度，语句为：数据名.length。属性length的执行结果是数组的长度，int类型结果。由此可以推断出，数组的最大索引值为数组名.length-1。 public class Demo02ArrayUse { public static void main(String[] agrs){ int[] arr = new int[]{1,2,3,4,5}; System.out.println(arr.length); System.out.println(arr[arr.length-1]); } } 索引访问数组中的元素： 数组名[索引]=数组，为数组中的元素赋值 变量=数组名[索引]，获取数组中的元素 2. 数组原理内存图2.1 内存概述内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 2.1 Java虚拟机的内存划分为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 JVM的内存划分： Java内存需划分为5个部分： ==栈(Stack)==：存放的都是方法中的局部变量。方法运行时使用的内存。 局部变量：方法的参数，或者是方法{}内部的变量 作用域：一旦超出作用域，立刻从栈内存当中消失。 ==堆(Heap)==：凡是new出来的东西，都在堆当中。存储对象或数组。 堆内存里面的东西都有一个地址值：16进制 堆内存里面的数据，都有默认值。规则： ==方法区(Method Area)==：存储.class相关信息，包含方法的信息。 本地方法栈(Native Method Stack)：与操作系统相关。 寄存器(pc Register)：与CPU相关。 2.2 数据在内存中的存储 public class Demo02ArrayOne { public static void main(String[] args){ int[] arr = new int[3]; System.out.println(arr); &#x2F;&#x2F; [I@5f184fc6 } } 以上方法执行，输出结果是[I@5f184fc6。这个是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的内存地址。一个数组内存图：两个数组内存图： 3. 数组的常见操作3.1 数组越界异常 public static void main(String[] args){ int[] arr = {1,2,3}; System.out.print(arr[3]); } 创建数组，赋值3个元素，数组索引就是0,1,2,没有索引3。如果我们访问了数组中不存在的索引，程序运行后就会抛出ArrayIndexOutOfBoundsException数组越界异常。 3.2 数组空指针异常 public class Demo02ArrayNull { public static void main(String[] args){ int [] array = null; &#x2F;&#x2F; array = new int[3]; System.out.println(array[0]); } } 所有的引用类型变量，都可以赋值为一个null值。但代表其中什么都没有。 数组必须进行new初始化才能使用其中的元素，如果赋值一个null，没有进行new创建数组，程序运行后将出现NullPointerException空指针异常。 3.3 数组遍历 数组遍历：将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。 public class Demo02Array_bianli { public static void main(String[] args){ int[] arr = {1,2,3,4,5}; for(int i = 0;i &lt; arr.length;i++){ System.out.println(arr[i]); } } } 3.4 数组获取最大值元素 最大值获取：从数组的所有元素中找出最大值。 实现思路： 定义变量，保存数组0索引上的元素 遍历数组，获取出数组中的每个元素 将遍历到的元素和保存数组0索引上值的变量进行比较 如果数组元素值大于保存变量值，则重新赋值给变量，替换掉 数组循环遍历结束，变量中保存的就是数组中的最大值 public class Demo02ArrayMAX { public static void main(String[] args){ int[] arr = {5,15,2000,10000,100,4000}; int max = 0; for(int i = 0;i &lt; arr.length;i++){ if(arr[i] &gt; max){ max = arr[i]; } } System.out.println(&quot;arr数组最大值为：&quot; + max); } } 3.5 数组反转 数组的反转：数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1 实现思路：数组最远端的元素互换位置 定义两个变量，保存数组的最小索引和最大索引 两个索引上的元素交换位置 最小索引++，最大索引–，再次交换位置 最小索引超过了最大索引，数组反转操作结束 4. 数组作为方法参数和返回值4.1 数组作为方法参数以前的方法中我们学习了方法的参数和返回值，但是使用的都是基本数据类型。 数组作为方法参数传递，传递的参数是数组内存的地址。","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"},{"name":"数组","slug":"数组","permalink":"https://zero024.cn/tags/数组/"}]},{"title":"IDEA的安装与激活","slug":"JavaBasics/Java开发工具安装","date":"2019-04-15T09:00:00.000Z","updated":"2020-03-08T00:46:00.664Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"概述IDEA是一个专门针对Java的集成开发工具(IDE)，由Java语言编写。所以，需要有JRE运行环境并配置好环境变量。它可以极大地提升我们的开发效率。可以自动编译，检查错误。","text":"概述IDEA是一个专门针对Java的集成开发工具(IDE)，由Java语言编写。所以，需要有JRE运行环境并配置好环境变量。它可以极大地提升我们的开发效率。可以自动编译，检查错误。 安装步骤 官网下载IDE安装包IntelliJ官网 agent破解方式详见zhile.io 破解教程 仅供个人学习研究使用，不得用于商业用途！若资金允许请点击链接支持正版 使用教程 新建一个项目，然后点击src文件夹，右击新建package，新建包后右键新建一个class，编写一个HelloWorld程序验证一下是否正常运行。 IDEA工具默认字体非常小，代码编辑器和控制台的输出字体都需进行调整 点击菜单栏上的File&gt;Settings&gt;Editor&gt;Font修改字体。 IDEA的项目目录 .idea目录和demo.iml和我们开发无关，是IDEA工具自己使用的 out目录是存储编译后的.class文件 src目录是存储我们编写的.java源文件 IEAD常用快捷键","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://zero024.cn/tags/IDEA/"}]},{"title":"Java流程控制语句","slug":"JavaBasics/Java流程控制","date":"2019-04-14T06:00:00.000Z","updated":"2020-03-08T00:49:31.531Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"流程控制在一个程序执行中，各条语句的执行顺序对程序的结果是有直接影响的。所以必须清楚每条语句的执行流程，而且，我们需要通过控制语句的执行顺序来实现我们要完成的功能。","text":"流程控制在一个程序执行中，各条语句的执行顺序对程序的结果是有直接影响的。所以必须清楚每条语句的执行流程，而且，我们需要通过控制语句的执行顺序来实现我们要完成的功能。 1. if else 判断语句1.1 if语句第一种格式：if if(关系表达式){ 语句体； } 执行流程 首先判断关系表达式其结果是true还是false 如果是true就执行语句体 如果是false就不执行语句体1.2 if语句第二种格式：if…else if(关系表达式){ 语句体1； }else{ 语句体2； } 执行流程 首先判断关系表达式看其结果是true还是false 如果是true就执行语句体1 如果是false就执行语句体2 public static void main(String[] args){ &#x2F;&#x2F; 判断给定的数据是奇数还是偶数 &#x2F;&#x2F; 定义变量 int a = 1; if(a % 2 == 0) { System.out.println(&quot;a是偶数&quot;); } else{ System.out.println(&quot;a是奇数&quot;); } System.out.println(&quot;结束&quot;); } 1.3 if语句第三种格式：if…else if…else if (判断条件1) { 执行语句1; } else if (判断条件2) { 执行语句2; } ... }else if (判断条件n) { 执行语句n; } else { 执行语句n+1; } 执行流程 首先判断关系表达式1看其结果是true还是false 如果是true就执行语句体1 如果是false就继续判断关系表达式2看其结果是true还是false true则执行语句体2，false就继续往下判断 如果没有任何关系表达式为true，则执行else语句体 2. switch选择语句2.1 选择语句–switch switch语句格式： switch(表达式){ case 常量值1： 语句体1； break； case 常量值2： 语句体2； break； ... default: 语句体n+1; break; } 执行流程 首先计算表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束。 实例： public class switch_exercise { public static void main(String[] agrs) { int weekday = 6; switch(weekday) { case 1: System.out.println(&quot;今天星期一&quot;); break; case 2: System.out.println(&quot;今天星期二&quot;); break; case 3: System.out.println(&quot;今天星期三&quot;); break; case 4: System.out.println(&quot;今天星期四&quot;); break; case 5: System.out.println(&quot;今天星期五&quot;); break; case 6: System.out.println(&quot;今天星期六&quot;); break; case 7: System.out.println(&quot;今天星期日&quot;); break; default: System.out.println(&quot;输入数据有误&quot;); break; } } } switch语句使用的注意事项： 多个case后面的数值不可重复。 switch后面小括号中只能是下列数据类型： 基本数据类型：byte/short/char/int 引用数据类型：String字符串、enum枚举 switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略，但需要考虑case穿透性。“匹配哪一个case就从哪一个位置向下执行，直到遇到break或者整体结束为止。” 2.2 case的穿透性在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。故编写switch语句时，必须写上break。 3. for循环语句3.1 循环概述循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句。当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。 3.2 循环语句–for for循环语句格式： for（初始化表达式1；布尔表达式2；步进表达式4）{ 循环体3； } 执行流程 执行顺序：1234&gt;234&gt;234…直到2不满足为止。 1负责完成循环变量初始化 2负责判断是否满足循环条件，不满足则跳出循环 3具体执行的语句 4循环后，循环条件所涉及变量的变化情况 实例： public class for_exercise { public static void main(String[] args) { int sum = 0; for (int i = 1;i &lt;= 100;i++) { if(i % 2 == 0) { sum += i; } } System.out.println(&quot;sum:&quot; + sum); } } 4. while循环语句 while循环语句格式： 初始化表达式1： while（布尔表达式2）{ 循环体3； 步进表达式4； } 执行流程 执行顺序：1234&gt;234&gt;234&gt;234…直到2不满足为止。 1负责完成循环变量初始化。 2负责判断是否满足循环条件，不满足则跳出循环。 3具体执行的语句。 4循环后，循环变量的变化情况。 实例： public class while_exercise { public static void main(String[] agrs) { int sum = 0; int i = 1; while(i &lt;= 100) { sum += i; i++; } System.out.println(&quot;1~100的值为：&quot; + sum); } } 5. do while循环语句 do…while循环格式： 初始化表达式1 do{ 循环体3； 步进表达式4； }while（布尔表达式2）； 执行流程 执行顺序：134&gt;234&gt;234…知道2不满足为止。 1负责完成循环变量初始化。 2负责判断是否满足循环条件，不满足则跳出循环。 3具体执行的语句 4循环后，循环变量的变化情况 实例： public class do_while_exercise { public static void main(String[] args) { int i = 1; do { System.out.println(&quot;hello:&quot; + i); i++; }while(i&lt;=10); } } Tips：do…while循环特点是会无条件执行一次循环体，即使我们将循环条件写出false，也依然会循环一次。这样的循环具有一定风险，不推荐使用。 7.循环语句的区别 三种循环的小区别： 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率 在已知循环次数的时候推荐使用for，循环次数未知时推荐使用while。 如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do…while循环会执行至少一次。 for循环的变量在小括号当中定义，只有循环内部可以使用。while循环和do…while循环初始化语句本来就在外面，所以出了循环可以继续使用。 8. 跳出语句break 使用场景：终止switch或者循环 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 continue 使用场景：结束本次循环，继续下一次循环 9.扩展知识点9.1嵌套循环 所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总共的循环次数 = 外循环次数 * 内循环次数 嵌套循环格式： for(初始化表达式1；循环条件2；步进表达式7){ for(初始化表达式3；循环条件4；步进表达式6){ 执行语句5； } } 嵌套循环执行流程： 执行顺序：123456&gt;456&gt;723456&gt;456 外循环一次，内循环多次 比如跳绳：一共5组，每组跳10个。5组就是外循环，10个就是内循环。","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Java运算符","slug":"JavaBasics/Java运算符","date":"2019-04-13T06:00:00.000Z","updated":"2020-03-08T00:49:27.227Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"算数运算符 + ：加法运算，字符串连接运算 - : 减法运算 * : 乘法运算 / : 除法运算 % : 取模运算，两个数字相除取余数 ++,-- : 自增自减运算","text":"算数运算符 + ：加法运算，字符串连接运算 - : 减法运算 * : 乘法运算 / : 除法运算 % : 取模运算，两个数字相除取余数 ++,-- : 自增自减运算 Java中，整数使用以上运算符，不会得到小数。 ++运算，变量自增长1。反之，–运算，变量自己减少1。 独立运算：++i和i++没有区别 混合运算：和其他变量放在一起，++i和i++就有不同结果。 &#x2F;&#x2F;变量前++：变量a自己先+1，将加1后的结果赋值给b，也就是说a先计算后赋值。 public static void main(String[] args) { int a = 1; int b = ++a; System.out.println(a);&#x2F;&#x2F;计算结果是2 System.out.println(b);&#x2F;&#x2F;计算结果是2 } &#x2F;&#x2F;变量后++：变量a先把自己的值1，赋值给变量b，此时b值就是1，变量a自己再加1，a值就是2。先赋值后计算。 public static void main(String[] args) { int a = 1; int b = a++; System.out.println(a);&#x2F;&#x2F;计算结果是2 System.out.println(b);&#x2F;&#x2F;计算结果是1 } 赋值运算符 = : 等于号 += : 加等于 -= : 减等于 *= : 乘等于 /= : 除等于 %= : 取模 赋值运算符，就是将符号右边的值，赋给左边的变量。 比较运算符 == : 比较符号两边数据是否相等，相等结果是true。 &lt; : 比较符号左边的数据是否小于右边的数据，如果小于结果是true。 &gt; : 比较符号左边的数据是否大于右边的数据，如果大于结果是true。 &lt;= : 比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是true。 &gt;= : 比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是true。 != : 不等于符号 ，如果符号两边的数据不相等，结果是true。比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值，true或者false。 逻辑运算符&amp;&amp;短路与 两边都真，则真 一边是假，则假短路特定：如果左边遇假则可以得到最终结果，右边不再运算 ||短路或 两边都假，则假 一边是真，则真短路特点：如果左边遇真则可以得到最终结果，右边不再运算 ！取反 ！true 则是假 ！false 则是真 &#x2F;&#x2F;逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false public static void main(String[] args) { System.out.println(true &amp;&amp; true);&#x2F;&#x2F;true System.out.println(true &amp;&amp; false);&#x2F;&#x2F;false System.out.println(false &amp;&amp; true);&#x2F;&#x2F;false，右边不计算 System.out.println(false || false);&#x2F;&#x2F;falase System.out.println(false || true);&#x2F;&#x2F;true System.out.println(true || false);&#x2F;&#x2F;true，右边不计算 System.out.println(!false);&#x2F;&#x2F;true } TIPS： 逻辑运算符只能用于boolean值。 与、或需要左右各自有一个boolean值，但是取反只要有唯一一个boolean值即可。 与、或两种运算符，如果有多个条件，可以连续写。多个条件：条件A &amp;&amp; 条件B &amp;&amp; 条件C 三元运算符 三元运算符格式：数据类型 变量名 = 布尔类型表达式？结果1：结果2 三元运算符计算方式： &#x2F;&#x2F;布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。 &#x2F;&#x2F;布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。 public static void main(String[] args) { int i = (1==2 ? 100 : 200); System.out.println(i);&#x2F;&#x2F;200 int j = (3&lt;=4 ? 500 : 600); System.out.println(j);&#x2F;&#x2F;500 }","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Java修饰符","slug":"JavaBasics/Java修饰符","date":"2019-04-12T08:00:00.000Z","updated":"2020-03-08T00:49:28.069Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"前言Java语言提供了很多修饰符,主要分为以下两类: 访问修饰符 非访问修饰符修饰符用来定义类、方法或者变量，通常放在语句的最前端。","text":"前言Java语言提供了很多修饰符,主要分为以下两类: 访问修饰符 非访问修饰符修饰符用来定义类、方法或者变量，通常放在语句的最前端。 访问控制修饰符Java中，可以使用==访问控制符==来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。 default（即缺省，什么也不写）：在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private：在同一类内可见。使用对象：变量、方法。注意：不能修饰类（外部类） public：对所有类可见。使用对象：类、接口、变量、方法 protected：对同一包内的类和所有子类可见。使用对象：变量，方法。注意：不能修饰类（外部类）。 默认访问修饰符-不使用任何关键字使用默认访问修饰符声明的变量和方法，对同一包内的类是可见的。接口里的变量都隐式声明为public static final，而接口里的方法默认情况下访问权限为publi。如下例，变量和方法的声明可以不使用任何修饰符 String version = &quot;3.0.3&quot;; boolean processOrder(){ return true; } 私有访问修饰符-private私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。Private访问控制修饰符的使用主要用来隐藏类的实现细节和保护类的数据。下面的类使用了私有访问控制符： public class Logger{ private String format; public String getFormat(){ return this.format; } public void setFormat(String format){ this.format = format; } } 实例中，Logger类中的format变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个public方法：getFormat()（能够返回format的值）和setFormat(String)（设置format的值） 公有访问修饰符-public被声明为public的类、方法、构造方法和接口能够被任何其他类访问。如果几个相互访问的public类分布在不同的包中，则需要导入相应public类所在包。由于类的继承性，类的所有公有方法和变量都能被其子类继承。以下函数使用了公有访问控制： public static void main(String[] args){ &#x2F;&#x2F; ... } Java程序的main()方法必须设置公有的，否则，Java解释器将不能运行该类。 受保护的访问修饰符-protectedprotected需要从以下两个点来分析说明： 子类与基类在同一包中：被声明protected的变量、方法和构造器能够被同一个包中的任何其他类访问； 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。protected可以修饰数据成员，构造方法，方法成员，不能修饰类(内部类除外)。子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。下面的父类使用了protected访问修饰符，子类重写了父类的openSpeaker()方法。 class AudioPlayer{ protected boolean openSpeaker(Speaker sp){ &#x2F;&#x2F;实现细节 } } class StreamingAudioPlayer extends AudioPlayer{ protected boolean openSpeaker(Speaker sp){ &#x2F;&#x2F;实现细节 } } 如果把 openSpeaker() 方法声明为 private，那么除了 AudioPlayer 之外的类将不能访问该方法。如果把 openSpeaker() 声明为 public，那么所有的类都能够访问该方法。如果我们只想让该方法对其所在类的子类可见，则将该方法声明为 protected。Java protected关键字详解 访问控制和继承请注意以下方法继承的规则: 父类中声明为public的方法在子类中也必须为public。 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public，不能声明为private。 父类中声明为private的方法，不能被继承。 非访问修饰符为了实现一些其他功能，Java也提供了许多非访问修饰符。 static修饰符，用来修饰类方法和类变量。 final修饰符，用来修饰类、方法和变量，final修饰的类不能被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract修饰符，用来创建抽象类和抽象方法。 synchronized和volatile修饰符，主要用于线程的编程。 static修饰符 静态变量：static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为static变量。 静态方法：static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 对类变量和方法的访问可以直接使用classname.variablename和classname.methodname方式访问。如下示例，static修饰符用来创建类方法和类变量。 public class InstanceCounter { private static int numInstances = 0; protected static int getCount() { return numInstances; } private static void addInstance() { numInstances++; } InstanceCounter() { InstanceCounter.addInstance(); } public static void main(String[] arguments) { System.out.println(&quot;Starting with &quot; + InstanceCounter.getCount() + &quot; instances&quot;); for (int i = 0; i &lt; 500; ++i){ new InstanceCounter(); } System.out.println(&quot;Created &quot; + InstanceCounter.getCount() + &quot; instances&quot;); } } &#x2F;&#x2F;以上示例运行结果如下： Starting with 0 instances Created 500 instances final修饰符final变量：final表示“最后的，最终的”意思，变量一旦赋值后，不能被重新赋值。被final修饰的实例变量必须显式指定初始值。final修饰符通常和static修饰符一起使用来创建类常量。 &#x2F;&#x2F;实例 public class Test{ final int value = 10; &#x2F;&#x2F; 下面是声明常量的实例 public static final int BOXWIDTH = 6; static final String TITLE = &quot;Manager&quot;; public void changeValue(){ value = 12; &#x2F;&#x2F;将输出一个错误 } } final方法 类中的final方法可以被子类继承，但不能被子类修改。 声明final方法的主要目的是防止该方法的内容被修改。如下所示，使用final修饰符声明方法。 public class Test{ public final void changeName(){ &#x2F;&#x2F;方法体 } } final类final类不能被继承，没有类能够继承final类的任何特性。 &#x2F;&#x2F;实例 public final class Test{ &#x2F;&#x2F;类体 } abstract修饰符抽象类： 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了对该类进行扩充。 一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将会编译错误。 抽象类可以包含抽象方法和非抽象方法。 &#x2F;&#x2F;实例 abstract class Caravan{ private double price; private String model; private String year; public abstract void goFast(); &#x2F;&#x2F;抽象方法 public abstract void changeColor(); } 抽象方法 抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。 抽象方法不能被声明成final和static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类，抽象类可以不包含抽象方法。抽象方法的声明以分号结尾，例如:public abstract sample(); &#x2F;&#x2F;实例 public abstract class SuperClass{ abstract void m(); &#x2F;&#x2F;抽象方法 } class SubClass extends SuperClass{ &#x2F;&#x2F;实现抽象方法 void m(){ ......... } } synchronized(同步)修饰符synchronized关键字声明的方法同一时间只能被一个线程访问。synchronized修饰符可以应用于四个访问修饰符。 &#x2F;&#x2F;实例 public synchronized void showDetails(){ ....... } transient(瞬态)修饰符序列化的对象包含被transient修饰的实例变量时，java虚拟机（JVM）跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 &#x2F;&#x2F;实例 public transient int limit = 55; &#x2F;&#x2F; 不会持久化 public int b; &#x2F;&#x2F; 持久化 volatile（挥发性）修饰符volatile修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且当成员变量发生变化时，会强制线程将变量值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。 &#x2F;&#x2F;实例 public class MyRunnable implements Runnable { private volatile boolean active; public void run() { active = true; while (active) &#x2F;&#x2F; 第一行 { &#x2F;&#x2F; 代码 } } public void stop() { active = false; &#x2F;&#x2F; 第二行 } } 通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 第一行 中缓冲区的 active 值被使用，那么在 第二行 的 active 值为 false 时循环不会停止。但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。 本章总结Java的类（外部类）有2种访问权限：public，default。而方法和变量有4种：public、default、protected，private。其中默认访问权限和protected很相似，有着细微的差别。 public意味着任何地方的其他类都能访问。 default则是同一个包的类可以访问。 protected表示同一个包的类可以访问，其他的包的该类子类也可以访问。 private表示只有自己类能够访问。 修饰符：abstract、static、final abstract：表示是抽象类。使用对象：类、接口、方法。 static：可以当做普通类使用，而不用先实例化一个外部类。（用他修饰后，就成了静态内部类了）。使用对象：类、变量、方法、初始化函数（注意：修饰类时只能修饰内部类） final：表示类不可以被继承。使用对象：类、变量、方法。 关于static static全局变量与普通的全局变量：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Java变量类型","slug":"JavaBasics/Java变量类型","date":"2019-04-12T01:18:23.000Z","updated":"2020-03-08T00:49:34.314Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"前言在Java语言中,所以的变量在使用前必须声明. 声明变量的基本格式如下: type indentifier = [ = value][, indentifier [= value] ...];","text":"前言在Java语言中,所以的变量在使用前必须声明. 声明变量的基本格式如下: type indentifier = [ = value][, indentifier [= value] ...]; 以下列出了一些变量的声明实例.注意有些包含了初始化过程 int a,b,c; &#x2F;&#x2F;声明三个int型整数:a,b,c int d = 3,e = 4, f = 5; &#x2F;&#x2F;声明三个整数并赋予初值 byte z = 22; &#x2F;&#x2F; 声明并初始化 z String s = &quot;runoob&quot;; &#x2F;&#x2F;声明并初始化字符串s double pi = 3.14159; &#x2F;&#x2F;声明了双精度浮点型变量 pi char x = &#39;x&#39;; &#x2F;&#x2F;声明变量x的值是字符 &#39;x&#39; Java语言支持的变量类型有: 类变量:独立于方法之外的变量,用static修饰 实例变量:独立于方法之外的变量,不用static修饰 局部变量:类的方法中的变量 public class Variable{ static int allClicks = 0; &#x2F;&#x2F;类变量 String str = &quot;hello world&quot;; &#x2F;&#x2F;实例变量 public void method(){ int i = 0 &#x2F;&#x2F; 局部变量 } } Java局部变量 局部变量声明在方法,构造方法或者语句块中; 局部变量在方法,构造方法,或者语句块被执行时创建,当它们执行完毕后,变量将会被销毁; 访问修饰符不能用于局部变量; 局部变量只在声明它的方法,构造方法或者语句块中可见; 局部变量是在栈上分配的; 局部变量没有默认值,所以局部变量被声明后,必须经过初始化,才可以使用实例变量 实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建时被创建，在对象销毁时被销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方法获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName。实例 package zerofirst.test; import java.io.*; public class Employee { public String name; &#x2F;&#x2F;这个实例变量对子类可见 private double salary; &#x2F;&#x2F;私有变量，仅在该类可见 public Employee (String empName) { name = empName; &#x2F;&#x2F;在构造器中对name赋值 } public void setSalary(double empSal) { salary = empSal; &#x2F;&#x2F; 设定salary的值 } &#x2F;&#x2F;打印信息 public void printEmp() { System.out.println(&quot;名字：&quot; + name); System.out.println(&quot;薪水：&quot; + salary); } public static void main(String[] args) { Employee empOne = new Employee(&quot;Java&quot;); empOne.setSalary(1000); empOne.printEmp(); } } &#x2F;&#x2F;以上结果输出 名字：Java 薪水：1000.0 类变量（静态变量） 类变量也称为静态变量，在类中以static关键字声明，但必须在方法之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认是false，引用类型默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName，VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Java基本数据类型","slug":"JavaBasics/Java基本数据类型","date":"2019-04-11T08:00:00.000Z","updated":"2020-03-08T00:49:33.628Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"前言变量就是申请内存来存储值.也就是说,当创建变量时,需要在内存中申请空间.内存管理系统根据变量的类型为变量分配存储空间,分配的空间只能用来存储该类型数据.因此,通过定义不同类型的变量,可以在内存中存储整数,小数或者字符Java的两大数据类型: 内置数据类型 引用数据类型","text":"前言变量就是申请内存来存储值.也就是说,当创建变量时,需要在内存中申请空间.内存管理系统根据变量的类型为变量分配存储空间,分配的空间只能用来存储该类型数据.因此,通过定义不同类型的变量,可以在内存中存储整数,小数或者字符Java的两大数据类型: 内置数据类型 引用数据类型 内置数据类型Java语言提供了四类八种基本类型。整数型,浮点型, 字符类型,布尔型。 byte byte数据类型是8位,有符号的,以二进制补码表示的整数; 最小值是-128(-2^7), 最大值是127(2^7-1), 默认值为0; byte类型用在大型数组中节约空间,主要代替整数,因为byte变量占用的空间只有int类型的四分之一; 例子:byte a = 100, byte b = -50; short short数据类型是16位,有符号的以二进制补码表示的整数; 最小值是-32768(-2^15),最大值是32767(2^15-1), 默认值为0; short数据类型也可以像byte那样节省空间. 一个short变量是int型变量的二分之一; 例子:short s = 1000, short r = -20000int int数据类型是32位,有符号的以二进制补码表示的整数; 最小值是-2 147 483 648(-2^31),最大值是2147483647(2^31-1),默认值为0; 一般地整型变量默认为int类型; 例子:int a = 10000, int b = - 200000long long数据类型是64位,有符号的二进制补码表示的整数; 最小值是-9 223 372 036 854 775 808(-2^63); 最大值是9 223 372 036 854 775 807(2^63-1); 这种类型主要使用在需要比较大整数的系统上; 默认值是0L; 例子:long a = 1000000L, Long b = -2000000Lfloat float数据类型是单精度,32位,符合IEEE754标准的浮点数; float在存储大型浮点数值时可以节省内存空间; 默认值是0.0f; 浮点数不能用来表示精确的值,如货币; 例子:float f1 = 234.5fdouble double数据类型是双精度,64位,符合IEEE754标准的浮点数; 浮点数的默认类型为double类型; double类型同样不能表示精确的值; 默认值为0.0d; 例子: double d1 = 123.4boolean boolean数据类型表示一位的信息; 只有两个取值:true和false; 这种类型只作为一种标志来记录true/false情况; 默认值是false; 例子:boolean one = truechar char类型是一个单一的16位Unicode字符; 最小值是\\u0000(即为0),最大值是\\uffff(即为65535); char数据类型可以存储任何字符; 例子:char letter = ‘A’ 变量定义的格式包括三个要素：数据类型、变量名、数据值 &#x2F;&#x2F;数据类型 变量名 = 数据值; &#x2F;&#x2F;例子： byte b = 100； short s = 1000; int i = 5; long l = 10000000000L; float f = 5.5F; double d = 8.5; boolean bool = true; char c = &#39;A&#39;; 实例 public class PrimitiveType { public static void main(String[] args) { &#x2F;&#x2F;byte System.out.println(&quot;基本类型:byte 二进制位数:&quot; + Byte.SIZE); System.out.println(&quot;包装类:java.lang.Byte&quot;); System.out.println(&quot;最小值:Byte.MIN_VALUE=&quot; + Byte.MIN_VALUE); System.out.println(&quot;最大值:Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE); System.out.println(); &#x2F;&#x2F;short System.out.println(&quot;基本类型: short 二进制位数:&quot; + Short.SIZE); System.out.println(&quot;包装类:java.lang.Short&quot;); System.out.println(&quot;最小值:Short.MIN_VALUE=&quot; + Short.MIN_VALUE); System.out.println(&quot;最大值:Short.MAX_VALUE=&quot; + Short.MAX_VALUE); System.out.println(); &#x2F;&#x2F;int System.out.println(&quot;基本类型: int 二级制位数:&quot; + Integer.SIZE); System.out.println(&quot;包装类:java.lang.Integer&quot;); System.out.println(&quot;最小值:Integer.MIN_VALUE=&quot; + Integer.MIN_VALUE); System.out.println(&quot;最大值:Integer.MAX_VALUE=&quot; + Integer.MAX_VALUE); System.out.println(); &#x2F;&#x2F;long System.out.println(&quot;基本类型: long 二进制位数:&quot; + Long.SIZE); System.out.println(&quot;包装类:java.lang.Long&quot;); System.out.println(&quot;最小值:Long.MIN_VALUE&quot; + Long.MIN_VALUE); System.out.println(&quot;最大值:Long.MAX_VALUE&quot; + Long.MAX_VALUE); System.out.println(); &#x2F;&#x2F;float System.out.println(&quot;基本类型: float 二进制位数:&quot; + Float.SIZE); System.out.println(&quot;包装类:java.lang.Float&quot;); System.out.println(&quot;最小值:Float.MIN_VALUE&quot; + Float.MIN_VALUE); System.out.println(&quot;最大值:Float.MAX_VALUE&quot; + Float.MAX_VALUE); System.out.println(); &#x2F;&#x2F;double System.out.println(&quot;基本类型: double 二进制位数:&quot; + Double.SIZE); System.out.println(&quot;包装类:java.lang.Double&quot;); System.out.println(&quot;最小值:Double.MIN_VALUE&quot; + Double.MIN_VALUE); System.out.println(&quot;最大值:Double.MAX_VALUE&quot; + Double.MAX_VALUE); System.out.println(); &#x2F;&#x2F;char System.out.println(&quot;基本类型: char 二进制位数:&quot; + Character.SIZE); System.out.println(&quot;包装类: java.lang.Character&quot;); &#x2F;&#x2F; 以数值形式而不是字符形式将Character.MIN_VALUE输出至控制台 System.out.println(&quot;最小值:Character.MIN_VALUE=&quot; + (int) Character.MIN_VALUE); System.out.println(&quot;最大值:Character.MAX_VALUE=&quot; + (int) Character.MAX_VALUE); } } &#x2F;&#x2F;学习类之后将该程序改进一下:输入任意类型就打印该类型的信息 引用类型 在Java中,引用类型的变量非常类似于C/C++的指针.引用类型指向一个对象,指向对象的变量是引用变量.这些变量在声明时被指定为一个特定的类型. 比如Employee,Puppy等. 变量一旦声明,类型就不能被改变了. 对象,数组都是引用数据类型 所以引用类型的默认值都是null 一个引用变量可以用来引用任何与之兼容的类型 例子: Site site = new Site(‘Java’)Java常量常量是指在Java程序中固定不变的数据。以下是常量的分类： 字符串常量：凡是用双引号引起来的部分，叫做字符串常量。例如：”abc”, “Hello”,”123” 字符常量：凡是用单引号引起来的单个字符，就是字符常量。例如：’A’,’b’,’9’,’中’ 整数常量：直接写上的数字，没有小数点。例如：100,123,200,0，-1 浮点数常量：直接写上数字，有小数点的。例如：2.5，-3.14,0.0 布尔常量：只有量中取值。true，false。 空常量：null。代表没有任何数据。在Java中使用final关键字来修饰常量,声明方式和变量类似: final double PI = 3.1415927; 虽然常量名也可以用小写,但为了方便识别,通常使用大写字母表示常量.字面量可以赋给任何内置类型的变量.例如: byte a = 68; char a = &#39;A&#39;; byte,int,long和short都可以用十进制,16进制以及8进制的方式来表示.当使用常量时,前缀0表示8进制,而前缀0x代办16进制,例如: int decimal = 100; int octal = 0144; int hexa = 0x64; 和其他语言一样,Java的字符串常量也是包含在两个引号之间的字符序列,例子: &quot;Hello World&quot; &quot;two\\nlines&quot; &quot;\\&quot;This is in quotes\\&quot;&quot; 字符串常量和字符常量都可以包含任何Unicode字符,例如: char a = &quot;\\u0001&quot;; String a = &quot;\\u0001&quot;; Java支持的转义字符序列 自动类型转换（显式）整型,实型(常量),字符型数据可以混合运算.运算中,不同类型的数据先转化为同一类型,然后进行运算.转换从低级到高级 低-------------------------------------&gt;高 byte,short,char--&gt; int--&gt; long--&gt; float--&gt; double 数据类型转换必须满足如下规则: 不能对boolean类型进行类型转换 不能把对象类型转换成不相关类的对象 在把容量大的类型转换为容量小的类型时必须使用强制类型转换 转换过程中可能导致溢出或损失精度,例如: int i = 128; byte b = (byte)i; 因为byte类型是8位,最大值为127,所以当int强制转换为byte类型时,值128会导致溢出5. 浮点数到整数的转换是通过舍弃小数得到,而不是四舍五入,例如: (int)23.7 == 23; (int)-45.89f == -45; 自动类型转换(隐式)必须满足转换前的数据类型的位数要低于转换后的数据类型,例如 short数据类型的位数为16位,就可以自动转换位数为32的int类型,同样float数据类型的位数为32位,可以自动转换为64位的double类型. 特点：代码不需要进行特殊处理，自动完成 规则：数据范围从小到大。 public class AutoSwitch{ public static viod main(String[] args){ char c1 = &#39;a&#39;; &#x2F;&#x2F; 定义一个char类型 int i1 = c1; &#x2F;&#x2F;char自动类型转换为int System.out.println(&quot;char自动类型转换为int后的值=&quot; + i1); char c2 = &#39;A&#39;; &#x2F;&#x2F;定义一个char类型 int i2 = c2 + 1; &#x2F;&#x2F;char类型金额int类型计算 System.out.println(&quot;char类型和int计算后的值为 = &quot; + i2); } } &#x2F;&#x2F;运行结果为: &#x2F;&#x2F;char自动类型转换为int后的值=97 &#x2F;&#x2F;char类型和int计算后的值为 = 66 &#x2F;&#x2F;解析:c1的值为字符a,查ASCII码表的对应的int类型值为97,A对应值为65,故i2=65+1=66 强制类型转换(显式)将取值范围大的类型强制转换成取值范围小的类型 转换格式：数据类型 变量名 = （数据类型）被强转的数据值； &#x2F;&#x2F;double类型强制转换为int类型，直接去掉小数点 int i = (int)1.5; public class QiangZhiZhuanHuan{ public static viod main(String[] args){ int i1 = 123; &#x2F;&#x2F; byte b = (byte)i1; &#x2F;&#x2F;int类型强制类型转换为byte System.out.println(&quot;int强制类型转换为byte后的值为:&quot; + b); } } &#x2F;&#x2F;运行结果: int强制类型转换为byte后的值等于123 Tips： 浮点转成整数，直接取消小数点，可能会造成数据损失精度。 int强制转成short砍掉2个字节，可能会造成数据溢出，导致数据丢失。 byte/short/char这三种类型都可以发生数学运算，例如加法“+”。 byte/short/char这三种类型在运算时，都会首先自动被提升成为int类型，然后再计算。 boolean类型不能发生任何数据类型转换强制类型转换(隐式) 整数的默认类型是int 浮点型不存在这种情况,因为在定义float类型时必须在数字后面跟上F或者f对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐式地为我们补上一个(byte)(short)(char)。 如果没有超过左侧的范围，编译器补上强转。 如果右侧超过了左侧的范围，编译报错。 public class Notice{ public static void main(String[] args){ &#x2F;&#x2F;右侧确实是一个int数字，但没有超过左侧的范围，故自动隐式强转不会报错。 &#x2F;&#x2F;int --&gt; byte 高位到低位，不是自动类型转换 byte num1 = 30; &#x2F;&#x2F; 右侧没有超过左侧范围 System.out.println(num1); &#x2F;&#x2F;byte num2 = 128; &#x2F;&#x2F; 右侧超过了左侧范围 &#x2F;&#x2F; int --&gt; char 只要右侧没超出范围，编译器会自动补上一个隐含的(char)，进行自动隐式强转。 char strings = &#x2F;*(char)*&#x2F; 65； System.out.println(strings) } } 编译器的常量优化在给变量进行赋值时，如果右侧表达式当中全部是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。short result = 5+8；//等号右边全部是常量，没有任何变量参与运算，编译之后，得到的.class字节码文件当中相当于==直接就是==：short result = 13;右侧的常量结果数值，没有超过左侧范围，所以正确。这称为“编译器的常量优化” 但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。 ASCII编码表ASCII码表：American Standard Code for Information Interchange，美国信息交换标准码。Unicode码表：万国码。也是数学和符号的对照关系，开头0-127部分和ASCII完全一样，但从128开始包含更多的字符。只需特殊记住三个字符，分别是 ‘0’=48 ‘A’=65 ‘a’=97","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Java基础","slug":"JavaBasics/Java基础","date":"2019-04-10T14:00:00.000Z","updated":"2020-03-08T00:49:32.761Z","comments":true,"path":"JavaBasics/undefined.html","link":"","permalink":"https://zero024.cn/JavaBasics/undefined.html","excerpt":"Java简介参考Runoob 搭建开发环境 JVM(Java Virtual Machine):Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java最具吸引力的特性之一。我们编写的Java代码，都是运行在Jvm之上。 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。 JRE（Java Runtime Environment）:是Java程序的运行时环境，包含JVM和运行时所需的核心类库。 JDK（Java Development Kit）:是Java程序开发工具包，包含JRE和开发人员使用工具。下载JDK下载Eclipse","text":"Java简介参考Runoob 搭建开发环境 JVM(Java Virtual Machine):Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java最具吸引力的特性之一。我们编写的Java代码，都是运行在Jvm之上。 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。 JRE（Java Runtime Environment）:是Java程序的运行时环境，包含JVM和运行时所需的核心类库。 JDK（Java Development Kit）:是Java程序开发工具包，包含JRE和开发人员使用工具。下载JDK下载Eclipse 基础语法编写Java程序时,需注意以下几点: 大小写敏感:Java是大小写敏感的,这就意味着标识符Hello与hello是不同的 类名:对于所有的类来说,类名的首字母应该大写.如果类名由若干单词组成,那么需采用驼峰命名法 方法名:所有的方法都应该以小写字母开头.如果方法名含有若干单词,则后面的每个单词首字母大写 源文件名:源文件名必须和类名相同.当保存文件时,你应该使用类名作为文件名保存,文件名的后缀为.java(如文件名和类名不相同则会导致编译错误) 主方法入口:所有的Java程序由public static void main(String []args)方法开始执行Java标识符Java所有的组成部分都需要名字. 类名,变量名以及方法名都被称为标识符.关于Java标识符,有一下几点需要注意: 所有的标识符都应该以字母(A-Za-z),美元符($),或者下划线(_)开始 首字符之后可以是字母(A-Za-z),美元符,下划线或数字的任何字符组合 关键字不能用作标识符 标识符大小写敏感 合法标识符举例:age, $salary, _value, __1_value 非法标识符举例:123abc, -salaryJava修饰符像其他语言一样,Java可以使用修饰符来修饰类中方法和属性.主要有两类修饰符: 访问控制修饰符: default, public, protected, private 非访问控制修饰符: final, abstract, static, synchronizedJava变量Java中主要有如下几种类型的变量 局部变量 类变量(静态变量) 成员变量(非静态变量)Java数组数组是存储在堆上的对象,可以保存多个同类型变量Java枚举枚举限制变量只能是预先设定好的值. 使用枚举可以减少代码中的bug.例如:为果汁店设计一个程序,它将限制果汁为小杯,中杯,大杯. 这就意味着它不允许顾客点除了这三种尺寸外的果汁 class FreshJuice { enum FreshJuinceSize{ SMALL, MEDIUM, LARGE } FreshJuiceSize size; } public class FreshJuiceTest { public static void main(String []args){ FreshJuice juice = new FreshJuice(); juice.size = FreshJuice.FreshJuiceSize.MEDIUM; } } &#x2F;&#x2F;注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义 Java关键字以下列出Java关键字,这些保留字不能用于常量,变量,和任何标识符的名称.详见runoob Java关键字 Java注释类似于C/C++, Java也支持单行以及多行注释.注释字符将被Java编译器忽略. public class HelloWorld { &#x2F;* 这是第一个Java程序 *它将打印Hello World * 这是一个多行注释的示例 *&#x2F; public static void main(String []args){ &#x2F;&#x2F; 这是单行注释的示例 &#x2F;* 这个也是单行注释的示例 *&#x2F; System.out.println(&quot;Hello World&quot;); } } Java空行空白行或者有注释的行,Java编译器都会忽略掉 继承在Java中,一个类可以由其他类派生.如果你要创建一个类,而且已经存在一个类具有你所需的属性或者方法,那么你可以将新创建的类继承该类.利用继承的方法,可以重用已存在类的方法和属性,而不用重写这些代码. 被继承的类称为超类(super class),派生类称为子类(sub class) 接口在Java中,接口可以理解为对象间相互通信的协议.接口在继承中扮演者重要的角色接口只定义派生要用到的方法,但是方法的具体实现完全取决于派生类 Java源程序与编译型运行区别如图所示: Java对象和类Java作为一种面向对象语言,支持以下基本概念: 多态 继承 封装 抽象 类 对象 实例 方法 重载以下重点研究对象和类的概念 对象:对象是类的一个实例,例如,一条狗是一个对象,它的状态有:颜色,名字,品种;行为有:摇尾巴,叫,吃等 类:类是一个模板,它描述一类对象的行为和状态.下图中男孩女孩为类,具体每个人为该类的对象:Java中的对象现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。对比现实对象和软件对象，它们之间十分相似。软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。Java中的类类可以看成是创建Java对象的模板,下面通过一个简单的类来理解下Java中类的定义: public class Dog{ String breed; int age; String color; void barking(){ } void hungry(){ } void sleeping(){ } } 一个类可以包含以下类型变量: 局部变量:在方法,构造方法或者语句块中定义的变量被称为局部变量.变量声明和初始化都是在方法中,方法结束后,变量就会自动销毁. 成员变量:成员变量是定义在类中,方法体之外的变量.这种变量在创建对象时实例化.成员变量可以被类中方法,构造方法和特定类的语句块访问 类变量:类变量也声明在类中,方法体之外,但必须声明为static类型一个类可以拥有多个方法,在上面的例子中:barking(),hungry(),sleeping()都是Dog类的方法构造方法每个类都有构造方法. 如果没有显式地为类定义构造方法,Java编译器将会为该类提供一个默认构造方法在创建一个对象时,至少要调用一个构造方法,构造方法的名称必须与类同名,一个类可以有多个构造方法.下面是一个构造方法实例: public class Puppy{ public Puppy(){ } public Puppy(String name){ &#x2F;&#x2F;这个构造器仅有一个参数:name } } 创建对象对象是根据类创建的.在Java中,使用关键字==new==来创建一个新的对象.创建对象需要以下三步: 声明:声明一个对象,包括对象名称和对象类型 实例化:使用关键字new来创建一个对象 初始化:使用new创建对象时,会调用构造方法初始化对象下面是一个创建对象的例子: public class Puppy{ public Puppy(String name){ &#x2F;&#x2F;这个构造器仅有一个参数:name Syetem.out.println(&quot;小狗的名字是:&quot;+name); } public static void main(String []args){ &#x2F;&#x2F;下面语句将创建一个Puppy对象 Puppy myPuppy = new Puppy(&quot;tommy&quot;); } } 访问实例变量和方法通过已创建的对象来访问成员变量和成员方法,如下所示: &#x2F;* 实例化对象 *&#x2F; Object referenceVariable = new Constructor(); &#x2F;* 访问类中的变量 *&#x2F; referenceVariable.variableName; &#x2F;* 访问类中的方法 *&#x2F; referenceVariable.methodName(); 实例下面的例子展示如何访问实例变量和调用成员方法: public class Puppy { int puppyAge; public Puppy(String name) { &#x2F;*这个构造器仅有一个参数:name*&#x2F; System.out.println(&quot;小狗的名字是:&quot; + name); } public void setAge(int age) { puppyAge = age; } public int getAge() { System.out.println(&quot;小狗的年龄为:&quot; + puppyAge); return puppyAge; } public static void main(String []args) { &#x2F;&#x2F;使用new创建对象 Puppy myPuppy = new Puppy(&quot;tommy&quot;); &#x2F;&#x2F;通过方法来设定age myPuppy.setAge( 2 ); &#x2F;&#x2F;调用另一个方法获取age myPuppy.getAge(); &#x2F;&#x2F;你也可以通过下面方法访问成员变量 System.out.println(&quot;变量值:&quot; + myPuppy.puppyAge); } } 源文件声明规则当在一个源文件中定义多个类,并且还有import语句和package语句时,要特别注意以下规则 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致.例如:源文件中public类的类名是Test,那么源文件应该命名为Test.java 如果一个类定义在某个包中,那么package语句应该在源文件的首行 如果源文件包含import语句,那么应该放在package语句和类定义之间.如果没有package语句,那么import语句应该在源文件中最前面 import语句和package语句对源文件中定义的所有类都有效.在同一源文件中,不能给不同的类不同的包声明.类有若干种访问级别,并且类也分不同的类型:抽象类和final类等.除了上述提到的几种类型,Java还有一些特殊类,如:内部类,匿名类.Java包包主要用来对类和接口进行分类,当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。import语句在Java中,如果给出一个完整的限定名,包括包名,类名,那么Java编译器就可以很容易地定位到源代码或者类.import语句就是用来提供一个合理的路径,使得编译器可以找到某个类.例如,下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类. import java.io.*;","categories":[{"name":"JavaBasics","slug":"JavaBasics","permalink":"https://zero024.cn/categories/JavaBasics/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zero024.cn/tags/Java/"}]},{"title":"Hexo+Git搭建个人博客","slug":"Other/hexo-git搭建个人博客","date":"2018-12-04T01:48:13.000Z","updated":"2020-03-25T01:05:27.425Z","comments":true,"path":"Other/hexo-build-blog.html","link":"","permalink":"https://zero024.cn/Other/hexo-build-blog.html","excerpt":"前言基于hexo+github pages服务搭建博客,快速,便捷,免费的搭建属于自己的个人博客 1.准备工作在开始一切之前,你必须已经: 有一个github账号,没有的话去注册一个 电脑 安装 了node.js,npm,并了解相关基础知识 安装了git for windows (或其他git客户端工具)","text":"前言基于hexo+github pages服务搭建博客,快速,便捷,免费的搭建属于自己的个人博客 1.准备工作在开始一切之前,你必须已经: 有一个github账号,没有的话去注册一个 电脑 安装 了node.js,npm,并了解相关基础知识 安装了git for windows (或其他git客户端工具) 2.创建仓库 新建一个名为 用户名.github.io的仓库.比如说,如果你的github用户名是test 那么你就新建test.github.io的仓库(必须是你的用户名,其他的无效) 然后你的网站访问地址就是http://test.github.io 了注意几个地方: 注册的邮箱一定要验证,否则不会成功 仓库名字必须是:username.github.io,其中username就是你的用户名 仓库创建成功不会立即生效,需要过一段时间(等待github分配网站域名等) 3.绑定域名 域名配置最常见有2种方式,CNAME和A记录,CNAME填写域名,A记录填写IP 由于不带WWW方式只能采用A记录,所以先ping一下username.github.io的IP 然后到你的域名DNS设置页,将A记录指向你ping出来的IP,将CNAME指向:yourname.github.io 这样可以保证无论是否添加WWW都可以访问 例: 记录类型:A 主机记录:@ 解析线路默认 记录值:IP 记录类型:CNAME 主机记录:www 解析线路默认 记录值:username.github.io 然后到你的github项目跟目录新建一个名为CNAME的文件(无后缀),里面填写你自定义的域名 4.配置SSH key提交代码需要github权限才可以,这里使用ssh key来解决本地和服务器的连接问题 $ cd ~&#x2F;.ssh # 检查本机已存在的ssh秘钥 如果提示:”No such file or directory”说明你是第一次使用git ssh-keygen -t rsa -C &#39;your email@example.com&#39; 一般情况下直接默认值就行,所以不用设置密码,一路回车就行最终会在.ssh目录下生成两个文件,id_rsa和id_rsa.pub,这两个就是SSH Key的密钥对id_rsa是私钥,不能泄露! cat id_rsa.pub 复制输出的内容,打开你的github主页,打开”Account settings”&gt;&gt;”SSH keys”页面 点击 ‘Add SSH Key’,填上任意title,在Key文本框内粘贴id_rsa.pub文件的内容 点击 ‘Add Key’,就成功添加Key了测试是否成功 $ ssh -T git@github.com 如果提示”Are you sure you want to continum connecting (yes/no)?” 输入yes,就会看到 Hi zero6996! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 说明SSH配置成功!此时你还需要配置: $ git config --global user.name &#39;zero6996&#39; #你的github用户名 $ git config --global user.email &#39;youremail@xx.com&#39; #你的github注册email 5.hexo简介Hexo是一个简单,快速,强大的基于GitHub Pages的博客发布工具,支持Markdown格式,有众多优秀的插件和主题官网Github 5.1.安装注意事项 很多命令既可以用Windows的cmd来完成,也可以使用git bash来完成,但是部分命令会有一些问题,为避免不必要的问题,这里统一使用git bash来执行 hexo不同版本差别较大,网上很文章的配置信息都是基于2.x的,所以注意不要被误导 hexo有两种”_config.yml” 文件,一个是跟目录下的全局的”_config.yml” , 一个是各个”theme” 下的 安装完node和npm以后,将npm替换为淘宝镜像,执行以下命令即可将,后续命令全部以cnpm执行 npm install -g cnpm --registry=https:&#x2F;&#x2F;registry.npm.taobao.org 5.2.安装 $ cnpm install -g hexo 5.3.初始化在本地新建一个名为hexo的文件夹(名字任意取),这里作为一个你存放代码的地方,比如我是D:\\hexo $ cd &#x2F;d&#x2F;hexo # 进入文件夹 $ hexo init # 初始化 hexo会自动下载一些文件到这个目录,包括node_modules,目录结构 $ ls _config.yml node_modules&#x2F; package-lock.json scaffolds&#x2F; themes&#x2F; db.json package.json public&#x2F; source&#x2F; $ hexo g # 生成 $ hexo s # 启动服务 执行上述命令之后,hexo就会在public文件夹生成相关html文件,这些文件后续会提交到github上去 “hexo s”是开启本地预览服务,打开浏览器访问localhost:4000即可看到博客内容. 如果无显示内容或拒绝访问,就是端口占用的问题,重新开启服务,使用”hexo s -p 8888”指定端口 5.4.修改主题hexo社区有丰富的主题可选,从官网主题自己挑选下载 下载主题(以hexo-theme-yilia为例): $ cd &#x2F;d&#x2F;hexo&#x2F; $ git clone git@github.com:litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia # 从github克隆主题,到本地的themes&#x2F;yilia文件夹 下载的主题都在hexo/themes文件夹内 $ cd themes $ ls landscape&#x2F; yilia&#x2F; 修改”_config.yml”中的”theme: landscape”改为”theme: yilia”,然后重新执行”hexo g”来生成页面如果出现一些莫名其妙的问题,可以先执行”hexo clean”来清理一下public的内容,然后再来重新生成和发布 5.5.上传之前上传代码到github之前,记得备份以前的所有代码,因为hexo提交代码时会把你以前的所有代码都删除 5.6.上传到Github如果你一切都配置好了,发布上传只需要”hexo d”就可以了,当然关键是所有东西都配置好首先,”ssh key”肯定要配置好其次,配置”_config.yml”中有关deploy的部分: #正确写法 deploy: type: git repository: git@github.com:zero6996&#x2F;zero6996.github.io.git branch: master 如果报如下错误: Deployer not found: github 或者 Deployer not found: git 原因是还需安装一个插件: cnpm install hexo-deployer-git --save 安装无误,输入github账户密码,输入”hexo d”就会将本次有改动的代码全部提交,没有改动的不会 5.7.常用hexo命令 hexo new &#39;postName&#39; # 新建文章 hexo new page &#39;pageName&#39; # 新建页面 hexo generate # 生成静态页面至public目录 hexo server # 开启预览访问端口(默认4000,使用-p可更换端口) hexo deploy # 部署至Github hexo help # 查看帮助 hexo version # 查看版本 以上命令均可缩写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 以及组合命令: hexo s -g # 生成页面并本地预览 hexo d -g # 生成页面并上传 hexo s -p # 本地预览并改变端口 5.8._config.yml这里面都是一些全局配置,每个参数意思都比较简单明了,需要注意的是冒号后面必须有一个空格 6.写博客进入hexo根目录,执行命令: hexo new &#39;my-first-blog&#39; hexo会帮我们在_posts下生成相关的md文件,我们只需要打开这个文件就可以开始写博客了 一般完整格式如下: --- title: postName # 文章页面上的显示名称,一般是中文 date: 2018-12-5 15:46:10 # 文章生成时间,一般不用改,也可自定义 categories: 默认分类 # 分类 tags: [tag1,tag2,tag3] # 文章标签,可空,多标签请用格式 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面 --- 以下是正文内容 hexo new page ‘my-second-blog’ 生成的是:index.md,它不会作为文章出现在博客目录 6.1.写博客工具 个人使用的是 ‘Visual Studio Code’ IDE 6.2.如何让博文列表不显示全部内容默认情况下,生成的博文目录会显示全部文章内容,如何设置文章摘要长度呢? 可以在合适的位置加上’‘即可,显示在页面上的效果就是新增了一个’more&gt;&gt;’功能选项,查看更多内容 7.关于缺失模块缺失模块 请确保node版本大于6.2 在博客根目录（注意不是yilia根目录）执行以下命令: cnpm i hexo-generator-json-content --save 在根目录_config.yml里添加配置： jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 参考自 以上内容整理参考自文章","categories":[{"name":"Other","slug":"Other","permalink":"https://zero024.cn/categories/Other/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zero024.cn/tags/Hexo/"}]}]}