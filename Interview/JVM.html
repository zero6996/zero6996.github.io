<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="JVM基础和GC, Zero的博客">
    <meta name="description" content="1. JVM体系结构概述JVM是运行在操作系统之上的，它与硬件没有直接的交互，下图示JVM体系结构图：


1. 类装载器(ClassLoader)负责加载class文件，class文件在文件开头有特定的文件标识(cafe babe)，将c">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>JVM基础和GC | Zero的博客</title>
    <link rel="icon" type="image/jpeg" href="/wlop.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    

</head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/" class="waves-effect waves-light">
                        
                        <img src="/medias/logo.png" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span">Zero的博客</span>
                    </a>
                </div>
                

<a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search" title="搜索"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Zero的博客</div>
        <div class="logo-desc">
            
            欢迎来到我的博客！
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/zero6996" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Follow Me 秋梨膏~
            </a>
        </li>
        
    </ul>

    <div class="social-link">
    <a href="https://github.com/zero6996" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:1490829140@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1490829140" class="tooltipped" data-tooltip="QQ联系我: 1490829140" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
</div>

            </div>
        </div>

        
        <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/zero6996" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Follow Me 秋梨膏~" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>
</header>





<div class="bg-cover post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        JVM基础和GC
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JVM/" target="_blank">
                                <span class="chip bg-color">JVM</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Interview/" class="post-category" target="_blank">
                                Interview
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-04-05
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        6.6k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        23 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="1-JVM体系结构概述"><a href="#1-JVM体系结构概述" class="headerlink" title="1. JVM体系结构概述"></a>1. JVM体系结构概述</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互，下图示JVM体系结构图：</p>
<a id="more"></a>
<p><img src="http://yanxuan.nosdn.127.net/12f295b0fb04302be7b78f8f1b07964c.png" alt="JVM体系结构概览"></p>
<h3 id="1-类装载器-ClassLoader"><a href="#1-类装载器-ClassLoader" class="headerlink" title="1. 类装载器(ClassLoader)"></a>1. 类装载器(ClassLoader)</h3><p>负责加载class文件，class文件在文件开头有特定的文件标识(<code>cafe babe</code>)，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构；并且ClassLoader只负责<strong>class文件的加载</strong>，至于它是否可以运行，则由Execution Engine决定。</p>
<p><img src="http://yanxuan.nosdn.127.net/1d33cee2d7a76915d726597771876579.png" alt="ClassLoader"></p>
<h4 id="1-1-类加载器的种类"><a href="#1-1-类加载器的种类" class="headerlink" title="1.1 类加载器的种类"></a>1.1 类加载器的种类</h4><ul>
<li>虚拟机自带的加载器<ul>
<li><code>Bootstrap ClassLoader</code>：C++语言写的根平台加载器，系统类加载器</li>
<li><code>Extension ClassLoader</code>：Java语言写的扩展类加载器，JDK9之后为平台类加载器(PlatformClassLoader)</li>
<li><code>Application ClassLoader</code>：应用程序类加载器</li>
</ul>
</li>
<li>用户自定义加载器<ul>
<li>Java.lang.ClassLoader的子类，用户可以定制类的加载方式</li>
</ul>
</li>
</ul>
<h4 id="1-2-双亲委派机制"><a href="#1-2-双亲委派机制" class="headerlink" title="1.2 双亲委派机制"></a>1.2 双亲委派机制</h4><p>当一个类收到了类加载请求，它首先不会去尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一层次类加载器都是如此，因此所有的加载请求都应该传递到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求时(它自己的加载路径下无法找到所需的类)，子类加载器才会尝试自己去加载。</p>
<ul>
<li>好处：采用双亲委派的一个好处就是比如加载位于rt.jar包中的类<code>java.lang.Object</code>，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同一个Object对象。</li>
</ul>
<blockquote>
<p>双亲委派机制保证了沙箱安全</p>
</blockquote>
<h3 id="2-执行引擎"><a href="#2-执行引擎" class="headerlink" title="2. 执行引擎"></a>2. 执行引擎</h3><p>Execution Engine执行引擎负责解释命令，提交给操作系统执行。输入的是<strong>字节码文件</strong>，处理过程是<strong>字节码解析</strong>，输出的是<strong>执行结果</strong>。</p>
<h3 id="3-本地接口"><a href="#3-本地接口" class="headerlink" title="3. 本地接口"></a>3. 本地接口</h3><p>Native Interface本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生时正是C/C++横行的时候，要想立足，必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies(本地方法库)。</p>
<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备；在现在的企业级应用中已经很少见了。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等。</p>
<h4 id="3-1-Native-Method-Stack"><a href="#3-1-Native-Method-Stack" class="headerlink" title="3.1 Native Method Stack"></a>3.1 Native Method Stack</h4><p>本地方法栈的具体做法是再其方法栈中登记native方法，在Execution Engine执行时加载本地方法库。</p>
<h3 id="4-PC寄存器"><a href="#4-PC寄存器" class="headerlink" title="4. PC寄存器"></a>4. PC寄存器</h3><p>每个线程都有一个程序计数器，是线程私有的，<font color="red">就是一个指针</font>，指向方法区中的方法字节码(<strong>用来存储指向下一条指令的地址，也即将要执行的指令代码</strong>)，由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计，因此不会引起GC问题。</p>
<p>这块内存区域很小，它是当前线程所执行的字节码的<strong>行号指示器</strong>，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<ul>
<li>如果执行的是一个Native方法，那这个计数器为空。</li>
<li>主要用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出(OutOfMemory=OOM)错误。</li>
</ul>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>供各<strong>线程共享</strong>的运行时内存区域。<font color="red">它存储了每个类的结构信息，就是模板</font>；例如运行时常量池(Runtime Constant Pool)、字段和方法数据、构造函数和普通方法的字节码内容。上面讲的<strong>是规范</strong>，具体实现不同虚拟机是不同的，最典型的就是永久代(PermGen Space)和元空间(Mate Space)。</p>
<h3 id="6-栈"><a href="#6-栈" class="headerlink" title="6. 栈"></a>6. 栈</h3><p>栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，<strong>对于栈来说不存在垃圾回收问题</strong>，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。<font color="red">8种基本类型的变量+对象引用的变量+实例方法都是在函数的栈内存中分配的。</font></p>
<h4 id="6-1-栈存储"><a href="#6-1-栈存储" class="headerlink" title="6.1 栈存储"></a>6.1 栈存储</h4><p>栈帧中主要保存3类数据：</p>
<ul>
<li>本地变量(Local Variables)：输入参数和输出参数以及方法内的变量；</li>
<li>栈操作(Operand Stack)：记录出栈、入栈的操作；</li>
<li>栈帧数据(Frame Data)：包括类文件、方法等。</li>
</ul>
<blockquote>
<p><strong>栈帧</strong>：在java中的方法，到了栈中就是栈帧；即<strong>方法=栈帧。</strong></p>
</blockquote>
<h4 id="6-2-栈运行原理"><a href="#6-2-栈运行原理" class="headerlink" title="6.2 栈运行原理"></a>6.2 栈运行原理</h4><p>栈中的数据都是以栈帧(Stack Frame)的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集；当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，B方法又调用了C方法，于是产生栈帧F3被压入栈，以此类推…；执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧….，遵循“先进后出(Frist In Last Out)”原则。</p>
<p>每个<strong>方法执行同时都会创建一个栈帧</strong>，用于<strong>存储局部变量表、操作数栈、动态链接、方法出口</strong>等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在<code>256K~756K</code>之间，约等于1MB左右。</p>
<p><img src="http://yanxuan.nosdn.127.net/680b77fb42288aa335d28704f7f19e7a.png" alt="Java Stack"></p>
<p>如上图示在一个栈中有两个栈帧：</p>
<ul>
<li>栈帧2是最先被调用的方法，先入栈；</li>
<li>然后方法2又调用了方法1，栈帧1处于栈顶的位置；</li>
<li>栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2；</li>
<li>线程结束，栈释放。</li>
</ul>
<p>每执行一个方法都会产生一个栈帧，保存到栈的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。</p>
<h4 id="6-3-堆栈溢出"><a href="#6-3-堆栈溢出" class="headerlink" title="6.3 堆栈溢出"></a>6.3 堆栈溢出</h4><p>Java默认的栈大小是有限的，当一个程序不停的入栈但是不出栈，当<strong>栈被压满</strong>后爆栈了，就会产生<strong>错误</strong>：<code>Exception in thread &quot;main&quot; java.lang.StackOverflowError</code>。</p>
<h4 id="6-4-堆-栈-方法区的交互关系"><a href="#6-4-堆-栈-方法区的交互关系" class="headerlink" title="6.4 堆+栈+方法区的交互关系"></a>6.4 堆+栈+方法区的交互关系</h4><p><img src="http://yanxuan.nosdn.127.net/d126ec1984e33cd7d4271157e1754e86.png" alt="堆栈方法区"></p>
<p>HotSpot是使用指针的方式来访问对象的：Java堆中会存放访问类元数据(就是访问方法区的模板)的地址，reference存储的就直接是对象的地址(堆中存放的都是new的实际对象数据)。</p>
<blockquote>
<p>栈管运行，堆管存储</p>
<p>HotSpot是Java目前使用范围最广的Java虚拟机。</p>
</blockquote>
<h2 id="2-堆体系结构概述"><a href="#2-堆体系结构概述" class="headerlink" title="2. 堆体系结构概述"></a>2. 堆体系结构概述</h2><h3 id="2-1-Heap堆结构简介"><a href="#2-1-Heap堆结构简介" class="headerlink" title="2.1 Heap堆结构简介"></a>2.1 Heap堆结构简介</h3><p>一个JVM实例只存在一个堆内存，堆内存的大小是可调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分：</p>
<ul>
<li>Young Generation Space(新生区)，简称<strong>Young/New</strong></li>
<li>Tenure Generation Space(养老区)，简称<strong>Old/Tenure</strong></li>
<li>Permanent Space(永久区)，简称<strong>Perm</strong></li>
</ul>
<p><img src="http://yanxuan.nosdn.127.net/c998367d6099f58618557e3b1010b94d.png" alt="Heap"></p>
<p>上图就是Java7之前的堆结构体系图，Java8之后<strong>永久存储区改名为了元空间</strong>。</p>
<h3 id="2-2-Heap堆new对象流程"><a href="#2-2-Heap堆new对象流程" class="headerlink" title="2.2 Heap堆new对象流程"></a>2.2 Heap堆new对象流程</h3><p>新生区是类诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区(Eden Space)和幸存者区(Survivor Space)，所有类都是在伊甸园区被new出来的。幸存者区有两个：0区(Survivor 0 Space)和1区(Survivor 1 Space)。</p>
<p>当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC，又称轻GC)，将伊甸园区中的无引用对象进行销毁。然后将会将伊甸园中剩余的对象移动到幸存者0区；若幸存者0区也满了，再对该区域进行垃圾回收，然后移动到1区。如果1区也满了，将移动到养老区，若最后养老区也满了，那么这时将产生(Major GC，又叫Full GC)，对养老区的内存进行清理。若养老区多次执行Full GC后依然无法腾出空间进行对象保存，就会产生OOM异常：<code>OutOfMemoryError</code>.</p>
<blockquote>
<p>如出现<code>java.lang.OutOfMemoryError:Java heap sapce</code>，说明Java虚拟机的堆内存不够，原因有二：</p>
<ol>
<li>Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用，故无法GC)。</li>
</ol>
</blockquote>
<h3 id="2-3-TransferValue"><a href="#2-3-TransferValue" class="headerlink" title="2.3 TransferValue"></a>2.3 TransferValue</h3><p>面试题：<code>str</code>打印什么？</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public class TestTransferValue {
    public void changeValue(String str){
        str = &quot;xxx&quot;;
    }

    public static void main(String[] args) {
        String str = &quot;abc&quot;;
        test.changeValue(str);
        System.out.println(&quot;String------&quot;+str);
    }
}
</code></pre>
<h3 id="2-4-对象生命周期和GC"><a href="#2-4-对象生命周期和GC" class="headerlink" title="2.4 对象生命周期和GC"></a>2.4 对象生命周期和GC</h3><p>Java堆从GC的角度还可细分为<strong>新生代</strong>(Eden 区、Form Survivor区和To Survivor区)和<strong>老年代</strong>，堆结构如下图：</p>
<p><img src="http://yanxuan.nosdn.127.net/d4182b6178d78b50471871943b10ac67.png" alt="Heap"></p>
<h4 id="2-4-1-MinorGC的过程：-复制-gt-清空-gt-互换"><a href="#2-4-1-MinorGC的过程：-复制-gt-清空-gt-互换" class="headerlink" title="2.4.1 MinorGC的过程：(复制-&gt;清空-&gt;互换)"></a>2.4.1 MinorGC的过程：(复制-&gt;清空-&gt;互换)</h4><ul>
<li>复制：Eden、SurvivorFrom复制到SurvivorTo，年龄+1</li>
</ul>
<p>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC时会扫描Eden区和From区，对这两个区域进行垃圾回收；经过这次回收后还存活的对象，则直接<strong>拷贝到To区</strong>(如果有对象年龄达到老年标准，则复制到老年代区)，同时把这些<strong>对象的年龄+1</strong>。</p>
<ul>
<li>清空：清空Eden、SurvivorFrom</li>
</ul>
<p>复制操作完毕后，会清空Eden和SurvivorFrom中的对象。</p>
<ul>
<li>互换：SurvivorTo和SurvivorFrom互换</li>
</ul>
<p>最后，SurvivorTo和SurvivorFrom身份互换，即<strong>复制之后有交换，谁空谁是To</strong>，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中来回复制，增加年龄；如此交换15次(由JVM参数<code>MaxTenuringThreshold</code>决定，该参数默认15)，最终还存活的，就会进入老年代。</p>
<h4 id="2-4-2-HotSpot内存管理"><a href="#2-4-2-HotSpot内存管理" class="headerlink" title="2.4.2 HotSpot内存管理"></a>2.4.2 HotSpot内存管理</h4><p><img src="http://yanxuan.nosdn.127.net/e6fbcbfc76ae8c09b5de10d95a6f9c28.png" alt="分代管理"></p>
<p>物理上堆实际只有新生代和老年代，Java中98%的对象是临时对象，在Eden生Eden死，只有极少数才能到老年代。</p>
<h3 id="2-5-永久代-元空间"><a href="#2-5-永久代-元空间" class="headerlink" title="2.5 永久代(元空间)"></a>2.5 永久代(元空间)</h3><p>方法区(Method Area)和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，<font color="red">虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。</font></p>
<p>对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)”，但严格本质上说两者不同，或者说是使用永久代实现方法区而已，<strong>永久代是方法区的一个实现(相当于方法区是一个接口规范，而永久代就是接口实现)</strong>，JDK7的版本中，已经将原本放在永久代的字符串常量池移走，移动到堆中了。</p>
<h4 id="2-5-1-永久区-Java7之前"><a href="#2-5-1-永久区-Java7之前" class="headerlink" title="2.5.1 永久区(Java7之前)"></a>2.5.1 永久区(Java7之前)</h4><p>永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class，Interface的元数据(比如rt.jar包内容、Spring框架必须jar包等等)，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占有的内存。</p>
<h2 id="3-堆参数调优入门"><a href="#3-堆参数调优入门" class="headerlink" title="3. 堆参数调优入门"></a>3. 堆参数调优入门</h2><p>以下内容以JDK1.8+Hotspot为例。</p>
<p><img src="http://yanxuan.nosdn.127.net/f1c18c8ba74c941692faeb8baa895d76.png" alt="Heap"></p>
<p>JDK1.8后将永久代取消了，由元空间取代，元空间的本质和永久代类似；元空间与永久代之间最大的区别在于：永久代使用的是JVM的堆内存，但Java8以后的<font color="red">元空间并不在虚拟机中而是使用本机物理内存。</font></p>
<p>因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入Native Memory，字符串池和类的静态变量放入Java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p>
<h3 id="3-1-堆参数调整"><a href="#3-1-堆参数调整" class="headerlink" title="3.1 堆参数调整"></a>3.1 堆参数调整</h3><p>以下是堆的几个重要的参数：</p>
<ul>
<li><code>-Xms</code>：初始大小，默认为物理内存的1/64；</li>
<li><code>-Xmx</code>：最大分配内存，默认为物理内存的1/4；</li>
<li><code>-XX:+PrintGCDetails</code>：输出详细的GC处理日志。</li>
</ul>
<p>Java将运行时数据区抽象成了一个类：<code>Runtime</code>，使用这个类的一些API可以查看一些堆参数</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public class HeapDemo {
    public static void main(String[] args) {
        System.out.println(&quot;CPU核心数:&quot;+Runtime.getRuntime().availableProcessors());
        System.out.println(&quot;-Xms:TOTAL_MEMORY = 虚拟机中的内存总量:&quot;+(Runtime.getRuntime().totalMemory())&#x2F;(double)1024&#x2F;1024+&quot;MB&quot;);
        System.out.println(&quot;-Xmx:MAX_MEMORY = 虚拟机试图使用的最大内存量:&quot;+(Runtime.getRuntime().maxMemory()&#x2F;(double)1024&#x2F;1024)+&quot;MB&quot;);
    }
}
</code></pre>
<h3 id="3-2-GC收集日志信息"><a href="#3-2-GC收集日志信息" class="headerlink" title="3.2 GC收集日志信息"></a>3.2 GC收集日志信息</h3><p>为了清晰明了的查看堆中的各种GC情况，编写以下测试类测试内存溢出，并查看GC详细日志。</p>
<ul>
<li>编写测试类</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public class HeapDemo {
    public static void main(String[] args) {
        String str = &quot;hello&quot;;
        while (true){
            &#x2F;&#x2F; Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
            str += str + new Random().nextInt(88888888) + new Random().nextInt(99999999);
        }
        &#x2F;&#x2F;        byte[] bytes = new byte[40 * 1024 * 1024];
    }
}
</code></pre>
<ul>
<li>在IDEA中配置参数：<code>-Xms10m -Xmx10m -XX:+PrintGCDetails</code>，将堆的内存设小。</li>
</ul>
<p><img src="http://yanxuan.nosdn.127.net/f2f0399f7a98d26814441c5b04508c2e.png" alt="Heap Parameter"></p>
<ul>
<li>运行程序，查看日志信息。</li>
</ul>
<p><img src="http://yanxuan.nosdn.127.net/bed54395e723f536a4fa39ba52bcd45d.png" alt="GCLog"></p>
<ul>
<li>GC信息查看模板如下：</li>
</ul>
<p><img src="http://yanxuan.nosdn.127.net/00ffe9b304ed8429f296989f636b8894.png" alt="GC"></p>
<ul>
<li>FGC模板</li>
</ul>
<p><img src="http://yanxuan.nosdn.127.net/88e855c3f353edd0ca601221e6332448.png" alt="FGC"></p>
<h2 id="4-GC垃圾回收"><a href="#4-GC垃圾回收" class="headerlink" title="4. GC垃圾回收"></a>4. GC垃圾回收</h2><h3 id="4-1-GC是什么-分代收集算法"><a href="#4-1-GC是什么-分代收集算法" class="headerlink" title="4.1 GC是什么(分代收集算法)"></a>4.1 GC是什么(分代收集算法)</h3><p>GC是Java的垃圾回收机制，主要可以概括为以下几点：</p>
<ul>
<li>次数上频繁收集Young区</li>
<li>次数上较少收集Old区</li>
<li>基本不动元空间</li>
</ul>
<h3 id="4-2-GC算法概述"><a href="#4-2-GC算法概述" class="headerlink" title="4.2 GC算法概述"></a>4.2 GC算法概述</h3><p><img src="http://yanxuan.nosdn.127.net/91c8be58bd03e0baf762d77d33c40890.png" alt="GC概述"></p>
<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收的都是新生代。因此GC按照回收区域又分了两种类型，一种是普通GC(Minor GC)，一种是全局GC(Major GC or Full GC)。</p>
<h4 id="4-2-1-Minor-GC和Full-GC的区别"><a href="#4-2-1-Minor-GC和Full-GC的区别" class="headerlink" title="4.2.1 Minor GC和Full GC的区别"></a>4.2.1 Minor GC和Full GC的区别</h4><ul>
<li>普通GC：只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所有Minor GC非常频繁，一般回收速度也比较快。</li>
<li>全局GC：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC(并非绝对的)；Major GC的速度一般要比Minor GC慢上10倍以上。</li>
</ul>
<h3 id="4-3-四大算法之：引用计数法"><a href="#4-3-四大算法之：引用计数法" class="headerlink" title="4.3 四大算法之：引用计数法"></a>4.3 四大算法之：引用计数法</h3><p><img src="http://yanxuan.nosdn.127.net/8f44594f7894884b1d47abce7b59461a.png" alt="引用计数法"></p>
<h3 id="4-4-四大算法之：复制算法-Copying"><a href="#4-4-四大算法之：复制算法-Copying" class="headerlink" title="4.4 四大算法之：复制算法(Copying)"></a>4.4 四大算法之：复制算法(Copying)</h3><p><strong>年轻代</strong>中使用的是Minor GC，这种GC算法采用的就是复制算法。</p>
<h4 id="4-4-1-Minor-GC原理"><a href="#4-4-1-Minor-GC原理" class="headerlink" title="4.4.1 Minor GC原理"></a>4.4.1 Minor GC原理</h4><p><img src="http://yanxuan.nosdn.127.net/bf44ebec2b2413603977993ed5683d9b.png" alt="堆结构图"></p>
<p>Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的存活对象就被移到Old代中，也即一旦收集后，Eden区就变成空的了。当对象在Eden(包括一个Survivor 区域，假设是From区域)出生后，经过一次Minor GC后，如果对象还存活，且能够被另外一块Survivor区域所容纳(上面假设是from区，那么这里就是to区，即to区域有足够的内存空间来存储Eden和from区中存活的对象)，则使用复制算法将这些仍然存活的对象复制到另外一块Survivor区(即to区)中，然后清理所使用过的Eden区以及Survivor区(即from区)， 并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过<code>-XX:MaxTenuringThreshold</code>来设定参数)，这些对象就会成为老年代。</p>
<ul>
<li><code>-XX:MaxTenuringThreshold</code> ：设置对象在新生代中存活的次数    </li>
</ul>
<h4 id="4-4-2-复制算法详细运行步骤"><a href="#4-4-2-复制算法详细运行步骤" class="headerlink" title="4.4.2 复制算法详细运行步骤"></a>4.4.2 复制算法详细运行步骤</h4><p><strong>HotSpot JVM</strong>将年轻带分为了三部分：<strong>1个Eden区和2个Survivor区</strong>(分别叫from和to)。默认比例为<strong>8:1:1</strong>，一般情况下，<strong>新</strong>创建的对象都会被分配到<strong>Eden区</strong>(一些大对象会特殊处理)，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到<strong>Survivor区</strong>。</p>
<p>对象在Survivor区中每熬过一次Minor GC，年龄就会<strong>增加一岁</strong>，当它的年龄到一定程度后，就会被移动到老年代。因为年轻代中的对象基本都是朝生夕死(90%以上)，所以在<strong>年轻代的垃圾回收算法使用的是复制算法</strong>，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。<strong>复制算法是不会产生内存碎片的。</strong></p>
<p><img src="http://yanxuan.nosdn.127.net/1941abf352c68e64f498523fecac9094.png" alt="复制算法"></p>
<p>在GC开始时，对象只会存在于Eden区和名为”From”的Survivor区，Survivor区的”To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到”To”，而在”From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移到到年老代中，没有达到阈值的对象会被复制到”To”区域。</p>
<p>经过这次GC后，Eden区和From区已经被清空。这时，”From”和”To”会<strong>交换他们的角色</strong>，也就是新的”To”就是上次GC前的”From”，新的”From”就是上次GC前的”To”。</p>
<p>不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到”To”区被填满，”To”区被填满后，会将所有对象移动到年老代中。</p>
<p><img src="http://yanxuan.nosdn.127.net/cfc8f3ea53603eda81f723d6632cda1c.png" alt="复制算法图示"></p>
<p>因为Eden区对象一般存活率较低，通常使用两块10%的内存作为空闲和活动区间，另外80%的内存用于给新建对象分配内存的。</p>
<p>一旦发生GC，将10%的from活动区间与另外80%中<strong>存活的</strong>Eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，依次类推。</p>
<h4 id="4-4-3-复制算法的劣势"><a href="#4-4-3-复制算法的劣势" class="headerlink" title="4.4.3 复制算法的劣势"></a>4.4.3 复制算法的劣势</h4><ol>
<li>它会浪费了一半内存；</li>
<li>如果对象的存活率过高，假设是100%，那么需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变得不可忽视。所以从以上描述不难看出，复制算法想要使用，最起码对象的存活率要非常低才行，而且最重要的是，必须克服50%内存的浪费。</li>
</ol>
<blockquote>
<p>简言之：复制算法优点速度快，缺点耗内存，<strong>空间换时间。</strong></p>
</blockquote>
<h3 id="4-5-四大算法之：标记清除-Mark-Sweep"><a href="#4-5-四大算法之：标记清除-Mark-Sweep" class="headerlink" title="4.5 四大算法之：标记清除(Mark-Sweep)"></a>4.5 四大算法之：标记清除(Mark-Sweep)</h3><p><strong>老年代</strong>一般是由标记清除或者是标记清除与标记整理的混合实现。</p>
<h4 id="4-5-1-原理"><a href="#4-5-1-原理" class="headerlink" title="4.5.1 原理"></a>4.5.1 原理</h4><p>算法分成<strong>标记和清除</strong>两个阶段，先标记出要回收的对象，然后统一回收这些对象</p>
<p><img src="http://yanxuan.nosdn.127.net/08ef0f765737522efedbe254227093eb.png" alt="标记清除"></p>
<p>用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将<strong>程序暂停</strong>，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。 </p>
<p>主要进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li>标记：从引用根节点开始标记遍历所有的GC Roots， 先标记出要回收的对象。</li>
<li>清除：遍历整个堆，把标记的对象清除。 </li>
</ul>
<h4 id="4-5-2-标记清除的优缺点"><a href="#4-5-2-标记清除的优缺点" class="headerlink" title="4.5.2 标记清除的优缺点"></a>4.5.2 标记清除的优缺点</h4><ul>
<li>优点：不需要额外的空间，节省内存</li>
<li>缺点：<ul>
<li>首先，它的缺点就是<strong>效率比较低</strong>（递归与全堆对象遍历），而且在进行GC的时候，需要<strong>停止应用程序</strong>，这会导致用户体验非常差劲；</li>
<li>其次，主要的缺点则是这种方式清理出来的<strong>空闲内存是不连续</strong>的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。   </li>
</ul>
</li>
</ul>
<blockquote>
<p>简言之：标记清除算法优点节省内存，缺点两次扫描耗时严重且会产生内存碎片；<strong>时间换空间</strong>。</p>
</blockquote>
<h3 id="4-6-四大算法之：标记压缩-Mark-Compact"><a href="#4-6-四大算法之：标记压缩-Mark-Compact" class="headerlink" title="4.6 四大算法之：标记压缩(Mark-Compact)"></a>4.6 四大算法之：标记压缩(Mark-Compact)</h3><p><strong>老年代</strong>一般是由标记清除或者是标记清除与标记整理的混合实现。</p>
<h4 id="4-6-1-原理"><a href="#4-6-1-原理" class="headerlink" title="4.6.1 原理"></a>4.6.1 原理</h4><p><img src="http://yanxuan.nosdn.127.net/9e17861745a6a56bc4599b6eb73b3d20.png" alt="标记压缩"></p>
<p>在整理压缩阶段，不再对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<p>标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价；当然并非没有缺点。</p>
<h4 id="4-6-2-劣势"><a href="#4-6-2-劣势" class="headerlink" title="4.6.2 劣势"></a>4.6.2 劣势</h4><p>标记/整理算法唯一的缺点就是<strong>效率也不高</strong>，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 </p>
<h3 id="4-7-小结"><a href="#4-7-小结" class="headerlink" title="4.7 小结"></a>4.7 小结</h3><p>GC算法对比：</p>
<ul>
<li>内存效率：复制算法&gt;标记清除算法&gt;标记整理算法(只是简单的对比时间复杂度，实际情况不一定)</li>
<li>内存整齐度：复制算法=标记整理算法&gt;标记清除算法</li>
<li>内存利用率：标记整理算法=标记清除算法&gt;复制算法</li>
</ul>
<p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程</p>
<p>难道就没有一种最优算法吗？ 回答：无，没有最好的算法，只有最合适的算法。==========&gt;分代收集算法。 </p>
<ul>
<li>年轻代(Young Gen)</li>
</ul>
<p>年轻代特点是区域相对老年代较小，对像存活率低。 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<ul>
<li>老年代(Tenure Gen)</li>
</ul>
<p>老年代的特点是区域较大，对像存活率高。 这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</p>
<p>Mark阶段的开销与存活对像的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。</p>
<p>Sweep阶段的开销与所管理区域的大小形正相关，但Sweep“就地处决”的特点(原地操作)，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。</p>
<p>Compact阶段的开销与存活对像的数据成开比，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。</p>
<p>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。    </p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><h3 id="5-1-小结-amp-面试题"><a href="#5-1-小结-amp-面试题" class="headerlink" title="5.1 小结&amp;面试题"></a>5.1 小结&amp;面试题</h3><ol>
<li>JVM结构<ol>
<li>有哪几种类加载器？</li>
<li>双亲委派机制</li>
<li>沙箱安全</li>
</ol>
</li>
<li>Native<ol>
<li>native是一个关键字么？</li>
<li>native方法只有声明，没有实现。</li>
</ol>
</li>
<li>寄存器<ol>
<li>记录了方法之间的调用和执行情况，类似排班值日表；用来存储指向下一条指令的地址，也即将要执行的指令代码，它是当前线程所执行的字节码的<strong>行号指示器</strong>。</li>
</ol>
</li>
</ol>

            </div>
            <hr>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="https://zero024.cn" class="b-link-green">Zero的博客</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/Interview/JVM.html" class="b-link-green">JVM基础和GC</a>
                </p>
            </div>
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '232778317d016c12944b',
        clientSecret: 'eff34508ca3902812960cd0c524ad0300bae98d8',
        repo: 'blog-comments',
        owner: 'zero6996',
        admin: "zero6996",
        id: '2020-04-05T23-33-00',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-dot-circle-o"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/Interview/JVM.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="JVM基础和GC">
                        
                        <span class="card-title">JVM基础和GC</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">1. JVM体系结构概述JVM是运行在操作系统之上的，它与硬件没有直接的交互，下图示JVM体系结构图：


1. 类装载器(ClassLoader)负责加载class文件，class文件在文件开头有特定的文件标识(cafe babe)，将c</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-04-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Interview/" class="post-category" target="_blank">
                                    Interview
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JVM/" target="_blank">
                        <span class="chip bg-color">JVM</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/DataBase/master-slave-replication.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="MySQL主从复制">
                        
                        <span class="card-title">MySQL主从复制</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">主从复制 主从复制（也称 AB 复制）允许将来自一个MySQL数据库服务器（主服务器）的数据复制到一个或多个MySQL数据库服务器（从服务器）。 

1. 复制的基本原理slave会从master读取binlog来进行数据同步。

MySQ</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-03-30
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/DataBase/" class="post-category" target="_blank">
                                    DataBase
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MySQL/" target="_blank">
                        <span class="chip bg-color">MySQL</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('200')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Zero的博客<br />'
            + '作者: Zero<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>

    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">296.4k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/zero6996" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:1490829140@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1490829140" class="tooltipped" data-tooltip="QQ联系我: 1490829140" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input" autofocus>
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/js/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>